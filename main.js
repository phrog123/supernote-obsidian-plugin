/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/iobuffer/lib/text-encoding-polyfill.js
var require_text_encoding_polyfill = __commonJS({
  "node_modules/iobuffer/lib/text-encoding-polyfill.js"(exports2) {
    "use strict";
    (function(scope) {
      "use strict";
      if (scope["TextEncoder"] && scope["TextDecoder"]) {
        return false;
      }
      function FastTextEncoder(utfLabel = "utf-8") {
        if (utfLabel !== "utf-8") {
          throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);
        }
      }
      Object.defineProperty(FastTextEncoder.prototype, "encoding", {
        value: "utf-8"
      });
      FastTextEncoder.prototype.encode = function(string, options = { stream: false }) {
        if (options.stream) {
          throw new Error(`Failed to encode: the 'stream' option is unsupported.`);
        }
        let pos = 0;
        const len = string.length;
        const out = [];
        let at2 = 0;
        let tlen = Math.max(32, len + (len >> 1) + 7);
        let target = new Uint8Array(tlen >> 3 << 3);
        while (pos < len) {
          let value = string.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319) {
            if (pos < len) {
              const extra = string.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
            if (value >= 55296 && value <= 56319) {
              continue;
            }
          }
          if (at2 + 4 > target.length) {
            tlen += 8;
            tlen *= 1 + pos / string.length * 2;
            tlen = tlen >> 3 << 3;
            const update = new Uint8Array(tlen);
            update.set(target);
            target = update;
          }
          if ((value & 4294967168) === 0) {
            target[at2++] = value;
            continue;
          } else if ((value & 4294965248) === 0) {
            target[at2++] = value >> 6 & 31 | 192;
          } else if ((value & 4294901760) === 0) {
            target[at2++] = value >> 12 & 15 | 224;
            target[at2++] = value >> 6 & 63 | 128;
          } else if ((value & 4292870144) === 0) {
            target[at2++] = value >> 18 & 7 | 240;
            target[at2++] = value >> 12 & 63 | 128;
            target[at2++] = value >> 6 & 63 | 128;
          } else {
            continue;
          }
          target[at2++] = value & 63 | 128;
        }
        return target.slice(0, at2);
      };
      function FastTextDecoder(utfLabel = "utf-8", options = { fatal: false }) {
        if (utfLabel !== "utf-8") {
          throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);
        }
        if (options.fatal) {
          throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);
        }
      }
      Object.defineProperty(FastTextDecoder.prototype, "encoding", {
        value: "utf-8"
      });
      Object.defineProperty(FastTextDecoder.prototype, "fatal", { value: false });
      Object.defineProperty(FastTextDecoder.prototype, "ignoreBOM", {
        value: false
      });
      FastTextDecoder.prototype.decode = function(buffer, options = { stream: false }) {
        if (options["stream"]) {
          throw new Error(`Failed to decode: the 'stream' option is unsupported.`);
        }
        const bytes = new Uint8Array(buffer);
        let pos = 0;
        const len = bytes.length;
        const out = [];
        while (pos < len) {
          const byte1 = bytes[pos++];
          if (byte1 === 0) {
            break;
          }
          if ((byte1 & 128) === 0) {
            out.push(byte1);
          } else if ((byte1 & 224) === 192) {
            const byte2 = bytes[pos++] & 63;
            out.push((byte1 & 31) << 6 | byte2);
          } else if ((byte1 & 240) === 224) {
            const byte2 = bytes[pos++] & 63;
            const byte3 = bytes[pos++] & 63;
            out.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
          } else if ((byte1 & 248) === 240) {
            const byte2 = bytes[pos++] & 63;
            const byte3 = bytes[pos++] & 63;
            const byte4 = bytes[pos++] & 63;
            let codepoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
            if (codepoint > 65535) {
              codepoint -= 65536;
              out.push(codepoint >>> 10 & 1023 | 55296);
              codepoint = 56320 | codepoint & 1023;
            }
            out.push(codepoint);
          } else {
          }
        }
        return String.fromCharCode.apply(null, out);
      };
      scope["TextEncoder"] = FastTextEncoder;
      scope["TextDecoder"] = FastTextDecoder;
    })(typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : exports2);
  }
});

// node_modules/iobuffer/lib/text.browser.js
var require_text_browser = __commonJS({
  "node_modules/iobuffer/lib/text.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    require_text_encoding_polyfill();
    function decode2(bytes, encoding = "utf8") {
      const decoder = new TextDecoder(encoding);
      return decoder.decode(bytes);
    }
    exports2.decode = decode2;
    var encoder = new TextEncoder();
    function encode2(str) {
      return encoder.encode(str);
    }
    exports2.encode = encode2;
  }
});

// node_modules/iobuffer/lib/IOBuffer.js
var require_IOBuffer = __commonJS({
  "node_modules/iobuffer/lib/IOBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IOBuffer = void 0;
    var text_1 = require_text_browser();
    var defaultByteLength = 1024 * 8;
    var hostBigEndian = (() => {
      const array3 = new Uint8Array(4);
      const view = new Uint32Array(array3.buffer);
      return !((view[0] = 1) & array3[0]);
    })();
    var typedArrays = {
      int8: globalThis.Int8Array,
      uint8: globalThis.Uint8Array,
      int16: globalThis.Int16Array,
      uint16: globalThis.Uint16Array,
      int32: globalThis.Int32Array,
      uint32: globalThis.Uint32Array,
      uint64: globalThis.BigUint64Array,
      int64: globalThis.BigInt64Array,
      float32: globalThis.Float32Array,
      float64: globalThis.Float64Array
    };
    var IOBuffer5 = class {
      /**
       * @param data - The data to construct the IOBuffer with.
       * If data is a number, it will be the new buffer's length<br>
       * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
       * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
       * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
       * @param options
       */
      constructor(data = defaultByteLength, options = {}) {
        let dataIsGiven = false;
        if (typeof data === "number") {
          data = new ArrayBuffer(data);
        } else {
          dataIsGiven = true;
          this.lastWrittenByte = data.byteLength;
        }
        const offset = options.offset ? options.offset >>> 0 : 0;
        const byteLength = data.byteLength - offset;
        let dvOffset = offset;
        if (ArrayBuffer.isView(data) || data instanceof IOBuffer5) {
          if (data.byteLength !== data.buffer.byteLength) {
            dvOffset = data.byteOffset + offset;
          }
          data = data.buffer;
        }
        if (dataIsGiven) {
          this.lastWrittenByte = byteLength;
        } else {
          this.lastWrittenByte = 0;
        }
        this.buffer = data;
        this.length = byteLength;
        this.byteLength = byteLength;
        this.byteOffset = dvOffset;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer, dvOffset, byteLength);
        this._mark = 0;
        this._marks = [];
      }
      /**
       * Checks if the memory allocated to the buffer is sufficient to store more
       * bytes after the offset.
       * @param byteLength - The needed memory in bytes.
       * @returns `true` if there is sufficient space and `false` otherwise.
       */
      available(byteLength = 1) {
        return this.offset + byteLength <= this.length;
      }
      /**
       * Check if little-endian mode is used for reading and writing multi-byte
       * values.
       * @returns `true` if little-endian mode is used, `false` otherwise.
       */
      isLittleEndian() {
        return this.littleEndian;
      }
      /**
       * Set little-endian mode for reading and writing multi-byte values.
       */
      setLittleEndian() {
        this.littleEndian = true;
        return this;
      }
      /**
       * Check if big-endian mode is used for reading and writing multi-byte values.
       * @returns `true` if big-endian mode is used, `false` otherwise.
       */
      isBigEndian() {
        return !this.littleEndian;
      }
      /**
       * Switches to big-endian mode for reading and writing multi-byte values.
       */
      setBigEndian() {
        this.littleEndian = false;
        return this;
      }
      /**
       * Move the pointer n bytes forward.
       * @param n - Number of bytes to skip.
       */
      skip(n3 = 1) {
        this.offset += n3;
        return this;
      }
      /**
       * Move the pointer n bytes backward.
       * @param n - Number of bytes to move back.
       */
      back(n3 = 1) {
        this.offset -= n3;
        return this;
      }
      /**
       * Move the pointer to the given offset.
       * @param offset
       */
      seek(offset) {
        this.offset = offset;
        return this;
      }
      /**
       * Store the current pointer offset.
       * @see {@link IOBuffer#reset}
       */
      mark() {
        this._mark = this.offset;
        return this;
      }
      /**
       * Move the pointer back to the last pointer offset set by mark.
       * @see {@link IOBuffer#mark}
       */
      reset() {
        this.offset = this._mark;
        return this;
      }
      /**
       * Push the current pointer offset to the mark stack.
       * @see {@link IOBuffer#popMark}
       */
      pushMark() {
        this._marks.push(this.offset);
        return this;
      }
      /**
       * Pop the last pointer offset from the mark stack, and set the current
       * pointer offset to the popped value.
       * @see {@link IOBuffer#pushMark}
       */
      popMark() {
        const offset = this._marks.pop();
        if (offset === void 0) {
          throw new Error("Mark stack empty");
        }
        this.seek(offset);
        return this;
      }
      /**
       * Move the pointer offset back to 0.
       */
      rewind() {
        this.offset = 0;
        return this;
      }
      /**
       * Make sure the buffer has sufficient memory to write a given byteLength at
       * the current pointer offset.
       * If the buffer's memory is insufficient, this method will create a new
       * buffer (a copy) with a length that is twice (byteLength + current offset).
       * @param byteLength
       */
      ensureAvailable(byteLength = 1) {
        if (!this.available(byteLength)) {
          const lengthNeeded = this.offset + byteLength;
          const newLength = lengthNeeded * 2;
          const newArray8 = new Uint8Array(newLength);
          newArray8.set(new Uint8Array(this.buffer));
          this.buffer = newArray8.buffer;
          this.length = this.byteLength = newLength;
          this._data = new DataView(this.buffer);
        }
        return this;
      }
      /**
       * Read a byte and return false if the byte's value is 0, or true otherwise.
       * Moves pointer forward by one byte.
       */
      readBoolean() {
        return this.readUint8() !== 0;
      }
      /**
       * Read a signed 8-bit integer and move pointer forward by 1 byte.
       */
      readInt8() {
        return this._data.getInt8(this.offset++);
      }
      /**
       * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
       */
      readUint8() {
        return this._data.getUint8(this.offset++);
      }
      /**
       * Alias for {@link IOBuffer#readUint8}.
       */
      readByte() {
        return this.readUint8();
      }
      /**
       * Read `n` bytes and move pointer forward by `n` bytes.
       */
      readBytes(n3 = 1) {
        return this.readArray(n3, "uint8");
      }
      /**
       * Creates an array of corresponding to the type `type` and size `size`.
       * For example type `uint8` will create a `Uint8Array`.
       * @param size - size of the resulting array
       * @param type - number type of elements to read
       */
      readArray(size, type) {
        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
        const offset = this.byteOffset + this.offset;
        const slice = this.buffer.slice(offset, offset + bytes);
        if (this.littleEndian === hostBigEndian && type !== "uint8" && type !== "int8") {
          const slice2 = new Uint8Array(this.buffer.slice(offset, offset + bytes));
          slice2.reverse();
          const returnArray2 = new typedArrays[type](slice2.buffer);
          this.offset += bytes;
          returnArray2.reverse();
          return returnArray2;
        }
        const returnArray = new typedArrays[type](slice);
        this.offset += bytes;
        return returnArray;
      }
      /**
       * Read a 16-bit signed integer and move pointer forward by 2 bytes.
       */
      readInt16() {
        const value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      /**
       * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
       */
      readUint16() {
        const value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      /**
       * Read a 32-bit signed integer and move pointer forward by 4 bytes.
       */
      readInt32() {
        const value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
       */
      readUint32() {
        const value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 32-bit floating number and move pointer forward by 4 bytes.
       */
      readFloat32() {
        const value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 64-bit floating number and move pointer forward by 8 bytes.
       */
      readFloat64() {
        const value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
       */
      readBigInt64() {
        const value = this._data.getBigInt64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
       */
      readBigUint64() {
        const value = this._data.getBigUint64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 1-byte ASCII character and move pointer forward by 1 byte.
       */
      readChar() {
        return String.fromCharCode(this.readInt8());
      }
      /**
       * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
       */
      readChars(n3 = 1) {
        let result = "";
        for (let i3 = 0; i3 < n3; i3++) {
          result += this.readChar();
        }
        return result;
      }
      /**
       * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
       * forward by `n` bytes.
       */
      readUtf8(n3 = 1) {
        return (0, text_1.decode)(this.readBytes(n3));
      }
      /**
       * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
       * forward by `n` bytes.
       * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
       */
      decodeText(n3 = 1, encoding = "utf-8") {
        return (0, text_1.decode)(this.readBytes(n3), encoding);
      }
      /**
       * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
       * forward by 1 byte.
       */
      writeBoolean(value) {
        this.writeUint8(value ? 255 : 0);
        return this;
      }
      /**
       * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
       */
      writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
       * byte.
       */
      writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * An alias for {@link IOBuffer#writeUint8}.
       */
      writeByte(value) {
        return this.writeUint8(value);
      }
      /**
       * Write all elements of `bytes` as uint8 values and move pointer forward by
       * `bytes.length` bytes.
       */
      writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        for (let i3 = 0; i3 < bytes.length; i3++) {
          this._data.setUint8(this.offset++, bytes[i3]);
        }
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 16-bit signed integer and move pointer forward by 2
       * bytes.
       */
      writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
       * bytes.
       */
      writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit signed integer and move pointer forward by 4
       * bytes.
       */
      writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
       * bytes.
       */
      writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit floating number and move pointer forward by 4
       * bytes.
       */
      writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit floating number and move pointer forward by 8
       * bytes.
       */
      writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit signed bigint and move pointer forward by 8
       * bytes.
       */
      writeBigInt64(value) {
        this.ensureAvailable(8);
        this._data.setBigInt64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
       * bytes.
       */
      writeBigUint64(value) {
        this.ensureAvailable(8);
        this._data.setBigUint64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write the charCode of `str`'s first character as an 8-bit unsigned integer
       * and move pointer forward by 1 byte.
       */
      writeChar(str) {
        return this.writeUint8(str.charCodeAt(0));
      }
      /**
       * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
       * and move pointer forward by `str.length` bytes.
       */
      writeChars(str) {
        for (let i3 = 0; i3 < str.length; i3++) {
          this.writeUint8(str.charCodeAt(i3));
        }
        return this;
      }
      /**
       * UTF-8 encode and write `str` to the current pointer offset and move pointer
       * forward according to the encoded length.
       */
      writeUtf8(str) {
        return this.writeBytes((0, text_1.encode)(str));
      }
      /**
       * Export a Uint8Array view of the internal buffer.
       * The view starts at the byte offset and its length
       * is calculated to stop at the last written byte or the original length.
       */
      toArray() {
        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
      }
      /**
       * Update the last written byte offset
       * @private
       */
      _updateLastWrittenByte() {
        if (this.offset > this.lastWrittenByte) {
          this.lastWrittenByte = this.offset;
        }
      }
    };
    exports2.IOBuffer = IOBuffer5;
  }
});

// node_modules/fast-bmp/src/constants.js
var require_constants = __commonJS({
  "node_modules/fast-bmp/src/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BITMAPV5HEADER: {
        LogicalColorSpace: {
          // https://msdn.microsoft.com/en-us/library/cc250396.aspx
          LCS_CALIBRATED_RGB: 0,
          LCS_sRGB: 1934772034,
          // eslint-disable-line camelcase
          LCS_WINDOWS_COLOR_SPACE: 1466527264
        },
        Compression: {
          // https://msdn.microsoft.com/en-us/library/cc250415.aspx
          BI_RGB: 0,
          // No compression
          BI_RLE8: 1,
          BI_RLE4: 2,
          BI_BITFIELDS: 3,
          BI_JPEG: 4,
          BI_PNG: 5,
          BI_CMYK: 11,
          BI_CMYKRLE8: 12,
          BI_CMYKRLE4: 13
        },
        GamutMappingIntent: {
          // https://msdn.microsoft.com/en-us/library/cc250392.aspx
          LCS_GM_ABS_COLORIMETRIC: 8,
          LCS_GM_BUSINESS: 1,
          LCS_GM_GRAPHICS: 2,
          LCS_GM_IMAGES: 4
        }
      }
    };
  }
});

// node_modules/fast-bmp/src/BMPEncoder.js
var require_BMPEncoder = __commonJS({
  "node_modules/fast-bmp/src/BMPEncoder.js"(exports2, module2) {
    "use strict";
    var { IOBuffer: IOBuffer5 } = require_IOBuffer();
    var constants2 = require_constants();
    var tableLeft = [];
    for (let i3 = 0; i3 <= 8; i3++) {
      tableLeft.push(255 << i3);
    }
    var BMPEncoder = class extends IOBuffer5 {
      constructor(data) {
        if (data.bitDepth !== 1) {
          throw new Error("Only bitDepth of 1 is supported");
        }
        if (!data.height || !data.width) {
          throw new Error("ImageData width and height are required");
        }
        super(data.data);
        this.width = data.width;
        this.height = data.height;
        this.bitDepth = data.bitDepth;
        this.channels = data.channels;
        this.components = data.components;
      }
      encode() {
        this.encoded = new IOBuffer5();
        this.encoded.skip(14);
        this.writeBitmapV5Header();
        this.writeColorTable();
        const offset = this.encoded.offset;
        this.writePixelArray();
        this.encoded.rewind();
        this.writeBitmapFileHeader(offset);
        return this.encoded.toArray();
      }
      writePixelArray() {
        let io = this.encoded;
        const rowSize = Math.floor((this.bitDepth * this.width + 31) / 32) * 4;
        const dataRowSize = Math.ceil(this.bitDepth * this.width / 8);
        const skipSize = rowSize - dataRowSize;
        const bitOverflow = this.bitDepth * this.width % 8;
        const bitSkip = bitOverflow === 0 ? 0 : 8 - bitOverflow;
        const totalBytes = rowSize * this.height;
        let byteA, byteB;
        let offset = 0;
        let relOffset = 0;
        let iOffset = 8;
        io.mark();
        byteB = this.readUint8();
        for (let i3 = this.height - 1; i3 >= 0; i3--) {
          const lastRow = i3 === 0;
          io.reset();
          io.skip(i3 * rowSize);
          for (let j2 = 0; j2 < dataRowSize; j2++) {
            const lastCol = j2 === dataRowSize - 1;
            if (relOffset <= bitSkip && lastCol) {
              io.writeByte(byteB << relOffset);
              if ((bitSkip === 0 || bitSkip === relOffset) && !lastRow) {
                byteA = byteB;
                byteB = this.readByte();
              }
            } else if (relOffset === 0) {
              byteA = byteB;
              byteB = this.readUint8();
              io.writeByte(byteA);
            } else {
              byteA = byteB;
              byteB = this.readUint8();
              io.writeByte(
                byteA << relOffset & tableLeft[relOffset] | byteB >> iOffset
              );
            }
            if (lastCol) {
              offset += bitOverflow || 0;
              io.skip(skipSize);
              relOffset = offset % 8;
              iOffset = 8 - relOffset;
            }
          }
        }
        if (rowSize > dataRowSize) {
          io.reset();
          io.skip(totalBytes - 1);
          io.writeUint8(0);
        }
      }
      writeColorTable() {
        this.encoded.writeUint32(0).writeUint32(16777215);
      }
      writeBitmapFileHeader(imageOffset) {
        this.encoded.writeChars("BM").writeInt32(this.encoded.lastWrittenByte).writeUint16(0).writeUint16(0).writeUint32(imageOffset);
      }
      writeBitmapV5Header() {
        const rowSize = Math.floor((this.bitDepth * this.width + 31) / 32) * 4;
        const totalBytes = rowSize * this.height;
        this.encoded.writeUint32(124).writeInt32(this.width).writeInt32(this.height).writeUint16(1).writeUint16(this.bitDepth).writeUint32(constants2.BITMAPV5HEADER.Compression.BI_RGB).writeUint32(totalBytes).writeInt32(0).writeInt32(0).writeUint32(Math.pow(2, this.bitDepth)).writeUint32(Math.pow(2, this.bitDepth)).writeUint32(4278190080).writeUint32(16711680).writeUint32(65280).writeUint32(255).writeUint32(constants2.BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB).skip(36).skip(12).writeUint32(constants2.BITMAPV5HEADER.GamutMappingIntent.LCS_GM_IMAGES).skip(12);
      }
    };
    module2.exports = BMPEncoder;
  }
});

// node_modules/fast-bmp/src/index.js
var require_src = __commonJS({
  "node_modules/fast-bmp/src/index.js"(exports2) {
    "use strict";
    var Encoder = require_BMPEncoder();
    exports2.encode = function encode2(data) {
      const encoder = new Encoder(data);
      return encoder.encode();
    };
  }
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/jpeg-js/lib/encoder.js"(exports2, module2) {
    var btoa2 = btoa2 || function(buf) {
      return Buffer.from(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i3 = 0; i3 < 64; i3++) {
          var t3 = ffloor((YQT[i3] * sf + 50) / 100);
          if (t3 < 1) {
            t3 = 1;
          } else if (t3 > 255) {
            t3 = 255;
          }
          YTable[ZigZag[i3]] = t3;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j2 = 0; j2 < 64; j2++) {
          var u3 = ffloor((UVQT[j2] * sf + 50) / 100);
          if (u3 < 1) {
            u3 = 1;
          } else if (u3 > 255) {
            u3 = 255;
          }
          UVTable[ZigZag[j2]] = u3;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k2 = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k2] = 1 / (YTable[ZigZag[k2]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k2] = 1 / (UVTable[ZigZag[k2]] * aasf[row] * aasf[col] * 8);
            k2++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k2 = 1; k2 <= 16; k2++) {
          for (var j2 = 1; j2 <= nrcodes[k2]; j2++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k2;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i3 = 0; i3 < 256; i3++) {
          RGB_YUV_TABLE[i3] = 19595 * i3;
          RGB_YUV_TABLE[i3 + 256 >> 0] = 38470 * i3;
          RGB_YUV_TABLE[i3 + 512 >> 0] = 7471 * i3 + 32768;
          RGB_YUV_TABLE[i3 + 768 >> 0] = -11059 * i3;
          RGB_YUV_TABLE[i3 + 1024 >> 0] = -21709 * i3;
          RGB_YUV_TABLE[i3 + 1280 >> 0] = 32768 * i3 + 8421375;
          RGB_YUV_TABLE[i3 + 1536 >> 0] = -27439 * i3;
          RGB_YUV_TABLE[i3 + 1792 >> 0] = -5329 * i3;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i3;
        var I8 = 8;
        var I64 = 64;
        for (i3 = 0; i3 < I8; ++i3) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i3 = 0; i3 < I8; ++i3) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i3 = 0; i3 < I64; ++i3) {
          fDCTQuant2 = data[i3] * fdtbl[i3];
          outputfDCTQuant[i3] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer)
          return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i3 = 0; i3 < exifBuffer.length; i3++) {
          writeByte(exifBuffer[i3]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i3 = 0; i3 < 64; i3++) {
          writeByte(YTable[i3]);
        }
        writeByte(1);
        for (var j2 = 0; j2 < 64; j2++) {
          writeByte(UVTable[j2]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i3 = 0; i3 < 16; i3++) {
          writeByte(std_dc_luminance_nrcodes[i3 + 1]);
        }
        for (var j2 = 0; j2 <= 11; j2++) {
          writeByte(std_dc_luminance_values[j2]);
        }
        writeByte(16);
        for (var k2 = 0; k2 < 16; k2++) {
          writeByte(std_ac_luminance_nrcodes[k2 + 1]);
        }
        for (var l3 = 0; l3 <= 161; l3++) {
          writeByte(std_ac_luminance_values[l3]);
        }
        writeByte(1);
        for (var m4 = 0; m4 < 16; m4++) {
          writeByte(std_dc_chrominance_nrcodes[m4 + 1]);
        }
        for (var n3 = 0; n3 <= 11; n3++) {
          writeByte(std_dc_chrominance_values[n3]);
        }
        writeByte(17);
        for (var o3 = 0; o3 < 16; o3++) {
          writeByte(std_ac_chrominance_nrcodes[o3 + 1]);
        }
        for (var p3 = 0; p3 <= 161; p3++) {
          writeByte(std_ac_chrominance_values[p3]);
        }
      }
      function writeCOM(comments) {
        if (typeof comments === "undefined" || comments.constructor !== Array)
          return;
        comments.forEach((e2) => {
          if (typeof e2 !== "string")
            return;
          writeWord(65534);
          var l3 = e2.length;
          writeWord(l3 + 2);
          var i3;
          for (i3 = 0; i3 < l3; i3++)
            writeByte(e2.charCodeAt(i3));
        });
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j2 = 0; j2 < I64; ++j2) {
          DU[ZigZag[j2]] = DU_DCT[j2];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i3 = 1;
        var lng;
        while (i3 <= end0pos) {
          var startpos = i3;
          for (; DU[i3] == 0 && i3 <= end0pos; ++i3) {
          }
          var nrzeroes = i3 - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i3];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i3++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i3 = 0; i3 < 256; i3++) {
          clt[i3] = sfcc(i3);
        }
      }
      this.encode = function(image, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeCOM(image.comments);
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x2, y3 = 0;
        var r2, g2, b2;
        var start, p3, col, row, pos;
        while (y3 < height) {
          x2 = 0;
          while (x2 < quadWidth) {
            start = quadWidth * y3 + x2;
            p3 = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p3 = start + row * quadWidth + col;
              if (y3 + row >= height) {
                p3 -= quadWidth * (y3 + 1 + row - height);
              }
              if (x2 + col >= quadWidth) {
                p3 -= x2 + col - quadWidth + 4;
              }
              r2 = imageData[p3++];
              g2 = imageData[p3++];
              b2 = imageData[p3++];
              YDU[pos] = (RGB_YUV_TABLE[r2] + RGB_YUV_TABLE[g2 + 256 >> 0] + RGB_YUV_TABLE[b2 + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r2 + 768 >> 0] + RGB_YUV_TABLE[g2 + 1024 >> 0] + RGB_YUV_TABLE[b2 + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r2 + 1280 >> 0] + RGB_YUV_TABLE[g2 + 1536 >> 0] + RGB_YUV_TABLE[b2 + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x2 += 32;
          }
          y3 += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        if (typeof module2 === "undefined")
          return new Uint8Array(byteout);
        return Buffer.from(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa2(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init();
    }
    if (typeof module2 !== "undefined") {
      module2.exports = encode2;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].encode = encode2;
    }
    function encode2(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/jpeg-js/lib/decoder.js"(exports2, module2) {
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k2 = 0, code = [], i3, j2, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p3 = code[0], q2;
        for (i3 = 0; i3 < length; i3++) {
          for (j2 = 0; j2 < codeLengths[i3]; j2++) {
            p3 = code.pop();
            p3.children[p3.index] = values[k2];
            while (p3.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p3 = code.pop();
            }
            p3.index++;
            code.push(p3);
            while (code.length <= i3) {
              code.push(q2 = { children: [], index: 0 });
              p3.children[p3.index] = q2.children;
              p3 = q2;
            }
            k2++;
          }
          if (i3 + 1 < length) {
            code.push(q2 = { children: [], index: 0 });
            p3.children[p3.index] = q2.children;
            p3 = q2;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node2 = tree, bit;
          while ((bit = readBit()) !== null) {
            node2 = node2[bit];
            if (typeof node2 === "number")
              return node2;
            if (typeof node2 !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n4 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n4 = n4 << 1 | bit;
            length--;
          }
          return n4;
        }
        function receiveAndExtend(length) {
          var n4 = receive(length);
          if (n4 >= 1 << length - 1)
            return n4;
          return n4 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t3 = decodeHuffman(component2.huffmanTableDC);
          var diff = t3 === 0 ? 0 : receiveAndExtend(t3);
          zz[0] = component2.pred += diff;
          var k3 = 1;
          while (k3 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s3 = rs & 15, r2 = rs >> 4;
            if (s3 === 0) {
              if (r2 < 15)
                break;
              k3 += 16;
              continue;
            }
            k3 += r2;
            var z2 = dctZigZag[k3];
            zz[z2] = receiveAndExtend(s3);
            k3++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t3 = decodeHuffman(component2.huffmanTableDC);
          var diff = t3 === 0 ? 0 : receiveAndExtend(t3) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k3 = spectralStart, e2 = spectralEnd;
          while (k3 <= e2) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s3 = rs & 15, r2 = rs >> 4;
            if (s3 === 0) {
              if (r2 < 15) {
                eobrun = receive(r2) + (1 << r2) - 1;
                break;
              }
              k3 += 16;
              continue;
            }
            k3 += r2;
            var z2 = dctZigZag[k3];
            zz[z2] = receiveAndExtend(s3) * (1 << successive);
            k3++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k3 = spectralStart, e2 = spectralEnd, r2 = 0;
          while (k3 <= e2) {
            var z2 = dctZigZag[k3];
            var direction = zz[z2] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s3 = rs & 15, r2 = rs >> 4;
                if (s3 === 0) {
                  if (r2 < 15) {
                    eobrun = receive(r2) + (1 << r2);
                    successiveACState = 4;
                  } else {
                    r2 = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s3 !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s3);
                  successiveACState = r2 ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z2])
                  zz[z2] += (readBit() << successive) * direction;
                else {
                  r2--;
                  if (r2 === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z2])
                  zz[z2] += (readBit() << successive) * direction;
                else {
                  zz[z2] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z2])
                  zz[z2] += (readBit() << successive) * direction;
                break;
            }
            k3++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode3, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode3(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode3, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode3(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i3, j2, k2, n3;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h3, v3;
        while (mcu < mcuExpected) {
          for (i3 = 0; i3 < componentsLength; i3++)
            components[i3].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n3 = 0; n3 < resetInterval; n3++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n3 = 0; n3 < resetInterval; n3++) {
              for (i3 = 0; i3 < componentsLength; i3++) {
                component = components[i3];
                h3 = component.h;
                v3 = component.v;
                for (j2 = 0; j2 < v3; j2++) {
                  for (k2 = 0; k2 < h3; k2++) {
                    decodeMcu(component, decodeFn, mcu, j2, k2);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R2 = new Int32Array(64), r2 = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt2 = component.quantizationTable;
          var v0, v1, v22, v3, v4, v5, v6, v7, t3;
          var p3 = dataIn;
          var i4;
          for (i4 = 0; i4 < 64; i4++)
            p3[i4] = zz[i4] * qt2[i4];
          for (i4 = 0; i4 < 8; ++i4) {
            var row = 8 * i4;
            if (p3[1 + row] == 0 && p3[2 + row] == 0 && p3[3 + row] == 0 && p3[4 + row] == 0 && p3[5 + row] == 0 && p3[6 + row] == 0 && p3[7 + row] == 0) {
              t3 = dctSqrt2 * p3[0 + row] + 512 >> 10;
              p3[0 + row] = t3;
              p3[1 + row] = t3;
              p3[2 + row] = t3;
              p3[3 + row] = t3;
              p3[4 + row] = t3;
              p3[5 + row] = t3;
              p3[6 + row] = t3;
              p3[7 + row] = t3;
              continue;
            }
            v0 = dctSqrt2 * p3[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p3[4 + row] + 128 >> 8;
            v22 = p3[2 + row];
            v3 = p3[6 + row];
            v4 = dctSqrt1d2 * (p3[1 + row] - p3[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p3[1 + row] + p3[7 + row]) + 128 >> 8;
            v5 = p3[3 + row] << 4;
            v6 = p3[5 + row] << 4;
            t3 = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t3;
            t3 = v22 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v22 = v22 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t3;
            t3 = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t3;
            t3 = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t3;
            t3 = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t3;
            t3 = v1 - v22 + 1 >> 1;
            v1 = v1 + v22 + 1 >> 1;
            v22 = t3;
            t3 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t3;
            t3 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t3;
            p3[0 + row] = v0 + v7;
            p3[7 + row] = v0 - v7;
            p3[1 + row] = v1 + v6;
            p3[6 + row] = v1 - v6;
            p3[2 + row] = v22 + v5;
            p3[5 + row] = v22 - v5;
            p3[3 + row] = v3 + v4;
            p3[4 + row] = v3 - v4;
          }
          for (i4 = 0; i4 < 8; ++i4) {
            var col = i4;
            if (p3[1 * 8 + col] == 0 && p3[2 * 8 + col] == 0 && p3[3 * 8 + col] == 0 && p3[4 * 8 + col] == 0 && p3[5 * 8 + col] == 0 && p3[6 * 8 + col] == 0 && p3[7 * 8 + col] == 0) {
              t3 = dctSqrt2 * dataIn[i4 + 0] + 8192 >> 14;
              p3[0 * 8 + col] = t3;
              p3[1 * 8 + col] = t3;
              p3[2 * 8 + col] = t3;
              p3[3 * 8 + col] = t3;
              p3[4 * 8 + col] = t3;
              p3[5 * 8 + col] = t3;
              p3[6 * 8 + col] = t3;
              p3[7 * 8 + col] = t3;
              continue;
            }
            v0 = dctSqrt2 * p3[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p3[4 * 8 + col] + 2048 >> 12;
            v22 = p3[2 * 8 + col];
            v3 = p3[6 * 8 + col];
            v4 = dctSqrt1d2 * (p3[1 * 8 + col] - p3[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p3[1 * 8 + col] + p3[7 * 8 + col]) + 2048 >> 12;
            v5 = p3[3 * 8 + col];
            v6 = p3[5 * 8 + col];
            t3 = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t3;
            t3 = v22 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v22 = v22 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t3;
            t3 = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t3;
            t3 = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t3;
            t3 = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t3;
            t3 = v1 - v22 + 1 >> 1;
            v1 = v1 + v22 + 1 >> 1;
            v22 = t3;
            t3 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t3;
            t3 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t3;
            p3[0 * 8 + col] = v0 + v7;
            p3[7 * 8 + col] = v0 - v7;
            p3[1 * 8 + col] = v1 + v6;
            p3[6 * 8 + col] = v1 - v6;
            p3[2 * 8 + col] = v22 + v5;
            p3[5 * 8 + col] = v22 - v5;
            p3[3 * 8 + col] = v3 + v4;
            p3[4 * 8 + col] = v3 - v4;
          }
          for (i4 = 0; i4 < 64; ++i4) {
            var sample2 = 128 + (p3[i4] + 8 >> 4);
            dataOut[i4] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i3, j2;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i3 = 0; i3 < 8; i3++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r2, R2);
            var offset = 0, sample = blockCol << 3;
            for (j2 = 0; j2 < 8; j2++) {
              var line = lines[scanLine + j2];
              for (i3 = 0; i3 < 8; i3++)
                line[sample + i3] = r2[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a3) {
        return a3 < 0 ? 0 : a3 > 255 ? 255 : a3;
      }
      constructor.prototype = {
        load: function load2(path) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse2(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array3 = data.subarray(offset, offset + length2 - 2);
            offset += array3.length;
            return array3;
          }
          function prepareComponents(frame2) {
            var maxH2 = 1, maxV2 = 1;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i4 = 0; i4 < blocksPerColumnForMcu; i4++) {
                  var row = [];
                  for (var j3 = 0; j3 < blocksPerLineForMcu; j3++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i3, j2, l3;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j2 = 0; j2 < 64; j2++) {
                      var z2 = dctZigZag[j2];
                      tableData[z2] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j2 = 0; j2 < 64; j2++) {
                      var z2 = dctZigZag[j2];
                      tableData[z2] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i3 = 0; i3 < componentsCount; i3++) {
                  componentId = data[offset];
                  var h3 = data[offset + 1] >> 4;
                  var v3 = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  if (h3 <= 0 || v3 <= 0) {
                    throw new Error("Invalid sampling factor, expected values above 0");
                  }
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h: h3,
                    v: v3,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i3 = 2; i3 < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j2 = 0; j2 < 16; j2++, offset++) {
                    codeLengthSum += codeLengths[j2] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j2 = 0; j2 < codeLengthSum; j2++, offset++)
                    huffmanValues[j2] = data[offset];
                  i3 += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i3 = 0; i3 < selectorsCount; i3++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(
                  data,
                  offset,
                  frame,
                  components,
                  resetInterval,
                  spectralStart,
                  spectralEnd,
                  successiveApproximation >> 4,
                  successiveApproximation & 15,
                  this.opts
                );
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i3 = 0; i3 < frames.length; i3++) {
            var cp = frames[i3].components;
            for (var j2 in cp) {
              cp[j2].quantizationTable = quantizationTables[cp[j2].quantizationIdx];
              delete cp[j2].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i3 = 0; i3 < frame.componentsOrder.length; i3++) {
            var component = frame.components[frame.componentsOrder[i3]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x2, y3;
          var offset = 0;
          var Y2, Cb, Cr, K2, C2, M2, Ye, R2, G2, B2;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y3 = 0; y3 < height; y3++) {
                component1Line = component1.lines[0 | y3 * component1.scaleY * scaleY];
                for (x2 = 0; x2 < width; x2++) {
                  Y2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                  data[offset++] = Y2;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y3 = 0; y3 < height; y3++) {
                component1Line = component1.lines[0 | y3 * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y3 * component2.scaleY * scaleY];
                for (x2 = 0; x2 < width; x2++) {
                  Y2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                  data[offset++] = Y2;
                  Y2 = component2Line[0 | x2 * component2.scaleX * scaleX];
                  data[offset++] = Y2;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y3 = 0; y3 < height; y3++) {
                component1Line = component1.lines[0 | y3 * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y3 * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y3 * component3.scaleY * scaleY];
                for (x2 = 0; x2 < width; x2++) {
                  if (!colorTransform) {
                    R2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                    G2 = component2Line[0 | x2 * component2.scaleX * scaleX];
                    B2 = component3Line[0 | x2 * component3.scaleX * scaleX];
                  } else {
                    Y2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x2 * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x2 * component3.scaleX * scaleX];
                    R2 = clampTo8bit(Y2 + 1.402 * (Cr - 128));
                    G2 = clampTo8bit(Y2 - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B2 = clampTo8bit(Y2 + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R2;
                  data[offset++] = G2;
                  data[offset++] = B2;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y3 = 0; y3 < height; y3++) {
                component1Line = component1.lines[0 | y3 * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y3 * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y3 * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y3 * component4.scaleY * scaleY];
                for (x2 = 0; x2 < width; x2++) {
                  if (!colorTransform) {
                    C2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                    M2 = component2Line[0 | x2 * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x2 * component3.scaleX * scaleX];
                    K2 = component4Line[0 | x2 * component4.scaleX * scaleX];
                  } else {
                    Y2 = component1Line[0 | x2 * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x2 * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x2 * component3.scaleX * scaleX];
                    K2 = component4Line[0 | x2 * component4.scaleX * scaleX];
                    C2 = 255 - clampTo8bit(Y2 + 1.402 * (Cr - 128));
                    M2 = 255 - clampTo8bit(Y2 - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y2 + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C2;
                  data[offset++] = 255 - M2;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K2;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i3 = 0, j2 = 0, x2, y3;
          var Y2, K2, C2, M2, R2, G2, B2;
          switch (this.components.length) {
            case 1:
              for (y3 = 0; y3 < height; y3++) {
                for (x2 = 0; x2 < width; x2++) {
                  Y2 = data[i3++];
                  imageDataArray[j2++] = Y2;
                  imageDataArray[j2++] = Y2;
                  imageDataArray[j2++] = Y2;
                  if (formatAsRGBA) {
                    imageDataArray[j2++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y3 = 0; y3 < height; y3++) {
                for (x2 = 0; x2 < width; x2++) {
                  R2 = data[i3++];
                  G2 = data[i3++];
                  B2 = data[i3++];
                  imageDataArray[j2++] = R2;
                  imageDataArray[j2++] = G2;
                  imageDataArray[j2++] = B2;
                  if (formatAsRGBA) {
                    imageDataArray[j2++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y3 = 0; y3 < height; y3++) {
                for (x2 = 0; x2 < width; x2++) {
                  C2 = data[i3++];
                  M2 = data[i3++];
                  Y2 = data[i3++];
                  K2 = data[i3++];
                  R2 = 255 - clampTo8bit(C2 * (1 - K2 / 255) + K2);
                  G2 = 255 - clampTo8bit(M2 * (1 - K2 / 255) + K2);
                  B2 = 255 - clampTo8bit(Y2 * (1 - K2 / 255) + K2);
                  imageDataArray[j2++] = R2;
                  imageDataArray[j2++] = G2;
                  imageDataArray[j2++] = B2;
                  if (formatAsRGBA) {
                    imageDataArray[j2++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    if (typeof module2 !== "undefined") {
      module2.exports = decode2;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].decode = decode2;
    }
    function decode2(jpegData, userOpts = {}) {
      var defaultOpts = {
        // "undefined" means "Choose whether to transform colors based on the image’s color model."
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        // Don't decode more than 100 megapixels
        maxMemoryUsageInMB: 512
        // Don't decode if memory footprint is more than 512MB
      };
      var opts = { ...defaultOpts, ...userOpts };
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder.width,
          height: decoder.height,
          exifBuffer: decoder.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder.comments.length > 0) {
          image["comments"] = decoder.comments;
        }
      } catch (err3) {
        if (err3 instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        }
        if (err3 instanceof ReferenceError) {
          if (err3.message === "Buffer is not defined") {
            throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
          }
        }
        throw err3;
      }
      decoder.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "node_modules/jpeg-js/index.js"(exports2, module2) {
    var encode2 = require_encoder();
    var decode2 = require_decoder();
    module2.exports = {
      encode: encode2,
      decode: decode2
    };
  }
});

// node_modules/has-own/package.json
var require_package = __commonJS({
  "node_modules/has-own/package.json"(exports2, module2) {
    module2.exports = {
      name: "has-own",
      version: "1.0.1",
      description: "A safer .hasOwnProperty() - hasOwn(name, obj)",
      main: "index.js",
      scripts: {
        test: "make test"
      },
      author: "Aaron Heckmann <aaron.heckmann+github@gmail.com>",
      license: "MIT",
      repository: {
        type: "git",
        url: "git://github.com/aheckmann/has-own.git"
      },
      homepage: "https://github.com/aheckmann/has-own/",
      devDependencies: {
        mocha: "^6.2.2"
      }
    };
  }
});

// node_modules/has-own/index.js
var require_has_own = __commonJS({
  "node_modules/has-own/index.js"(exports2, module2) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module2.exports = exports2 = function hasOwn3(prop, obj) {
      return hasOwnProperty.call(obj, prop);
    };
    exports2.version = require_package().version;
  }
});

// node_modules/fast-jpeg/node_modules/iobuffer/IOBuffer.js
var require_IOBuffer2 = __commonJS({
  "node_modules/fast-jpeg/node_modules/iobuffer/IOBuffer.js"(exports2, module2) {
    "use strict";
    var defaultByteLength = 1024 * 8;
    var charArray = [];
    var IOBuffer5 = class {
      constructor(data, options) {
        options = options || {};
        if (data === void 0) {
          data = defaultByteLength;
        }
        if (typeof data === "number") {
          data = new ArrayBuffer(data);
        }
        let length = data.byteLength;
        const offset = options.offset ? options.offset >>> 0 : 0;
        if (data.buffer) {
          length = data.byteLength - offset;
          if (data.byteLength !== data.buffer.byteLength) {
            data = data.buffer.slice(data.byteOffset + offset, data.byteOffset + data.byteLength);
          } else if (offset) {
            data = data.buffer.slice(offset);
          } else {
            data = data.buffer;
          }
        }
        this.buffer = data;
        this.length = length;
        this.byteLength = length;
        this.byteOffset = 0;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer);
        this._increment = length || defaultByteLength;
        this._mark = 0;
      }
      available(byteLength) {
        if (byteLength === void 0)
          byteLength = 1;
        return this.offset + byteLength <= this.length;
      }
      isLittleEndian() {
        return this.littleEndian;
      }
      setLittleEndian() {
        this.littleEndian = true;
      }
      isBigEndian() {
        return !this.littleEndian;
      }
      setBigEndian() {
        this.littleEndian = false;
      }
      skip(n3) {
        if (n3 === void 0)
          n3 = 1;
        this.offset += n3;
      }
      seek(offset) {
        this.offset = offset;
      }
      mark() {
        this._mark = this.offset;
      }
      reset() {
        this.offset = this._mark;
      }
      rewind() {
        this.offset = 0;
      }
      ensureAvailable(byteLength) {
        if (byteLength === void 0)
          byteLength = 1;
        if (!this.available(byteLength)) {
          const newIncrement = this._increment + this._increment;
          this._increment = newIncrement;
          const newLength = this.length + newIncrement;
          const newArray8 = new Uint8Array(newLength);
          newArray8.set(new Uint8Array(this.buffer));
          this.buffer = newArray8.buffer;
          this.length = newLength;
          this._data = new DataView(this.buffer);
        }
      }
      readBoolean() {
        return this.readUint8() !== 0;
      }
      readInt8() {
        return this._data.getInt8(this.offset++);
      }
      readUint8() {
        return this._data.getUint8(this.offset++);
      }
      readByte() {
        return this.readUint8();
      }
      readBytes(n3) {
        if (n3 === void 0)
          n3 = 1;
        var bytes = new Uint8Array(n3);
        for (var i3 = 0; i3 < n3; i3++) {
          bytes[i3] = this.readByte();
        }
        return bytes;
      }
      readInt16() {
        var value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      readUint16() {
        var value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      readInt32() {
        var value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      readUint32() {
        var value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      readFloat32() {
        var value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      readFloat64() {
        var value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      readChar() {
        return String.fromCharCode(this.readInt8());
      }
      readChars(n3) {
        if (n3 === void 0)
          n3 = 1;
        charArray.length = n3;
        for (var i3 = 0; i3 < n3; i3++) {
          charArray[i3] = this.readChar();
        }
        return charArray.join("");
      }
      writeBoolean(bool) {
        this.writeUint8(bool ? 255 : 0);
      }
      writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
      }
      writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
      }
      writeByte(value) {
        this.writeUint8(value);
      }
      writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        for (var i3 = 0; i3 < bytes.length; i3++) {
          this._data.setUint8(this.offset++, bytes[i3]);
        }
      }
      writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
      }
      writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
      }
      writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
      }
      writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
      }
      writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
      }
      writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
      }
      writeChar(str) {
        this.writeUint8(str.charCodeAt(0));
      }
      writeChars(str) {
        for (var i3 = 0; i3 < str.length; i3++) {
          this.writeUint8(str.charCodeAt(i3));
        }
      }
      toArray() {
        return new Uint8Array(this.buffer, 0, this.offset);
      }
    };
    module2.exports = IOBuffer5;
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tags/standard.js
var require_standard = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tags/standard.js"(exports2, module2) {
    "use strict";
    var tagsById4 = {
      // Baseline tags
      254: "NewSubfileType",
      255: "SubfileType",
      256: "ImageWidth",
      257: "ImageLength",
      258: "BitsPerSample",
      259: "Compression",
      262: "PhotometricInterpretation",
      263: "Threshholding",
      264: "CellWidth",
      265: "CellLength",
      266: "FillOrder",
      270: "ImageDescription",
      271: "Make",
      272: "Model",
      273: "StripOffsets",
      274: "Orientation",
      277: "SamplesPerPixel",
      278: "RowsPerStrip",
      279: "StripByteCounts",
      280: "MinSampleValue",
      281: "MaxSampleValue",
      282: "XResolution",
      283: "YResolution",
      284: "PlanarConfiguration",
      288: "FreeOffsets",
      289: "FreeByteCounts",
      290: "GrayResponseUnit",
      291: "GrayResponseCurve",
      296: "ResolutionUnit",
      305: "Software",
      306: "DateTime",
      315: "Artist",
      316: "HostComputer",
      320: "ColorMap",
      338: "ExtraSamples",
      33432: "Copyright",
      // Extension tags
      269: "DocumentName",
      285: "PageName",
      286: "XPosition",
      287: "YPosition",
      292: "T4Options",
      293: "T6Options",
      297: "PageNumber",
      301: "TransferFunction",
      317: "Predictor",
      318: "WhitePoint",
      319: "PrimaryChromaticities",
      321: "HalftoneHints",
      322: "TileWidth",
      323: "TileLength",
      324: "TileOffsets",
      325: "TileByteCounts",
      326: "BadFaxLines",
      327: "CleanFaxData",
      328: "ConsecutiveBadFaxLines",
      330: "SubIFDs",
      332: "InkSet",
      333: "InkNames",
      334: "NumberOfInks",
      336: "DotRange",
      337: "TargetPrinter",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      342: "TransferRange",
      343: "ClipPath",
      344: "XClipPathUnits",
      345: "YClipPathUnits",
      346: "Indexed",
      347: "JPEGTables",
      351: "OPIProxy",
      400: "GlobalParametersIFD",
      401: "ProfileType",
      402: "FaxProfile",
      403: "CodingMethods",
      404: "VersionYear",
      405: "ModeNumber",
      433: "Decode",
      434: "DefaultImageColor",
      512: "JPEGProc",
      513: "JPEGInterchangeFormat",
      514: "JPEGInterchangeFormatLength",
      515: "JPEGRestartInterval",
      517: "JPEGLosslessPredictors",
      518: "JPEGPointTransforms",
      519: "JPEGQTables",
      520: "JPEGDCTables",
      521: "JPEGACTables",
      529: "YCbCrCoefficients",
      530: "YCbCrSubSampling",
      531: "YCbCrPositioning",
      532: "ReferenceBlackWhite",
      559: "StripRowCounts",
      700: "XMP",
      32781: "ImageID",
      34732: "ImageLayer",
      // Private tags
      32932: "WangAnnotatio",
      33445: "MDFileTag",
      33446: "MDScalePixel",
      33447: "MDColorTable",
      33448: "MDLabName",
      33449: "MDSampleInfo",
      33450: "MDPrepDate",
      33451: "MDPrepTime",
      33452: "MDFileUnits",
      33550: "ModelPixelScaleTag",
      33723: "IPTC",
      33918: "INGRPacketDataTag",
      33919: "INGRFlagRegisters",
      33920: "IrasBTransformationMatrix",
      33922: "ModelTiepointTag",
      34264: "ModelTransformationTag",
      34377: "Photoshop",
      34665: "ExifIFD",
      34675: "ICCProfile",
      34735: "GeoKeyDirectoryTag",
      34736: "GeoDoubleParamsTag",
      34737: "GeoAsciiParamsTag",
      34853: "GPSIFD",
      34908: "HylaFAXFaxRecvParams",
      34909: "HylaFAXFaxSubAddress",
      34910: "HylaFAXFaxRecvTime",
      37724: "ImageSourceData",
      40965: "InteroperabilityIFD",
      42112: "GDAL_METADATA",
      42113: "GDAL_NODATA",
      50215: "OceScanjobDescription",
      50216: "OceApplicationSelector",
      50217: "OceIdentificationNumber",
      50218: "OceImageLogicCharacteristics",
      50706: "DNGVersion",
      50707: "DNGBackwardVersion",
      50708: "UniqueCameraModel",
      50709: "LocalizedCameraModel",
      50710: "CFAPlaneColor",
      50711: "CFALayout",
      50712: "LinearizationTable",
      50713: "BlackLevelRepeatDim",
      50714: "BlackLevel",
      50715: "BlackLevelDeltaH",
      50716: "BlackLevelDeltaV",
      50717: "WhiteLevel",
      50718: "DefaultScale",
      50719: "DefaultCropOrigin",
      50720: "DefaultCropSize",
      50721: "ColorMatrix1",
      50722: "ColorMatrix2",
      50723: "CameraCalibration1",
      50724: "CameraCalibration2",
      50725: "ReductionMatrix1",
      50726: "ReductionMatrix2",
      50727: "AnalogBalance",
      50728: "AsShotNeutral",
      50729: "AsShotWhiteXY",
      50730: "BaselineExposure",
      50731: "BaselineNoise",
      50732: "BaselineSharpness",
      50733: "BayerGreenSplit",
      50734: "LinearResponseLimit",
      50735: "CameraSerialNumber",
      50736: "LensInfo",
      50737: "ChromaBlurRadius",
      50738: "AntiAliasStrength",
      50740: "DNGPrivateData",
      50741: "MakerNoteSafety",
      50778: "CalibrationIlluminant1",
      50779: "CalibrationIlluminant2",
      50780: "BestQualityScale",
      50784: "AliasLayerMetadata"
    };
    var tagsByName4 = {};
    for (i3 in tagsById4) {
      tagsByName4[tagsById4[i3]] = i3;
    }
    var i3;
    module2.exports = {
      tagsById: tagsById4,
      tagsByName: tagsByName4
    };
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tags/exif.js
var require_exif = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tags/exif.js"(exports2, module2) {
    "use strict";
    var tagsById4 = {
      33434: "ExposureTime",
      33437: "FNumber",
      34850: "ExposureProgram",
      34852: "SpectralSensitivity",
      34855: "ISOSpeedRatings",
      34856: "OECF",
      34864: "SensitivityType",
      34865: "StandardOutputSensitivity",
      34866: "RecommendedExposureIndex",
      34867: "ISOSpeed",
      34868: "ISOSpeedLatitudeyyy",
      34869: "ISOSpeedLatitudezzz",
      36864: "ExifVersion",
      36867: "DateTimeOriginal",
      36868: "DateTimeDigitized",
      37121: "ComponentsConfiguration",
      37122: "CompressedBitsPerPixel",
      37377: "ShutterSpeedValue",
      37378: "ApertureValue",
      37379: "BrightnessValue",
      37380: "ExposureBiasValue",
      37381: "MaxApertureValue",
      37382: "SubjectDistance",
      37383: "MeteringMode",
      37384: "LightSource",
      37385: "Flash",
      37386: "FocalLength",
      37396: "SubjectArea",
      37500: "MakerNote",
      37510: "UserComment",
      37520: "SubsecTime",
      37521: "SubsecTimeOriginal",
      37522: "SubsecTimeDigitized",
      40960: "FlashpixVersion",
      40961: "ColorSpace",
      40962: "PixelXDimension",
      40963: "PixelYDimension",
      40964: "RelatedSoundFile",
      41483: "FlashEnergy",
      41484: "SpatialFrequencyResponse",
      41486: "FocalPlaneXResolution",
      41487: "FocalPlaneYResolution",
      41488: "FocalPlaneResolutionUnit",
      41492: "SubjectLocation",
      41493: "ExposureIndex",
      41495: "SensingMethod",
      41728: "FileSource",
      41729: "SceneType",
      41730: "CFAPattern",
      41985: "CustomRendered",
      41986: "ExposureMode",
      41987: "WhiteBalance",
      41988: "DigitalZoomRatio",
      41989: "FocalLengthIn35mmFilm",
      41990: "SceneCaptureType",
      41991: "GainControl",
      41992: "Contrast",
      41993: "Saturation",
      41994: "Sharpness",
      41995: "DeviceSettingDescription",
      41996: "SubjectDistanceRange",
      42016: "ImageUniqueID",
      42032: "CameraOwnerName",
      42033: "BodySerialNumber",
      42034: "LensSpecification",
      42035: "LensMake",
      42036: "LensModel",
      42037: "LensSerialNumber",
      42240: "Gamma"
    };
    var tagsByName4 = {};
    for (i3 in tagsById4) {
      tagsByName4[tagsById4[i3]] = i3;
    }
    var i3;
    module2.exports = {
      tagsById: tagsById4,
      tagsByName: tagsByName4
    };
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tags/gps.js
var require_gps = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tags/gps.js"(exports2, module2) {
    "use strict";
    var tagsById4 = {
      0: "GPSVersionID",
      1: "GPSLatitudeRef",
      2: "GPSLatitude",
      3: "GPSLongitudeRef",
      4: "GPSLongitude",
      5: "GPSAltitudeRef",
      6: "GPSAltitude",
      7: "GPSTimeStamp",
      8: "GPSSatellites",
      9: "GPSStatus",
      10: "GPSMeasureMode",
      11: "GPSDOP",
      12: "GPSSpeedRef",
      13: "GPSSpeed",
      14: "GPSTrackRef",
      15: "GPSTrack",
      16: "GPSImgDirectionRef",
      17: "GPSImgDirection",
      18: "GPSMapDatum",
      19: "GPSDestLatitudeRef",
      20: "GPSDestLatitude",
      21: "GPSDestLongitudeRef",
      22: "GPSDestLongitude",
      23: "GPSDestBearingRef",
      24: "GPSDestBearing",
      25: "GPSDestDistanceRef",
      26: "GPSDestDistance",
      27: "GPSProcessingMethod",
      28: "GPSAreaInformation",
      29: "GPSDateStamp",
      30: "GPSDifferential",
      31: "GPSHPositioningError"
    };
    var tagsByName4 = {};
    for (i3 in tagsById4) {
      tagsByName4[tagsById4[i3]] = i3;
    }
    var i3;
    module2.exports = {
      tagsById: tagsById4,
      tagsByName: tagsByName4
    };
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/ifd.js
var require_ifd = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/ifd.js"(exports2, module2) {
    "use strict";
    var tags2 = {
      standard: require_standard(),
      exif: require_exif(),
      gps: require_gps()
    };
    var IFD2 = class {
      constructor(kind) {
        if (!kind) {
          throw new Error("missing kind");
        }
        this.data = null;
        this.fields = /* @__PURE__ */ new Map();
        this.kind = kind;
        this._map = null;
      }
      get(tag) {
        if (typeof tag === "number") {
          return this.fields.get(tag);
        } else if (typeof tag === "string") {
          return this.fields.get(tags2[this.kind].tagsByName[tag]);
        } else {
          throw new Error("expected a number or string");
        }
      }
      get map() {
        if (!this._map) {
          this._map = {};
          const taglist = tags2[this.kind].tagsById;
          for (var key of this.fields.keys()) {
            if (taglist[key]) {
              this._map[taglist[key]] = this.fields.get(key);
            }
          }
        }
        return this._map;
      }
    };
    module2.exports = IFD2;
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tiffIfd.js
var require_tiffIfd = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tiffIfd.js"(exports2, module2) {
    "use strict";
    var Ifd = require_ifd();
    var dateTimeRegex2 = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;
    var TiffIfd2 = class extends Ifd {
      constructor() {
        super("standard");
      }
      // Custom fields
      get size() {
        return this.width * this.height;
      }
      get width() {
        return this.imageWidth;
      }
      get height() {
        return this.imageLength;
      }
      get components() {
        return this.samplesPerPixel;
      }
      get date() {
        var date = new Date();
        var result = dateTimeRegex2.exec(this.dateTime);
        date.setFullYear(result[1], result[2] - 1, result[3]);
        date.setHours(result[4], result[5], result[6]);
        return date;
      }
      // IFD fields
      get newSubfileType() {
        return this.get(254);
      }
      get imageWidth() {
        return this.get(256);
      }
      get imageLength() {
        return this.get(257);
      }
      get bitsPerSample() {
        return this.get(258);
      }
      get compression() {
        return this.get(259) || 1;
      }
      get type() {
        return this.get(262);
      }
      get fillOrder() {
        return this.get(266) || 1;
      }
      get documentName() {
        return this.get(269);
      }
      get imageDescription() {
        return this.get(270);
      }
      get stripOffsets() {
        return alwaysArray2(this.get(273));
      }
      get orientation() {
        return this.get(274);
      }
      get samplesPerPixel() {
        return this.get(277);
      }
      get rowsPerStrip() {
        return this.get(278);
      }
      get stripByteCounts() {
        return alwaysArray2(this.get(279));
      }
      get minSampleValue() {
        return this.get(280) || 0;
      }
      get maxSampleValue() {
        return this.get(281) || Math.pow(2, this.bitsPerSample) - 1;
      }
      get xResolution() {
        return this.get(282);
      }
      get yResolution() {
        return this.get(283);
      }
      get planarConfiguration() {
        return this.get(284) || 1;
      }
      get resolutionUnit() {
        return this.get(296) || 2;
      }
      get dateTime() {
        return this.get(306);
      }
      get predictor() {
        return this.get(317) || 1;
      }
      get sampleFormat() {
        return this.get(339) || 1;
      }
      get sMinSampleValue() {
        return this.get(340) || this.minSampleValue;
      }
      get sMaxSampleValue() {
        return this.get(341) || this.maxSampleValue;
      }
    };
    function alwaysArray2(value) {
      if (typeof value === "number")
        return [value];
      return value;
    }
    module2.exports = TiffIfd2;
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/ifdValue.js
var require_ifdValue = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/ifdValue.js"(exports2) {
    "use strict";
    var types2 = /* @__PURE__ */ new Map([
      [1, [1, readByte2]],
      // BYTE
      [2, [1, readASCII2]],
      // ASCII
      [3, [2, readShort2]],
      // SHORT
      [4, [4, readLong2]],
      // LONG
      [5, [8, readRational2]],
      // RATIONAL
      [6, [1, readSByte2]],
      // SBYTE
      [7, [1, readByte2]],
      // UNDEFINED
      [8, [2, readSShort2]],
      // SSHORT
      [9, [4, readSLong2]],
      // SLONG
      [10, [8, readSRational2]],
      // SRATIONAL
      [11, [4, readFloat2]],
      // FLOAT
      [12, [8, readDouble2]]
      // DOUBLE
    ]);
    exports2.getByteLength = function(type, count) {
      return types2.get(type)[0] * count;
    };
    exports2.readData = function(decoder, type, count) {
      return types2.get(type)[1](decoder, count);
    };
    function readByte2(decoder, count) {
      if (count === 1)
        return decoder.readUint8();
      var array3 = new Uint8Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        array3[i3] = decoder.readUint8();
      }
      return array3;
    }
    function readASCII2(decoder, count) {
      var strings2 = [];
      var currentString = "";
      for (var i3 = 0; i3 < count; i3++) {
        var char = String.fromCharCode(decoder.readUint8());
        if (char === "\0") {
          strings2.push(currentString);
          currentString = "";
        } else {
          currentString += char;
        }
      }
      if (strings2.length === 1) {
        return strings2[0];
      } else {
        return strings2;
      }
    }
    function readShort2(decoder, count) {
      if (count === 1)
        return decoder.readUint16();
      var array3 = new Uint16Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        array3[i3] = decoder.readUint16();
      }
      return array3;
    }
    function readLong2(decoder, count) {
      if (count === 1)
        return decoder.readUint32();
      var array3 = new Uint32Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        array3[i3] = decoder.readUint32();
      }
      return array3;
    }
    function readRational2(decoder, count) {
      if (count === 1) {
        return decoder.readUint32() / decoder.readUint32();
      }
      var rationals = new Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        rationals[i3] = decoder.readUint32() / decoder.readUint32();
      }
      return rationals;
    }
    function readSByte2(decoder, count) {
      if (count === 1)
        return decoder.readInt8();
      var array3 = new Int8Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        array3[i3] = decoder.readInt8();
      }
      return array3;
    }
    function readSShort2(decoder, count) {
      if (count === 1)
        return decoder.readInt16();
      var array3 = new Int16Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        array3[i3] = decoder.readInt16();
      }
      return array3;
    }
    function readSLong2(decoder, count) {
      if (count === 1)
        return decoder.readInt32();
      var array3 = new Int32Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        array3[i3] = decoder.readInt32();
      }
      return array3;
    }
    function readSRational2(decoder, count) {
      if (count === 1) {
        return decoder.readInt32() / decoder.readInt32();
      }
      var rationals = new Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        rationals[i3] = decoder.readInt32() / decoder.readInt32();
      }
      return rationals;
    }
    function readFloat2(decoder, count) {
      if (count === 1)
        return decoder.readFloat32();
      var array3 = new Float32Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        array3[i3] = decoder.readFloat32();
      }
      return array3;
    }
    function readDouble2(decoder, count) {
      if (count === 1)
        return decoder.readFloat64();
      var array3 = new Float64Array(count);
      for (var i3 = 0; i3 < count; i3++) {
        array3[i3] = decoder.readFloat64();
      }
      return array3;
    }
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tiffDecoder.js
var require_tiffDecoder = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tiffDecoder.js"(exports2, module2) {
    "use strict";
    var IOBuffer5 = require_IOBuffer2();
    var IFD2 = require_ifd();
    var TiffIFD = require_tiffIfd();
    var IFDValue = require_ifdValue();
    var defaultOptions5 = {
      ignoreImageData: false,
      onlyFirst: false
    };
    var TIFFDecoder2 = class extends IOBuffer5 {
      constructor(data, options) {
        super(data, options);
        this._nextIFD = 0;
      }
      decode(options) {
        options = Object.assign({}, defaultOptions5, options);
        const result = [];
        this.decodeHeader();
        while (this._nextIFD) {
          result.push(this.decodeIFD(options));
          if (options.onlyFirst) {
            return result[0];
          }
        }
        return result;
      }
      decodeHeader() {
        let value = this.readUint16();
        if (value === 18761) {
          this.setLittleEndian();
        } else if (value === 19789) {
          this.setBigEndian();
        } else {
          throw new Error("invalid byte order: 0x" + value.toString(16));
        }
        value = this.readUint16();
        if (value !== 42) {
          throw new Error("not a TIFF file");
        }
        this._nextIFD = this.readUint32();
      }
      decodeIFD(options) {
        this.seek(this._nextIFD);
        var ifd;
        if (!options.kind) {
          ifd = new TiffIFD();
        } else {
          ifd = new IFD2(options.kind);
        }
        const numEntries = this.readUint16();
        for (var i3 = 0; i3 < numEntries; i3++) {
          this.decodeIFDEntry(ifd);
        }
        if (!options.ignoreImageData) {
          this.decodeImageData(ifd);
        }
        this._nextIFD = this.readUint32();
        return ifd;
      }
      decodeIFDEntry(ifd) {
        const offset = this.offset;
        const tag = this.readUint16();
        const type = this.readUint16();
        const numValues = this.readUint32();
        if (type < 1 || type > 12) {
          this.skip(4);
          return;
        }
        const valueByteLength = IFDValue.getByteLength(type, numValues);
        if (valueByteLength > 4) {
          this.seek(this.readUint32());
        }
        const value = IFDValue.readData(this, type, numValues);
        ifd.fields.set(tag, value);
        if (tag === 34665 || tag === 34853) {
          let currentOffset = this.offset;
          let kind;
          if (tag === 34665) {
            kind = "exif";
          } else if (tag === 34853) {
            kind = "gps";
          }
          this._nextIFD = value;
          ifd[kind] = this.decodeIFD({
            kind,
            ignoreImageData: true
          });
          this.offset = currentOffset;
        }
        this.seek(offset);
        this.skip(12);
      }
      decodeImageData(ifd) {
        const orientation = ifd.orientation;
        if (orientation && orientation !== 1) {
          unsupported2("orientation", orientation);
        }
        switch (ifd.type) {
          case 1:
          case 2:
            this.readStripData(ifd);
            break;
          default:
            unsupported2("image type", ifd.type);
            break;
        }
      }
      readStripData(ifd) {
        const width = ifd.width;
        const height = ifd.height;
        const bitDepth = validateBitDepth(ifd.bitsPerSample);
        const sampleFormat = ifd.sampleFormat;
        let size = width * height;
        const data = getDataArray2(size, 1, bitDepth, sampleFormat);
        const compression = ifd.compression;
        const rowsPerStrip = ifd.rowsPerStrip;
        const maxPixels = rowsPerStrip * width;
        const stripOffsets = ifd.stripOffsets;
        const stripByteCounts = ifd.stripByteCounts;
        var pixel = 0;
        for (var i3 = 0; i3 < stripOffsets.length; i3++) {
          var stripData = this.getStripData(compression, stripOffsets[i3], stripByteCounts[i3]);
          var length = size > maxPixels ? maxPixels : size;
          size -= length;
          if (bitDepth === 8) {
            pixel = fill8bit2(data, stripData, pixel, length);
          } else if (bitDepth === 16) {
            pixel = fill16bit2(data, stripData, pixel, length, this.isLittleEndian());
          } else if (bitDepth === 32 && sampleFormat === 3) {
            pixel = fillFloat322(data, stripData, pixel, length, this.isLittleEndian());
          } else {
            unsupported2("bitDepth", bitDepth);
          }
        }
        ifd.data = data;
      }
      getStripData(compression, offset, byteCounts) {
        switch (compression) {
          case 1:
            return new DataView(this.buffer, offset, byteCounts);
          case 2:
          case 32773:
            return unsupported2("Compression", compression);
          default:
            throw new Error("invalid compression: " + compression);
        }
      }
    };
    module2.exports = TIFFDecoder2;
    function getDataArray2(size, channels, bitDepth, sampleFormat) {
      if (bitDepth === 8) {
        return new Uint8Array(size * channels);
      } else if (bitDepth === 16) {
        return new Uint16Array(size * channels);
      } else if (bitDepth === 32 && sampleFormat === 3) {
        return new Float32Array(size * channels);
      } else {
        return unsupported2("bit depth / sample format", bitDepth + " / " + sampleFormat);
      }
    }
    function fill8bit2(dataTo, dataFrom, index2, length) {
      for (var i3 = 0; i3 < length; i3++) {
        dataTo[index2++] = dataFrom.getUint8(i3);
      }
      return index2;
    }
    function fill16bit2(dataTo, dataFrom, index2, length, littleEndian) {
      for (var i3 = 0; i3 < length * 2; i3 += 2) {
        dataTo[index2++] = dataFrom.getUint16(i3, littleEndian);
      }
      return index2;
    }
    function fillFloat322(dataTo, dataFrom, index2, length, littleEndian) {
      for (var i3 = 0; i3 < length * 4; i3 += 4) {
        dataTo[index2++] = dataFrom.getFloat32(i3, littleEndian);
      }
      return index2;
    }
    function unsupported2(type, value) {
      throw new Error("Unsupported " + type + ": " + value);
    }
    function validateBitDepth(bitDepth) {
      if (bitDepth.length) {
        const bitDepthArray = bitDepth;
        bitDepth = bitDepthArray[0];
        for (var i3 = 0; i3 < bitDepthArray.length; i3++) {
          if (bitDepthArray[i3] !== bitDepth) {
            unsupported2("bit depth", bitDepthArray);
          }
        }
      }
      return bitDepth;
    }
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/decode.js
var require_decode = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/decode.js"(exports2, module2) {
    "use strict";
    var TIFFDecoder2 = require_tiffDecoder();
    module2.exports = function decodeTIFF2(data, options) {
      const decoder = new TIFFDecoder2(data, options);
      return decoder.decode(options);
    };
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/index.js
var require_src2 = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/index.js"(exports2) {
    "use strict";
    exports2.decode = require_decode();
  }
});

// node_modules/fast-jpeg/src/decode.js
var require_decode2 = __commonJS({
  "node_modules/fast-jpeg/src/decode.js"(exports2, module2) {
    "use strict";
    var IOBuffer5 = require_IOBuffer2();
    var tiff = require_src2();
    function decode2(data) {
      const buffer = new IOBuffer5(data);
      const result = {};
      buffer.setBigEndian();
      const val = buffer.readUint16();
      if (val !== 65496) {
        throw new Error("SOI marker not found. Not a valid JPEG file");
      }
      const next = buffer.readUint16();
      if (next === 65505) {
        const length = buffer.readUint16();
        const header = buffer.readBytes(6);
        if (header[0] === 69 && // E
        header[1] === 120 && // x
        header[2] === 105 && // i
        header[3] === 102 && // f
        header[4] === 0 && header[5] === 0) {
          const exif = tiff.decode(buffer, {
            onlyFirst: true,
            ignoreImageData: true,
            offset: buffer.offset
          });
          result.exif = exif;
        }
      }
      return result;
    }
    module2.exports = decode2;
  }
});

// node_modules/fast-jpeg/src/index.js
var require_src3 = __commonJS({
  "node_modules/fast-jpeg/src/index.js"(exports2) {
    "use strict";
    exports2.decode = require_decode2();
  }
});

// node_modules/file-type/index.js
var require_file_type = __commonJS({
  "node_modules/file-type/index.js"(exports, module) {
    "use strict";
    var toBytes = (s3) => [...s3].map((c4) => c4.charCodeAt(0));
    var xpiZipFilename = toBytes("META-INF/mozilla.rsa");
    var oxmlContentTypes = toBytes("[Content_Types].xml");
    var oxmlRels = toBytes("_rels/.rels");
    function readUInt64LE(buf, offset = 0) {
      let n3 = buf[offset];
      let mul = 1;
      let i3 = 0;
      while (++i3 < 8) {
        mul *= 256;
        n3 += buf[offset + i3] * mul;
      }
      return n3;
    }
    var fileType = (input) => {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buf = input instanceof Uint8Array ? input : new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, options) => {
        options = Object.assign({
          offset: 0
        }, options);
        for (let i3 = 0; i3 < header.length; i3++) {
          if (options.mask) {
            if (header[i3] !== (options.mask[i3] & buf[i3 + options.offset])) {
              return false;
            }
          } else if (header[i3] !== buf[i3 + options.offset]) {
            return false;
          }
        }
        return true;
      };
      const checkString = (header, options) => check(toBytes(header), options);
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4])) {
        if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        }
        if (check(xpiZipFilename, { offset: 30 })) {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", { offset: 30 })) {
          return {
            ext: "odt",
            mime: "application/vnd.oasis.opendocument.text"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", { offset: 30 })) {
          return {
            ext: "ods",
            mime: "application/vnd.oasis.opendocument.spreadsheet"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", { offset: 30 })) {
          return {
            ext: "odp",
            mime: "application/vnd.oasis.opendocument.presentation"
          };
        }
        const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i3, arr2) => i3 >= startAt && arr2[i3] === 80 && arr2[i3 + 1] === 75 && arr2[i3 + 2] === 3 && arr2[i3 + 3] === 4);
        let zipHeaderIndex = 0;
        let oxmlFound = false;
        let type = null;
        do {
          const offset = zipHeaderIndex + 30;
          if (!oxmlFound) {
            oxmlFound = check(oxmlContentTypes, { offset }) || check(oxmlRels, { offset });
          }
          if (!type) {
            if (checkString("word/", { offset })) {
              type = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              };
            } else if (checkString("ppt/", { offset })) {
              type = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              };
            } else if (checkString("xl/", { offset })) {
              type = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
          }
          if (oxmlFound && type) {
            return type;
          }
          zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
        } while (zipHeaderIndex >= 0);
        if (type) {
          return type;
        }
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([51, 103, 112, 53]) || // 3gp5
      check([0, 0, 0]) && check([102, 116, 121, 112], { offset: 4 }) && (check([109, 112, 52, 49], { offset: 8 }) || // MP41
      check([109, 112, 52, 50], { offset: 8 }) || // MP42
      check([105, 115, 111, 109], { offset: 8 }) || // ISOM
      check([105, 115, 111, 50], { offset: 8 }) || // ISO2
      check([109, 109, 112, 52], { offset: 8 }) || // MMP4
      check([77, 52, 86], { offset: 8 }) || // M4V
      check([100, 97, 115, 104], { offset: 8 }))) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i3, arr) => arr[i3] === 66 && arr[i3 + 1] === 130);
        if (idPos !== -1) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => [...type].every((c4, i3) => sliced[docTypePos + i3] === c4.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || // Type: `free`
      check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || // MJPEG
      check([109, 111, 111, 118], { offset: 4 }) || // Type: `moov`
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        let offset = 30;
        do {
          const objectSize = readUInt64LE(buf, offset + 16);
          if (check([145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101], { offset })) {
            if (check([64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
              return {
                ext: "wma",
                mime: "audio/x-ms-wma"
              };
            }
            if (check([192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
              return {
                ext: "wmv",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          offset += objectSize;
        } while (offset + 24 <= buf.length);
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 51, 103], { offset: 4 })) {
        return {
          ext: "3gp",
          mime: "video/3gpp"
        };
      }
      for (let start = 0; start < 2 && start < buf.length - 16; start++) {
        if (check([73, 68, 51], { offset: start }) || // ID3 header
        check([255, 226], { offset: start, mask: [255, 226] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 228], { offset: start, mask: [255, 228] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 248], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 240], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp4",
            mime: "audio/mpeg"
          };
        }
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 })) {
        return {
          // MPEG-4 layer 3 (audio)
          ext: "m4a",
          mime: "audio/mp4"
          // RFC 4337
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        if (check([128, 116, 104, 101, 111, 114, 97], { offset: 28 })) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (check([1, 118, 105, 100, 101, 111, 0], { offset: 28 })) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (check([127, 70, 76, 65, 67], { offset: 28 })) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (check([83, 112, 101, 101, 120, 32, 32], { offset: 28 })) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (check([1, 118, 111, 114, 98, 105, 115], { offset: 28 })) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([77, 65, 67, 32])) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([119, 118, 112, 107])) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        if (check([106, 112, 50, 32], { offset: 20 })) {
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        }
        if (check([106, 112, 120, 32], { offset: 20 })) {
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        }
        if (check([106, 112, 109, 32], { offset: 20 })) {
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        }
        if (check([109, 106, 112, 50], { offset: 20 })) {
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        }
      }
      if (check([70, 79, 82, 77])) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([102, 116, 121, 112], { offset: 4 })) {
        if (check([109, 105, 102, 49], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heif"
          };
        }
        if (check([109, 115, 102, 49], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heif-sequence"
          };
        }
        if (check([104, 101, 105, 99], { offset: 8 }) || check([104, 101, 105, 120], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heic"
          };
        }
        if (check([104, 101, 118, 99], { offset: 8 }) || check([104, 101, 118, 120], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heic-sequence"
          };
        }
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if (check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (check([77, 80, 43])) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (check([77, 80, 67, 75])) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (check([66, 69, 71, 73, 78, 58])) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
      if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      return null;
    };
    module.exports = fileType;
    module.exports.default = fileType;
    Object.defineProperty(fileType, "minimumBytes", { value: 4100 });
    module.exports.stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.once("readable", () => {
        const pass = new stream.PassThrough();
        const chunk = readableStream.read(module.exports.minimumBytes) || readableStream.read();
        try {
          pass.fileType = fileType(chunk);
        } catch (error) {
          reject(error);
        }
        readableStream.unshift(chunk);
        if (stream.pipeline) {
          resolve(stream.pipeline(readableStream, pass, () => {
          }));
        } else {
          resolve(readableStream.pipe(pass));
        }
      });
    });
  }
});

// node_modules/image-type/index.js
var require_image_type = __commonJS({
  "node_modules/image-type/index.js"(exports2, module2) {
    "use strict";
    var fileType2 = require_file_type();
    var imageExts = /* @__PURE__ */ new Set([
      "jpg",
      "png",
      "gif",
      "webp",
      "flif",
      "cr2",
      "tif",
      "bmp",
      "jxr",
      "psd",
      "ico",
      "bpg",
      "jp2",
      "jpm",
      "jpx",
      "heic",
      "cur",
      "dcm"
    ]);
    var imageType2 = (input) => {
      const ret = fileType2(input);
      return imageExts.has(ret && ret.ext) ? ret : null;
    };
    module2.exports = imageType2;
    module2.exports.default = imageType2;
    Object.defineProperty(imageType2, "minimumBytes", { value: fileType2.minimumBytes });
  }
});

// node_modules/median-quickselect/lib/median-quickselect.min.js
var require_median_quickselect_min = __commonJS({
  "node_modules/median-quickselect/lib/median-quickselect.min.js"(exports2, module2) {
    (function() {
      function a3(d2) {
        for (var e2 = 0, f3 = d2.length - 1, g2 = void 0, h3 = void 0, i3 = void 0, j2 = c4(e2, f3); true; ) {
          if (f3 <= e2)
            return d2[j2];
          if (f3 == e2 + 1)
            return d2[e2] > d2[f3] && b2(d2, e2, f3), d2[j2];
          for (g2 = c4(e2, f3), d2[g2] > d2[f3] && b2(d2, g2, f3), d2[e2] > d2[f3] && b2(d2, e2, f3), d2[g2] > d2[e2] && b2(d2, g2, e2), b2(d2, g2, e2 + 1), h3 = e2 + 1, i3 = f3; true; ) {
            do
              h3++;
            while (d2[e2] > d2[h3]);
            do
              i3--;
            while (d2[i3] > d2[e2]);
            if (i3 < h3)
              break;
            b2(d2, h3, i3);
          }
          b2(d2, e2, i3), i3 <= j2 && (e2 = h3), i3 >= j2 && (f3 = i3 - 1);
        }
      }
      var b2 = function b3(d2, e2, f3) {
        var _ref;
        return _ref = [d2[f3], d2[e2]], d2[e2] = _ref[0], d2[f3] = _ref[1], _ref;
      }, c4 = function c5(d2, e2) {
        return ~~((d2 + e2) / 2);
      };
      "undefined" != typeof module2 && module2.exports ? module2.exports = a3 : window.median = a3;
    })();
  }
});

// node_modules/ml-fft/src/fftlib.js
var require_fftlib = __commonJS({
  "node_modules/ml-fft/src/fftlib.js"(exports2) {
    var FFT2 = function() {
      var FFT3;
      if (typeof exports2 !== "undefined") {
        FFT3 = exports2;
      } else {
        FFT3 = {};
      }
      var version = {
        release: "0.3.0",
        date: "2013-03"
      };
      FFT3.toString = function() {
        return "version " + version.release + ", released " + version.date;
      };
      var _n = 0, _bitrev = null, _cstb = null;
      var core = {
        init: function(n3) {
          if (n3 !== 0 && (n3 & n3 - 1) === 0) {
            _n = n3;
            core._initArray();
            core._makeBitReversalTable();
            core._makeCosSinTable();
          } else {
            throw new Error("init: radix-2 required");
          }
        },
        // 1D-FFT
        fft1d: function(re2, im) {
          core.fft(re2, im, 1);
        },
        // 1D-IFFT
        ifft1d: function(re2, im) {
          var n3 = 1 / _n;
          core.fft(re2, im, -1);
          for (var i4 = 0; i4 < _n; i4++) {
            re2[i4] *= n3;
            im[i4] *= n3;
          }
        },
        // 1D-IFFT
        bt1d: function(re2, im) {
          core.fft(re2, im, -1);
        },
        // 2D-FFT Not very useful if the number of rows have to be equal to cols
        fft2d: function(re2, im) {
          var tre = [], tim = [], i4 = 0;
          for (var y3 = 0; y3 < _n; y3++) {
            i4 = y3 * _n;
            for (var x1 = 0; x1 < _n; x1++) {
              tre[x1] = re2[x1 + i4];
              tim[x1] = im[x1 + i4];
            }
            core.fft1d(tre, tim);
            for (var x2 = 0; x2 < _n; x2++) {
              re2[x2 + i4] = tre[x2];
              im[x2 + i4] = tim[x2];
            }
          }
          for (var x3 = 0; x3 < _n; x3++) {
            for (var y1 = 0; y1 < _n; y1++) {
              i4 = x3 + y1 * _n;
              tre[y1] = re2[i4];
              tim[y1] = im[i4];
            }
            core.fft1d(tre, tim);
            for (var y22 = 0; y22 < _n; y22++) {
              i4 = x3 + y22 * _n;
              re2[i4] = tre[y22];
              im[i4] = tim[y22];
            }
          }
        },
        // 2D-IFFT
        ifft2d: function(re2, im) {
          var tre = [], tim = [], i4 = 0;
          for (var y3 = 0; y3 < _n; y3++) {
            i4 = y3 * _n;
            for (var x1 = 0; x1 < _n; x1++) {
              tre[x1] = re2[x1 + i4];
              tim[x1] = im[x1 + i4];
            }
            core.ifft1d(tre, tim);
            for (var x2 = 0; x2 < _n; x2++) {
              re2[x2 + i4] = tre[x2];
              im[x2 + i4] = tim[x2];
            }
          }
          for (var x3 = 0; x3 < _n; x3++) {
            for (var y1 = 0; y1 < _n; y1++) {
              i4 = x3 + y1 * _n;
              tre[y1] = re2[i4];
              tim[y1] = im[i4];
            }
            core.ifft1d(tre, tim);
            for (var y22 = 0; y22 < _n; y22++) {
              i4 = x3 + y22 * _n;
              re2[i4] = tre[y22];
              im[i4] = tim[y22];
            }
          }
        },
        // core operation of FFT
        fft: function(re2, im, inv) {
          var d2, h3, ik, m4, tmp, wr, wi, xr, xi, n4 = _n >> 2;
          for (var l3 = 0; l3 < _n; l3++) {
            m4 = _bitrev[l3];
            if (l3 < m4) {
              tmp = re2[l3];
              re2[l3] = re2[m4];
              re2[m4] = tmp;
              tmp = im[l3];
              im[l3] = im[m4];
              im[m4] = tmp;
            }
          }
          for (var k2 = 1; k2 < _n; k2 <<= 1) {
            h3 = 0;
            d2 = _n / (k2 << 1);
            for (var j2 = 0; j2 < k2; j2++) {
              wr = _cstb[h3 + n4];
              wi = inv * _cstb[h3];
              for (var i4 = j2; i4 < _n; i4 += k2 << 1) {
                ik = i4 + k2;
                xr = wr * re2[ik] + wi * im[ik];
                xi = wr * im[ik] - wi * re2[ik];
                re2[ik] = re2[i4] - xr;
                re2[i4] += xr;
                im[ik] = im[i4] - xi;
                im[i4] += xi;
              }
              h3 += d2;
            }
          }
        },
        // initialize the array (supports TypedArray)
        _initArray: function() {
          if (typeof Uint32Array !== "undefined") {
            _bitrev = new Uint32Array(_n);
          } else {
            _bitrev = [];
          }
          if (typeof Float64Array !== "undefined") {
            _cstb = new Float64Array(_n * 1.25);
          } else {
            _cstb = [];
          }
        },
        // zero padding
        _paddingZero: function() {
        },
        // makes bit reversal table
        _makeBitReversalTable: function() {
          var i4 = 0, j2 = 0, k2 = 0;
          _bitrev[0] = 0;
          while (++i4 < _n) {
            k2 = _n >> 1;
            while (k2 <= j2) {
              j2 -= k2;
              k2 >>= 1;
            }
            j2 += k2;
            _bitrev[i4] = j2;
          }
        },
        // makes trigonometiric function table
        _makeCosSinTable: function() {
          var n22 = _n >> 1, n4 = _n >> 2, n8 = _n >> 3, n2p4 = n22 + n4, t3 = Math.sin(Math.PI / _n), dc = 2 * t3 * t3, ds = Math.sqrt(dc * (2 - dc)), c4 = _cstb[n4] = 1, s3 = _cstb[0] = 0;
          t3 = 2 * dc;
          for (var i4 = 1; i4 < n8; i4++) {
            c4 -= dc;
            dc += t3 * c4;
            s3 += ds;
            ds -= t3 * s3;
            _cstb[i4] = s3;
            _cstb[n4 - i4] = c4;
          }
          if (n8 !== 0) {
            _cstb[n8] = Math.sqrt(0.5);
          }
          for (var j2 = 0; j2 < n4; j2++) {
            _cstb[n22 - j2] = _cstb[j2];
          }
          for (var k2 = 0; k2 < n2p4; k2++) {
            _cstb[k2 + n22] = -_cstb[k2];
          }
        }
      };
      var apis = ["init", "fft1d", "ifft1d", "fft2d", "ifft2d"];
      for (var i3 = 0; i3 < apis.length; i3++) {
        FFT3[apis[i3]] = core[apis[i3]];
      }
      FFT3.bt = core.bt1d;
      FFT3.fft = core.fft1d;
      FFT3.ifft = core.ifft1d;
      return FFT3;
    }.call(exports2);
  }
});

// node_modules/ml-fft/src/FFTUtils.js
var require_FFTUtils = __commonJS({
  "node_modules/ml-fft/src/FFTUtils.js"(exports2, module2) {
    "use strict";
    var FFT2 = require_fftlib();
    var FFTUtils = {
      DEBUG: false,
      /**
       * Calculates the inverse of a 2D Fourier transform
       *
       * @param ft
       * @param ftRows
       * @param ftCols
       * @return
       */
      ifft2DArray: function(ft2, ftRows, ftCols) {
        var tempTransform = new Array(ftRows * ftCols);
        var nRows = ftRows / 2;
        var nCols = (ftCols - 1) * 2;
        FFT2.init(nRows);
        var tmpCols = { re: new Array(nRows), im: new Array(nRows) };
        for (var iCol = 0; iCol < ftCols; iCol++) {
          for (var iRow = nRows - 1; iRow >= 0; iRow--) {
            tmpCols.re[iRow] = ft2[iRow * 2 * ftCols + iCol];
            tmpCols.im[iRow] = ft2[(iRow * 2 + 1) * ftCols + iCol];
          }
          FFT2.bt(tmpCols.re, tmpCols.im);
          for (var iRow = nRows - 1; iRow >= 0; iRow--) {
            tempTransform[iRow * 2 * ftCols + iCol] = tmpCols.re[iRow];
            tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];
          }
        }
        var finalTransform = new Array(nRows * nCols);
        FFT2.init(nCols);
        var tmpRows = { re: new Array(nCols), im: new Array(nCols) };
        var scale = nCols * nRows;
        for (var iRow = 0; iRow < ftRows; iRow += 2) {
          tmpRows.re[0] = tempTransform[iRow * ftCols];
          tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];
          for (var iCol = 1; iCol < ftCols; iCol++) {
            tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];
            tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];
            tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];
            tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];
          }
          FFT2.bt(tmpRows.re, tmpRows.im);
          var indexB = iRow / 2 * nCols;
          for (var iCol = nCols - 1; iCol >= 0; iCol--) {
            finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;
          }
        }
        return finalTransform;
      },
      /**
       * Calculates the fourier transform of a matrix of size (nRows,nCols) It is
       * assumed that both nRows and nCols are a power of two
       *
       * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the
       * even rows contain the real part and the odd rows the imaginary part of the
       * transform
       * @param data
       * @param nRows
       * @param nCols
       * @return
       */
      fft2DArray: function(data, nRows, nCols, opt) {
        var options = Object.assign({}, { inplace: true });
        var ftCols = nCols / 2 + 1;
        var ftRows = nRows * 2;
        var tempTransform = new Array(ftRows * ftCols);
        FFT2.init(nCols);
        var tmpRows = { re: new Array(nCols), im: new Array(nCols) };
        var row1 = { re: new Array(nCols), im: new Array(nCols) };
        var row2 = { re: new Array(nCols), im: new Array(nCols) };
        var index2, iRow0, iRow1, iRow2, iRow3;
        for (var iRow = 0; iRow < nRows / 2; iRow++) {
          index2 = iRow * 2 * nCols;
          tmpRows.re = data.slice(index2, index2 + nCols);
          index2 = (iRow * 2 + 1) * nCols;
          tmpRows.im = data.slice(index2, index2 + nCols);
          FFT2.fft1d(tmpRows.re, tmpRows.im);
          this.reconstructTwoRealFFT(tmpRows, row1, row2);
          iRow0 = iRow * 4 * ftCols;
          iRow1 = (iRow * 4 + 1) * ftCols;
          iRow2 = (iRow * 4 + 2) * ftCols;
          iRow3 = (iRow * 4 + 3) * ftCols;
          for (var k2 = ftCols - 1; k2 >= 0; k2--) {
            tempTransform[iRow0 + k2] = row1.re[k2];
            tempTransform[iRow1 + k2] = row1.im[k2];
            tempTransform[iRow2 + k2] = row2.re[k2];
            tempTransform[iRow3 + k2] = row2.im[k2];
          }
        }
        row1 = null;
        row2 = null;
        var finalTransform = new Array(ftRows * ftCols);
        FFT2.init(nRows);
        var tmpCols = { re: new Array(nRows), im: new Array(nRows) };
        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {
          for (var iRow = nRows - 1; iRow >= 0; iRow--) {
            tmpCols.re[iRow] = tempTransform[iRow * 2 * ftCols + iCol];
            tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];
            if (isNaN(tmpCols.re[iRow])) {
              tmpCols.re[iRow] = 0;
            }
            if (isNaN(tmpCols.im[iRow])) {
              tmpCols.im[iRow] = 0;
            }
          }
          FFT2.fft1d(tmpCols.re, tmpCols.im);
          for (var iRow = nRows - 1; iRow >= 0; iRow--) {
            finalTransform[iRow * 2 * ftCols + iCol] = tmpCols.re[iRow];
            finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];
          }
        }
        return finalTransform;
      },
      /**
       *
       * @param fourierTransform
       * @param realTransform1
       * @param realTransform2
       *
       * Reconstructs the individual Fourier transforms of two simultaneously
       * transformed series. Based on the Symmetry relationships (the asterisk
       * denotes the complex conjugate)
       *
       * F_{N-n} = F_n^{*} for a purely real f transformed to F
       *
       * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G
       *
       */
      reconstructTwoRealFFT: function(fourierTransform, realTransform1, realTransform2) {
        var length = fourierTransform.re.length;
        realTransform1.re[0] = fourierTransform.re[0];
        realTransform1.im[0] = 0;
        realTransform2.re[0] = fourierTransform.im[0];
        realTransform2.im[0] = 0;
        var rm, rp, im, ip, j2;
        for (var i3 = length / 2; i3 > 0; i3--) {
          j2 = length - i3;
          rm = 0.5 * (fourierTransform.re[i3] - fourierTransform.re[j2]);
          rp = 0.5 * (fourierTransform.re[i3] + fourierTransform.re[j2]);
          im = 0.5 * (fourierTransform.im[i3] - fourierTransform.im[j2]);
          ip = 0.5 * (fourierTransform.im[i3] + fourierTransform.im[j2]);
          realTransform1.re[i3] = rp;
          realTransform1.im[i3] = im;
          realTransform1.re[j2] = rp;
          realTransform1.im[j2] = -im;
          realTransform2.re[i3] = ip;
          realTransform2.im[i3] = -rm;
          realTransform2.re[j2] = ip;
          realTransform2.im[j2] = rm;
        }
      },
      /**
       * In place version of convolute 2D
       *
       * @param ftSignal
       * @param ftFilter
       * @param ftRows
       * @param ftCols
       * @return
       */
      convolute2DI: function(ftSignal, ftFilter, ftRows, ftCols) {
        var re2, im;
        for (var iRow = 0; iRow < ftRows / 2; iRow++) {
          for (var iCol = 0; iCol < ftCols; iCol++) {
            re2 = ftSignal[iRow * 2 * ftCols + iCol] * ftFilter[iRow * 2 * ftCols + iCol] - ftSignal[(iRow * 2 + 1) * ftCols + iCol] * ftFilter[(iRow * 2 + 1) * ftCols + iCol];
            im = ftSignal[iRow * 2 * ftCols + iCol] * ftFilter[(iRow * 2 + 1) * ftCols + iCol] + ftSignal[(iRow * 2 + 1) * ftCols + iCol] * ftFilter[iRow * 2 * ftCols + iCol];
            ftSignal[iRow * 2 * ftCols + iCol] = re2;
            ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;
          }
        }
      },
      /**
       *
       * @param data
       * @param kernel
       * @param nRows
       * @param nCols
       * @returns {*}
       */
      convolute: function(data, kernel, nRows, nCols, opt) {
        var ftSpectrum = new Array(nCols * nRows);
        for (var i3 = 0; i3 < nRows * nCols; i3++) {
          ftSpectrum[i3] = data[i3];
        }
        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);
        var dimR = kernel.length;
        var dimC = kernel[0].length;
        var ftFilterData = new Array(nCols * nRows);
        for (var i3 = 0; i3 < nCols * nRows; i3++) {
          ftFilterData[i3] = 0;
        }
        var iRow, iCol;
        var shiftR = Math.floor((dimR - 1) / 2);
        var shiftC = Math.floor((dimC - 1) / 2);
        for (var ir = 0; ir < dimR; ir++) {
          iRow = (ir - shiftR + nRows) % nRows;
          for (var ic = 0; ic < dimC; ic++) {
            iCol = (ic - shiftC + nCols) % nCols;
            ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];
          }
        }
        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);
        var ftRows = nRows * 2;
        var ftCols = nCols / 2 + 1;
        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);
        return this.ifft2DArray(ftSpectrum, ftRows, ftCols);
      },
      toRadix2: function(data, nRows, nCols) {
        var i3, j2, irow, icol;
        var cols = nCols, rows = nRows, prows = 0, pcols = 0;
        if (!(nCols !== 0 && (nCols & nCols - 1) === 0)) {
          cols = 0;
          while (nCols >> ++cols != 0)
            ;
          cols = 1 << cols;
          pcols = cols - nCols;
        }
        if (!(nRows !== 0 && (nRows & nRows - 1) === 0)) {
          rows = 0;
          while (nRows >> ++rows != 0)
            ;
          rows = 1 << rows;
          prows = (rows - nRows) * cols;
        }
        if (rows == nRows && cols == nCols)
          return { data, rows: nRows, cols: nCols };
        var output = new Array(rows * cols);
        var shiftR = Math.floor((rows - nRows) / 2) - nRows;
        var shiftC = Math.floor((cols - nCols) / 2) - nCols;
        for (i3 = 0; i3 < rows; i3++) {
          irow = i3 * cols;
          icol = (i3 - shiftR) % nRows * nCols;
          for (j2 = 0; j2 < cols; j2++) {
            output[irow + j2] = data[icol + (j2 - shiftC) % nCols];
          }
        }
        return { data: output, rows, cols };
      },
      /**
       * Crop the given matrix to fit the corresponding number of rows and columns
       */
      crop: function(data, rows, cols, nRows, nCols, opt) {
        if (rows == nRows && cols == nCols)
          return data;
        var options = Object.assign({}, opt);
        var output = new Array(nCols * nRows);
        var shiftR = Math.floor((rows - nRows) / 2);
        var shiftC = Math.floor((cols - nCols) / 2);
        var destinyRow, sourceRow, i3, j2;
        for (i3 = 0; i3 < nRows; i3++) {
          destinyRow = i3 * nCols;
          sourceRow = (i3 + shiftR) * cols;
          for (j2 = 0; j2 < nCols; j2++) {
            output[destinyRow + j2] = data[sourceRow + (j2 + shiftC)];
          }
        }
        return output;
      }
    };
    module2.exports = FFTUtils;
  }
});

// node_modules/ml-fft/src/index.js
var require_src4 = __commonJS({
  "node_modules/ml-fft/src/index.js"(exports2) {
    "use strict";
    exports2.FFTUtils = require_FFTUtils();
    exports2.FFT = require_fftlib();
  }
});

// node_modules/ml-matrix-convolution/src/index.js
var require_src5 = __commonJS({
  "node_modules/ml-matrix-convolution/src/index.js"(exports2, module2) {
    "use strict;";
    var FFTUtils = require_src4().FFTUtils;
    function convolutionFFT(input, kernel, opt) {
      var tmp = matrix2Array(input);
      var inputData = tmp.data;
      var options = Object.assign({ normalize: false, divisor: 1, rows: tmp.rows, cols: tmp.cols }, opt);
      var nRows, nCols;
      if (options.rows && options.cols) {
        nRows = options.rows;
        nCols = options.cols;
      } else {
        throw new Error("Invalid number of rows or columns " + nRows + " " + nCols);
      }
      var divisor = options.divisor;
      var i3, j2;
      var kHeight = kernel.length;
      var kWidth = kernel[0].length;
      if (options.normalize) {
        divisor = 0;
        for (i3 = 0; i3 < kHeight; i3++)
          for (j2 = 0; j2 < kWidth; j2++)
            divisor += kernel[i3][j2];
      }
      if (divisor === 0) {
        throw new RangeError("convolution: The divisor is equal to zero");
      }
      var radix2Sized = FFTUtils.toRadix2(inputData, nRows, nCols);
      var conv = FFTUtils.convolute(radix2Sized.data, kernel, radix2Sized.rows, radix2Sized.cols);
      conv = FFTUtils.crop(conv, radix2Sized.rows, radix2Sized.cols, nRows, nCols);
      if (divisor != 0 && divisor != 1) {
        for (i3 = 0; i3 < conv.length; i3++) {
          conv[i3] /= divisor;
        }
      }
      return conv;
    }
    function convolutionDirect(input, kernel, opt) {
      var tmp = matrix2Array(input);
      var inputData = tmp.data;
      var options = Object.assign({ normalize: false, divisor: 1, rows: tmp.rows, cols: tmp.cols }, opt);
      var nRows, nCols;
      if (options.rows && options.cols) {
        nRows = options.rows;
        nCols = options.cols;
      } else {
        throw new Error("Invalid number of rows or columns " + nRows + " " + nCols);
      }
      var divisor = options.divisor;
      var kHeight = kernel.length;
      var kWidth = kernel[0].length;
      var i3, j2, x2, y3, index2, sum2, kVal, row, col;
      if (options.normalize) {
        divisor = 0;
        for (i3 = 0; i3 < kHeight; i3++)
          for (j2 = 0; j2 < kWidth; j2++)
            divisor += kernel[i3][j2];
      }
      if (divisor === 0) {
        throw new RangeError("convolution: The divisor is equal to zero");
      }
      var output = new Array(nRows * nCols);
      var hHeight = Math.floor(kHeight / 2);
      var hWidth = Math.floor(kWidth / 2);
      for (y3 = 0; y3 < nRows; y3++) {
        for (x2 = 0; x2 < nCols; x2++) {
          sum2 = 0;
          for (j2 = 0; j2 < kHeight; j2++) {
            for (i3 = 0; i3 < kWidth; i3++) {
              kVal = kernel[kHeight - j2 - 1][kWidth - i3 - 1];
              row = (y3 + j2 - hHeight + nRows) % nRows;
              col = (x2 + i3 - hWidth + nCols) % nCols;
              index2 = row * nCols + col;
              sum2 += inputData[index2] * kVal;
            }
          }
          index2 = y3 * nCols + x2;
          output[index2] = sum2 / divisor;
        }
      }
      return output;
    }
    function LoG(sigma, nPoints, options) {
      var factor = 1e3;
      if (options && options.factor) {
        factor = options.factor;
      }
      var kernel = new Array(nPoints);
      var i3, j2, tmp, y22, tmp2;
      factor *= -1;
      var center = (nPoints - 1) / 2;
      var sigma2 = 2 * sigma * sigma;
      for (i3 = 0; i3 < nPoints; i3++) {
        kernel[i3] = new Array(nPoints);
        y22 = (i3 - center) * (i3 - center);
        for (j2 = 0; j2 < nPoints; j2++) {
          tmp = -((j2 - center) * (j2 - center) + y22) / sigma2;
          kernel[i3][j2] = Math.round(factor * (1 + tmp) * Math.exp(tmp));
        }
      }
      return kernel;
    }
    function matrix2Array(input) {
      var inputData = input;
      var nRows, nCols;
      if (typeof input[0] != "number") {
        nRows = input.length;
        nCols = input[0].length;
        inputData = new Array(nRows * nCols);
        for (var i3 = 0; i3 < nRows; i3++) {
          for (var j2 = 0; j2 < nCols; j2++) {
            inputData[i3 * nCols + j2] = input[i3][j2];
          }
        }
      } else {
        var tmp = Math.sqrt(input.length);
        if (Number.isInteger(tmp)) {
          nRows = tmp;
          nCols = tmp;
        }
      }
      return { data: inputData, rows: nRows, cols: nCols };
    }
    module2.exports = {
      fft: convolutionFFT,
      direct: convolutionDirect,
      kernelFactory: { LoG },
      matrix2Array
    };
  }
});

// node_modules/is-finite/index.js
var require_is_finite = __commonJS({
  "node_modules/is-finite/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isFinite || function(value) {
      return !(typeof value !== "number" || value !== value || value === Infinity || value === -Infinity);
    };
  }
});

// node_modules/is-integer/index.js
var require_is_integer = __commonJS({
  "node_modules/is-integer/index.js"(exports2, module2) {
    var isFinite2 = require_is_finite();
    module2.exports = Number.isInteger || function(val) {
      return typeof val === "number" && isFinite2(val) && Math.floor(val) === val;
    };
  }
});

// node_modules/fft.js/lib/fft.js
var require_fft = __commonJS({
  "node_modules/fft.js/lib/fft.js"(exports2, module2) {
    "use strict";
    function FFT2(size) {
      this.size = size | 0;
      if (this.size <= 1 || (this.size & this.size - 1) !== 0)
        throw new Error("FFT size must be a power of two and bigger than 1");
      this._csize = size << 1;
      var table = new Array(this.size * 2);
      for (var i3 = 0; i3 < table.length; i3 += 2) {
        const angle = Math.PI * i3 / this.size;
        table[i3] = Math.cos(angle);
        table[i3 + 1] = -Math.sin(angle);
      }
      this.table = table;
      var power = 0;
      for (var t3 = 1; this.size > t3; t3 <<= 1)
        power++;
      this._width = power % 2 === 0 ? power - 1 : power;
      this._bitrev = new Array(1 << this._width);
      for (var j2 = 0; j2 < this._bitrev.length; j2++) {
        this._bitrev[j2] = 0;
        for (var shift = 0; shift < this._width; shift += 2) {
          var revShift = this._width - shift - 2;
          this._bitrev[j2] |= (j2 >>> shift & 3) << revShift;
        }
      }
      this._out = null;
      this._data = null;
      this._inv = 0;
    }
    module2.exports = FFT2;
    FFT2.prototype.fromComplexArray = function fromComplexArray(complex, storage) {
      var res = storage || new Array(complex.length >>> 1);
      for (var i3 = 0; i3 < complex.length; i3 += 2)
        res[i3 >>> 1] = complex[i3];
      return res;
    };
    FFT2.prototype.createComplexArray = function createComplexArray() {
      const res = new Array(this._csize);
      for (var i3 = 0; i3 < res.length; i3++)
        res[i3] = 0;
      return res;
    };
    FFT2.prototype.toComplexArray = function toComplexArray(input, storage) {
      var res = storage || this.createComplexArray();
      for (var i3 = 0; i3 < res.length; i3 += 2) {
        res[i3] = input[i3 >>> 1];
        res[i3 + 1] = 0;
      }
      return res;
    };
    FFT2.prototype.completeSpectrum = function completeSpectrum(spectrum) {
      var size = this._csize;
      var half = size >>> 1;
      for (var i3 = 2; i3 < half; i3 += 2) {
        spectrum[size - i3] = spectrum[i3];
        spectrum[size - i3 + 1] = -spectrum[i3 + 1];
      }
    };
    FFT2.prototype.transform = function transform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 0;
      this._transform4();
      this._out = null;
      this._data = null;
    };
    FFT2.prototype.realTransform = function realTransform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 0;
      this._realTransform4();
      this._out = null;
      this._data = null;
    };
    FFT2.prototype.inverseTransform = function inverseTransform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 1;
      this._transform4();
      for (var i3 = 0; i3 < out.length; i3++)
        out[i3] /= this.size;
      this._out = null;
      this._data = null;
    };
    FFT2.prototype._transform4 = function _transform4() {
      var out = this._out;
      var size = this._csize;
      var width = this._width;
      var step = 1 << width;
      var len = size / step << 1;
      var outOff;
      var t3;
      var bitrev = this._bitrev;
      if (len === 4) {
        for (outOff = 0, t3 = 0; outOff < size; outOff += len, t3++) {
          const off = bitrev[t3];
          this._singleTransform2(outOff, off, step);
        }
      } else {
        for (outOff = 0, t3 = 0; outOff < size; outOff += len, t3++) {
          const off = bitrev[t3];
          this._singleTransform4(outOff, off, step);
        }
      }
      var inv = this._inv ? -1 : 1;
      var table = this.table;
      for (step >>= 2; step >= 2; step >>= 2) {
        len = size / step << 1;
        var quarterLen = len >>> 2;
        for (outOff = 0; outOff < size; outOff += len) {
          var limit = outOff + quarterLen;
          for (var i3 = outOff, k2 = 0; i3 < limit; i3 += 2, k2 += step) {
            const A2 = i3;
            const B2 = A2 + quarterLen;
            const C2 = B2 + quarterLen;
            const D2 = C2 + quarterLen;
            const Ar = out[A2];
            const Ai = out[A2 + 1];
            const Br = out[B2];
            const Bi = out[B2 + 1];
            const Cr = out[C2];
            const Ci = out[C2 + 1];
            const Dr = out[D2];
            const Di = out[D2 + 1];
            const MAr = Ar;
            const MAi = Ai;
            const tableBr = table[k2];
            const tableBi = inv * table[k2 + 1];
            const MBr = Br * tableBr - Bi * tableBi;
            const MBi = Br * tableBi + Bi * tableBr;
            const tableCr = table[2 * k2];
            const tableCi = inv * table[2 * k2 + 1];
            const MCr = Cr * tableCr - Ci * tableCi;
            const MCi = Cr * tableCi + Ci * tableCr;
            const tableDr = table[3 * k2];
            const tableDi = inv * table[3 * k2 + 1];
            const MDr = Dr * tableDr - Di * tableDi;
            const MDi = Dr * tableDi + Di * tableDr;
            const T0r = MAr + MCr;
            const T0i = MAi + MCi;
            const T1r = MAr - MCr;
            const T1i = MAi - MCi;
            const T2r = MBr + MDr;
            const T2i = MBi + MDi;
            const T3r = inv * (MBr - MDr);
            const T3i = inv * (MBi - MDi);
            const FAr = T0r + T2r;
            const FAi = T0i + T2i;
            const FCr = T0r - T2r;
            const FCi = T0i - T2i;
            const FBr = T1r + T3i;
            const FBi = T1i - T3r;
            const FDr = T1r - T3i;
            const FDi = T1i + T3r;
            out[A2] = FAr;
            out[A2 + 1] = FAi;
            out[B2] = FBr;
            out[B2 + 1] = FBi;
            out[C2] = FCr;
            out[C2 + 1] = FCi;
            out[D2] = FDr;
            out[D2 + 1] = FDi;
          }
        }
      }
    };
    FFT2.prototype._singleTransform2 = function _singleTransform2(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const evenR = data[off];
      const evenI = data[off + 1];
      const oddR = data[off + step];
      const oddI = data[off + step + 1];
      const leftR = evenR + oddR;
      const leftI = evenI + oddI;
      const rightR = evenR - oddR;
      const rightI = evenI - oddI;
      out[outOff] = leftR;
      out[outOff + 1] = leftI;
      out[outOff + 2] = rightR;
      out[outOff + 3] = rightI;
    };
    FFT2.prototype._singleTransform4 = function _singleTransform4(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const inv = this._inv ? -1 : 1;
      const step2 = step * 2;
      const step3 = step * 3;
      const Ar = data[off];
      const Ai = data[off + 1];
      const Br = data[off + step];
      const Bi = data[off + step + 1];
      const Cr = data[off + step2];
      const Ci = data[off + step2 + 1];
      const Dr = data[off + step3];
      const Di = data[off + step3 + 1];
      const T0r = Ar + Cr;
      const T0i = Ai + Ci;
      const T1r = Ar - Cr;
      const T1i = Ai - Ci;
      const T2r = Br + Dr;
      const T2i = Bi + Di;
      const T3r = inv * (Br - Dr);
      const T3i = inv * (Bi - Di);
      const FAr = T0r + T2r;
      const FAi = T0i + T2i;
      const FBr = T1r + T3i;
      const FBi = T1i - T3r;
      const FCr = T0r - T2r;
      const FCi = T0i - T2i;
      const FDr = T1r - T3i;
      const FDi = T1i + T3r;
      out[outOff] = FAr;
      out[outOff + 1] = FAi;
      out[outOff + 2] = FBr;
      out[outOff + 3] = FBi;
      out[outOff + 4] = FCr;
      out[outOff + 5] = FCi;
      out[outOff + 6] = FDr;
      out[outOff + 7] = FDi;
    };
    FFT2.prototype._realTransform4 = function _realTransform4() {
      var out = this._out;
      var size = this._csize;
      var width = this._width;
      var step = 1 << width;
      var len = size / step << 1;
      var outOff;
      var t3;
      var bitrev = this._bitrev;
      if (len === 4) {
        for (outOff = 0, t3 = 0; outOff < size; outOff += len, t3++) {
          const off = bitrev[t3];
          this._singleRealTransform2(outOff, off >>> 1, step >>> 1);
        }
      } else {
        for (outOff = 0, t3 = 0; outOff < size; outOff += len, t3++) {
          const off = bitrev[t3];
          this._singleRealTransform4(outOff, off >>> 1, step >>> 1);
        }
      }
      var inv = this._inv ? -1 : 1;
      var table = this.table;
      for (step >>= 2; step >= 2; step >>= 2) {
        len = size / step << 1;
        var halfLen = len >>> 1;
        var quarterLen = halfLen >>> 1;
        var hquarterLen = quarterLen >>> 1;
        for (outOff = 0; outOff < size; outOff += len) {
          for (var i3 = 0, k2 = 0; i3 <= hquarterLen; i3 += 2, k2 += step) {
            var A2 = outOff + i3;
            var B2 = A2 + quarterLen;
            var C2 = B2 + quarterLen;
            var D2 = C2 + quarterLen;
            var Ar = out[A2];
            var Ai = out[A2 + 1];
            var Br = out[B2];
            var Bi = out[B2 + 1];
            var Cr = out[C2];
            var Ci = out[C2 + 1];
            var Dr = out[D2];
            var Di = out[D2 + 1];
            var MAr = Ar;
            var MAi = Ai;
            var tableBr = table[k2];
            var tableBi = inv * table[k2 + 1];
            var MBr = Br * tableBr - Bi * tableBi;
            var MBi = Br * tableBi + Bi * tableBr;
            var tableCr = table[2 * k2];
            var tableCi = inv * table[2 * k2 + 1];
            var MCr = Cr * tableCr - Ci * tableCi;
            var MCi = Cr * tableCi + Ci * tableCr;
            var tableDr = table[3 * k2];
            var tableDi = inv * table[3 * k2 + 1];
            var MDr = Dr * tableDr - Di * tableDi;
            var MDi = Dr * tableDi + Di * tableDr;
            var T0r = MAr + MCr;
            var T0i = MAi + MCi;
            var T1r = MAr - MCr;
            var T1i = MAi - MCi;
            var T2r = MBr + MDr;
            var T2i = MBi + MDi;
            var T3r = inv * (MBr - MDr);
            var T3i = inv * (MBi - MDi);
            var FAr = T0r + T2r;
            var FAi = T0i + T2i;
            var FBr = T1r + T3i;
            var FBi = T1i - T3r;
            out[A2] = FAr;
            out[A2 + 1] = FAi;
            out[B2] = FBr;
            out[B2 + 1] = FBi;
            if (i3 === 0) {
              var FCr = T0r - T2r;
              var FCi = T0i - T2i;
              out[C2] = FCr;
              out[C2 + 1] = FCi;
              continue;
            }
            if (i3 === hquarterLen)
              continue;
            var ST0r = T1r;
            var ST0i = -T1i;
            var ST1r = T0r;
            var ST1i = -T0i;
            var ST2r = -inv * T3i;
            var ST2i = -inv * T3r;
            var ST3r = -inv * T2i;
            var ST3i = -inv * T2r;
            var SFAr = ST0r + ST2r;
            var SFAi = ST0i + ST2i;
            var SFBr = ST1r + ST3i;
            var SFBi = ST1i - ST3r;
            var SA = outOff + quarterLen - i3;
            var SB = outOff + halfLen - i3;
            out[SA] = SFAr;
            out[SA + 1] = SFAi;
            out[SB] = SFBr;
            out[SB + 1] = SFBi;
          }
        }
      }
    };
    FFT2.prototype._singleRealTransform2 = function _singleRealTransform2(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const evenR = data[off];
      const oddR = data[off + step];
      const leftR = evenR + oddR;
      const rightR = evenR - oddR;
      out[outOff] = leftR;
      out[outOff + 1] = 0;
      out[outOff + 2] = rightR;
      out[outOff + 3] = 0;
    };
    FFT2.prototype._singleRealTransform4 = function _singleRealTransform4(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const inv = this._inv ? -1 : 1;
      const step2 = step * 2;
      const step3 = step * 3;
      const Ar = data[off];
      const Br = data[off + step];
      const Cr = data[off + step2];
      const Dr = data[off + step3];
      const T0r = Ar + Cr;
      const T1r = Ar - Cr;
      const T2r = Br + Dr;
      const T3r = inv * (Br - Dr);
      const FAr = T0r + T2r;
      const FBr = T1r;
      const FBi = -T3r;
      const FCr = T0r - T2r;
      const FDr = T1r;
      const FDi = T3r;
      out[outOff] = FAr;
      out[outOff + 1] = 0;
      out[outOff + 2] = FBr;
      out[outOff + 3] = FBi;
      out[outOff + 4] = FCr;
      out[outOff + 5] = 0;
      out[outOff + 6] = FDr;
      out[outOff + 7] = FDi;
    };
  }
});

// node_modules/next-power-of-two/index.js
var require_next_power_of_two = __commonJS({
  "node_modules/next-power-of-two/index.js"(exports2, module2) {
    module2.exports = nextPowerOfTwo;
    function nextPowerOfTwo(n3) {
      if (n3 === 0)
        return 1;
      n3--;
      n3 |= n3 >> 1;
      n3 |= n3 >> 2;
      n3 |= n3 >> 4;
      n3 |= n3 >> 8;
      n3 |= n3 >> 16;
      return n3 + 1;
    }
  }
});

// node_modules/is-any-array/lib/index.js
var require_lib = __commonJS({
  "node_modules/is-any-array/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAnyArray = void 0;
    var toString2 = Object.prototype.toString;
    function isAnyArray3(value) {
      const tag = toString2.call(value);
      return tag.endsWith("Array]") && !tag.includes("Big");
    }
    exports2.isAnyArray = isAnyArray3;
  }
});

// node_modules/ml-array-max/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ml-array-max/lib/index.js"(exports2, module2) {
    "use strict";
    var isAnyArray3 = require_lib();
    function max4(input, options = {}) {
      if (!isAnyArray3.isAnyArray(input)) {
        throw new TypeError("input must be an array");
      }
      if (input.length === 0) {
        throw new TypeError("input must not be empty");
      }
      const { fromIndex = 0, toIndex = input.length } = options;
      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error("fromIndex must be a positive integer smaller than length");
      }
      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error(
          "toIndex must be an integer greater than fromIndex and at most equal to length"
        );
      }
      let maxValue = input[fromIndex];
      for (let i3 = fromIndex + 1; i3 < toIndex; i3++) {
        if (input[i3] > maxValue)
          maxValue = input[i3];
      }
      return maxValue;
    }
    module2.exports = max4;
  }
});

// node_modules/ml-array-min/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/ml-array-min/lib/index.js"(exports2, module2) {
    "use strict";
    var isAnyArray3 = require_lib();
    function min3(input, options = {}) {
      if (!isAnyArray3.isAnyArray(input)) {
        throw new TypeError("input must be an array");
      }
      if (input.length === 0) {
        throw new TypeError("input must not be empty");
      }
      const { fromIndex = 0, toIndex = input.length } = options;
      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error("fromIndex must be a positive integer smaller than length");
      }
      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error(
          "toIndex must be an integer greater than fromIndex and at most equal to length"
        );
      }
      let minValue = input[fromIndex];
      for (let i3 = fromIndex + 1; i3 < toIndex; i3++) {
        if (input[i3] < minValue)
          minValue = input[i3];
      }
      return minValue;
    }
    module2.exports = min3;
  }
});

// node_modules/ml-array-rescale/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/ml-array-rescale/lib/index.js"(exports2, module2) {
    "use strict";
    var isAnyArray3 = require_lib();
    var max4 = require_lib2();
    var min3 = require_lib3();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
    }
    var max__default = /* @__PURE__ */ _interopDefaultLegacy(max4);
    var min__default = /* @__PURE__ */ _interopDefaultLegacy(min3);
    function rescale(input, options = {}) {
      if (!isAnyArray3.isAnyArray(input)) {
        throw new TypeError("input must be an array");
      } else if (input.length === 0) {
        throw new TypeError("input must not be empty");
      }
      let output;
      if (options.output !== void 0) {
        if (!isAnyArray3.isAnyArray(options.output)) {
          throw new TypeError("output option must be an array if specified");
        }
        output = options.output;
      } else {
        output = new Array(input.length);
      }
      const currentMin = min__default["default"](input);
      const currentMax = max__default["default"](input);
      if (currentMin === currentMax) {
        throw new RangeError(
          "minimum and maximum input values are equal. Cannot rescale a constant array"
        );
      }
      const {
        min: minValue = options.autoMinMax ? currentMin : 0,
        max: maxValue = options.autoMinMax ? currentMax : 1
      } = options;
      if (minValue >= maxValue) {
        throw new RangeError("min option must be smaller than max option");
      }
      const factor = (maxValue - minValue) / (currentMax - currentMin);
      for (let i3 = 0; i3 < input.length; i3++) {
        output[i3] = (input[i3] - currentMin) * factor + minValue;
      }
      return output;
    }
    module2.exports = rescale;
  }
});

// node_modules/ml-matrix/matrix.js
var require_matrix = __commonJS({
  "node_modules/ml-matrix/matrix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isAnyArray3 = require_lib();
    var rescale = require_lib4();
    var indent = " ".repeat(2);
    var indentData = " ".repeat(4);
    function inspectMatrix() {
      return inspectMatrixWithOptions(this);
    }
    function inspectMatrixWithOptions(matrix2, options = {}) {
      const {
        maxRows = 15,
        maxColumns = 10,
        maxNumSize = 8,
        padMinus = "auto"
      } = options;
      return `${matrix2.constructor.name} {
${indent}[
${indentData}${inspectData(matrix2, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix2.rows}
${indent}columns: ${matrix2.columns}
}`;
    }
    function inspectData(matrix2, maxRows, maxColumns, maxNumSize, padMinus) {
      const { rows, columns } = matrix2;
      const maxI = Math.min(rows, maxRows);
      const maxJ = Math.min(columns, maxColumns);
      const result = [];
      if (padMinus === "auto") {
        padMinus = false;
        loop:
          for (let i3 = 0; i3 < maxI; i3++) {
            for (let j2 = 0; j2 < maxJ; j2++) {
              if (matrix2.get(i3, j2) < 0) {
                padMinus = true;
                break loop;
              }
            }
          }
      }
      for (let i3 = 0; i3 < maxI; i3++) {
        let line = [];
        for (let j2 = 0; j2 < maxJ; j2++) {
          line.push(formatNumber(matrix2.get(i3, j2), maxNumSize, padMinus));
        }
        result.push(`${line.join(" ")}`);
      }
      if (maxJ !== columns) {
        result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
      }
      if (maxI !== rows) {
        result.push(`... ${rows - maxRows} more rows`);
      }
      return result.join(`
${indentData}`);
    }
    function formatNumber(num, maxNumSize, padMinus) {
      return (num >= 0 && padMinus ? ` ${formatNumber2(num, maxNumSize - 1)}` : formatNumber2(num, maxNumSize)).padEnd(maxNumSize);
    }
    function formatNumber2(num, len) {
      let str = num.toString();
      if (str.length <= len)
        return str;
      let fix = num.toFixed(len);
      if (fix.length > len) {
        fix = num.toFixed(Math.max(0, len - (fix.length - len)));
      }
      if (fix.length <= len && !fix.startsWith("0.000") && !fix.startsWith("-0.000")) {
        return fix;
      }
      let exp = num.toExponential(len);
      if (exp.length > len) {
        exp = num.toExponential(Math.max(0, len - (exp.length - len)));
      }
      return exp.slice(0);
    }
    function installMathOperations(AbstractMatrix3, Matrix6) {
      AbstractMatrix3.prototype.add = function add2(value) {
        if (typeof value === "number")
          return this.addS(value);
        return this.addM(value);
      };
      AbstractMatrix3.prototype.addS = function addS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) + value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.addM = function addM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) + matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.add = function add2(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.add(value);
      };
      AbstractMatrix3.prototype.sub = function sub(value) {
        if (typeof value === "number")
          return this.subS(value);
        return this.subM(value);
      };
      AbstractMatrix3.prototype.subS = function subS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) - value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.subM = function subM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) - matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.sub = function sub(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.sub(value);
      };
      AbstractMatrix3.prototype.subtract = AbstractMatrix3.prototype.sub;
      AbstractMatrix3.prototype.subtractS = AbstractMatrix3.prototype.subS;
      AbstractMatrix3.prototype.subtractM = AbstractMatrix3.prototype.subM;
      AbstractMatrix3.subtract = AbstractMatrix3.sub;
      AbstractMatrix3.prototype.mul = function mul(value) {
        if (typeof value === "number")
          return this.mulS(value);
        return this.mulM(value);
      };
      AbstractMatrix3.prototype.mulS = function mulS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) * value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.mulM = function mulM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) * matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.mul = function mul(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.mul(value);
      };
      AbstractMatrix3.prototype.multiply = AbstractMatrix3.prototype.mul;
      AbstractMatrix3.prototype.multiplyS = AbstractMatrix3.prototype.mulS;
      AbstractMatrix3.prototype.multiplyM = AbstractMatrix3.prototype.mulM;
      AbstractMatrix3.multiply = AbstractMatrix3.mul;
      AbstractMatrix3.prototype.div = function div(value) {
        if (typeof value === "number")
          return this.divS(value);
        return this.divM(value);
      };
      AbstractMatrix3.prototype.divS = function divS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) / value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.divM = function divM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) / matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.div = function div(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.div(value);
      };
      AbstractMatrix3.prototype.divide = AbstractMatrix3.prototype.div;
      AbstractMatrix3.prototype.divideS = AbstractMatrix3.prototype.divS;
      AbstractMatrix3.prototype.divideM = AbstractMatrix3.prototype.divM;
      AbstractMatrix3.divide = AbstractMatrix3.div;
      AbstractMatrix3.prototype.mod = function mod(value) {
        if (typeof value === "number")
          return this.modS(value);
        return this.modM(value);
      };
      AbstractMatrix3.prototype.modS = function modS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) % value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.modM = function modM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) % matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.mod = function mod(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.mod(value);
      };
      AbstractMatrix3.prototype.modulus = AbstractMatrix3.prototype.mod;
      AbstractMatrix3.prototype.modulusS = AbstractMatrix3.prototype.modS;
      AbstractMatrix3.prototype.modulusM = AbstractMatrix3.prototype.modM;
      AbstractMatrix3.modulus = AbstractMatrix3.mod;
      AbstractMatrix3.prototype.and = function and(value) {
        if (typeof value === "number")
          return this.andS(value);
        return this.andM(value);
      };
      AbstractMatrix3.prototype.andS = function andS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) & value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.andM = function andM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) & matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.and = function and(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.and(value);
      };
      AbstractMatrix3.prototype.or = function or(value) {
        if (typeof value === "number")
          return this.orS(value);
        return this.orM(value);
      };
      AbstractMatrix3.prototype.orS = function orS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) | value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.orM = function orM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) | matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.or = function or(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.or(value);
      };
      AbstractMatrix3.prototype.xor = function xor(value) {
        if (typeof value === "number")
          return this.xorS(value);
        return this.xorM(value);
      };
      AbstractMatrix3.prototype.xorS = function xorS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) ^ value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.xorM = function xorM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) ^ matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.xor = function xor(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.xor(value);
      };
      AbstractMatrix3.prototype.leftShift = function leftShift(value) {
        if (typeof value === "number")
          return this.leftShiftS(value);
        return this.leftShiftM(value);
      };
      AbstractMatrix3.prototype.leftShiftS = function leftShiftS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) << value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.leftShiftM = function leftShiftM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) << matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.leftShift = function leftShift(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.leftShift(value);
      };
      AbstractMatrix3.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
        if (typeof value === "number")
          return this.signPropagatingRightShiftS(value);
        return this.signPropagatingRightShiftM(value);
      };
      AbstractMatrix3.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) >> value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) >> matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.signPropagatingRightShift = function signPropagatingRightShift(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.signPropagatingRightShift(value);
      };
      AbstractMatrix3.prototype.rightShift = function rightShift(value) {
        if (typeof value === "number")
          return this.rightShiftS(value);
        return this.rightShiftM(value);
      };
      AbstractMatrix3.prototype.rightShiftS = function rightShiftS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) >>> value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.rightShiftM = function rightShiftM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) >>> matrix2.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.rightShift = function rightShift(matrix2, value) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.rightShift(value);
      };
      AbstractMatrix3.prototype.zeroFillRightShift = AbstractMatrix3.prototype.rightShift;
      AbstractMatrix3.prototype.zeroFillRightShiftS = AbstractMatrix3.prototype.rightShiftS;
      AbstractMatrix3.prototype.zeroFillRightShiftM = AbstractMatrix3.prototype.rightShiftM;
      AbstractMatrix3.zeroFillRightShift = AbstractMatrix3.rightShift;
      AbstractMatrix3.prototype.not = function not() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, ~this.get(i3, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.not = function not(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.not();
      };
      AbstractMatrix3.prototype.abs = function abs2() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.abs(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.abs = function abs2(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.abs();
      };
      AbstractMatrix3.prototype.acos = function acos() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.acos(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.acos = function acos(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.acos();
      };
      AbstractMatrix3.prototype.acosh = function acosh() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.acosh(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.acosh = function acosh(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.acosh();
      };
      AbstractMatrix3.prototype.asin = function asin() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.asin(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.asin = function asin(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.asin();
      };
      AbstractMatrix3.prototype.asinh = function asinh() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.asinh(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.asinh = function asinh(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.asinh();
      };
      AbstractMatrix3.prototype.atan = function atan() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.atan(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.atan = function atan(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.atan();
      };
      AbstractMatrix3.prototype.atanh = function atanh() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.atanh(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.atanh = function atanh(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.atanh();
      };
      AbstractMatrix3.prototype.cbrt = function cbrt() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.cbrt(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.cbrt = function cbrt(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.cbrt();
      };
      AbstractMatrix3.prototype.ceil = function ceil() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.ceil(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.ceil = function ceil(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.ceil();
      };
      AbstractMatrix3.prototype.clz32 = function clz32() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.clz32(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.clz32 = function clz32(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.clz32();
      };
      AbstractMatrix3.prototype.cos = function cos() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.cos(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.cos = function cos(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.cos();
      };
      AbstractMatrix3.prototype.cosh = function cosh() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.cosh(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.cosh = function cosh(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.cosh();
      };
      AbstractMatrix3.prototype.exp = function exp() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.exp(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.exp = function exp(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.exp();
      };
      AbstractMatrix3.prototype.expm1 = function expm1() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.expm1(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.expm1 = function expm1(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.expm1();
      };
      AbstractMatrix3.prototype.floor = function floor() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.floor(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.floor = function floor(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.floor();
      };
      AbstractMatrix3.prototype.fround = function fround() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.fround(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.fround = function fround(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.fround();
      };
      AbstractMatrix3.prototype.log = function log() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.log(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.log = function log(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.log();
      };
      AbstractMatrix3.prototype.log1p = function log1p() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.log1p(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.log1p = function log1p(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.log1p();
      };
      AbstractMatrix3.prototype.log10 = function log10() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.log10(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.log10 = function log10(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.log10();
      };
      AbstractMatrix3.prototype.log2 = function log2() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.log2(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.log2 = function log2(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.log2();
      };
      AbstractMatrix3.prototype.round = function round2() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.round(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.round = function round2(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.round();
      };
      AbstractMatrix3.prototype.sign = function sign() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.sign(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.sign = function sign(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.sign();
      };
      AbstractMatrix3.prototype.sin = function sin() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.sin(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.sin = function sin(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.sin();
      };
      AbstractMatrix3.prototype.sinh = function sinh() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.sinh(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.sinh = function sinh(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.sinh();
      };
      AbstractMatrix3.prototype.sqrt = function sqrt() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.sqrt(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.sqrt = function sqrt(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.sqrt();
      };
      AbstractMatrix3.prototype.tan = function tan() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.tan(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.tan = function tan(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.tan();
      };
      AbstractMatrix3.prototype.tanh = function tanh() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.tanh(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.tanh = function tanh(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.tanh();
      };
      AbstractMatrix3.prototype.trunc = function trunc() {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.trunc(this.get(i3, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.trunc = function trunc(matrix2) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.trunc();
      };
      AbstractMatrix3.pow = function pow(matrix2, arg0) {
        const newMatrix = new Matrix6(matrix2);
        return newMatrix.pow(arg0);
      };
      AbstractMatrix3.prototype.pow = function pow(value) {
        if (typeof value === "number")
          return this.powS(value);
        return this.powM(value);
      };
      AbstractMatrix3.prototype.powS = function powS(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.pow(this.get(i3, j2), value));
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.powM = function powM(matrix2) {
        matrix2 = Matrix6.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, Math.pow(this.get(i3, j2), matrix2.get(i3, j2)));
          }
        }
        return this;
      };
    }
    function checkRowIndex(matrix2, index2, outer) {
      let max4 = outer ? matrix2.rows : matrix2.rows - 1;
      if (index2 < 0 || index2 > max4) {
        throw new RangeError("Row index out of range");
      }
    }
    function checkColumnIndex(matrix2, index2, outer) {
      let max4 = outer ? matrix2.columns : matrix2.columns - 1;
      if (index2 < 0 || index2 > max4) {
        throw new RangeError("Column index out of range");
      }
    }
    function checkRowVector(matrix2, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix2.columns) {
        throw new RangeError(
          "vector size must be the same as the number of columns"
        );
      }
      return vector;
    }
    function checkColumnVector(matrix2, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix2.rows) {
        throw new RangeError("vector size must be the same as the number of rows");
      }
      return vector;
    }
    function checkRowIndices(matrix2, rowIndices) {
      if (!isAnyArray3.isAnyArray(rowIndices)) {
        throw new TypeError("row indices must be an array");
      }
      for (let i3 = 0; i3 < rowIndices.length; i3++) {
        if (rowIndices[i3] < 0 || rowIndices[i3] >= matrix2.rows) {
          throw new RangeError("row indices are out of range");
        }
      }
    }
    function checkColumnIndices(matrix2, columnIndices) {
      if (!isAnyArray3.isAnyArray(columnIndices)) {
        throw new TypeError("column indices must be an array");
      }
      for (let i3 = 0; i3 < columnIndices.length; i3++) {
        if (columnIndices[i3] < 0 || columnIndices[i3] >= matrix2.columns) {
          throw new RangeError("column indices are out of range");
        }
      }
    }
    function checkRange(matrix2, startRow, endRow, startColumn, endColumn) {
      if (arguments.length !== 5) {
        throw new RangeError("expected 4 arguments");
      }
      checkNumber("startRow", startRow);
      checkNumber("endRow", endRow);
      checkNumber("startColumn", startColumn);
      checkNumber("endColumn", endColumn);
      if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix2.rows || endRow < 0 || endRow >= matrix2.rows || startColumn < 0 || startColumn >= matrix2.columns || endColumn < 0 || endColumn >= matrix2.columns) {
        throw new RangeError("Submatrix indices are out of range");
      }
    }
    function newArray8(length, value = 0) {
      let array3 = [];
      for (let i3 = 0; i3 < length; i3++) {
        array3.push(value);
      }
      return array3;
    }
    function checkNumber(name, value) {
      if (typeof value !== "number") {
        throw new TypeError(`${name} must be a number`);
      }
    }
    function checkNonEmpty(matrix2) {
      if (matrix2.isEmpty()) {
        throw new Error("Empty matrix has no elements to index");
      }
    }
    function sumByRow(matrix2) {
      let sum2 = newArray8(matrix2.rows);
      for (let i3 = 0; i3 < matrix2.rows; ++i3) {
        for (let j2 = 0; j2 < matrix2.columns; ++j2) {
          sum2[i3] += matrix2.get(i3, j2);
        }
      }
      return sum2;
    }
    function sumByColumn(matrix2) {
      let sum2 = newArray8(matrix2.columns);
      for (let i3 = 0; i3 < matrix2.rows; ++i3) {
        for (let j2 = 0; j2 < matrix2.columns; ++j2) {
          sum2[j2] += matrix2.get(i3, j2);
        }
      }
      return sum2;
    }
    function sumAll(matrix2) {
      let v3 = 0;
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          v3 += matrix2.get(i3, j2);
        }
      }
      return v3;
    }
    function productByRow(matrix2) {
      let sum2 = newArray8(matrix2.rows, 1);
      for (let i3 = 0; i3 < matrix2.rows; ++i3) {
        for (let j2 = 0; j2 < matrix2.columns; ++j2) {
          sum2[i3] *= matrix2.get(i3, j2);
        }
      }
      return sum2;
    }
    function productByColumn(matrix2) {
      let sum2 = newArray8(matrix2.columns, 1);
      for (let i3 = 0; i3 < matrix2.rows; ++i3) {
        for (let j2 = 0; j2 < matrix2.columns; ++j2) {
          sum2[j2] *= matrix2.get(i3, j2);
        }
      }
      return sum2;
    }
    function productAll(matrix2) {
      let v3 = 1;
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          v3 *= matrix2.get(i3, j2);
        }
      }
      return v3;
    }
    function varianceByRow(matrix2, unbiased, mean4) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const variance = [];
      for (let i3 = 0; i3 < rows; i3++) {
        let sum1 = 0;
        let sum2 = 0;
        let x2 = 0;
        for (let j2 = 0; j2 < cols; j2++) {
          x2 = matrix2.get(i3, j2) - mean4[i3];
          sum1 += x2;
          sum2 += x2 * x2;
        }
        if (unbiased) {
          variance.push((sum2 - sum1 * sum1 / cols) / (cols - 1));
        } else {
          variance.push((sum2 - sum1 * sum1 / cols) / cols);
        }
      }
      return variance;
    }
    function varianceByColumn(matrix2, unbiased, mean4) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const variance = [];
      for (let j2 = 0; j2 < cols; j2++) {
        let sum1 = 0;
        let sum2 = 0;
        let x2 = 0;
        for (let i3 = 0; i3 < rows; i3++) {
          x2 = matrix2.get(i3, j2) - mean4[j2];
          sum1 += x2;
          sum2 += x2 * x2;
        }
        if (unbiased) {
          variance.push((sum2 - sum1 * sum1 / rows) / (rows - 1));
        } else {
          variance.push((sum2 - sum1 * sum1 / rows) / rows);
        }
      }
      return variance;
    }
    function varianceAll(matrix2, unbiased, mean4) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const size = rows * cols;
      let sum1 = 0;
      let sum2 = 0;
      let x2 = 0;
      for (let i3 = 0; i3 < rows; i3++) {
        for (let j2 = 0; j2 < cols; j2++) {
          x2 = matrix2.get(i3, j2) - mean4;
          sum1 += x2;
          sum2 += x2 * x2;
        }
      }
      if (unbiased) {
        return (sum2 - sum1 * sum1 / size) / (size - 1);
      } else {
        return (sum2 - sum1 * sum1 / size) / size;
      }
    }
    function centerByRow(matrix2, mean4) {
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i3, j2, matrix2.get(i3, j2) - mean4[i3]);
        }
      }
    }
    function centerByColumn(matrix2, mean4) {
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i3, j2, matrix2.get(i3, j2) - mean4[j2]);
        }
      }
    }
    function centerAll(matrix2, mean4) {
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i3, j2, matrix2.get(i3, j2) - mean4);
        }
      }
    }
    function getScaleByRow(matrix2) {
      const scale = [];
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        let sum2 = 0;
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          sum2 += Math.pow(matrix2.get(i3, j2), 2) / (matrix2.columns - 1);
        }
        scale.push(Math.sqrt(sum2));
      }
      return scale;
    }
    function scaleByRow(matrix2, scale) {
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i3, j2, matrix2.get(i3, j2) / scale[i3]);
        }
      }
    }
    function getScaleByColumn(matrix2) {
      const scale = [];
      for (let j2 = 0; j2 < matrix2.columns; j2++) {
        let sum2 = 0;
        for (let i3 = 0; i3 < matrix2.rows; i3++) {
          sum2 += Math.pow(matrix2.get(i3, j2), 2) / (matrix2.rows - 1);
        }
        scale.push(Math.sqrt(sum2));
      }
      return scale;
    }
    function scaleByColumn(matrix2, scale) {
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i3, j2, matrix2.get(i3, j2) / scale[j2]);
        }
      }
    }
    function getScaleAll(matrix2) {
      const divider = matrix2.size - 1;
      let sum2 = 0;
      for (let j2 = 0; j2 < matrix2.columns; j2++) {
        for (let i3 = 0; i3 < matrix2.rows; i3++) {
          sum2 += Math.pow(matrix2.get(i3, j2), 2) / divider;
        }
      }
      return Math.sqrt(sum2);
    }
    function scaleAll(matrix2, scale) {
      for (let i3 = 0; i3 < matrix2.rows; i3++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i3, j2, matrix2.get(i3, j2) / scale);
        }
      }
    }
    var AbstractMatrix2 = class {
      static from1DArray(newRows, newColumns, newData) {
        let length = newRows * newColumns;
        if (length !== newData.length) {
          throw new RangeError("data length does not match given dimensions");
        }
        let newMatrix = new Matrix5(newRows, newColumns);
        for (let row = 0; row < newRows; row++) {
          for (let column = 0; column < newColumns; column++) {
            newMatrix.set(row, column, newData[row * newColumns + column]);
          }
        }
        return newMatrix;
      }
      static rowVector(newData) {
        let vector = new Matrix5(1, newData.length);
        for (let i3 = 0; i3 < newData.length; i3++) {
          vector.set(0, i3, newData[i3]);
        }
        return vector;
      }
      static columnVector(newData) {
        let vector = new Matrix5(newData.length, 1);
        for (let i3 = 0; i3 < newData.length; i3++) {
          vector.set(i3, 0, newData[i3]);
        }
        return vector;
      }
      static zeros(rows, columns) {
        return new Matrix5(rows, columns);
      }
      static ones(rows, columns) {
        return new Matrix5(rows, columns).fill(1);
      }
      static rand(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { random = Math.random } = options;
        let matrix2 = new Matrix5(rows, columns);
        for (let i3 = 0; i3 < rows; i3++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix2.set(i3, j2, random());
          }
        }
        return matrix2;
      }
      static randInt(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max4 = 1e3, random = Math.random } = options;
        if (!Number.isInteger(min3))
          throw new TypeError("min must be an integer");
        if (!Number.isInteger(max4))
          throw new TypeError("max must be an integer");
        if (min3 >= max4)
          throw new RangeError("min must be smaller than max");
        let interval = max4 - min3;
        let matrix2 = new Matrix5(rows, columns);
        for (let i3 = 0; i3 < rows; i3++) {
          for (let j2 = 0; j2 < columns; j2++) {
            let value = min3 + Math.round(random() * interval);
            matrix2.set(i3, j2, value);
          }
        }
        return matrix2;
      }
      static eye(rows, columns, value) {
        if (columns === void 0)
          columns = rows;
        if (value === void 0)
          value = 1;
        let min3 = Math.min(rows, columns);
        let matrix2 = this.zeros(rows, columns);
        for (let i3 = 0; i3 < min3; i3++) {
          matrix2.set(i3, i3, value);
        }
        return matrix2;
      }
      static diag(data, rows, columns) {
        let l3 = data.length;
        if (rows === void 0)
          rows = l3;
        if (columns === void 0)
          columns = rows;
        let min3 = Math.min(l3, rows, columns);
        let matrix2 = this.zeros(rows, columns);
        for (let i3 = 0; i3 < min3; i3++) {
          matrix2.set(i3, i3, data[i3]);
        }
        return matrix2;
      }
      static min(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new Matrix5(rows, columns);
        for (let i3 = 0; i3 < rows; i3++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i3, j2, Math.min(matrix1.get(i3, j2), matrix2.get(i3, j2)));
          }
        }
        return result;
      }
      static max(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new this(rows, columns);
        for (let i3 = 0; i3 < rows; i3++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i3, j2, Math.max(matrix1.get(i3, j2), matrix2.get(i3, j2)));
          }
        }
        return result;
      }
      static checkMatrix(value) {
        return AbstractMatrix2.isMatrix(value) ? value : new Matrix5(value);
      }
      static isMatrix(value) {
        return value != null && value.klass === "Matrix";
      }
      get size() {
        return this.rows * this.columns;
      }
      apply(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            callback.call(this, i3, j2);
          }
        }
        return this;
      }
      to1DArray() {
        let array3 = [];
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            array3.push(this.get(i3, j2));
          }
        }
        return array3;
      }
      to2DArray() {
        let copy = [];
        for (let i3 = 0; i3 < this.rows; i3++) {
          copy.push([]);
          for (let j2 = 0; j2 < this.columns; j2++) {
            copy[i3].push(this.get(i3, j2));
          }
        }
        return copy;
      }
      toJSON() {
        return this.to2DArray();
      }
      isRowVector() {
        return this.rows === 1;
      }
      isColumnVector() {
        return this.columns === 1;
      }
      isVector() {
        return this.rows === 1 || this.columns === 1;
      }
      isSquare() {
        return this.rows === this.columns;
      }
      isEmpty() {
        return this.rows === 0 || this.columns === 0;
      }
      isSymmetric() {
        if (this.isSquare()) {
          for (let i3 = 0; i3 < this.rows; i3++) {
            for (let j2 = 0; j2 <= i3; j2++) {
              if (this.get(i3, j2) !== this.get(j2, i3)) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      isDistance() {
        if (!this.isSymmetric())
          return false;
        for (let i3 = 0; i3 < this.rows; i3++) {
          if (this.get(i3, i3) !== 0)
            return false;
        }
        return true;
      }
      isEchelonForm() {
        let i3 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isEchelonForm = true;
        let checked = false;
        while (i3 < this.rows && isEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i3, j2) === 0) {
              j2++;
            } else if (this.get(i3, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isEchelonForm = false;
              checked = true;
            }
          }
          i3++;
        }
        return isEchelonForm;
      }
      isReducedEchelonForm() {
        let i3 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isReducedEchelonForm = true;
        let checked = false;
        while (i3 < this.rows && isReducedEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i3, j2) === 0) {
              j2++;
            } else if (this.get(i3, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isReducedEchelonForm = false;
              checked = true;
            }
          }
          for (let k2 = j2 + 1; k2 < this.rows; k2++) {
            if (this.get(i3, k2) !== 0) {
              isReducedEchelonForm = false;
            }
          }
          i3++;
        }
        return isReducedEchelonForm;
      }
      echelonForm() {
        let result = this.clone();
        let h3 = 0;
        let k2 = 0;
        while (h3 < result.rows && k2 < result.columns) {
          let iMax = h3;
          for (let i3 = h3; i3 < result.rows; i3++) {
            if (result.get(i3, k2) > result.get(iMax, k2)) {
              iMax = i3;
            }
          }
          if (result.get(iMax, k2) === 0) {
            k2++;
          } else {
            result.swapRows(h3, iMax);
            let tmp = result.get(h3, k2);
            for (let j2 = k2; j2 < result.columns; j2++) {
              result.set(h3, j2, result.get(h3, j2) / tmp);
            }
            for (let i3 = h3 + 1; i3 < result.rows; i3++) {
              let factor = result.get(i3, k2) / result.get(h3, k2);
              result.set(i3, k2, 0);
              for (let j2 = k2 + 1; j2 < result.columns; j2++) {
                result.set(i3, j2, result.get(i3, j2) - result.get(h3, j2) * factor);
              }
            }
            h3++;
            k2++;
          }
        }
        return result;
      }
      reducedEchelonForm() {
        let result = this.echelonForm();
        let m4 = result.columns;
        let n3 = result.rows;
        let h3 = n3 - 1;
        while (h3 >= 0) {
          if (result.maxRow(h3) === 0) {
            h3--;
          } else {
            let p3 = 0;
            let pivot = false;
            while (p3 < n3 && pivot === false) {
              if (result.get(h3, p3) === 1) {
                pivot = true;
              } else {
                p3++;
              }
            }
            for (let i3 = 0; i3 < h3; i3++) {
              let factor = result.get(i3, p3);
              for (let j2 = p3; j2 < m4; j2++) {
                let tmp = result.get(i3, j2) - factor * result.get(h3, j2);
                result.set(i3, j2, tmp);
              }
            }
            h3--;
          }
        }
        return result;
      }
      set() {
        throw new Error("set method is unimplemented");
      }
      get() {
        throw new Error("get method is unimplemented");
      }
      repeat(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { rows = 1, columns = 1 } = options;
        if (!Number.isInteger(rows) || rows <= 0) {
          throw new TypeError("rows must be a positive integer");
        }
        if (!Number.isInteger(columns) || columns <= 0) {
          throw new TypeError("columns must be a positive integer");
        }
        let matrix2 = new Matrix5(this.rows * rows, this.columns * columns);
        for (let i3 = 0; i3 < rows; i3++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix2.setSubMatrix(this, this.rows * i3, this.columns * j2);
          }
        }
        return matrix2;
      }
      fill(value) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, value);
          }
        }
        return this;
      }
      neg() {
        return this.mulS(-1);
      }
      getRow(index2) {
        checkRowIndex(this, index2);
        let row = [];
        for (let i3 = 0; i3 < this.columns; i3++) {
          row.push(this.get(index2, i3));
        }
        return row;
      }
      getRowVector(index2) {
        return Matrix5.rowVector(this.getRow(index2));
      }
      setRow(index2, array3) {
        checkRowIndex(this, index2);
        array3 = checkRowVector(this, array3);
        for (let i3 = 0; i3 < this.columns; i3++) {
          this.set(index2, i3, array3[i3]);
        }
        return this;
      }
      swapRows(row1, row2) {
        checkRowIndex(this, row1);
        checkRowIndex(this, row2);
        for (let i3 = 0; i3 < this.columns; i3++) {
          let temp = this.get(row1, i3);
          this.set(row1, i3, this.get(row2, i3));
          this.set(row2, i3, temp);
        }
        return this;
      }
      getColumn(index2) {
        checkColumnIndex(this, index2);
        let column = [];
        for (let i3 = 0; i3 < this.rows; i3++) {
          column.push(this.get(i3, index2));
        }
        return column;
      }
      getColumnVector(index2) {
        return Matrix5.columnVector(this.getColumn(index2));
      }
      setColumn(index2, array3) {
        checkColumnIndex(this, index2);
        array3 = checkColumnVector(this, array3);
        for (let i3 = 0; i3 < this.rows; i3++) {
          this.set(i3, index2, array3[i3]);
        }
        return this;
      }
      swapColumns(column1, column2) {
        checkColumnIndex(this, column1);
        checkColumnIndex(this, column2);
        for (let i3 = 0; i3 < this.rows; i3++) {
          let temp = this.get(i3, column1);
          this.set(i3, column1, this.get(i3, column2));
          this.set(i3, column2, temp);
        }
        return this;
      }
      addRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) + vector[j2]);
          }
        }
        return this;
      }
      subRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) - vector[j2]);
          }
        }
        return this;
      }
      mulRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) * vector[j2]);
          }
        }
        return this;
      }
      divRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) / vector[j2]);
          }
        }
        return this;
      }
      addColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) + vector[i3]);
          }
        }
        return this;
      }
      subColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) - vector[i3]);
          }
        }
        return this;
      }
      mulColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) * vector[i3]);
          }
        }
        return this;
      }
      divColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i3, j2, this.get(i3, j2) / vector[i3]);
          }
        }
        return this;
      }
      mulRow(index2, value) {
        checkRowIndex(this, index2);
        for (let i3 = 0; i3 < this.columns; i3++) {
          this.set(index2, i3, this.get(index2, i3) * value);
        }
        return this;
      }
      mulColumn(index2, value) {
        checkColumnIndex(this, index2);
        for (let i3 = 0; i3 < this.rows; i3++) {
          this.set(i3, index2, this.get(i3, index2) * value);
        }
        return this;
      }
      max(by) {
        if (this.isEmpty()) {
          return NaN;
        }
        switch (by) {
          case "row": {
            const max4 = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max4[row]) {
                  max4[row] = this.get(row, column);
                }
              }
            }
            return max4;
          }
          case "column": {
            const max4 = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max4[column]) {
                  max4[column] = this.get(row, column);
                }
              }
            }
            return max4;
          }
          case void 0: {
            let max4 = this.get(0, 0);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max4) {
                  max4 = this.get(row, column);
                }
              }
            }
            return max4;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      maxIndex() {
        checkNonEmpty(this);
        let v3 = this.get(0, 0);
        let idx = [0, 0];
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i3, j2) > v3) {
              v3 = this.get(i3, j2);
              idx[0] = i3;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      min(by) {
        if (this.isEmpty()) {
          return NaN;
        }
        switch (by) {
          case "row": {
            const min3 = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min3[row]) {
                  min3[row] = this.get(row, column);
                }
              }
            }
            return min3;
          }
          case "column": {
            const min3 = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min3[column]) {
                  min3[column] = this.get(row, column);
                }
              }
            }
            return min3;
          }
          case void 0: {
            let min3 = this.get(0, 0);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min3) {
                  min3 = this.get(row, column);
                }
              }
            }
            return min3;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      minIndex() {
        checkNonEmpty(this);
        let v3 = this.get(0, 0);
        let idx = [0, 0];
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i3, j2) < v3) {
              v3 = this.get(i3, j2);
              idx[0] = i3;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      maxRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v3 = this.get(row, 0);
        for (let i3 = 1; i3 < this.columns; i3++) {
          if (this.get(row, i3) > v3) {
            v3 = this.get(row, i3);
          }
        }
        return v3;
      }
      maxRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v3 = this.get(row, 0);
        let idx = [row, 0];
        for (let i3 = 1; i3 < this.columns; i3++) {
          if (this.get(row, i3) > v3) {
            v3 = this.get(row, i3);
            idx[1] = i3;
          }
        }
        return idx;
      }
      minRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v3 = this.get(row, 0);
        for (let i3 = 1; i3 < this.columns; i3++) {
          if (this.get(row, i3) < v3) {
            v3 = this.get(row, i3);
          }
        }
        return v3;
      }
      minRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v3 = this.get(row, 0);
        let idx = [row, 0];
        for (let i3 = 1; i3 < this.columns; i3++) {
          if (this.get(row, i3) < v3) {
            v3 = this.get(row, i3);
            idx[1] = i3;
          }
        }
        return idx;
      }
      maxColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v3 = this.get(0, column);
        for (let i3 = 1; i3 < this.rows; i3++) {
          if (this.get(i3, column) > v3) {
            v3 = this.get(i3, column);
          }
        }
        return v3;
      }
      maxColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v3 = this.get(0, column);
        let idx = [0, column];
        for (let i3 = 1; i3 < this.rows; i3++) {
          if (this.get(i3, column) > v3) {
            v3 = this.get(i3, column);
            idx[0] = i3;
          }
        }
        return idx;
      }
      minColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v3 = this.get(0, column);
        for (let i3 = 1; i3 < this.rows; i3++) {
          if (this.get(i3, column) < v3) {
            v3 = this.get(i3, column);
          }
        }
        return v3;
      }
      minColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v3 = this.get(0, column);
        let idx = [0, column];
        for (let i3 = 1; i3 < this.rows; i3++) {
          if (this.get(i3, column) < v3) {
            v3 = this.get(i3, column);
            idx[0] = i3;
          }
        }
        return idx;
      }
      diag() {
        let min3 = Math.min(this.rows, this.columns);
        let diag = [];
        for (let i3 = 0; i3 < min3; i3++) {
          diag.push(this.get(i3, i3));
        }
        return diag;
      }
      norm(type = "frobenius") {
        switch (type) {
          case "max":
            return this.max();
          case "frobenius":
            return Math.sqrt(this.dot(this));
          default:
            throw new RangeError(`unknown norm type: ${type}`);
        }
      }
      cumulativeSum() {
        let sum2 = 0;
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            sum2 += this.get(i3, j2);
            this.set(i3, j2, sum2);
          }
        }
        return this;
      }
      dot(vector2) {
        if (AbstractMatrix2.isMatrix(vector2))
          vector2 = vector2.to1DArray();
        let vector1 = this.to1DArray();
        if (vector1.length !== vector2.length) {
          throw new RangeError("vectors do not have the same size");
        }
        let dot = 0;
        for (let i3 = 0; i3 < vector1.length; i3++) {
          dot += vector1[i3] * vector2[i3];
        }
        return dot;
      }
      mmul(other) {
        other = Matrix5.checkMatrix(other);
        let m4 = this.rows;
        let n3 = this.columns;
        let p3 = other.columns;
        let result = new Matrix5(m4, p3);
        let Bcolj = new Float64Array(n3);
        for (let j2 = 0; j2 < p3; j2++) {
          for (let k2 = 0; k2 < n3; k2++) {
            Bcolj[k2] = other.get(k2, j2);
          }
          for (let i3 = 0; i3 < m4; i3++) {
            let s3 = 0;
            for (let k2 = 0; k2 < n3; k2++) {
              s3 += this.get(i3, k2) * Bcolj[k2];
            }
            result.set(i3, j2, s3);
          }
        }
        return result;
      }
      strassen2x2(other) {
        other = Matrix5.checkMatrix(other);
        let result = new Matrix5(2, 2);
        const a11 = this.get(0, 0);
        const b11 = other.get(0, 0);
        const a12 = this.get(0, 1);
        const b12 = other.get(0, 1);
        const a21 = this.get(1, 0);
        const b21 = other.get(1, 0);
        const a22 = this.get(1, 1);
        const b22 = other.get(1, 1);
        const m1 = (a11 + a22) * (b11 + b22);
        const m22 = (a21 + a22) * b11;
        const m32 = a11 * (b12 - b22);
        const m4 = a22 * (b21 - b11);
        const m5 = (a11 + a12) * b22;
        const m6 = (a21 - a11) * (b11 + b12);
        const m7 = (a12 - a22) * (b21 + b22);
        const c00 = m1 + m4 - m5 + m7;
        const c01 = m32 + m5;
        const c10 = m22 + m4;
        const c11 = m1 - m22 + m32 + m6;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        return result;
      }
      strassen3x3(other) {
        other = Matrix5.checkMatrix(other);
        let result = new Matrix5(3, 3);
        const a00 = this.get(0, 0);
        const a01 = this.get(0, 1);
        const a02 = this.get(0, 2);
        const a10 = this.get(1, 0);
        const a11 = this.get(1, 1);
        const a12 = this.get(1, 2);
        const a20 = this.get(2, 0);
        const a21 = this.get(2, 1);
        const a22 = this.get(2, 2);
        const b00 = other.get(0, 0);
        const b01 = other.get(0, 1);
        const b02 = other.get(0, 2);
        const b10 = other.get(1, 0);
        const b11 = other.get(1, 1);
        const b12 = other.get(1, 2);
        const b20 = other.get(2, 0);
        const b21 = other.get(2, 1);
        const b22 = other.get(2, 2);
        const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
        const m22 = (a00 - a10) * (-b01 + b11);
        const m32 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
        const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
        const m5 = (a10 + a11) * (-b00 + b01);
        const m6 = a00 * b00;
        const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
        const m8 = (-a00 + a20) * (b02 - b12);
        const m9 = (a20 + a21) * (-b00 + b02);
        const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
        const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
        const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
        const m13 = (a02 - a22) * (b11 - b21);
        const m14 = a02 * b20;
        const m15 = (a21 + a22) * (-b20 + b21);
        const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
        const m17 = (a02 - a12) * (b12 - b22);
        const m18 = (a11 + a12) * (-b20 + b22);
        const m19 = a01 * b10;
        const m20 = a12 * b21;
        const m21 = a10 * b02;
        const m222 = a20 * b01;
        const m23 = a22 * b22;
        const c00 = m6 + m14 + m19;
        const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
        const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
        const c10 = m22 + m32 + m4 + m6 + m14 + m16 + m17;
        const c11 = m22 + m4 + m5 + m6 + m20;
        const c12 = m14 + m16 + m17 + m18 + m21;
        const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
        const c21 = m12 + m13 + m14 + m15 + m222;
        const c22 = m6 + m7 + m8 + m9 + m23;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(0, 2, c02);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        result.set(1, 2, c12);
        result.set(2, 0, c20);
        result.set(2, 1, c21);
        result.set(2, 2, c22);
        return result;
      }
      mmulStrassen(y3) {
        y3 = Matrix5.checkMatrix(y3);
        let x2 = this.clone();
        let r1 = x2.rows;
        let c1 = x2.columns;
        let r2 = y3.rows;
        let c22 = y3.columns;
        if (c1 !== r2) {
          console.warn(
            `Multiplying ${r1} x ${c1} and ${r2} x ${c22} matrix: dimensions do not match.`
          );
        }
        function embed(mat, rows, cols) {
          let r4 = mat.rows;
          let c5 = mat.columns;
          if (r4 === rows && c5 === cols) {
            return mat;
          } else {
            let resultat = AbstractMatrix2.zeros(rows, cols);
            resultat = resultat.setSubMatrix(mat, 0, 0);
            return resultat;
          }
        }
        let r3 = Math.max(r1, r2);
        let c4 = Math.max(c1, c22);
        x2 = embed(x2, r3, c4);
        y3 = embed(y3, r3, c4);
        function blockMult(a3, b2, rows, cols) {
          if (rows <= 512 || cols <= 512) {
            return a3.mmul(b2);
          }
          if (rows % 2 === 1 && cols % 2 === 1) {
            a3 = embed(a3, rows + 1, cols + 1);
            b2 = embed(b2, rows + 1, cols + 1);
          } else if (rows % 2 === 1) {
            a3 = embed(a3, rows + 1, cols);
            b2 = embed(b2, rows + 1, cols);
          } else if (cols % 2 === 1) {
            a3 = embed(a3, rows, cols + 1);
            b2 = embed(b2, rows, cols + 1);
          }
          let halfRows = parseInt(a3.rows / 2, 10);
          let halfCols = parseInt(a3.columns / 2, 10);
          let a11 = a3.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let b11 = b2.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let a12 = a3.subMatrix(0, halfRows - 1, halfCols, a3.columns - 1);
          let b12 = b2.subMatrix(0, halfRows - 1, halfCols, b2.columns - 1);
          let a21 = a3.subMatrix(halfRows, a3.rows - 1, 0, halfCols - 1);
          let b21 = b2.subMatrix(halfRows, b2.rows - 1, 0, halfCols - 1);
          let a22 = a3.subMatrix(halfRows, a3.rows - 1, halfCols, a3.columns - 1);
          let b22 = b2.subMatrix(halfRows, b2.rows - 1, halfCols, b2.columns - 1);
          let m1 = blockMult(
            AbstractMatrix2.add(a11, a22),
            AbstractMatrix2.add(b11, b22),
            halfRows,
            halfCols
          );
          let m22 = blockMult(AbstractMatrix2.add(a21, a22), b11, halfRows, halfCols);
          let m32 = blockMult(a11, AbstractMatrix2.sub(b12, b22), halfRows, halfCols);
          let m4 = blockMult(a22, AbstractMatrix2.sub(b21, b11), halfRows, halfCols);
          let m5 = blockMult(AbstractMatrix2.add(a11, a12), b22, halfRows, halfCols);
          let m6 = blockMult(
            AbstractMatrix2.sub(a21, a11),
            AbstractMatrix2.add(b11, b12),
            halfRows,
            halfCols
          );
          let m7 = blockMult(
            AbstractMatrix2.sub(a12, a22),
            AbstractMatrix2.add(b21, b22),
            halfRows,
            halfCols
          );
          let c11 = AbstractMatrix2.add(m1, m4);
          c11.sub(m5);
          c11.add(m7);
          let c12 = AbstractMatrix2.add(m32, m5);
          let c21 = AbstractMatrix2.add(m22, m4);
          let c222 = AbstractMatrix2.sub(m1, m22);
          c222.add(m32);
          c222.add(m6);
          let result = AbstractMatrix2.zeros(2 * c11.rows, 2 * c11.columns);
          result = result.setSubMatrix(c11, 0, 0);
          result = result.setSubMatrix(c12, c11.rows, 0);
          result = result.setSubMatrix(c21, 0, c11.columns);
          result = result.setSubMatrix(c222, c11.rows, c11.columns);
          return result.subMatrix(0, rows - 1, 0, cols - 1);
        }
        return blockMult(x2, y3, r3, c4);
      }
      scaleRows(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max4 = 1 } = options;
        if (!Number.isFinite(min3))
          throw new TypeError("min must be a number");
        if (!Number.isFinite(max4))
          throw new TypeError("max must be a number");
        if (min3 >= max4)
          throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix5(this.rows, this.columns);
        for (let i3 = 0; i3 < this.rows; i3++) {
          const row = this.getRow(i3);
          if (row.length > 0) {
            rescale(row, { min: min3, max: max4, output: row });
          }
          newMatrix.setRow(i3, row);
        }
        return newMatrix;
      }
      scaleColumns(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max4 = 1 } = options;
        if (!Number.isFinite(min3))
          throw new TypeError("min must be a number");
        if (!Number.isFinite(max4))
          throw new TypeError("max must be a number");
        if (min3 >= max4)
          throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix5(this.rows, this.columns);
        for (let i3 = 0; i3 < this.columns; i3++) {
          const column = this.getColumn(i3);
          if (column.length) {
            rescale(column, {
              min: min3,
              max: max4,
              output: column
            });
          }
          newMatrix.setColumn(i3, column);
        }
        return newMatrix;
      }
      flipRows() {
        const middle = Math.ceil(this.columns / 2);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < middle; j2++) {
            let first = this.get(i3, j2);
            let last = this.get(i3, this.columns - 1 - j2);
            this.set(i3, j2, last);
            this.set(i3, this.columns - 1 - j2, first);
          }
        }
        return this;
      }
      flipColumns() {
        const middle = Math.ceil(this.rows / 2);
        for (let j2 = 0; j2 < this.columns; j2++) {
          for (let i3 = 0; i3 < middle; i3++) {
            let first = this.get(i3, j2);
            let last = this.get(this.rows - 1 - i3, j2);
            this.set(i3, j2, last);
            this.set(this.rows - 1 - i3, j2, first);
          }
        }
        return this;
      }
      kroneckerProduct(other) {
        other = Matrix5.checkMatrix(other);
        let m4 = this.rows;
        let n3 = this.columns;
        let p3 = other.rows;
        let q2 = other.columns;
        let result = new Matrix5(m4 * p3, n3 * q2);
        for (let i3 = 0; i3 < m4; i3++) {
          for (let j2 = 0; j2 < n3; j2++) {
            for (let k2 = 0; k2 < p3; k2++) {
              for (let l3 = 0; l3 < q2; l3++) {
                result.set(p3 * i3 + k2, q2 * j2 + l3, this.get(i3, j2) * other.get(k2, l3));
              }
            }
          }
        }
        return result;
      }
      kroneckerSum(other) {
        other = Matrix5.checkMatrix(other);
        if (!this.isSquare() || !other.isSquare()) {
          throw new Error("Kronecker Sum needs two Square Matrices");
        }
        let m4 = this.rows;
        let n3 = other.rows;
        let AxI = this.kroneckerProduct(Matrix5.eye(n3, n3));
        let IxB = Matrix5.eye(m4, m4).kroneckerProduct(other);
        return AxI.add(IxB);
      }
      transpose() {
        let result = new Matrix5(this.columns, this.rows);
        for (let i3 = 0; i3 < this.rows; i3++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            result.set(j2, i3, this.get(i3, j2));
          }
        }
        return result;
      }
      sortRows(compareFunction = compareNumbers) {
        for (let i3 = 0; i3 < this.rows; i3++) {
          this.setRow(i3, this.getRow(i3).sort(compareFunction));
        }
        return this;
      }
      sortColumns(compareFunction = compareNumbers) {
        for (let i3 = 0; i3 < this.columns; i3++) {
          this.setColumn(i3, this.getColumn(i3).sort(compareFunction));
        }
        return this;
      }
      subMatrix(startRow, endRow, startColumn, endColumn) {
        checkRange(this, startRow, endRow, startColumn, endColumn);
        let newMatrix = new Matrix5(
          endRow - startRow + 1,
          endColumn - startColumn + 1
        );
        for (let i3 = startRow; i3 <= endRow; i3++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            newMatrix.set(i3 - startRow, j2 - startColumn, this.get(i3, j2));
          }
        }
        return newMatrix;
      }
      subMatrixRow(indices, startColumn, endColumn) {
        if (startColumn === void 0)
          startColumn = 0;
        if (endColumn === void 0)
          endColumn = this.columns - 1;
        if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix5(indices.length, endColumn - startColumn + 1);
        for (let i3 = 0; i3 < indices.length; i3++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            if (indices[i3] < 0 || indices[i3] >= this.rows) {
              throw new RangeError(`Row index out of range: ${indices[i3]}`);
            }
            newMatrix.set(i3, j2 - startColumn, this.get(indices[i3], j2));
          }
        }
        return newMatrix;
      }
      subMatrixColumn(indices, startRow, endRow) {
        if (startRow === void 0)
          startRow = 0;
        if (endRow === void 0)
          endRow = this.rows - 1;
        if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix5(endRow - startRow + 1, indices.length);
        for (let i3 = 0; i3 < indices.length; i3++) {
          for (let j2 = startRow; j2 <= endRow; j2++) {
            if (indices[i3] < 0 || indices[i3] >= this.columns) {
              throw new RangeError(`Column index out of range: ${indices[i3]}`);
            }
            newMatrix.set(j2 - startRow, i3, this.get(j2, indices[i3]));
          }
        }
        return newMatrix;
      }
      setSubMatrix(matrix2, startRow, startColumn) {
        matrix2 = Matrix5.checkMatrix(matrix2);
        if (matrix2.isEmpty()) {
          return this;
        }
        let endRow = startRow + matrix2.rows - 1;
        let endColumn = startColumn + matrix2.columns - 1;
        checkRange(this, startRow, endRow, startColumn, endColumn);
        for (let i3 = 0; i3 < matrix2.rows; i3++) {
          for (let j2 = 0; j2 < matrix2.columns; j2++) {
            this.set(startRow + i3, startColumn + j2, matrix2.get(i3, j2));
          }
        }
        return this;
      }
      selection(rowIndices, columnIndices) {
        checkRowIndices(this, rowIndices);
        checkColumnIndices(this, columnIndices);
        let newMatrix = new Matrix5(rowIndices.length, columnIndices.length);
        for (let i3 = 0; i3 < rowIndices.length; i3++) {
          let rowIndex = rowIndices[i3];
          for (let j2 = 0; j2 < columnIndices.length; j2++) {
            let columnIndex = columnIndices[j2];
            newMatrix.set(i3, j2, this.get(rowIndex, columnIndex));
          }
        }
        return newMatrix;
      }
      trace() {
        let min3 = Math.min(this.rows, this.columns);
        let trace = 0;
        for (let i3 = 0; i3 < min3; i3++) {
          trace += this.get(i3, i3);
        }
        return trace;
      }
      clone() {
        return this.constructor.copy(this, new Matrix5(this.rows, this.columns));
      }
      /**
       * @template {AbstractMatrix} M
       * @param {AbstractMatrix} from
       * @param {M} to
       * @return {M}
       */
      static copy(from, to) {
        for (const [row, column, value] of from.entries()) {
          to.set(row, column, value);
        }
        return to;
      }
      sum(by) {
        switch (by) {
          case "row":
            return sumByRow(this);
          case "column":
            return sumByColumn(this);
          case void 0:
            return sumAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      product(by) {
        switch (by) {
          case "row":
            return productByRow(this);
          case "column":
            return productByColumn(this);
          case void 0:
            return productAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      mean(by) {
        const sum2 = this.sum(by);
        switch (by) {
          case "row": {
            for (let i3 = 0; i3 < this.rows; i3++) {
              sum2[i3] /= this.columns;
            }
            return sum2;
          }
          case "column": {
            for (let i3 = 0; i3 < this.columns; i3++) {
              sum2[i3] /= this.rows;
            }
            return sum2;
          }
          case void 0:
            return sum2 / this.size;
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      variance(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { unbiased = true, mean: mean4 = this.mean(by) } = options;
        if (typeof unbiased !== "boolean") {
          throw new TypeError("unbiased must be a boolean");
        }
        switch (by) {
          case "row": {
            if (!isAnyArray3.isAnyArray(mean4)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByRow(this, unbiased, mean4);
          }
          case "column": {
            if (!isAnyArray3.isAnyArray(mean4)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByColumn(this, unbiased, mean4);
          }
          case void 0: {
            if (typeof mean4 !== "number") {
              throw new TypeError("mean must be a number");
            }
            return varianceAll(this, unbiased, mean4);
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      standardDeviation(by, options) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        const variance = this.variance(by, options);
        if (by === void 0) {
          return Math.sqrt(variance);
        } else {
          for (let i3 = 0; i3 < variance.length; i3++) {
            variance[i3] = Math.sqrt(variance[i3]);
          }
          return variance;
        }
      }
      center(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { center = this.mean(by) } = options;
        switch (by) {
          case "row": {
            if (!isAnyArray3.isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByRow(this, center);
            return this;
          }
          case "column": {
            if (!isAnyArray3.isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByColumn(this, center);
            return this;
          }
          case void 0: {
            if (typeof center !== "number") {
              throw new TypeError("center must be a number");
            }
            centerAll(this, center);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      scale(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        let scale = options.scale;
        switch (by) {
          case "row": {
            if (scale === void 0) {
              scale = getScaleByRow(this);
            } else if (!isAnyArray3.isAnyArray(scale)) {
              throw new TypeError("scale must be an array");
            }
            scaleByRow(this, scale);
            return this;
          }
          case "column": {
            if (scale === void 0) {
              scale = getScaleByColumn(this);
            } else if (!isAnyArray3.isAnyArray(scale)) {
              throw new TypeError("scale must be an array");
            }
            scaleByColumn(this, scale);
            return this;
          }
          case void 0: {
            if (scale === void 0) {
              scale = getScaleAll(this);
            } else if (typeof scale !== "number") {
              throw new TypeError("scale must be a number");
            }
            scaleAll(this, scale);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      toString(options) {
        return inspectMatrixWithOptions(this, options);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * iterator from left to right, from top to bottom
       * yield [row, column, value]
       * @returns {Generator<[number, number, number], void, *>}
       */
      *entries() {
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.columns; col++) {
            yield [row, col, this.get(row, col)];
          }
        }
      }
      /**
       * iterator from left to right, from top to bottom
       * yield value
       * @returns {Generator<number, void, *>}
       */
      *values() {
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.columns; col++) {
            yield this.get(row, col);
          }
        }
      }
    };
    AbstractMatrix2.prototype.klass = "Matrix";
    if (typeof Symbol !== "undefined") {
      AbstractMatrix2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
    }
    function compareNumbers(a3, b2) {
      return a3 - b2;
    }
    function isArrayOfNumbers(array3) {
      return array3.every((element) => {
        return typeof element === "number";
      });
    }
    AbstractMatrix2.random = AbstractMatrix2.rand;
    AbstractMatrix2.randomInt = AbstractMatrix2.randInt;
    AbstractMatrix2.diagonal = AbstractMatrix2.diag;
    AbstractMatrix2.prototype.diagonal = AbstractMatrix2.prototype.diag;
    AbstractMatrix2.identity = AbstractMatrix2.eye;
    AbstractMatrix2.prototype.negate = AbstractMatrix2.prototype.neg;
    AbstractMatrix2.prototype.tensorProduct = AbstractMatrix2.prototype.kroneckerProduct;
    var _initData, initData_fn;
    var _Matrix = class extends AbstractMatrix2 {
      constructor(nRows, nColumns) {
        super();
        /**
         * Init an empty matrix
         * @param {number} nRows
         * @param {number} nColumns
         */
        __privateAdd(this, _initData);
        /**
         * @type {Float64Array[]}
         */
        __publicField(this, "data");
        if (_Matrix.isMatrix(nRows)) {
          __privateMethod(this, _initData, initData_fn).call(this, nRows.rows, nRows.columns);
          _Matrix.copy(nRows, this);
        } else if (Number.isInteger(nRows) && nRows >= 0) {
          __privateMethod(this, _initData, initData_fn).call(this, nRows, nColumns);
        } else if (isAnyArray3.isAnyArray(nRows)) {
          const arrayData = nRows;
          nRows = arrayData.length;
          nColumns = nRows ? arrayData[0].length : 0;
          if (typeof nColumns !== "number") {
            throw new TypeError(
              "Data must be a 2D array with at least one element"
            );
          }
          this.data = [];
          for (let i3 = 0; i3 < nRows; i3++) {
            if (arrayData[i3].length !== nColumns) {
              throw new RangeError("Inconsistent array dimensions");
            }
            if (!isArrayOfNumbers(arrayData[i3])) {
              throw new TypeError("Input data contains non-numeric values");
            }
            this.data.push(Float64Array.from(arrayData[i3]));
          }
          this.rows = nRows;
          this.columns = nColumns;
        } else {
          throw new TypeError(
            "First argument must be a positive number or an array"
          );
        }
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
      removeRow(index2) {
        checkRowIndex(this, index2);
        this.data.splice(index2, 1);
        this.rows -= 1;
        return this;
      }
      addRow(index2, array3) {
        if (array3 === void 0) {
          array3 = index2;
          index2 = this.rows;
        }
        checkRowIndex(this, index2, true);
        array3 = Float64Array.from(checkRowVector(this, array3));
        this.data.splice(index2, 0, array3);
        this.rows += 1;
        return this;
      }
      removeColumn(index2) {
        checkColumnIndex(this, index2);
        for (let i3 = 0; i3 < this.rows; i3++) {
          const newRow = new Float64Array(this.columns - 1);
          for (let j2 = 0; j2 < index2; j2++) {
            newRow[j2] = this.data[i3][j2];
          }
          for (let j2 = index2 + 1; j2 < this.columns; j2++) {
            newRow[j2 - 1] = this.data[i3][j2];
          }
          this.data[i3] = newRow;
        }
        this.columns -= 1;
        return this;
      }
      addColumn(index2, array3) {
        if (typeof array3 === "undefined") {
          array3 = index2;
          index2 = this.columns;
        }
        checkColumnIndex(this, index2, true);
        array3 = checkColumnVector(this, array3);
        for (let i3 = 0; i3 < this.rows; i3++) {
          const newRow = new Float64Array(this.columns + 1);
          let j2 = 0;
          for (; j2 < index2; j2++) {
            newRow[j2] = this.data[i3][j2];
          }
          newRow[j2++] = array3[i3];
          for (; j2 < this.columns + 1; j2++) {
            newRow[j2] = this.data[i3][j2 - 1];
          }
          this.data[i3] = newRow;
        }
        this.columns += 1;
        return this;
      }
    };
    var Matrix5 = _Matrix;
    _initData = new WeakSet();
    initData_fn = function(nRows, nColumns) {
      this.data = [];
      if (Number.isInteger(nColumns) && nColumns >= 0) {
        for (let i3 = 0; i3 < nRows; i3++) {
          this.data.push(new Float64Array(nColumns));
        }
      } else {
        throw new TypeError("nColumns must be a positive integer");
      }
      this.rows = nRows;
      this.columns = nColumns;
    };
    installMathOperations(AbstractMatrix2, Matrix5);
    var _matrix;
    var _SymmetricMatrix = class extends AbstractMatrix2 {
      /**
       * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
       * @return {this}
       */
      constructor(diagonalSize) {
        super();
        /** @type {Matrix} */
        __privateAdd(this, _matrix, void 0);
        if (Matrix5.isMatrix(diagonalSize)) {
          if (!diagonalSize.isSymmetric()) {
            throw new TypeError("not symmetric data");
          }
          __privateSet(this, _matrix, Matrix5.copy(
            diagonalSize,
            new Matrix5(diagonalSize.rows, diagonalSize.rows)
          ));
        } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {
          __privateSet(this, _matrix, new Matrix5(diagonalSize, diagonalSize));
        } else {
          __privateSet(this, _matrix, new Matrix5(diagonalSize));
          if (!this.isSymmetric()) {
            throw new TypeError("not symmetric data");
          }
        }
      }
      get size() {
        return __privateGet(this, _matrix).size;
      }
      get rows() {
        return __privateGet(this, _matrix).rows;
      }
      get columns() {
        return __privateGet(this, _matrix).columns;
      }
      get diagonalSize() {
        return this.rows;
      }
      /**
       * not the same as matrix.isSymmetric()
       * Here is to check if it's instanceof SymmetricMatrix without bundling issues
       *
       * @param value
       * @returns {boolean}
       */
      static isSymmetricMatrix(value) {
        return Matrix5.isMatrix(value) && value.klassType === "SymmetricMatrix";
      }
      /**
       * @param diagonalSize
       * @return {SymmetricMatrix}
       */
      static zeros(diagonalSize) {
        return new this(diagonalSize);
      }
      /**
       * @param diagonalSize
       * @return {SymmetricMatrix}
       */
      static ones(diagonalSize) {
        return new this(diagonalSize).fill(1);
      }
      clone() {
        const matrix2 = new _SymmetricMatrix(this.diagonalSize);
        for (const [row, col, value] of this.upperRightEntries()) {
          matrix2.set(row, col, value);
        }
        return matrix2;
      }
      toMatrix() {
        return new Matrix5(this);
      }
      get(rowIndex, columnIndex) {
        return __privateGet(this, _matrix).get(rowIndex, columnIndex);
      }
      set(rowIndex, columnIndex, value) {
        __privateGet(this, _matrix).set(rowIndex, columnIndex, value);
        __privateGet(this, _matrix).set(columnIndex, rowIndex, value);
        return this;
      }
      removeCross(index2) {
        __privateGet(this, _matrix).removeRow(index2);
        __privateGet(this, _matrix).removeColumn(index2);
        return this;
      }
      addCross(index2, array3) {
        if (array3 === void 0) {
          array3 = index2;
          index2 = this.diagonalSize;
        }
        const row = array3.slice();
        row.splice(index2, 1);
        __privateGet(this, _matrix).addRow(index2, row);
        __privateGet(this, _matrix).addColumn(index2, array3);
        return this;
      }
      /**
       * @param {Mask[]} mask
       */
      applyMask(mask2) {
        if (mask2.length !== this.diagonalSize) {
          throw new RangeError("Mask size do not match with matrix size");
        }
        const sidesToRemove = [];
        for (const [index2, passthroughs] of mask2.entries()) {
          if (passthroughs)
            continue;
          sidesToRemove.push(index2);
        }
        sidesToRemove.reverse();
        for (const sideIndex of sidesToRemove) {
          this.removeCross(sideIndex);
        }
        return this;
      }
      /**
       * Compact format upper-right corner of matrix
       * iterate from left to right, from top to bottom.
       *
       * ```
       *   A B C D
       * A 1 2 3 4
       * B 2 5 6 7
       * C 3 6 8 9
       * D 4 7 9 10
       * ```
       *
       * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
       *
       * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
       *
       * @returns {number[]}
       */
      toCompact() {
        const { diagonalSize } = this;
        const compact = new Array(diagonalSize * (diagonalSize + 1) / 2);
        for (let col = 0, row = 0, index2 = 0; index2 < compact.length; index2++) {
          compact[index2] = this.get(row, col);
          if (++col >= diagonalSize)
            col = ++row;
        }
        return compact;
      }
      /**
       * @param {number[]} compact
       * @return {SymmetricMatrix}
       */
      static fromCompact(compact) {
        const compactSize = compact.length;
        const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;
        if (!Number.isInteger(diagonalSize)) {
          throw new TypeError(
            `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
              compact
            )}`
          );
        }
        const matrix2 = new _SymmetricMatrix(diagonalSize);
        for (let col = 0, row = 0, index2 = 0; index2 < compactSize; index2++) {
          matrix2.set(col, row, compact[index2]);
          if (++col >= diagonalSize)
            col = ++row;
        }
        return matrix2;
      }
      /**
       * half iterator upper-right-corner from left to right, from top to bottom
       * yield [row, column, value]
       *
       * @returns {Generator<[number, number, number], void, *>}
       */
      *upperRightEntries() {
        for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
          const value = this.get(row, col);
          yield [row, col, value];
          if (++col >= this.diagonalSize)
            col = ++row;
        }
      }
      /**
       * half iterator upper-right-corner from left to right, from top to bottom
       * yield value
       *
       * @returns {Generator<[number, number, number], void, *>}
       */
      *upperRightValues() {
        for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
          const value = this.get(row, col);
          yield value;
          if (++col >= this.diagonalSize)
            col = ++row;
        }
      }
    };
    var SymmetricMatrix2 = _SymmetricMatrix;
    _matrix = new WeakMap();
    SymmetricMatrix2.prototype.klassType = "SymmetricMatrix";
    var DistanceMatrix2 = class extends SymmetricMatrix2 {
      /**
       * not the same as matrix.isSymmetric()
       * Here is to check if it's instanceof SymmetricMatrix without bundling issues
       *
       * @param value
       * @returns {boolean}
       */
      static isDistanceMatrix(value) {
        return SymmetricMatrix2.isSymmetricMatrix(value) && value.klassSubType === "DistanceMatrix";
      }
      constructor(sideSize) {
        super(sideSize);
        if (!this.isDistance()) {
          throw new TypeError("Provided arguments do no produce a distance matrix");
        }
      }
      set(rowIndex, columnIndex, value) {
        if (rowIndex === columnIndex)
          value = 0;
        return super.set(rowIndex, columnIndex, value);
      }
      addCross(index2, array3) {
        if (array3 === void 0) {
          array3 = index2;
          index2 = this.diagonalSize;
        }
        array3 = array3.slice();
        array3[index2] = 0;
        return super.addCross(index2, array3);
      }
      toSymmetricMatrix() {
        return new SymmetricMatrix2(this);
      }
      clone() {
        const matrix2 = new DistanceMatrix2(this.diagonalSize);
        for (const [row, col, value] of this.upperRightEntries()) {
          if (row === col)
            continue;
          matrix2.set(row, col, value);
        }
        return matrix2;
      }
      /**
       * Compact format upper-right corner of matrix
       * no diagonal (only zeros)
       * iterable from left to right, from top to bottom.
       *
       * ```
       *   A B C D
       * A 0 1 2 3
       * B 1 0 4 5
       * C 2 4 0 6
       * D 3 5 6 0
       * ```
       *
       * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
       *
       * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
       *
       * @returns {number[]}
       */
      toCompact() {
        const { diagonalSize } = this;
        const compactLength = (diagonalSize - 1) * diagonalSize / 2;
        const compact = new Array(compactLength);
        for (let col = 1, row = 0, index2 = 0; index2 < compact.length; index2++) {
          compact[index2] = this.get(row, col);
          if (++col >= diagonalSize)
            col = ++row + 1;
        }
        return compact;
      }
      /**
       * @param {number[]} compact
       */
      static fromCompact(compact) {
        const compactSize = compact.length;
        const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;
        if (!Number.isInteger(diagonalSize)) {
          throw new TypeError(
            `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
              compact
            )}`
          );
        }
        const matrix2 = new this(diagonalSize);
        for (let col = 1, row = 0, index2 = 0; index2 < compactSize; index2++) {
          matrix2.set(col, row, compact[index2]);
          if (++col >= diagonalSize)
            col = ++row + 1;
        }
        return matrix2;
      }
    };
    DistanceMatrix2.prototype.klassSubType = "DistanceMatrix";
    var BaseView = class extends AbstractMatrix2 {
      constructor(matrix2, rows, columns) {
        super();
        this.matrix = matrix2;
        this.rows = rows;
        this.columns = columns;
      }
    };
    var MatrixColumnView2 = class extends BaseView {
      constructor(matrix2, column) {
        checkColumnIndex(matrix2, column);
        super(matrix2, matrix2.rows, 1);
        this.column = column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }
      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    };
    var MatrixColumnSelectionView2 = class extends BaseView {
      constructor(matrix2, columnIndices) {
        checkColumnIndices(matrix2, columnIndices);
        super(matrix2, matrix2.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    };
    var MatrixFlipColumnView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.rows, matrix2.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    };
    var MatrixFlipRowView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.rows, matrix2.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    };
    var MatrixRowView2 = class extends BaseView {
      constructor(matrix2, row) {
        checkRowIndex(matrix2, row);
        super(matrix2, 1, matrix2.columns);
        this.row = row;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    };
    var MatrixRowSelectionView2 = class extends BaseView {
      constructor(matrix2, rowIndices) {
        checkRowIndices(matrix2, rowIndices);
        super(matrix2, rowIndices.length, matrix2.columns);
        this.rowIndices = rowIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    };
    var MatrixSelectionView2 = class extends BaseView {
      constructor(matrix2, rowIndices, columnIndices) {
        checkRowIndices(matrix2, rowIndices);
        checkColumnIndices(matrix2, columnIndices);
        super(matrix2, rowIndices.length, columnIndices.length);
        this.rowIndices = rowIndices;
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    };
    var MatrixSubView2 = class extends BaseView {
      constructor(matrix2, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix2, startRow, endRow, startColumn, endColumn);
        super(matrix2, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    };
    var MatrixTransposeView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.columns, matrix2.rows);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    };
    var WrapperMatrix1D2 = class extends AbstractMatrix2 {
      constructor(data, options = {}) {
        const { rows = 1 } = options;
        if (data.length % rows !== 0) {
          throw new Error("the data length is not divisible by the number of rows");
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }
      set(rowIndex, columnIndex, value) {
        let index2 = this._calculateIndex(rowIndex, columnIndex);
        this.data[index2] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        let index2 = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index2];
      }
      _calculateIndex(row, column) {
        return row * this.columns + column;
      }
    };
    var WrapperMatrix2D2 = class extends AbstractMatrix2 {
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
    };
    function wrap2(array3, options) {
      if (isAnyArray3.isAnyArray(array3)) {
        if (array3[0] && isAnyArray3.isAnyArray(array3[0])) {
          return new WrapperMatrix2D2(array3);
        } else {
          return new WrapperMatrix1D2(array3, options);
        }
      } else {
        throw new Error("the argument is not an array");
      }
    }
    var LuDecomposition2 = class {
      constructor(matrix2) {
        matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
        let lu = matrix2.clone();
        let rows = lu.rows;
        let columns = lu.columns;
        let pivotVector = new Float64Array(rows);
        let pivotSign = 1;
        let i3, j2, k2, p3, s3, t3, v3;
        let LUcolj, kmax;
        for (i3 = 0; i3 < rows; i3++) {
          pivotVector[i3] = i3;
        }
        LUcolj = new Float64Array(rows);
        for (j2 = 0; j2 < columns; j2++) {
          for (i3 = 0; i3 < rows; i3++) {
            LUcolj[i3] = lu.get(i3, j2);
          }
          for (i3 = 0; i3 < rows; i3++) {
            kmax = Math.min(i3, j2);
            s3 = 0;
            for (k2 = 0; k2 < kmax; k2++) {
              s3 += lu.get(i3, k2) * LUcolj[k2];
            }
            LUcolj[i3] -= s3;
            lu.set(i3, j2, LUcolj[i3]);
          }
          p3 = j2;
          for (i3 = j2 + 1; i3 < rows; i3++) {
            if (Math.abs(LUcolj[i3]) > Math.abs(LUcolj[p3])) {
              p3 = i3;
            }
          }
          if (p3 !== j2) {
            for (k2 = 0; k2 < columns; k2++) {
              t3 = lu.get(p3, k2);
              lu.set(p3, k2, lu.get(j2, k2));
              lu.set(j2, k2, t3);
            }
            v3 = pivotVector[p3];
            pivotVector[p3] = pivotVector[j2];
            pivotVector[j2] = v3;
            pivotSign = -pivotSign;
          }
          if (j2 < rows && lu.get(j2, j2) !== 0) {
            for (i3 = j2 + 1; i3 < rows; i3++) {
              lu.set(i3, j2, lu.get(i3, j2) / lu.get(j2, j2));
            }
          }
        }
        this.LU = lu;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }
      isSingular() {
        let data = this.LU;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          if (data.get(j2, j2) === 0) {
            return true;
          }
        }
        return false;
      }
      solve(value) {
        value = Matrix5.checkMatrix(value);
        let lu = this.LU;
        let rows = lu.rows;
        if (rows !== value.rows) {
          throw new Error("Invalid matrix dimensions");
        }
        if (this.isSingular()) {
          throw new Error("LU matrix is singular");
        }
        let count = value.columns;
        let X2 = value.subMatrixRow(this.pivotVector, 0, count - 1);
        let columns = lu.columns;
        let i3, j2, k2;
        for (k2 = 0; k2 < columns; k2++) {
          for (i3 = k2 + 1; i3 < columns; i3++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i3, j2, X2.get(i3, j2) - X2.get(k2, j2) * lu.get(i3, k2));
            }
          }
        }
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / lu.get(k2, k2));
          }
          for (i3 = 0; i3 < k2; i3++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i3, j2, X2.get(i3, j2) - X2.get(k2, j2) * lu.get(i3, k2));
            }
          }
        }
        return X2;
      }
      get determinant() {
        let data = this.LU;
        if (!data.isSquare()) {
          throw new Error("Matrix must be square");
        }
        let determinant3 = this.pivotSign;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          determinant3 *= data.get(j2, j2);
        }
        return determinant3;
      }
      get lowerTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix5(rows, columns);
        for (let i3 = 0; i3 < rows; i3++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i3 > j2) {
              X2.set(i3, j2, data.get(i3, j2));
            } else if (i3 === j2) {
              X2.set(i3, j2, 1);
            } else {
              X2.set(i3, j2, 0);
            }
          }
        }
        return X2;
      }
      get upperTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix5(rows, columns);
        for (let i3 = 0; i3 < rows; i3++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i3 <= j2) {
              X2.set(i3, j2, data.get(i3, j2));
            } else {
              X2.set(i3, j2, 0);
            }
          }
        }
        return X2;
      }
      get pivotPermutationVector() {
        return Array.from(this.pivotVector);
      }
    };
    function hypotenuse2(a3, b2) {
      let r2 = 0;
      if (Math.abs(a3) > Math.abs(b2)) {
        r2 = b2 / a3;
        return Math.abs(a3) * Math.sqrt(1 + r2 * r2);
      }
      if (b2 !== 0) {
        r2 = a3 / b2;
        return Math.abs(b2) * Math.sqrt(1 + r2 * r2);
      }
      return 0;
    }
    var QrDecomposition2 = class {
      constructor(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        let qr = value.clone();
        let m4 = value.rows;
        let n3 = value.columns;
        let rdiag = new Float64Array(n3);
        let i3, j2, k2, s3;
        for (k2 = 0; k2 < n3; k2++) {
          let nrm = 0;
          for (i3 = k2; i3 < m4; i3++) {
            nrm = hypotenuse2(nrm, qr.get(i3, k2));
          }
          if (nrm !== 0) {
            if (qr.get(k2, k2) < 0) {
              nrm = -nrm;
            }
            for (i3 = k2; i3 < m4; i3++) {
              qr.set(i3, k2, qr.get(i3, k2) / nrm);
            }
            qr.set(k2, k2, qr.get(k2, k2) + 1);
            for (j2 = k2 + 1; j2 < n3; j2++) {
              s3 = 0;
              for (i3 = k2; i3 < m4; i3++) {
                s3 += qr.get(i3, k2) * qr.get(i3, j2);
              }
              s3 = -s3 / qr.get(k2, k2);
              for (i3 = k2; i3 < m4; i3++) {
                qr.set(i3, j2, qr.get(i3, j2) + s3 * qr.get(i3, k2));
              }
            }
          }
          rdiag[k2] = -nrm;
        }
        this.QR = qr;
        this.Rdiag = rdiag;
      }
      solve(value) {
        value = Matrix5.checkMatrix(value);
        let qr = this.QR;
        let m4 = qr.rows;
        if (value.rows !== m4) {
          throw new Error("Matrix row dimensions must agree");
        }
        if (!this.isFullRank()) {
          throw new Error("Matrix is rank deficient");
        }
        let count = value.columns;
        let X2 = value.clone();
        let n3 = qr.columns;
        let i3, j2, k2, s3;
        for (k2 = 0; k2 < n3; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            s3 = 0;
            for (i3 = k2; i3 < m4; i3++) {
              s3 += qr.get(i3, k2) * X2.get(i3, j2);
            }
            s3 = -s3 / qr.get(k2, k2);
            for (i3 = k2; i3 < m4; i3++) {
              X2.set(i3, j2, X2.get(i3, j2) + s3 * qr.get(i3, k2));
            }
          }
        }
        for (k2 = n3 - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / this.Rdiag[k2]);
          }
          for (i3 = 0; i3 < k2; i3++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i3, j2, X2.get(i3, j2) - X2.get(k2, j2) * qr.get(i3, k2));
            }
          }
        }
        return X2.subMatrix(0, n3 - 1, 0, count - 1);
      }
      isFullRank() {
        let columns = this.QR.columns;
        for (let i3 = 0; i3 < columns; i3++) {
          if (this.Rdiag[i3] === 0) {
            return false;
          }
        }
        return true;
      }
      get upperTriangularMatrix() {
        let qr = this.QR;
        let n3 = qr.columns;
        let X2 = new Matrix5(n3, n3);
        let i3, j2;
        for (i3 = 0; i3 < n3; i3++) {
          for (j2 = 0; j2 < n3; j2++) {
            if (i3 < j2) {
              X2.set(i3, j2, qr.get(i3, j2));
            } else if (i3 === j2) {
              X2.set(i3, j2, this.Rdiag[i3]);
            } else {
              X2.set(i3, j2, 0);
            }
          }
        }
        return X2;
      }
      get orthogonalMatrix() {
        let qr = this.QR;
        let rows = qr.rows;
        let columns = qr.columns;
        let X2 = new Matrix5(rows, columns);
        let i3, j2, k2, s3;
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (i3 = 0; i3 < rows; i3++) {
            X2.set(i3, k2, 0);
          }
          X2.set(k2, k2, 1);
          for (j2 = k2; j2 < columns; j2++) {
            if (qr.get(k2, k2) !== 0) {
              s3 = 0;
              for (i3 = k2; i3 < rows; i3++) {
                s3 += qr.get(i3, k2) * X2.get(i3, j2);
              }
              s3 = -s3 / qr.get(k2, k2);
              for (i3 = k2; i3 < rows; i3++) {
                X2.set(i3, j2, X2.get(i3, j2) + s3 * qr.get(i3, k2));
              }
            }
          }
        }
        return X2;
      }
    };
    var SingularValueDecomposition3 = class {
      constructor(value, options = {}) {
        value = WrapperMatrix2D2.checkMatrix(value);
        if (value.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let m4 = value.rows;
        let n3 = value.columns;
        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;
        let wantu = Boolean(computeLeftSingularVectors);
        let wantv = Boolean(computeRightSingularVectors);
        let swapped = false;
        let a3;
        if (m4 < n3) {
          if (!autoTranspose) {
            a3 = value.clone();
            console.warn(
              "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
            );
          } else {
            a3 = value.transpose();
            m4 = a3.rows;
            n3 = a3.columns;
            swapped = true;
            let aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a3 = value.clone();
        }
        let nu = Math.min(m4, n3);
        let ni = Math.min(m4 + 1, n3);
        let s3 = new Float64Array(ni);
        let U2 = new Matrix5(m4, nu);
        let V2 = new Matrix5(n3, n3);
        let e2 = new Float64Array(n3);
        let work2 = new Float64Array(m4);
        let si = new Float64Array(ni);
        for (let i3 = 0; i3 < ni; i3++)
          si[i3] = i3;
        let nct = Math.min(m4 - 1, n3);
        let nrt = Math.max(0, Math.min(n3 - 2, m4));
        let mrc = Math.max(nct, nrt);
        for (let k2 = 0; k2 < mrc; k2++) {
          if (k2 < nct) {
            s3[k2] = 0;
            for (let i3 = k2; i3 < m4; i3++) {
              s3[k2] = hypotenuse2(s3[k2], a3.get(i3, k2));
            }
            if (s3[k2] !== 0) {
              if (a3.get(k2, k2) < 0) {
                s3[k2] = -s3[k2];
              }
              for (let i3 = k2; i3 < m4; i3++) {
                a3.set(i3, k2, a3.get(i3, k2) / s3[k2]);
              }
              a3.set(k2, k2, a3.get(k2, k2) + 1);
            }
            s3[k2] = -s3[k2];
          }
          for (let j2 = k2 + 1; j2 < n3; j2++) {
            if (k2 < nct && s3[k2] !== 0) {
              let t3 = 0;
              for (let i3 = k2; i3 < m4; i3++) {
                t3 += a3.get(i3, k2) * a3.get(i3, j2);
              }
              t3 = -t3 / a3.get(k2, k2);
              for (let i3 = k2; i3 < m4; i3++) {
                a3.set(i3, j2, a3.get(i3, j2) + t3 * a3.get(i3, k2));
              }
            }
            e2[j2] = a3.get(k2, j2);
          }
          if (wantu && k2 < nct) {
            for (let i3 = k2; i3 < m4; i3++) {
              U2.set(i3, k2, a3.get(i3, k2));
            }
          }
          if (k2 < nrt) {
            e2[k2] = 0;
            for (let i3 = k2 + 1; i3 < n3; i3++) {
              e2[k2] = hypotenuse2(e2[k2], e2[i3]);
            }
            if (e2[k2] !== 0) {
              if (e2[k2 + 1] < 0) {
                e2[k2] = 0 - e2[k2];
              }
              for (let i3 = k2 + 1; i3 < n3; i3++) {
                e2[i3] /= e2[k2];
              }
              e2[k2 + 1] += 1;
            }
            e2[k2] = -e2[k2];
            if (k2 + 1 < m4 && e2[k2] !== 0) {
              for (let i3 = k2 + 1; i3 < m4; i3++) {
                work2[i3] = 0;
              }
              for (let i3 = k2 + 1; i3 < m4; i3++) {
                for (let j2 = k2 + 1; j2 < n3; j2++) {
                  work2[i3] += e2[j2] * a3.get(i3, j2);
                }
              }
              for (let j2 = k2 + 1; j2 < n3; j2++) {
                let t3 = -e2[j2] / e2[k2 + 1];
                for (let i3 = k2 + 1; i3 < m4; i3++) {
                  a3.set(i3, j2, a3.get(i3, j2) + t3 * work2[i3]);
                }
              }
            }
            if (wantv) {
              for (let i3 = k2 + 1; i3 < n3; i3++) {
                V2.set(i3, k2, e2[i3]);
              }
            }
          }
        }
        let p3 = Math.min(n3, m4 + 1);
        if (nct < n3) {
          s3[nct] = a3.get(nct, nct);
        }
        if (m4 < p3) {
          s3[p3 - 1] = 0;
        }
        if (nrt + 1 < p3) {
          e2[nrt] = a3.get(nrt, p3 - 1);
        }
        e2[p3 - 1] = 0;
        if (wantu) {
          for (let j2 = nct; j2 < nu; j2++) {
            for (let i3 = 0; i3 < m4; i3++) {
              U2.set(i3, j2, 0);
            }
            U2.set(j2, j2, 1);
          }
          for (let k2 = nct - 1; k2 >= 0; k2--) {
            if (s3[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < nu; j2++) {
                let t3 = 0;
                for (let i3 = k2; i3 < m4; i3++) {
                  t3 += U2.get(i3, k2) * U2.get(i3, j2);
                }
                t3 = -t3 / U2.get(k2, k2);
                for (let i3 = k2; i3 < m4; i3++) {
                  U2.set(i3, j2, U2.get(i3, j2) + t3 * U2.get(i3, k2));
                }
              }
              for (let i3 = k2; i3 < m4; i3++) {
                U2.set(i3, k2, -U2.get(i3, k2));
              }
              U2.set(k2, k2, 1 + U2.get(k2, k2));
              for (let i3 = 0; i3 < k2 - 1; i3++) {
                U2.set(i3, k2, 0);
              }
            } else {
              for (let i3 = 0; i3 < m4; i3++) {
                U2.set(i3, k2, 0);
              }
              U2.set(k2, k2, 1);
            }
          }
        }
        if (wantv) {
          for (let k2 = n3 - 1; k2 >= 0; k2--) {
            if (k2 < nrt && e2[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < n3; j2++) {
                let t3 = 0;
                for (let i3 = k2 + 1; i3 < n3; i3++) {
                  t3 += V2.get(i3, k2) * V2.get(i3, j2);
                }
                t3 = -t3 / V2.get(k2 + 1, k2);
                for (let i3 = k2 + 1; i3 < n3; i3++) {
                  V2.set(i3, j2, V2.get(i3, j2) + t3 * V2.get(i3, k2));
                }
              }
            }
            for (let i3 = 0; i3 < n3; i3++) {
              V2.set(i3, k2, 0);
            }
            V2.set(k2, k2, 1);
          }
        }
        let pp = p3 - 1;
        let eps = Number.EPSILON;
        while (p3 > 0) {
          let k2, kase;
          for (k2 = p3 - 2; k2 >= -1; k2--) {
            if (k2 === -1) {
              break;
            }
            const alpha = Number.MIN_VALUE + eps * Math.abs(s3[k2] + Math.abs(s3[k2 + 1]));
            if (Math.abs(e2[k2]) <= alpha || Number.isNaN(e2[k2])) {
              e2[k2] = 0;
              break;
            }
          }
          if (k2 === p3 - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p3 - 1; ks >= k2; ks--) {
              if (ks === k2) {
                break;
              }
              let t3 = (ks !== p3 ? Math.abs(e2[ks]) : 0) + (ks !== k2 + 1 ? Math.abs(e2[ks - 1]) : 0);
              if (Math.abs(s3[ks]) <= eps * t3) {
                s3[ks] = 0;
                break;
              }
            }
            if (ks === k2) {
              kase = 3;
            } else if (ks === p3 - 1) {
              kase = 1;
            } else {
              kase = 2;
              k2 = ks;
            }
          }
          k2++;
          switch (kase) {
            case 1: {
              let f3 = e2[p3 - 2];
              e2[p3 - 2] = 0;
              for (let j2 = p3 - 2; j2 >= k2; j2--) {
                let t3 = hypotenuse2(s3[j2], f3);
                let cs = s3[j2] / t3;
                let sn = f3 / t3;
                s3[j2] = t3;
                if (j2 !== k2) {
                  f3 = -sn * e2[j2 - 1];
                  e2[j2 - 1] = cs * e2[j2 - 1];
                }
                if (wantv) {
                  for (let i3 = 0; i3 < n3; i3++) {
                    t3 = cs * V2.get(i3, j2) + sn * V2.get(i3, p3 - 1);
                    V2.set(i3, p3 - 1, -sn * V2.get(i3, j2) + cs * V2.get(i3, p3 - 1));
                    V2.set(i3, j2, t3);
                  }
                }
              }
              break;
            }
            case 2: {
              let f3 = e2[k2 - 1];
              e2[k2 - 1] = 0;
              for (let j2 = k2; j2 < p3; j2++) {
                let t3 = hypotenuse2(s3[j2], f3);
                let cs = s3[j2] / t3;
                let sn = f3 / t3;
                s3[j2] = t3;
                f3 = -sn * e2[j2];
                e2[j2] = cs * e2[j2];
                if (wantu) {
                  for (let i3 = 0; i3 < m4; i3++) {
                    t3 = cs * U2.get(i3, j2) + sn * U2.get(i3, k2 - 1);
                    U2.set(i3, k2 - 1, -sn * U2.get(i3, j2) + cs * U2.get(i3, k2 - 1));
                    U2.set(i3, j2, t3);
                  }
                }
              }
              break;
            }
            case 3: {
              const scale = Math.max(
                Math.abs(s3[p3 - 1]),
                Math.abs(s3[p3 - 2]),
                Math.abs(e2[p3 - 2]),
                Math.abs(s3[k2]),
                Math.abs(e2[k2])
              );
              const sp = s3[p3 - 1] / scale;
              const spm1 = s3[p3 - 2] / scale;
              const epm1 = e2[p3 - 2] / scale;
              const sk = s3[k2] / scale;
              const ek = e2[k2] / scale;
              const b2 = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c4 = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b2 !== 0 || c4 !== 0) {
                if (b2 < 0) {
                  shift = 0 - Math.sqrt(b2 * b2 + c4);
                } else {
                  shift = Math.sqrt(b2 * b2 + c4);
                }
                shift = c4 / (b2 + shift);
              }
              let f3 = (sk + sp) * (sk - sp) + shift;
              let g2 = sk * ek;
              for (let j2 = k2; j2 < p3 - 1; j2++) {
                let t3 = hypotenuse2(f3, g2);
                if (t3 === 0)
                  t3 = Number.MIN_VALUE;
                let cs = f3 / t3;
                let sn = g2 / t3;
                if (j2 !== k2) {
                  e2[j2 - 1] = t3;
                }
                f3 = cs * s3[j2] + sn * e2[j2];
                e2[j2] = cs * e2[j2] - sn * s3[j2];
                g2 = sn * s3[j2 + 1];
                s3[j2 + 1] = cs * s3[j2 + 1];
                if (wantv) {
                  for (let i3 = 0; i3 < n3; i3++) {
                    t3 = cs * V2.get(i3, j2) + sn * V2.get(i3, j2 + 1);
                    V2.set(i3, j2 + 1, -sn * V2.get(i3, j2) + cs * V2.get(i3, j2 + 1));
                    V2.set(i3, j2, t3);
                  }
                }
                t3 = hypotenuse2(f3, g2);
                if (t3 === 0)
                  t3 = Number.MIN_VALUE;
                cs = f3 / t3;
                sn = g2 / t3;
                s3[j2] = t3;
                f3 = cs * e2[j2] + sn * s3[j2 + 1];
                s3[j2 + 1] = -sn * e2[j2] + cs * s3[j2 + 1];
                g2 = sn * e2[j2 + 1];
                e2[j2 + 1] = cs * e2[j2 + 1];
                if (wantu && j2 < m4 - 1) {
                  for (let i3 = 0; i3 < m4; i3++) {
                    t3 = cs * U2.get(i3, j2) + sn * U2.get(i3, j2 + 1);
                    U2.set(i3, j2 + 1, -sn * U2.get(i3, j2) + cs * U2.get(i3, j2 + 1));
                    U2.set(i3, j2, t3);
                  }
                }
              }
              e2[p3 - 2] = f3;
              break;
            }
            case 4: {
              if (s3[k2] <= 0) {
                s3[k2] = s3[k2] < 0 ? -s3[k2] : 0;
                if (wantv) {
                  for (let i3 = 0; i3 <= pp; i3++) {
                    V2.set(i3, k2, -V2.get(i3, k2));
                  }
                }
              }
              while (k2 < pp) {
                if (s3[k2] >= s3[k2 + 1]) {
                  break;
                }
                let t3 = s3[k2];
                s3[k2] = s3[k2 + 1];
                s3[k2 + 1] = t3;
                if (wantv && k2 < n3 - 1) {
                  for (let i3 = 0; i3 < n3; i3++) {
                    t3 = V2.get(i3, k2 + 1);
                    V2.set(i3, k2 + 1, V2.get(i3, k2));
                    V2.set(i3, k2, t3);
                  }
                }
                if (wantu && k2 < m4 - 1) {
                  for (let i3 = 0; i3 < m4; i3++) {
                    t3 = U2.get(i3, k2 + 1);
                    U2.set(i3, k2 + 1, U2.get(i3, k2));
                    U2.set(i3, k2, t3);
                  }
                }
                k2++;
              }
              p3--;
              break;
            }
          }
        }
        if (swapped) {
          let tmp = V2;
          V2 = U2;
          U2 = tmp;
        }
        this.m = m4;
        this.n = n3;
        this.s = s3;
        this.U = U2;
        this.V = V2;
      }
      solve(value) {
        let Y2 = value;
        let e2 = this.threshold;
        let scols = this.s.length;
        let Ls = Matrix5.zeros(scols, scols);
        for (let i3 = 0; i3 < scols; i3++) {
          if (Math.abs(this.s[i3]) <= e2) {
            Ls.set(i3, i3, 0);
          } else {
            Ls.set(i3, i3, 1 / this.s[i3]);
          }
        }
        let U2 = this.U;
        let V2 = this.rightSingularVectors;
        let VL = V2.mmul(Ls);
        let vrows = V2.rows;
        let urows = U2.rows;
        let VLU = Matrix5.zeros(vrows, urows);
        for (let i3 = 0; i3 < vrows; i3++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum2 = 0;
            for (let k2 = 0; k2 < scols; k2++) {
              sum2 += VL.get(i3, k2) * U2.get(j2, k2);
            }
            VLU.set(i3, j2, sum2);
          }
        }
        return VLU.mmul(Y2);
      }
      solveForDiagonal(value) {
        return this.solve(Matrix5.diag(value));
      }
      inverse() {
        let V2 = this.V;
        let e2 = this.threshold;
        let vrows = V2.rows;
        let vcols = V2.columns;
        let X2 = new Matrix5(vrows, this.s.length);
        for (let i3 = 0; i3 < vrows; i3++) {
          for (let j2 = 0; j2 < vcols; j2++) {
            if (Math.abs(this.s[j2]) > e2) {
              X2.set(i3, j2, V2.get(i3, j2) / this.s[j2]);
            }
          }
        }
        let U2 = this.U;
        let urows = U2.rows;
        let ucols = U2.columns;
        let Y2 = new Matrix5(vrows, urows);
        for (let i3 = 0; i3 < vrows; i3++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum2 = 0;
            for (let k2 = 0; k2 < ucols; k2++) {
              sum2 += X2.get(i3, k2) * U2.get(j2, k2);
            }
            Y2.set(i3, j2, sum2);
          }
        }
        return Y2;
      }
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }
      get norm2() {
        return this.s[0];
      }
      get rank() {
        let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        let r2 = 0;
        let s3 = this.s;
        for (let i3 = 0, ii = s3.length; i3 < ii; i3++) {
          if (s3[i3] > tol) {
            r2++;
          }
        }
        return r2;
      }
      get diagonal() {
        return Array.from(this.s);
      }
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }
      get leftSingularVectors() {
        return this.U;
      }
      get rightSingularVectors() {
        return this.V;
      }
      get diagonalMatrix() {
        return Matrix5.diag(this.s);
      }
    };
    function inverse3(matrix2, useSVD = false) {
      matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
      if (useSVD) {
        return new SingularValueDecomposition3(matrix2).inverse();
      } else {
        return solve3(matrix2, Matrix5.eye(matrix2.rows));
      }
    }
    function solve3(leftHandSide, rightHandSide, useSVD = false) {
      leftHandSide = WrapperMatrix2D2.checkMatrix(leftHandSide);
      rightHandSide = WrapperMatrix2D2.checkMatrix(rightHandSide);
      if (useSVD) {
        return new SingularValueDecomposition3(leftHandSide).solve(rightHandSide);
      } else {
        return leftHandSide.isSquare() ? new LuDecomposition2(leftHandSide).solve(rightHandSide) : new QrDecomposition2(leftHandSide).solve(rightHandSide);
      }
    }
    function determinant2(matrix2) {
      matrix2 = Matrix5.checkMatrix(matrix2);
      if (matrix2.isSquare()) {
        if (matrix2.columns === 0) {
          return 1;
        }
        let a3, b2, c4, d2;
        if (matrix2.columns === 2) {
          a3 = matrix2.get(0, 0);
          b2 = matrix2.get(0, 1);
          c4 = matrix2.get(1, 0);
          d2 = matrix2.get(1, 1);
          return a3 * d2 - b2 * c4;
        } else if (matrix2.columns === 3) {
          let subMatrix0, subMatrix1, subMatrix2;
          subMatrix0 = new MatrixSelectionView2(matrix2, [1, 2], [1, 2]);
          subMatrix1 = new MatrixSelectionView2(matrix2, [1, 2], [0, 2]);
          subMatrix2 = new MatrixSelectionView2(matrix2, [1, 2], [0, 1]);
          a3 = matrix2.get(0, 0);
          b2 = matrix2.get(0, 1);
          c4 = matrix2.get(0, 2);
          return a3 * determinant2(subMatrix0) - b2 * determinant2(subMatrix1) + c4 * determinant2(subMatrix2);
        } else {
          return new LuDecomposition2(matrix2).determinant;
        }
      } else {
        throw Error("determinant can only be calculated for a square matrix");
      }
    }
    function xrange(n3, exception) {
      let range = [];
      for (let i3 = 0; i3 < n3; i3++) {
        if (i3 !== exception) {
          range.push(i3);
        }
      }
      return range;
    }
    function dependenciesOneRow(error, matrix2, index2, thresholdValue = 1e-9, thresholdError = 1e-9) {
      if (error > thresholdError) {
        return new Array(matrix2.rows + 1).fill(0);
      } else {
        let returnArray = matrix2.addRow(index2, [0]);
        for (let i3 = 0; i3 < returnArray.rows; i3++) {
          if (Math.abs(returnArray.get(i3, 0)) < thresholdValue) {
            returnArray.set(i3, 0, 0);
          }
        }
        return returnArray.to1DArray();
      }
    }
    function linearDependencies2(matrix2, options = {}) {
      const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
      matrix2 = Matrix5.checkMatrix(matrix2);
      let n3 = matrix2.rows;
      let results = new Matrix5(n3, n3);
      for (let i3 = 0; i3 < n3; i3++) {
        let b2 = Matrix5.columnVector(matrix2.getRow(i3));
        let Abis = matrix2.subMatrixRow(xrange(n3, i3)).transpose();
        let svd = new SingularValueDecomposition3(Abis);
        let x2 = svd.solve(b2);
        let error = Matrix5.sub(b2, Abis.mmul(x2)).abs().max();
        results.setRow(
          i3,
          dependenciesOneRow(error, x2, i3, thresholdValue, thresholdError)
        );
      }
      return results;
    }
    function pseudoInverse2(matrix2, threshold = Number.EPSILON) {
      matrix2 = Matrix5.checkMatrix(matrix2);
      if (matrix2.isEmpty()) {
        return matrix2.transpose();
      }
      let svdSolution = new SingularValueDecomposition3(matrix2, { autoTranspose: true });
      let U2 = svdSolution.leftSingularVectors;
      let V2 = svdSolution.rightSingularVectors;
      let s3 = svdSolution.diagonal;
      for (let i3 = 0; i3 < s3.length; i3++) {
        if (Math.abs(s3[i3]) > threshold) {
          s3[i3] = 1 / s3[i3];
        } else {
          s3[i3] = 0;
        }
      }
      return V2.mmul(Matrix5.diag(s3).mmul(U2.transpose()));
    }
    function covariance2(xMatrix, yMatrix = xMatrix, options = {}) {
      xMatrix = new Matrix5(xMatrix);
      let yIsSame = false;
      if (typeof yMatrix === "object" && !Matrix5.isMatrix(yMatrix) && !isAnyArray3.isAnyArray(yMatrix)) {
        options = yMatrix;
        yMatrix = xMatrix;
        yIsSame = true;
      } else {
        yMatrix = new Matrix5(yMatrix);
      }
      if (xMatrix.rows !== yMatrix.rows) {
        throw new TypeError("Both matrices must have the same number of rows");
      }
      const { center = true } = options;
      if (center) {
        xMatrix = xMatrix.center("column");
        if (!yIsSame) {
          yMatrix = yMatrix.center("column");
        }
      }
      const cov = xMatrix.transpose().mmul(yMatrix);
      for (let i3 = 0; i3 < cov.rows; i3++) {
        for (let j2 = 0; j2 < cov.columns; j2++) {
          cov.set(i3, j2, cov.get(i3, j2) * (1 / (xMatrix.rows - 1)));
        }
      }
      return cov;
    }
    function correlation2(xMatrix, yMatrix = xMatrix, options = {}) {
      xMatrix = new Matrix5(xMatrix);
      let yIsSame = false;
      if (typeof yMatrix === "object" && !Matrix5.isMatrix(yMatrix) && !isAnyArray3.isAnyArray(yMatrix)) {
        options = yMatrix;
        yMatrix = xMatrix;
        yIsSame = true;
      } else {
        yMatrix = new Matrix5(yMatrix);
      }
      if (xMatrix.rows !== yMatrix.rows) {
        throw new TypeError("Both matrices must have the same number of rows");
      }
      const { center = true, scale = true } = options;
      if (center) {
        xMatrix.center("column");
        if (!yIsSame) {
          yMatrix.center("column");
        }
      }
      if (scale) {
        xMatrix.scale("column");
        if (!yIsSame) {
          yMatrix.scale("column");
        }
      }
      const sdx = xMatrix.standardDeviation("column", { unbiased: true });
      const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
      const corr = xMatrix.transpose().mmul(yMatrix);
      for (let i3 = 0; i3 < corr.rows; i3++) {
        for (let j2 = 0; j2 < corr.columns; j2++) {
          corr.set(
            i3,
            j2,
            corr.get(i3, j2) * (1 / (sdx[i3] * sdy[j2])) * (1 / (xMatrix.rows - 1))
          );
        }
      }
      return corr;
    }
    var EigenvalueDecomposition2 = class {
      constructor(matrix2, options = {}) {
        const { assumeSymmetric = false } = options;
        matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
        if (!matrix2.isSquare()) {
          throw new Error("Matrix is not a square matrix");
        }
        if (matrix2.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let n3 = matrix2.columns;
        let V2 = new Matrix5(n3, n3);
        let d2 = new Float64Array(n3);
        let e2 = new Float64Array(n3);
        let value = matrix2;
        let i3, j2;
        let isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix2.isSymmetric();
        }
        if (isSymmetric) {
          for (i3 = 0; i3 < n3; i3++) {
            for (j2 = 0; j2 < n3; j2++) {
              V2.set(i3, j2, value.get(i3, j2));
            }
          }
          tred2(n3, e2, d2, V2);
          tql2(n3, e2, d2, V2);
        } else {
          let H2 = new Matrix5(n3, n3);
          let ort = new Float64Array(n3);
          for (j2 = 0; j2 < n3; j2++) {
            for (i3 = 0; i3 < n3; i3++) {
              H2.set(i3, j2, value.get(i3, j2));
            }
          }
          orthes(n3, H2, ort, V2);
          hqr2(n3, e2, d2, V2, H2);
        }
        this.n = n3;
        this.e = e2;
        this.d = d2;
        this.V = V2;
      }
      get realEigenvalues() {
        return Array.from(this.d);
      }
      get imaginaryEigenvalues() {
        return Array.from(this.e);
      }
      get eigenvectorMatrix() {
        return this.V;
      }
      get diagonalMatrix() {
        let n3 = this.n;
        let e2 = this.e;
        let d2 = this.d;
        let X2 = new Matrix5(n3, n3);
        let i3, j2;
        for (i3 = 0; i3 < n3; i3++) {
          for (j2 = 0; j2 < n3; j2++) {
            X2.set(i3, j2, 0);
          }
          X2.set(i3, i3, d2[i3]);
          if (e2[i3] > 0) {
            X2.set(i3, i3 + 1, e2[i3]);
          } else if (e2[i3] < 0) {
            X2.set(i3, i3 - 1, e2[i3]);
          }
        }
        return X2;
      }
    };
    function tred2(n3, e2, d2, V2) {
      let f3, g2, h3, i3, j2, k2, hh, scale;
      for (j2 = 0; j2 < n3; j2++) {
        d2[j2] = V2.get(n3 - 1, j2);
      }
      for (i3 = n3 - 1; i3 > 0; i3--) {
        scale = 0;
        h3 = 0;
        for (k2 = 0; k2 < i3; k2++) {
          scale = scale + Math.abs(d2[k2]);
        }
        if (scale === 0) {
          e2[i3] = d2[i3 - 1];
          for (j2 = 0; j2 < i3; j2++) {
            d2[j2] = V2.get(i3 - 1, j2);
            V2.set(i3, j2, 0);
            V2.set(j2, i3, 0);
          }
        } else {
          for (k2 = 0; k2 < i3; k2++) {
            d2[k2] /= scale;
            h3 += d2[k2] * d2[k2];
          }
          f3 = d2[i3 - 1];
          g2 = Math.sqrt(h3);
          if (f3 > 0) {
            g2 = -g2;
          }
          e2[i3] = scale * g2;
          h3 = h3 - f3 * g2;
          d2[i3 - 1] = f3 - g2;
          for (j2 = 0; j2 < i3; j2++) {
            e2[j2] = 0;
          }
          for (j2 = 0; j2 < i3; j2++) {
            f3 = d2[j2];
            V2.set(j2, i3, f3);
            g2 = e2[j2] + V2.get(j2, j2) * f3;
            for (k2 = j2 + 1; k2 <= i3 - 1; k2++) {
              g2 += V2.get(k2, j2) * d2[k2];
              e2[k2] += V2.get(k2, j2) * f3;
            }
            e2[j2] = g2;
          }
          f3 = 0;
          for (j2 = 0; j2 < i3; j2++) {
            e2[j2] /= h3;
            f3 += e2[j2] * d2[j2];
          }
          hh = f3 / (h3 + h3);
          for (j2 = 0; j2 < i3; j2++) {
            e2[j2] -= hh * d2[j2];
          }
          for (j2 = 0; j2 < i3; j2++) {
            f3 = d2[j2];
            g2 = e2[j2];
            for (k2 = j2; k2 <= i3 - 1; k2++) {
              V2.set(k2, j2, V2.get(k2, j2) - (f3 * e2[k2] + g2 * d2[k2]));
            }
            d2[j2] = V2.get(i3 - 1, j2);
            V2.set(i3, j2, 0);
          }
        }
        d2[i3] = h3;
      }
      for (i3 = 0; i3 < n3 - 1; i3++) {
        V2.set(n3 - 1, i3, V2.get(i3, i3));
        V2.set(i3, i3, 1);
        h3 = d2[i3 + 1];
        if (h3 !== 0) {
          for (k2 = 0; k2 <= i3; k2++) {
            d2[k2] = V2.get(k2, i3 + 1) / h3;
          }
          for (j2 = 0; j2 <= i3; j2++) {
            g2 = 0;
            for (k2 = 0; k2 <= i3; k2++) {
              g2 += V2.get(k2, i3 + 1) * V2.get(k2, j2);
            }
            for (k2 = 0; k2 <= i3; k2++) {
              V2.set(k2, j2, V2.get(k2, j2) - g2 * d2[k2]);
            }
          }
        }
        for (k2 = 0; k2 <= i3; k2++) {
          V2.set(k2, i3 + 1, 0);
        }
      }
      for (j2 = 0; j2 < n3; j2++) {
        d2[j2] = V2.get(n3 - 1, j2);
        V2.set(n3 - 1, j2, 0);
      }
      V2.set(n3 - 1, n3 - 1, 1);
      e2[0] = 0;
    }
    function tql2(n3, e2, d2, V2) {
      let g2, h3, i3, j2, k2, l3, m4, p3, r2, dl1, c4, c22, c32, el1, s3, s22;
      for (i3 = 1; i3 < n3; i3++) {
        e2[i3 - 1] = e2[i3];
      }
      e2[n3 - 1] = 0;
      let f3 = 0;
      let tst1 = 0;
      let eps = Number.EPSILON;
      for (l3 = 0; l3 < n3; l3++) {
        tst1 = Math.max(tst1, Math.abs(d2[l3]) + Math.abs(e2[l3]));
        m4 = l3;
        while (m4 < n3) {
          if (Math.abs(e2[m4]) <= eps * tst1) {
            break;
          }
          m4++;
        }
        if (m4 > l3) {
          do {
            g2 = d2[l3];
            p3 = (d2[l3 + 1] - g2) / (2 * e2[l3]);
            r2 = hypotenuse2(p3, 1);
            if (p3 < 0) {
              r2 = -r2;
            }
            d2[l3] = e2[l3] / (p3 + r2);
            d2[l3 + 1] = e2[l3] * (p3 + r2);
            dl1 = d2[l3 + 1];
            h3 = g2 - d2[l3];
            for (i3 = l3 + 2; i3 < n3; i3++) {
              d2[i3] -= h3;
            }
            f3 = f3 + h3;
            p3 = d2[m4];
            c4 = 1;
            c22 = c4;
            c32 = c4;
            el1 = e2[l3 + 1];
            s3 = 0;
            s22 = 0;
            for (i3 = m4 - 1; i3 >= l3; i3--) {
              c32 = c22;
              c22 = c4;
              s22 = s3;
              g2 = c4 * e2[i3];
              h3 = c4 * p3;
              r2 = hypotenuse2(p3, e2[i3]);
              e2[i3 + 1] = s3 * r2;
              s3 = e2[i3] / r2;
              c4 = p3 / r2;
              p3 = c4 * d2[i3] - s3 * g2;
              d2[i3 + 1] = h3 + s3 * (c4 * g2 + s3 * d2[i3]);
              for (k2 = 0; k2 < n3; k2++) {
                h3 = V2.get(k2, i3 + 1);
                V2.set(k2, i3 + 1, s3 * V2.get(k2, i3) + c4 * h3);
                V2.set(k2, i3, c4 * V2.get(k2, i3) - s3 * h3);
              }
            }
            p3 = -s3 * s22 * c32 * el1 * e2[l3] / dl1;
            e2[l3] = s3 * p3;
            d2[l3] = c4 * p3;
          } while (Math.abs(e2[l3]) > eps * tst1);
        }
        d2[l3] = d2[l3] + f3;
        e2[l3] = 0;
      }
      for (i3 = 0; i3 < n3 - 1; i3++) {
        k2 = i3;
        p3 = d2[i3];
        for (j2 = i3 + 1; j2 < n3; j2++) {
          if (d2[j2] < p3) {
            k2 = j2;
            p3 = d2[j2];
          }
        }
        if (k2 !== i3) {
          d2[k2] = d2[i3];
          d2[i3] = p3;
          for (j2 = 0; j2 < n3; j2++) {
            p3 = V2.get(j2, i3);
            V2.set(j2, i3, V2.get(j2, k2));
            V2.set(j2, k2, p3);
          }
        }
      }
    }
    function orthes(n3, H2, ort, V2) {
      let low = 0;
      let high = n3 - 1;
      let f3, g2, h3, i3, j2, m4;
      let scale;
      for (m4 = low + 1; m4 <= high - 1; m4++) {
        scale = 0;
        for (i3 = m4; i3 <= high; i3++) {
          scale = scale + Math.abs(H2.get(i3, m4 - 1));
        }
        if (scale !== 0) {
          h3 = 0;
          for (i3 = high; i3 >= m4; i3--) {
            ort[i3] = H2.get(i3, m4 - 1) / scale;
            h3 += ort[i3] * ort[i3];
          }
          g2 = Math.sqrt(h3);
          if (ort[m4] > 0) {
            g2 = -g2;
          }
          h3 = h3 - ort[m4] * g2;
          ort[m4] = ort[m4] - g2;
          for (j2 = m4; j2 < n3; j2++) {
            f3 = 0;
            for (i3 = high; i3 >= m4; i3--) {
              f3 += ort[i3] * H2.get(i3, j2);
            }
            f3 = f3 / h3;
            for (i3 = m4; i3 <= high; i3++) {
              H2.set(i3, j2, H2.get(i3, j2) - f3 * ort[i3]);
            }
          }
          for (i3 = 0; i3 <= high; i3++) {
            f3 = 0;
            for (j2 = high; j2 >= m4; j2--) {
              f3 += ort[j2] * H2.get(i3, j2);
            }
            f3 = f3 / h3;
            for (j2 = m4; j2 <= high; j2++) {
              H2.set(i3, j2, H2.get(i3, j2) - f3 * ort[j2]);
            }
          }
          ort[m4] = scale * ort[m4];
          H2.set(m4, m4 - 1, scale * g2);
        }
      }
      for (i3 = 0; i3 < n3; i3++) {
        for (j2 = 0; j2 < n3; j2++) {
          V2.set(i3, j2, i3 === j2 ? 1 : 0);
        }
      }
      for (m4 = high - 1; m4 >= low + 1; m4--) {
        if (H2.get(m4, m4 - 1) !== 0) {
          for (i3 = m4 + 1; i3 <= high; i3++) {
            ort[i3] = H2.get(i3, m4 - 1);
          }
          for (j2 = m4; j2 <= high; j2++) {
            g2 = 0;
            for (i3 = m4; i3 <= high; i3++) {
              g2 += ort[i3] * V2.get(i3, j2);
            }
            g2 = g2 / ort[m4] / H2.get(m4, m4 - 1);
            for (i3 = m4; i3 <= high; i3++) {
              V2.set(i3, j2, V2.get(i3, j2) + g2 * ort[i3]);
            }
          }
        }
      }
    }
    function hqr2(nn, e2, d2, V2, H2) {
      let n3 = nn - 1;
      let low = 0;
      let high = nn - 1;
      let eps = Number.EPSILON;
      let exshift = 0;
      let norm = 0;
      let p3 = 0;
      let q2 = 0;
      let r2 = 0;
      let s3 = 0;
      let z2 = 0;
      let iter = 0;
      let i3, j2, k2, l3, m4, t3, w2, x2, y3;
      let ra, sa, vr, vi;
      let notlast, cdivres;
      for (i3 = 0; i3 < nn; i3++) {
        if (i3 < low || i3 > high) {
          d2[i3] = H2.get(i3, i3);
          e2[i3] = 0;
        }
        for (j2 = Math.max(i3 - 1, 0); j2 < nn; j2++) {
          norm = norm + Math.abs(H2.get(i3, j2));
        }
      }
      while (n3 >= low) {
        l3 = n3;
        while (l3 > low) {
          s3 = Math.abs(H2.get(l3 - 1, l3 - 1)) + Math.abs(H2.get(l3, l3));
          if (s3 === 0) {
            s3 = norm;
          }
          if (Math.abs(H2.get(l3, l3 - 1)) < eps * s3) {
            break;
          }
          l3--;
        }
        if (l3 === n3) {
          H2.set(n3, n3, H2.get(n3, n3) + exshift);
          d2[n3] = H2.get(n3, n3);
          e2[n3] = 0;
          n3--;
          iter = 0;
        } else if (l3 === n3 - 1) {
          w2 = H2.get(n3, n3 - 1) * H2.get(n3 - 1, n3);
          p3 = (H2.get(n3 - 1, n3 - 1) - H2.get(n3, n3)) / 2;
          q2 = p3 * p3 + w2;
          z2 = Math.sqrt(Math.abs(q2));
          H2.set(n3, n3, H2.get(n3, n3) + exshift);
          H2.set(n3 - 1, n3 - 1, H2.get(n3 - 1, n3 - 1) + exshift);
          x2 = H2.get(n3, n3);
          if (q2 >= 0) {
            z2 = p3 >= 0 ? p3 + z2 : p3 - z2;
            d2[n3 - 1] = x2 + z2;
            d2[n3] = d2[n3 - 1];
            if (z2 !== 0) {
              d2[n3] = x2 - w2 / z2;
            }
            e2[n3 - 1] = 0;
            e2[n3] = 0;
            x2 = H2.get(n3, n3 - 1);
            s3 = Math.abs(x2) + Math.abs(z2);
            p3 = x2 / s3;
            q2 = z2 / s3;
            r2 = Math.sqrt(p3 * p3 + q2 * q2);
            p3 = p3 / r2;
            q2 = q2 / r2;
            for (j2 = n3 - 1; j2 < nn; j2++) {
              z2 = H2.get(n3 - 1, j2);
              H2.set(n3 - 1, j2, q2 * z2 + p3 * H2.get(n3, j2));
              H2.set(n3, j2, q2 * H2.get(n3, j2) - p3 * z2);
            }
            for (i3 = 0; i3 <= n3; i3++) {
              z2 = H2.get(i3, n3 - 1);
              H2.set(i3, n3 - 1, q2 * z2 + p3 * H2.get(i3, n3));
              H2.set(i3, n3, q2 * H2.get(i3, n3) - p3 * z2);
            }
            for (i3 = low; i3 <= high; i3++) {
              z2 = V2.get(i3, n3 - 1);
              V2.set(i3, n3 - 1, q2 * z2 + p3 * V2.get(i3, n3));
              V2.set(i3, n3, q2 * V2.get(i3, n3) - p3 * z2);
            }
          } else {
            d2[n3 - 1] = x2 + p3;
            d2[n3] = x2 + p3;
            e2[n3 - 1] = z2;
            e2[n3] = -z2;
          }
          n3 = n3 - 2;
          iter = 0;
        } else {
          x2 = H2.get(n3, n3);
          y3 = 0;
          w2 = 0;
          if (l3 < n3) {
            y3 = H2.get(n3 - 1, n3 - 1);
            w2 = H2.get(n3, n3 - 1) * H2.get(n3 - 1, n3);
          }
          if (iter === 10) {
            exshift += x2;
            for (i3 = low; i3 <= n3; i3++) {
              H2.set(i3, i3, H2.get(i3, i3) - x2);
            }
            s3 = Math.abs(H2.get(n3, n3 - 1)) + Math.abs(H2.get(n3 - 1, n3 - 2));
            x2 = y3 = 0.75 * s3;
            w2 = -0.4375 * s3 * s3;
          }
          if (iter === 30) {
            s3 = (y3 - x2) / 2;
            s3 = s3 * s3 + w2;
            if (s3 > 0) {
              s3 = Math.sqrt(s3);
              if (y3 < x2) {
                s3 = -s3;
              }
              s3 = x2 - w2 / ((y3 - x2) / 2 + s3);
              for (i3 = low; i3 <= n3; i3++) {
                H2.set(i3, i3, H2.get(i3, i3) - s3);
              }
              exshift += s3;
              x2 = y3 = w2 = 0.964;
            }
          }
          iter = iter + 1;
          m4 = n3 - 2;
          while (m4 >= l3) {
            z2 = H2.get(m4, m4);
            r2 = x2 - z2;
            s3 = y3 - z2;
            p3 = (r2 * s3 - w2) / H2.get(m4 + 1, m4) + H2.get(m4, m4 + 1);
            q2 = H2.get(m4 + 1, m4 + 1) - z2 - r2 - s3;
            r2 = H2.get(m4 + 2, m4 + 1);
            s3 = Math.abs(p3) + Math.abs(q2) + Math.abs(r2);
            p3 = p3 / s3;
            q2 = q2 / s3;
            r2 = r2 / s3;
            if (m4 === l3) {
              break;
            }
            if (Math.abs(H2.get(m4, m4 - 1)) * (Math.abs(q2) + Math.abs(r2)) < eps * (Math.abs(p3) * (Math.abs(H2.get(m4 - 1, m4 - 1)) + Math.abs(z2) + Math.abs(H2.get(m4 + 1, m4 + 1))))) {
              break;
            }
            m4--;
          }
          for (i3 = m4 + 2; i3 <= n3; i3++) {
            H2.set(i3, i3 - 2, 0);
            if (i3 > m4 + 2) {
              H2.set(i3, i3 - 3, 0);
            }
          }
          for (k2 = m4; k2 <= n3 - 1; k2++) {
            notlast = k2 !== n3 - 1;
            if (k2 !== m4) {
              p3 = H2.get(k2, k2 - 1);
              q2 = H2.get(k2 + 1, k2 - 1);
              r2 = notlast ? H2.get(k2 + 2, k2 - 1) : 0;
              x2 = Math.abs(p3) + Math.abs(q2) + Math.abs(r2);
              if (x2 !== 0) {
                p3 = p3 / x2;
                q2 = q2 / x2;
                r2 = r2 / x2;
              }
            }
            if (x2 === 0) {
              break;
            }
            s3 = Math.sqrt(p3 * p3 + q2 * q2 + r2 * r2);
            if (p3 < 0) {
              s3 = -s3;
            }
            if (s3 !== 0) {
              if (k2 !== m4) {
                H2.set(k2, k2 - 1, -s3 * x2);
              } else if (l3 !== m4) {
                H2.set(k2, k2 - 1, -H2.get(k2, k2 - 1));
              }
              p3 = p3 + s3;
              x2 = p3 / s3;
              y3 = q2 / s3;
              z2 = r2 / s3;
              q2 = q2 / p3;
              r2 = r2 / p3;
              for (j2 = k2; j2 < nn; j2++) {
                p3 = H2.get(k2, j2) + q2 * H2.get(k2 + 1, j2);
                if (notlast) {
                  p3 = p3 + r2 * H2.get(k2 + 2, j2);
                  H2.set(k2 + 2, j2, H2.get(k2 + 2, j2) - p3 * z2);
                }
                H2.set(k2, j2, H2.get(k2, j2) - p3 * x2);
                H2.set(k2 + 1, j2, H2.get(k2 + 1, j2) - p3 * y3);
              }
              for (i3 = 0; i3 <= Math.min(n3, k2 + 3); i3++) {
                p3 = x2 * H2.get(i3, k2) + y3 * H2.get(i3, k2 + 1);
                if (notlast) {
                  p3 = p3 + z2 * H2.get(i3, k2 + 2);
                  H2.set(i3, k2 + 2, H2.get(i3, k2 + 2) - p3 * r2);
                }
                H2.set(i3, k2, H2.get(i3, k2) - p3);
                H2.set(i3, k2 + 1, H2.get(i3, k2 + 1) - p3 * q2);
              }
              for (i3 = low; i3 <= high; i3++) {
                p3 = x2 * V2.get(i3, k2) + y3 * V2.get(i3, k2 + 1);
                if (notlast) {
                  p3 = p3 + z2 * V2.get(i3, k2 + 2);
                  V2.set(i3, k2 + 2, V2.get(i3, k2 + 2) - p3 * r2);
                }
                V2.set(i3, k2, V2.get(i3, k2) - p3);
                V2.set(i3, k2 + 1, V2.get(i3, k2 + 1) - p3 * q2);
              }
            }
          }
        }
      }
      if (norm === 0) {
        return;
      }
      for (n3 = nn - 1; n3 >= 0; n3--) {
        p3 = d2[n3];
        q2 = e2[n3];
        if (q2 === 0) {
          l3 = n3;
          H2.set(n3, n3, 1);
          for (i3 = n3 - 1; i3 >= 0; i3--) {
            w2 = H2.get(i3, i3) - p3;
            r2 = 0;
            for (j2 = l3; j2 <= n3; j2++) {
              r2 = r2 + H2.get(i3, j2) * H2.get(j2, n3);
            }
            if (e2[i3] < 0) {
              z2 = w2;
              s3 = r2;
            } else {
              l3 = i3;
              if (e2[i3] === 0) {
                H2.set(i3, n3, w2 !== 0 ? -r2 / w2 : -r2 / (eps * norm));
              } else {
                x2 = H2.get(i3, i3 + 1);
                y3 = H2.get(i3 + 1, i3);
                q2 = (d2[i3] - p3) * (d2[i3] - p3) + e2[i3] * e2[i3];
                t3 = (x2 * s3 - z2 * r2) / q2;
                H2.set(i3, n3, t3);
                H2.set(
                  i3 + 1,
                  n3,
                  Math.abs(x2) > Math.abs(z2) ? (-r2 - w2 * t3) / x2 : (-s3 - y3 * t3) / z2
                );
              }
              t3 = Math.abs(H2.get(i3, n3));
              if (eps * t3 * t3 > 1) {
                for (j2 = i3; j2 <= n3; j2++) {
                  H2.set(j2, n3, H2.get(j2, n3) / t3);
                }
              }
            }
          }
        } else if (q2 < 0) {
          l3 = n3 - 1;
          if (Math.abs(H2.get(n3, n3 - 1)) > Math.abs(H2.get(n3 - 1, n3))) {
            H2.set(n3 - 1, n3 - 1, q2 / H2.get(n3, n3 - 1));
            H2.set(n3 - 1, n3, -(H2.get(n3, n3) - p3) / H2.get(n3, n3 - 1));
          } else {
            cdivres = cdiv(0, -H2.get(n3 - 1, n3), H2.get(n3 - 1, n3 - 1) - p3, q2);
            H2.set(n3 - 1, n3 - 1, cdivres[0]);
            H2.set(n3 - 1, n3, cdivres[1]);
          }
          H2.set(n3, n3 - 1, 0);
          H2.set(n3, n3, 1);
          for (i3 = n3 - 2; i3 >= 0; i3--) {
            ra = 0;
            sa = 0;
            for (j2 = l3; j2 <= n3; j2++) {
              ra = ra + H2.get(i3, j2) * H2.get(j2, n3 - 1);
              sa = sa + H2.get(i3, j2) * H2.get(j2, n3);
            }
            w2 = H2.get(i3, i3) - p3;
            if (e2[i3] < 0) {
              z2 = w2;
              r2 = ra;
              s3 = sa;
            } else {
              l3 = i3;
              if (e2[i3] === 0) {
                cdivres = cdiv(-ra, -sa, w2, q2);
                H2.set(i3, n3 - 1, cdivres[0]);
                H2.set(i3, n3, cdivres[1]);
              } else {
                x2 = H2.get(i3, i3 + 1);
                y3 = H2.get(i3 + 1, i3);
                vr = (d2[i3] - p3) * (d2[i3] - p3) + e2[i3] * e2[i3] - q2 * q2;
                vi = (d2[i3] - p3) * 2 * q2;
                if (vr === 0 && vi === 0) {
                  vr = eps * norm * (Math.abs(w2) + Math.abs(q2) + Math.abs(x2) + Math.abs(y3) + Math.abs(z2));
                }
                cdivres = cdiv(
                  x2 * r2 - z2 * ra + q2 * sa,
                  x2 * s3 - z2 * sa - q2 * ra,
                  vr,
                  vi
                );
                H2.set(i3, n3 - 1, cdivres[0]);
                H2.set(i3, n3, cdivres[1]);
                if (Math.abs(x2) > Math.abs(z2) + Math.abs(q2)) {
                  H2.set(
                    i3 + 1,
                    n3 - 1,
                    (-ra - w2 * H2.get(i3, n3 - 1) + q2 * H2.get(i3, n3)) / x2
                  );
                  H2.set(
                    i3 + 1,
                    n3,
                    (-sa - w2 * H2.get(i3, n3) - q2 * H2.get(i3, n3 - 1)) / x2
                  );
                } else {
                  cdivres = cdiv(
                    -r2 - y3 * H2.get(i3, n3 - 1),
                    -s3 - y3 * H2.get(i3, n3),
                    z2,
                    q2
                  );
                  H2.set(i3 + 1, n3 - 1, cdivres[0]);
                  H2.set(i3 + 1, n3, cdivres[1]);
                }
              }
              t3 = Math.max(Math.abs(H2.get(i3, n3 - 1)), Math.abs(H2.get(i3, n3)));
              if (eps * t3 * t3 > 1) {
                for (j2 = i3; j2 <= n3; j2++) {
                  H2.set(j2, n3 - 1, H2.get(j2, n3 - 1) / t3);
                  H2.set(j2, n3, H2.get(j2, n3) / t3);
                }
              }
            }
          }
        }
      }
      for (i3 = 0; i3 < nn; i3++) {
        if (i3 < low || i3 > high) {
          for (j2 = i3; j2 < nn; j2++) {
            V2.set(i3, j2, H2.get(i3, j2));
          }
        }
      }
      for (j2 = nn - 1; j2 >= low; j2--) {
        for (i3 = low; i3 <= high; i3++) {
          z2 = 0;
          for (k2 = low; k2 <= Math.min(j2, high); k2++) {
            z2 = z2 + V2.get(i3, k2) * H2.get(k2, j2);
          }
          V2.set(i3, j2, z2);
        }
      }
    }
    function cdiv(xr, xi, yr, yi) {
      let r2, d2;
      if (Math.abs(yr) > Math.abs(yi)) {
        r2 = yi / yr;
        d2 = yr + r2 * yi;
        return [(xr + r2 * xi) / d2, (xi - r2 * xr) / d2];
      } else {
        r2 = yr / yi;
        d2 = yi + r2 * yr;
        return [(r2 * xr + xi) / d2, (r2 * xi - xr) / d2];
      }
    }
    var CholeskyDecomposition2 = class {
      constructor(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error("Matrix is not symmetric");
        }
        let a3 = value;
        let dimension = a3.rows;
        let l3 = new Matrix5(dimension, dimension);
        let positiveDefinite = true;
        let i3, j2, k2;
        for (j2 = 0; j2 < dimension; j2++) {
          let d2 = 0;
          for (k2 = 0; k2 < j2; k2++) {
            let s3 = 0;
            for (i3 = 0; i3 < k2; i3++) {
              s3 += l3.get(k2, i3) * l3.get(j2, i3);
            }
            s3 = (a3.get(j2, k2) - s3) / l3.get(k2, k2);
            l3.set(j2, k2, s3);
            d2 = d2 + s3 * s3;
          }
          d2 = a3.get(j2, j2) - d2;
          positiveDefinite &= d2 > 0;
          l3.set(j2, j2, Math.sqrt(Math.max(d2, 0)));
          for (k2 = j2 + 1; k2 < dimension; k2++) {
            l3.set(j2, k2, 0);
          }
        }
        this.L = l3;
        this.positiveDefinite = Boolean(positiveDefinite);
      }
      isPositiveDefinite() {
        return this.positiveDefinite;
      }
      solve(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        let l3 = this.L;
        let dimension = l3.rows;
        if (value.rows !== dimension) {
          throw new Error("Matrix dimensions do not match");
        }
        if (this.isPositiveDefinite() === false) {
          throw new Error("Matrix is not positive definite");
        }
        let count = value.columns;
        let B2 = value.clone();
        let i3, j2, k2;
        for (k2 = 0; k2 < dimension; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            for (i3 = 0; i3 < k2; i3++) {
              B2.set(k2, j2, B2.get(k2, j2) - B2.get(i3, j2) * l3.get(k2, i3));
            }
            B2.set(k2, j2, B2.get(k2, j2) / l3.get(k2, k2));
          }
        }
        for (k2 = dimension - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            for (i3 = k2 + 1; i3 < dimension; i3++) {
              B2.set(k2, j2, B2.get(k2, j2) - B2.get(i3, j2) * l3.get(i3, k2));
            }
            B2.set(k2, j2, B2.get(k2, j2) / l3.get(k2, k2));
          }
        }
        return B2;
      }
      get lowerTriangularMatrix() {
        return this.L;
      }
    };
    var nipals = class {
      constructor(X2, options = {}) {
        X2 = WrapperMatrix2D2.checkMatrix(X2);
        let { Y: Y2 } = options;
        const {
          scaleScores = false,
          maxIterations = 1e3,
          terminationCriteria = 1e-10
        } = options;
        let u3;
        if (Y2) {
          if (isAnyArray3.isAnyArray(Y2) && typeof Y2[0] === "number") {
            Y2 = Matrix5.columnVector(Y2);
          } else {
            Y2 = WrapperMatrix2D2.checkMatrix(Y2);
          }
          if (Y2.rows !== X2.rows) {
            throw new Error("Y should have the same number of rows as X");
          }
          u3 = Y2.getColumnVector(0);
        } else {
          u3 = X2.getColumnVector(0);
        }
        let diff = 1;
        let t3, q2, w2, tOld;
        for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
          w2 = X2.transpose().mmul(u3).div(u3.transpose().mmul(u3).get(0, 0));
          w2 = w2.div(w2.norm());
          t3 = X2.mmul(w2).div(w2.transpose().mmul(w2).get(0, 0));
          if (counter > 0) {
            diff = t3.clone().sub(tOld).pow(2).sum();
          }
          tOld = t3.clone();
          if (Y2) {
            q2 = Y2.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
            q2 = q2.div(q2.norm());
            u3 = Y2.mmul(q2).div(q2.transpose().mmul(q2).get(0, 0));
          } else {
            u3 = t3;
          }
        }
        if (Y2) {
          let p3 = X2.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
          p3 = p3.div(p3.norm());
          let xResidual = X2.clone().sub(t3.clone().mmul(p3.transpose()));
          let residual = u3.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
          let yResidual = Y2.clone().sub(
            t3.clone().mulS(residual.get(0, 0)).mmul(q2.transpose())
          );
          this.t = t3;
          this.p = p3.transpose();
          this.w = w2.transpose();
          this.q = q2;
          this.u = u3;
          this.s = t3.transpose().mmul(t3);
          this.xResidual = xResidual;
          this.yResidual = yResidual;
          this.betas = residual;
        } else {
          this.w = w2.transpose();
          this.s = t3.transpose().mmul(t3).sqrt();
          if (scaleScores) {
            this.t = t3.clone().div(this.s.get(0, 0));
          } else {
            this.t = t3;
          }
          this.xResidual = X2.sub(t3.mmul(w2.transpose()));
        }
      }
    };
    exports2.AbstractMatrix = AbstractMatrix2;
    exports2.CHO = CholeskyDecomposition2;
    exports2.CholeskyDecomposition = CholeskyDecomposition2;
    exports2.DistanceMatrix = DistanceMatrix2;
    exports2.EVD = EigenvalueDecomposition2;
    exports2.EigenvalueDecomposition = EigenvalueDecomposition2;
    exports2.LU = LuDecomposition2;
    exports2.LuDecomposition = LuDecomposition2;
    exports2.Matrix = Matrix5;
    exports2.MatrixColumnSelectionView = MatrixColumnSelectionView2;
    exports2.MatrixColumnView = MatrixColumnView2;
    exports2.MatrixFlipColumnView = MatrixFlipColumnView2;
    exports2.MatrixFlipRowView = MatrixFlipRowView2;
    exports2.MatrixRowSelectionView = MatrixRowSelectionView2;
    exports2.MatrixRowView = MatrixRowView2;
    exports2.MatrixSelectionView = MatrixSelectionView2;
    exports2.MatrixSubView = MatrixSubView2;
    exports2.MatrixTransposeView = MatrixTransposeView2;
    exports2.NIPALS = nipals;
    exports2.Nipals = nipals;
    exports2.QR = QrDecomposition2;
    exports2.QrDecomposition = QrDecomposition2;
    exports2.SVD = SingularValueDecomposition3;
    exports2.SingularValueDecomposition = SingularValueDecomposition3;
    exports2.SymmetricMatrix = SymmetricMatrix2;
    exports2.WrapperMatrix1D = WrapperMatrix1D2;
    exports2.WrapperMatrix2D = WrapperMatrix2D2;
    exports2.correlation = correlation2;
    exports2.covariance = covariance2;
    exports2.default = Matrix5;
    exports2.determinant = determinant2;
    exports2.inverse = inverse3;
    exports2.linearDependencies = linearDependencies2;
    exports2.pseudoInverse = pseudoInverse2;
    exports2.solve = solve3;
    exports2.wrap = wrap2;
  }
});

// node_modules/new-array/index.js
var require_new_array = __commonJS({
  "node_modules/new-array/index.js"(exports2, module2) {
    module2.exports = newArray8;
    function newArray8(n3, value) {
      n3 = n3 || 0;
      var array3 = new Array(n3);
      for (var i3 = 0; i3 < n3; i3++) {
        array3[i3] = value;
      }
      return array3;
    }
  }
});

// node_modules/is-array-type/is-array-type.js
var require_is_array_type = __commonJS({
  "node_modules/is-array-type/is-array-type.js"(exports2, module2) {
    "use strict";
    var toString2 = Object.prototype.toString;
    module2.exports = function isArrayType(value) {
      return toString2.call(value).substr(-6, 5) === "Array";
    };
  }
});

// node_modules/ml-distance-euclidean/lib/euclidean.js
var require_euclidean = __commonJS({
  "node_modules/ml-distance-euclidean/lib/euclidean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function squaredEuclidean(p3, q2) {
      let d2 = 0;
      for (let i3 = 0; i3 < p3.length; i3++) {
        d2 += (p3[i3] - q2[i3]) * (p3[i3] - q2[i3]);
      }
      return d2;
    }
    exports2.squaredEuclidean = squaredEuclidean;
    function euclidean(p3, q2) {
      return Math.sqrt(squaredEuclidean(p3, q2));
    }
    exports2.euclidean = euclidean;
  }
});

// node_modules/ml-kernel-gaussian/gaussian-kernel.js
var require_gaussian_kernel = __commonJS({
  "node_modules/ml-kernel-gaussian/gaussian-kernel.js"(exports2, module2) {
    "use strict";
    var { squaredEuclidean } = require_euclidean();
    var defaultOptions5 = {
      sigma: 1
    };
    var GaussianKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.sigma = options.sigma;
        this.divisor = 2 * options.sigma * options.sigma;
      }
      compute(x2, y3) {
        const distance = squaredEuclidean(x2, y3);
        return Math.exp(-distance / this.divisor);
      }
    };
    module2.exports = GaussianKernel;
  }
});

// node_modules/ml-kernel-polynomial/polynomial-kernel.js
var require_polynomial_kernel = __commonJS({
  "node_modules/ml-kernel-polynomial/polynomial-kernel.js"(exports2, module2) {
    "use strict";
    var defaultOptions5 = {
      degree: 1,
      constant: 1,
      scale: 1
    };
    var PolynomialKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.degree = options.degree;
        this.constant = options.constant;
        this.scale = options.scale;
      }
      compute(x2, y3) {
        var sum2 = 0;
        for (var i3 = 0; i3 < x2.length; i3++) {
          sum2 += x2[i3] * y3[i3];
        }
        return Math.pow(this.scale * sum2 + this.constant, this.degree);
      }
    };
    module2.exports = PolynomialKernel;
  }
});

// node_modules/ml-kernel-sigmoid/sigmoid-kernel.js
var require_sigmoid_kernel = __commonJS({
  "node_modules/ml-kernel-sigmoid/sigmoid-kernel.js"(exports2, module2) {
    "use strict";
    var defaultOptions5 = {
      alpha: 0.01,
      constant: -Math.E
    };
    var SigmoidKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.alpha = options.alpha;
        this.constant = options.constant;
      }
      compute(x2, y3) {
        var sum2 = 0;
        for (var i3 = 0; i3 < x2.length; i3++) {
          sum2 += x2[i3] * y3[i3];
        }
        return Math.tanh(this.alpha * sum2 + this.constant);
      }
    };
    module2.exports = SigmoidKernel;
  }
});

// node_modules/ml-kernel/src/kernels/anova-kernel.js
var require_anova_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/anova-kernel.js"(exports2, module2) {
    "use strict";
    var defaultOptions5 = {
      sigma: 1,
      degree: 1
    };
    var ANOVAKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.sigma = options.sigma;
        this.degree = options.degree;
      }
      compute(x2, y3) {
        var sum2 = 0;
        var len = Math.min(x2.length, y3.length);
        for (var i3 = 1; i3 <= len; ++i3) {
          sum2 += Math.pow(
            Math.exp(
              -this.sigma * Math.pow(Math.pow(x2[i3 - 1], i3) - Math.pow(y3[i3 - 1], i3), 2)
            ),
            this.degree
          );
        }
        return sum2;
      }
    };
    module2.exports = ANOVAKernel;
  }
});

// node_modules/ml-kernel/src/kernels/cauchy-kernel.js
var require_cauchy_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/cauchy-kernel.js"(exports2, module2) {
    "use strict";
    var { squaredEuclidean } = require_euclidean();
    var defaultOptions5 = {
      sigma: 1
    };
    var CauchyKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.sigma = options.sigma;
      }
      compute(x2, y3) {
        return 1 / (1 + squaredEuclidean(x2, y3) / (this.sigma * this.sigma));
      }
    };
    module2.exports = CauchyKernel;
  }
});

// node_modules/ml-kernel/src/kernels/exponential-kernel.js
var require_exponential_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/exponential-kernel.js"(exports2, module2) {
    "use strict";
    var { euclidean } = require_euclidean();
    var defaultOptions5 = {
      sigma: 1
    };
    var ExponentialKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.sigma = options.sigma;
        this.divisor = 2 * options.sigma * options.sigma;
      }
      compute(x2, y3) {
        const distance = euclidean(x2, y3);
        return Math.exp(-distance / this.divisor);
      }
    };
    module2.exports = ExponentialKernel;
  }
});

// node_modules/ml-kernel/src/kernels/histogram-intersection-kernel.js
var require_histogram_intersection_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/histogram-intersection-kernel.js"(exports2, module2) {
    "use strict";
    var HistogramIntersectionKernel = class {
      compute(x2, y3) {
        var min3 = Math.min(x2.length, y3.length);
        var sum2 = 0;
        for (var i3 = 0; i3 < min3; ++i3) {
          sum2 += Math.min(x2[i3], y3[i3]);
        }
        return sum2;
      }
    };
    module2.exports = HistogramIntersectionKernel;
  }
});

// node_modules/ml-kernel/src/kernels/laplacian-kernel.js
var require_laplacian_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/laplacian-kernel.js"(exports2, module2) {
    "use strict";
    var { euclidean } = require_euclidean();
    var defaultOptions5 = {
      sigma: 1
    };
    var LaplacianKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.sigma = options.sigma;
      }
      compute(x2, y3) {
        const distance = euclidean(x2, y3);
        return Math.exp(-distance / this.sigma);
      }
    };
    module2.exports = LaplacianKernel;
  }
});

// node_modules/ml-kernel/src/kernels/multiquadratic-kernel.js
var require_multiquadratic_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/multiquadratic-kernel.js"(exports2, module2) {
    "use strict";
    var { squaredEuclidean } = require_euclidean();
    var defaultOptions5 = {
      constant: 1
    };
    var MultiquadraticKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.constant = options.constant;
      }
      compute(x2, y3) {
        return Math.sqrt(squaredEuclidean(x2, y3) + this.constant * this.constant);
      }
    };
    module2.exports = MultiquadraticKernel;
  }
});

// node_modules/ml-kernel/src/kernels/rational-quadratic-kernel.js
var require_rational_quadratic_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/rational-quadratic-kernel.js"(exports2, module2) {
    "use strict";
    var { squaredEuclidean } = require_euclidean();
    var defaultOptions5 = {
      constant: 1
    };
    var RationalQuadraticKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions5, options);
        this.constant = options.constant;
      }
      compute(x2, y3) {
        const distance = squaredEuclidean(x2, y3);
        return 1 - distance / (distance + this.constant);
      }
    };
    module2.exports = RationalQuadraticKernel;
  }
});

// node_modules/ml-kernel/src/kernel.js
var require_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernel.js"(exports2, module2) {
    "use strict";
    var { Matrix: Matrix5, MatrixTransposeView: MatrixTransposeView2 } = require_matrix();
    var GaussianKernel = require_gaussian_kernel();
    var PolynomialKernel = require_polynomial_kernel();
    var SigmoidKernel = require_sigmoid_kernel();
    var ANOVAKernel = require_anova_kernel();
    var CauchyKernel = require_cauchy_kernel();
    var ExponentialKernel = require_exponential_kernel();
    var HistogramKernel = require_histogram_intersection_kernel();
    var LaplacianKernel = require_laplacian_kernel();
    var MultiquadraticKernel = require_multiquadratic_kernel();
    var RationalKernel = require_rational_quadratic_kernel();
    var kernelType = {
      gaussian: GaussianKernel,
      rbf: GaussianKernel,
      polynomial: PolynomialKernel,
      poly: PolynomialKernel,
      anova: ANOVAKernel,
      cauchy: CauchyKernel,
      exponential: ExponentialKernel,
      histogram: HistogramKernel,
      min: HistogramKernel,
      laplacian: LaplacianKernel,
      multiquadratic: MultiquadraticKernel,
      rational: RationalKernel,
      sigmoid: SigmoidKernel,
      mlp: SigmoidKernel
    };
    var Kernel2 = class {
      constructor(type, options) {
        this.kernelType = type;
        if (type === "linear")
          return;
        if (typeof type === "string") {
          type = type.toLowerCase();
          var KernelConstructor = kernelType[type];
          if (KernelConstructor) {
            this.kernelFunction = new KernelConstructor(options);
          } else {
            throw new Error(`unsupported kernel type: ${type}`);
          }
        } else if (typeof type === "object" && typeof type.compute === "function") {
          this.kernelFunction = type;
        } else {
          throw new TypeError(
            "first argument must be a valid kernel type or instance"
          );
        }
      }
      compute(inputs, landmarks) {
        inputs = Matrix5.checkMatrix(inputs);
        if (landmarks === void 0) {
          landmarks = inputs;
        } else {
          landmarks = Matrix5.checkMatrix(landmarks);
        }
        if (this.kernelType === "linear") {
          return inputs.mmul(new MatrixTransposeView2(landmarks));
        }
        const kernelMatrix = new Matrix5(inputs.rows, landmarks.rows);
        if (inputs === landmarks) {
          for (let i3 = 0; i3 < inputs.rows; i3++) {
            for (let j2 = i3; j2 < inputs.rows; j2++) {
              const value = this.kernelFunction.compute(
                inputs.getRow(i3),
                inputs.getRow(j2)
              );
              kernelMatrix.set(i3, j2, value);
              kernelMatrix.set(j2, i3, value);
            }
          }
        } else {
          for (let i3 = 0; i3 < inputs.rows; i3++) {
            for (let j2 = 0; j2 < landmarks.rows; j2++) {
              kernelMatrix.set(
                i3,
                j2,
                this.kernelFunction.compute(inputs.getRow(i3), landmarks.getRow(j2))
              );
            }
          }
        }
        return kernelMatrix;
      }
    };
    module2.exports = Kernel2;
  }
});

// node_modules/fast-list/fast-list.js
var require_fast_list = __commonJS({
  "node_modules/fast-list/fast-list.js"(exports2, module2) {
    (function() {
      function Item(data, prev, next) {
        this.next = next;
        if (next)
          next.prev = this;
        this.prev = prev;
        if (prev)
          prev.next = this;
        this.data = data;
      }
      function FastList() {
        if (!(this instanceof FastList))
          return new FastList();
        this._head = null;
        this._tail = null;
        this.length = 0;
      }
      FastList.prototype = {
        push: function(data) {
          this._tail = new Item(data, this._tail, null);
          if (!this._head)
            this._head = this._tail;
          this.length++;
        },
        pop: function() {
          if (this.length === 0)
            return void 0;
          var t3 = this._tail;
          this._tail = t3.prev;
          if (t3.prev) {
            t3.prev = this._tail.next = null;
          }
          this.length--;
          if (this.length === 1)
            this._head = this._tail;
          else if (this.length === 0)
            this._head = this._tail = null;
          return t3.data;
        },
        unshift: function(data) {
          this._head = new Item(data, null, this._head);
          if (!this._tail)
            this._tail = this._head;
          this.length++;
        },
        shift: function() {
          if (this.length === 0)
            return void 0;
          var h3 = this._head;
          this._head = h3.next;
          if (h3.next) {
            h3.next = this._head.prev = null;
          }
          this.length--;
          if (this.length === 1)
            this._tail = this._head;
          else if (this.length === 0)
            this._head = this._tail = null;
          return h3.data;
        },
        item: function(n3) {
          if (n3 < 0)
            n3 = this.length + n3;
          var h3 = this._head;
          while (n3-- > 0 && h3)
            h3 = h3.next;
          return h3 ? h3.data : void 0;
        },
        slice: function(n3, m4) {
          if (!n3)
            n3 = 0;
          if (!m4)
            m4 = this.length;
          if (m4 < 0)
            m4 = this.length + m4;
          if (n3 < 0)
            n3 = this.length + n3;
          if (m4 === n3) {
            return [];
          }
          if (m4 < n3) {
            throw new Error("invalid offset: " + n3 + "," + m4 + " (length=" + this.length + ")");
          }
          var len = m4 - n3, ret = new Array(len), i3 = 0, h3 = this._head;
          while (n3-- > 0 && h3)
            h3 = h3.next;
          while (i3 < len && h3) {
            ret[i3++] = h3.data;
            h3 = h3.next;
          }
          return ret;
        },
        drop: function() {
          FastList.call(this);
        },
        forEach: function(fn, thisp) {
          var p3 = this._head, i3 = 0, len = this.length;
          while (i3 < len && p3) {
            fn.call(thisp || this, p3.data, i3, this);
            p3 = p3.next;
            i3++;
          }
        },
        map: function(fn, thisp) {
          var n3 = new FastList();
          this.forEach(function(v3, i3, me2) {
            n3.push(fn.call(thisp || me2, v3, i3, me2));
          });
          return n3;
        },
        filter: function(fn, thisp) {
          var n3 = new FastList();
          this.forEach(function(v3, i3, me2) {
            if (fn.call(thisp || me2, v3, i3, me2))
              n3.push(v3);
          });
          return n3;
        },
        reduce: function(fn, val, thisp) {
          var i3 = 0, p3 = this._head, len = this.length;
          if (!val) {
            i3 = 1;
            val = p3 && p3.data;
            p3 = p3 && p3.next;
          }
          while (i3 < len && p3) {
            val = fn.call(thisp || this, val, p3.data, this);
            i3++;
            p3 = p3.next;
          }
          return val;
        }
      };
      if ("undefined" !== typeof exports2)
        module2.exports = FastList;
      else if ("function" === typeof define && define.amd) {
        define("FastList", function() {
          return FastList;
        });
      } else
        (function() {
          return this;
        })().FastList = FastList;
    })();
  }
});

// node_modules/js-quantities/build/quantities.js
var require_quantities = __commonJS({
  "node_modules/js-quantities/build/quantities.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Qty = factory());
    })(exports2, function() {
      "use strict";
      function isString(value) {
        return typeof value === "string" || value instanceof String;
      }
      var isFiniteImpl = Number.isFinite || window.isFinite;
      function isNumber(value) {
        return isFiniteImpl(value);
      }
      function identity(value) {
        return value;
      }
      function uniq(strings2) {
        var seen = {};
        return strings2.filter(function(item) {
          return seen.hasOwnProperty(item) ? false : seen[item] = true;
        });
      }
      function compareArray(array1, array22) {
        if (array22.length !== array1.length) {
          return false;
        }
        for (var i4 = 0; i4 < array1.length; i4++) {
          if (array22[i4].compareArray) {
            if (!array22[i4].compareArray(array1[i4])) {
              return false;
            }
          }
          if (array22[i4] !== array1[i4]) {
            return false;
          }
        }
        return true;
      }
      function assign2(target, properties) {
        Object.keys(properties).forEach(function(key) {
          target[key] = properties[key];
        });
      }
      function mulSafe() {
        var result = 1, decimals = 0;
        for (var i4 = 0; i4 < arguments.length; i4++) {
          var arg = arguments[i4];
          decimals = decimals + getFractional(arg);
          result *= arg;
        }
        return decimals !== 0 ? round2(result, decimals) : result;
      }
      function divSafe(num, den) {
        if (den === 0) {
          throw new Error("Divide by zero");
        }
        var factor = Math.pow(10, getFractional(den));
        var invDen = factor / (factor * den);
        return mulSafe(num, invDen);
      }
      function round2(val, decimals) {
        return Math.round(val * Math.pow(10, decimals)) / Math.pow(10, decimals);
      }
      function getFractional(num) {
        if (!isFinite(num)) {
          return 0;
        }
        var count = 0;
        while (num % 1 !== 0) {
          num *= 10;
          count++;
        }
        return count;
      }
      function QtyError() {
        var err3;
        if (!this) {
          err3 = Object.create(QtyError.prototype);
          QtyError.apply(err3, arguments);
          return err3;
        }
        err3 = Error.apply(this, arguments);
        this.name = "QtyError";
        this.message = err3.message;
        this.stack = err3.stack;
      }
      QtyError.prototype = Object.create(Error.prototype, { constructor: { value: QtyError } });
      function throwIncompatibleUnits(left, right) {
        throw new QtyError("Incompatible units: " + left + " and " + right);
      }
      var UNITS = {
        /* prefixes */
        "<googol>": [["googol"], 1e100, "prefix"],
        "<kibi>": [["Ki", "Kibi", "kibi"], Math.pow(2, 10), "prefix"],
        "<mebi>": [["Mi", "Mebi", "mebi"], Math.pow(2, 20), "prefix"],
        "<gibi>": [["Gi", "Gibi", "gibi"], Math.pow(2, 30), "prefix"],
        "<tebi>": [["Ti", "Tebi", "tebi"], Math.pow(2, 40), "prefix"],
        "<pebi>": [["Pi", "Pebi", "pebi"], Math.pow(2, 50), "prefix"],
        "<exi>": [["Ei", "Exi", "exi"], Math.pow(2, 60), "prefix"],
        "<zebi>": [["Zi", "Zebi", "zebi"], Math.pow(2, 70), "prefix"],
        "<yebi>": [["Yi", "Yebi", "yebi"], Math.pow(2, 80), "prefix"],
        "<yotta>": [["Y", "Yotta", "yotta"], 1e24, "prefix"],
        "<zetta>": [["Z", "Zetta", "zetta"], 1e21, "prefix"],
        "<exa>": [["E", "Exa", "exa"], 1e18, "prefix"],
        "<peta>": [["P", "Peta", "peta"], 1e15, "prefix"],
        "<tera>": [["T", "Tera", "tera"], 1e12, "prefix"],
        "<giga>": [["G", "Giga", "giga"], 1e9, "prefix"],
        "<mega>": [["M", "Mega", "mega"], 1e6, "prefix"],
        "<kilo>": [["k", "kilo"], 1e3, "prefix"],
        "<hecto>": [["h", "Hecto", "hecto"], 100, "prefix"],
        "<deca>": [["da", "Deca", "deca", "deka"], 10, "prefix"],
        "<deci>": [["d", "Deci", "deci"], 0.1, "prefix"],
        "<centi>": [["c", "Centi", "centi"], 0.01, "prefix"],
        "<milli>": [["m", "Milli", "milli"], 1e-3, "prefix"],
        "<micro>": [
          ["u", "\u03BC", "\xB5", "Micro", "mc", "micro"],
          1e-6,
          "prefix"
        ],
        "<nano>": [["n", "Nano", "nano"], 1e-9, "prefix"],
        "<pico>": [["p", "Pico", "pico"], 1e-12, "prefix"],
        "<femto>": [["f", "Femto", "femto"], 1e-15, "prefix"],
        "<atto>": [["a", "Atto", "atto"], 1e-18, "prefix"],
        "<zepto>": [["z", "Zepto", "zepto"], 1e-21, "prefix"],
        "<yocto>": [["y", "Yocto", "yocto"], 1e-24, "prefix"],
        "<1>": [["1", "<1>"], 1, ""],
        /* length units */
        "<meter>": [["m", "meter", "meters", "metre", "metres"], 1, "length", ["<meter>"]],
        "<inch>": [["in", "inch", "inches", '"'], 0.0254, "length", ["<meter>"]],
        "<foot>": [["ft", "foot", "feet", "'"], 0.3048, "length", ["<meter>"]],
        "<yard>": [["yd", "yard", "yards"], 0.9144, "length", ["<meter>"]],
        "<mile>": [["mi", "mile", "miles"], 1609.344, "length", ["<meter>"]],
        "<naut-mile>": [["nmi", "naut-mile"], 1852, "length", ["<meter>"]],
        "<league>": [["league", "leagues"], 4828, "length", ["<meter>"]],
        "<furlong>": [["furlong", "furlongs"], 201.2, "length", ["<meter>"]],
        "<rod>": [["rd", "rod", "rods"], 5.029, "length", ["<meter>"]],
        "<mil>": [["mil", "mils"], 254e-7, "length", ["<meter>"]],
        "<angstrom>": [["ang", "angstrom", "angstroms"], 1e-10, "length", ["<meter>"]],
        "<fathom>": [["fathom", "fathoms"], 1.829, "length", ["<meter>"]],
        "<pica>": [["pica", "picas"], 0.00423333333, "length", ["<meter>"]],
        "<point>": [["pt", "point", "points"], 352777778e-12, "length", ["<meter>"]],
        "<redshift>": [["z", "red-shift", "redshift"], 1302773e20, "length", ["<meter>"]],
        "<AU>": [["AU", "astronomical-unit"], 1495979e5, "length", ["<meter>"]],
        "<light-second>": [["ls", "light-second"], 299792500, "length", ["<meter>"]],
        "<light-minute>": [["lmin", "light-minute"], 1798755e4, "length", ["<meter>"]],
        "<light-year>": [["ly", "light-year"], 9460528e9, "length", ["<meter>"]],
        "<parsec>": [["pc", "parsec", "parsecs"], 3085678e10, "length", ["<meter>"]],
        "<datamile>": [["DM", "datamile"], 1828.8, "length", ["<meter>"]],
        /* mass */
        "<kilogram>": [["kg", "kilogram", "kilograms"], 1, "mass", ["<kilogram>"]],
        "<AMU>": [["u", "AMU", "amu"], 1660538921e-36, "mass", ["<kilogram>"]],
        "<dalton>": [["Da", "Dalton", "Daltons", "dalton", "daltons"], 1660538921e-36, "mass", ["<kilogram>"]],
        "<slug>": [["slug", "slugs"], 14.5939029, "mass", ["<kilogram>"]],
        "<short-ton>": [["tn", "ton", "short-ton"], 907.18474, "mass", ["<kilogram>"]],
        "<metric-ton>": [["t", "tonne", "metric-ton"], 1e3, "mass", ["<kilogram>"]],
        "<carat>": [["ct", "carat", "carats"], 2e-4, "mass", ["<kilogram>"]],
        "<pound>": [["lbs", "lb", "pound", "pounds", "#"], 0.45359237, "mass", ["<kilogram>"]],
        "<ounce>": [["oz", "ounce", "ounces"], 0.0283495231, "mass", ["<kilogram>"]],
        "<gram>": [["g", "gram", "grams", "gramme", "grammes"], 1e-3, "mass", ["<kilogram>"]],
        "<grain>": [["grain", "grains", "gr"], 6479891e-11, "mass", ["<kilogram>"]],
        "<dram>": [["dram", "drams", "dr"], 0.0017718452, "mass", ["<kilogram>"]],
        "<stone>": [["stone", "stones", "st"], 6.35029318, "mass", ["<kilogram>"]],
        /* area */
        "<hectare>": [["hectare"], 1e4, "area", ["<meter>", "<meter>"]],
        "<acre>": [["acre", "acres"], 4046.85642, "area", ["<meter>", "<meter>"]],
        "<sqft>": [["sqft"], 1, "area", ["<foot>", "<foot>"]],
        /* volume */
        "<liter>": [["l", "L", "liter", "liters", "litre", "litres"], 1e-3, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<gallon>": [["gal", "gallon", "gallons"], 0.0037854118, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<gallon-imp>": [["galimp", "gallon-imp", "gallons-imp"], 454609e-8, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<quart>": [["qt", "quart", "quarts"], 94635295e-11, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<pint>": [["pt", "pint", "pints"], 473176475e-12, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<pint-imp>": [["ptimp", "pint-imp", "pints-imp"], 56826125e-11, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<cup>": [["cu", "cup", "cups"], 236588238e-12, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<fluid-ounce>": [["floz", "fluid-ounce", "fluid-ounces"], 295735297e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<fluid-ounce-imp>": [["flozimp", "floz-imp", "fluid-ounce-imp", "fluid-ounces-imp"], 284130625e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<tablespoon>": [["tb", "tbsp", "tbs", "tablespoon", "tablespoons"], 147867648e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<teaspoon>": [["tsp", "teaspoon", "teaspoons"], 492892161e-14, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<bushel>": [["bu", "bsh", "bushel", "bushels"], 0.035239072, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<oilbarrel>": [["bbl", "oilbarrel", "oilbarrels", "oil-barrel", "oil-barrels"], 0.158987294928, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<beerbarrel>": [["bl", "bl-us", "beerbarrel", "beerbarrels", "beer-barrel", "beer-barrels"], 0.1173477658, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<beerbarrel-imp>": [["blimp", "bl-imp", "beerbarrel-imp", "beerbarrels-imp", "beer-barrel-imp", "beer-barrels-imp"], 0.16365924, "volume", ["<meter>", "<meter>", "<meter>"]],
        /* speed */
        "<kph>": [["kph"], 0.277777778, "speed", ["<meter>"], ["<second>"]],
        "<mph>": [["mph"], 0.44704, "speed", ["<meter>"], ["<second>"]],
        "<knot>": [["kt", "kn", "kts", "knot", "knots"], 0.514444444, "speed", ["<meter>"], ["<second>"]],
        "<fps>": [["fps"], 0.3048, "speed", ["<meter>"], ["<second>"]],
        /* acceleration */
        "<gee>": [["gee"], 9.80665, "acceleration", ["<meter>"], ["<second>", "<second>"]],
        "<Gal>": [["Gal"], 0.01, "acceleration", ["<meter>"], ["<second>", "<second>"]],
        /* temperature_difference */
        "<kelvin>": [["degK", "kelvin"], 1, "temperature", ["<kelvin>"]],
        "<celsius>": [["degC", "celsius", "celsius", "centigrade"], 1, "temperature", ["<kelvin>"]],
        "<fahrenheit>": [["degF", "fahrenheit"], 5 / 9, "temperature", ["<kelvin>"]],
        "<rankine>": [["degR", "rankine"], 5 / 9, "temperature", ["<kelvin>"]],
        "<temp-K>": [["tempK", "temp-K"], 1, "temperature", ["<temp-K>"]],
        "<temp-C>": [["tempC", "temp-C"], 1, "temperature", ["<temp-K>"]],
        "<temp-F>": [["tempF", "temp-F"], 5 / 9, "temperature", ["<temp-K>"]],
        "<temp-R>": [["tempR", "temp-R"], 5 / 9, "temperature", ["<temp-K>"]],
        /* time */
        "<second>": [["s", "sec", "secs", "second", "seconds"], 1, "time", ["<second>"]],
        "<minute>": [["min", "mins", "minute", "minutes"], 60, "time", ["<second>"]],
        "<hour>": [["h", "hr", "hrs", "hour", "hours"], 3600, "time", ["<second>"]],
        "<day>": [["d", "day", "days"], 3600 * 24, "time", ["<second>"]],
        "<week>": [["wk", "week", "weeks"], 7 * 3600 * 24, "time", ["<second>"]],
        "<fortnight>": [["fortnight", "fortnights"], 1209600, "time", ["<second>"]],
        "<year>": [["y", "yr", "year", "years", "annum"], 31556926, "time", ["<second>"]],
        "<decade>": [["decade", "decades"], 315569260, "time", ["<second>"]],
        "<century>": [["century", "centuries"], 3155692600, "time", ["<second>"]],
        /* pressure */
        "<pascal>": [["Pa", "pascal", "Pascal"], 1, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<bar>": [["bar", "bars"], 1e5, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<mmHg>": [["mmHg"], 133.322368, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<inHg>": [["inHg"], 3386.3881472, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<torr>": [["torr"], 133.322368, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<atm>": [["atm", "ATM", "atmosphere", "atmospheres"], 101325, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<psi>": [["psi"], 6894.76, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<cmh2o>": [["cmH2O", "cmh2o"], 98.0638, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<inh2o>": [["inH2O", "inh2o"], 249.082052, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        /* viscosity */
        "<poise>": [["P", "poise"], 0.1, "viscosity", ["<kilogram>"], ["<meter>", "<second>"]],
        "<stokes>": [["St", "stokes"], 1e-4, "viscosity", ["<meter>", "<meter>"], ["<second>"]],
        /* substance */
        "<mole>": [["mol", "mole"], 1, "substance", ["<mole>"]],
        /* molar_concentration */
        "<molar>": [["M", "molar"], 1e3, "molar_concentration", ["<mole>"], ["<meter>", "<meter>", "<meter>"]],
        "<wtpercent>": [["wt%", "wtpercent"], 10, "molar_concentration", ["<kilogram>"], ["<meter>", "<meter>", "<meter>"]],
        /* activity */
        "<katal>": [["kat", "katal", "Katal"], 1, "activity", ["<mole>"], ["<second>"]],
        "<unit>": [["U", "enzUnit", "unit"], 16667e-19, "activity", ["<mole>"], ["<second>"]],
        /* capacitance */
        "<farad>": [["F", "farad", "Farad"], 1, "capacitance", ["<second>", "<second>", "<second>", "<second>", "<ampere>", "<ampere>"], ["<meter>", "<meter>", "<kilogram>"]],
        /* charge */
        "<coulomb>": [["C", "coulomb", "Coulomb"], 1, "charge", ["<ampere>", "<second>"]],
        "<Ah>": [["Ah"], 3600, "charge", ["<ampere>", "<second>"]],
        /* current */
        "<ampere>": [["A", "Ampere", "ampere", "amp", "amps"], 1, "current", ["<ampere>"]],
        /* conductance */
        "<siemens>": [["S", "Siemens", "siemens"], 1, "conductance", ["<second>", "<second>", "<second>", "<ampere>", "<ampere>"], ["<kilogram>", "<meter>", "<meter>"]],
        /* inductance */
        "<henry>": [["H", "Henry", "henry"], 1, "inductance", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>", "<ampere>"]],
        /* potential */
        "<volt>": [["V", "Volt", "volt", "volts"], 1, "potential", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<second>", "<ampere>"]],
        /* resistance */
        "<ohm>": [
          [
            "Ohm",
            "ohm",
            "\u03A9",
            "\u2126"
            /*Ω as ohm sign*/
          ],
          1,
          "resistance",
          ["<meter>", "<meter>", "<kilogram>"],
          ["<second>", "<second>", "<second>", "<ampere>", "<ampere>"]
        ],
        /* magnetism */
        "<weber>": [["Wb", "weber", "webers"], 1, "magnetism", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<tesla>": [["T", "tesla", "teslas"], 1, "magnetism", ["<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<gauss>": [["G", "gauss"], 1e-4, "magnetism", ["<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<maxwell>": [["Mx", "maxwell", "maxwells"], 1e-8, "magnetism", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<oersted>": [["Oe", "oersted", "oersteds"], 250 / Math.PI, "magnetism", ["<ampere>"], ["<meter>"]],
        /* energy */
        "<joule>": [["J", "joule", "Joule", "joules", "Joules"], 1, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<erg>": [["erg", "ergs"], 1e-7, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<btu>": [["BTU", "btu", "BTUs"], 1055.056, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<calorie>": [["cal", "calorie", "calories"], 4.184, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<Calorie>": [["Cal", "Calorie", "Calories"], 4184, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<therm-US>": [["th", "therm", "therms", "Therm", "therm-US"], 105480400, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<Wh>": [["Wh"], 3600, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<electronvolt>": [["eV", "electronvolt", "electronvolts"], 1602176634e-28, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        /* force */
        "<newton>": [["N", "Newton", "newton"], 1, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        "<dyne>": [["dyn", "dyne"], 1e-5, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        "<pound-force>": [["lbf", "pound-force"], 4.448222, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        /* frequency */
        "<hertz>": [["Hz", "hertz", "Hertz"], 1, "frequency", ["<1>"], ["<second>"]],
        /* angle */
        "<radian>": [["rad", "radian", "radians"], 1, "angle", ["<radian>"]],
        "<degree>": [["deg", "degree", "degrees"], Math.PI / 180, "angle", ["<radian>"]],
        "<arcminute>": [["arcmin", "arcminute", "arcminutes"], Math.PI / 10800, "angle", ["<radian>"]],
        "<arcsecond>": [["arcsec", "arcsecond", "arcseconds"], Math.PI / 648e3, "angle", ["<radian>"]],
        "<gradian>": [["gon", "grad", "gradian", "grads"], Math.PI / 200, "angle", ["<radian>"]],
        "<steradian>": [["sr", "steradian", "steradians"], 1, "solid_angle", ["<steradian>"]],
        /* rotation */
        "<rotation>": [["rotation"], 2 * Math.PI, "angle", ["<radian>"]],
        "<rpm>": [["rpm"], 2 * Math.PI / 60, "angular_velocity", ["<radian>"], ["<second>"]],
        /* information */
        "<byte>": [["B", "byte", "bytes"], 1, "information", ["<byte>"]],
        "<bit>": [["b", "bit", "bits"], 0.125, "information", ["<byte>"]],
        /* information rate */
        "<Bps>": [["Bps"], 1, "information_rate", ["<byte>"], ["<second>"]],
        "<bps>": [["bps"], 0.125, "information_rate", ["<byte>"], ["<second>"]],
        /* currency */
        "<dollar>": [["USD", "dollar"], 1, "currency", ["<dollar>"]],
        "<cents>": [["cents"], 0.01, "currency", ["<dollar>"]],
        /* luminosity */
        "<candela>": [["cd", "candela"], 1, "luminosity", ["<candela>"]],
        "<lumen>": [["lm", "lumen"], 1, "luminous_power", ["<candela>", "<steradian>"]],
        "<lux>": [["lux"], 1, "illuminance", ["<candela>", "<steradian>"], ["<meter>", "<meter>"]],
        /* power */
        "<watt>": [["W", "watt", "watts"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<volt-ampere>": [["VA", "volt-ampere"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<volt-ampere-reactive>": [["var", "Var", "VAr", "VAR", "volt-ampere-reactive"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<horsepower>": [["hp", "horsepower"], 745.699872, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        /* radiation */
        "<gray>": [["Gy", "gray", "grays"], 1, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<roentgen>": [["R", "roentgen"], 933e-5, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<sievert>": [["Sv", "sievert", "sieverts"], 1, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<becquerel>": [["Bq", "becquerel", "becquerels"], 1, "radiation", ["<1>"], ["<second>"]],
        "<curie>": [["Ci", "curie", "curies"], 37e9, "radiation", ["<1>"], ["<second>"]],
        /* rate */
        "<cpm>": [["cpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        "<dpm>": [["dpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        "<bpm>": [["bpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        /* resolution / typography */
        "<dot>": [["dot", "dots"], 1, "resolution", ["<each>"]],
        "<pixel>": [["pixel", "px"], 1, "resolution", ["<each>"]],
        "<ppi>": [["ppi"], 1, "resolution", ["<pixel>"], ["<inch>"]],
        "<dpi>": [["dpi"], 1, "typography", ["<dot>"], ["<inch>"]],
        /* other */
        "<cell>": [["cells", "cell"], 1, "counting", ["<each>"]],
        "<each>": [["each"], 1, "counting", ["<each>"]],
        "<count>": [["count"], 1, "counting", ["<each>"]],
        "<base-pair>": [["bp", "base-pair"], 1, "counting", ["<each>"]],
        "<nucleotide>": [["nt", "nucleotide"], 1, "counting", ["<each>"]],
        "<molecule>": [["molecule", "molecules"], 1, "counting", ["<1>"]],
        "<dozen>": [["doz", "dz", "dozen"], 12, "prefix_only", ["<each>"]],
        "<percent>": [["%", "percent"], 0.01, "prefix_only", ["<1>"]],
        "<ppm>": [["ppm"], 1e-6, "prefix_only", ["<1>"]],
        "<ppb>": [["ppb"], 1e-9, "prefix_only", ["<1>"]],
        "<ppt>": [["ppt"], 1e-12, "prefix_only", ["<1>"]],
        "<ppq>": [["ppq"], 1e-15, "prefix_only", ["<1>"]],
        "<gross>": [["gr", "gross"], 144, "prefix_only", ["<dozen>", "<dozen>"]],
        "<decibel>": [["dB", "decibel", "decibels"], 1, "logarithmic", ["<decibel>"]]
      };
      var BASE_UNITS = ["<meter>", "<kilogram>", "<second>", "<mole>", "<ampere>", "<radian>", "<kelvin>", "<temp-K>", "<byte>", "<dollar>", "<candela>", "<each>", "<steradian>", "<decibel>"];
      var UNITY = "<1>";
      var UNITY_ARRAY = [UNITY];
      function validateUnitDefinition(unitDef2, definition2) {
        var scalar = definition2[1];
        var numerator = definition2[3] || [];
        var denominator = definition2[4] || [];
        if (!isNumber(scalar)) {
          throw new QtyError(unitDef2 + ": Invalid unit definition. 'scalar' must be a number");
        }
        numerator.forEach(function(unit) {
          if (UNITS[unit] === void 0) {
            throw new QtyError(unitDef2 + ": Invalid unit definition. Unit " + unit + " in 'numerator' is not recognized");
          }
        });
        denominator.forEach(function(unit) {
          if (UNITS[unit] === void 0) {
            throw new QtyError(unitDef2 + ": Invalid unit definition. Unit " + unit + " in 'denominator' is not recognized");
          }
        });
      }
      var PREFIX_VALUES = {};
      var PREFIX_MAP = {};
      var UNIT_VALUES = {};
      var UNIT_MAP = {};
      var OUTPUT_MAP = {};
      for (var unitDef in UNITS) {
        if (UNITS.hasOwnProperty(unitDef)) {
          var definition = UNITS[unitDef];
          if (definition[2] === "prefix") {
            PREFIX_VALUES[unitDef] = definition[1];
            for (var i3 = 0; i3 < definition[0].length; i3++) {
              PREFIX_MAP[definition[0][i3]] = unitDef;
            }
          } else {
            validateUnitDefinition(unitDef, definition);
            UNIT_VALUES[unitDef] = {
              scalar: definition[1],
              numerator: definition[3],
              denominator: definition[4]
            };
            for (var j2 = 0; j2 < definition[0].length; j2++) {
              UNIT_MAP[definition[0][j2]] = unitDef;
            }
          }
          OUTPUT_MAP[unitDef] = definition[0][0];
        }
      }
      function getUnits(kind) {
        var i4;
        var units = [];
        var unitKeys = Object.keys(UNITS);
        if (typeof kind === "undefined") {
          for (i4 = 0; i4 < unitKeys.length; i4++) {
            if (["", "prefix"].indexOf(UNITS[unitKeys[i4]][2]) === -1) {
              units.push(unitKeys[i4].substr(1, unitKeys[i4].length - 2));
            }
          }
        } else if (this.getKinds().indexOf(kind) === -1) {
          throw new QtyError("Kind not recognized");
        } else {
          for (i4 = 0; i4 < unitKeys.length; i4++) {
            if (UNITS[unitKeys[i4]][2] === kind) {
              units.push(unitKeys[i4].substr(1, unitKeys[i4].length - 2));
            }
          }
        }
        return units.sort(function(a3, b2) {
          if (a3.toLowerCase() < b2.toLowerCase()) {
            return -1;
          }
          if (a3.toLowerCase() > b2.toLowerCase()) {
            return 1;
          }
          return 0;
        });
      }
      function getAliases(unitName) {
        if (!UNIT_MAP[unitName]) {
          throw new QtyError("Unit not recognized");
        }
        return UNITS[UNIT_MAP[unitName]][0];
      }
      var SIGNATURE_VECTOR = ["length", "time", "temperature", "mass", "current", "substance", "luminosity", "currency", "information", "angle"];
      function unitSignature() {
        if (this.signature) {
          return this.signature;
        }
        var vector = unitSignatureVector.call(this);
        for (var i4 = 0; i4 < vector.length; i4++) {
          vector[i4] *= Math.pow(20, i4);
        }
        return vector.reduce(
          function(previous, current) {
            return previous + current;
          },
          0
        );
      }
      function unitSignatureVector() {
        if (!this.isBase()) {
          return unitSignatureVector.call(this.toBase());
        }
        var vector = new Array(SIGNATURE_VECTOR.length);
        for (var i4 = 0; i4 < vector.length; i4++) {
          vector[i4] = 0;
        }
        var r2, n3;
        for (var j3 = 0; j3 < this.numerator.length; j3++) {
          if (r2 = UNITS[this.numerator[j3]]) {
            n3 = SIGNATURE_VECTOR.indexOf(r2[2]);
            if (n3 >= 0) {
              vector[n3] = vector[n3] + 1;
            }
          }
        }
        for (var k2 = 0; k2 < this.denominator.length; k2++) {
          if (r2 = UNITS[this.denominator[k2]]) {
            n3 = SIGNATURE_VECTOR.indexOf(r2[2]);
            if (n3 >= 0) {
              vector[n3] = vector[n3] - 1;
            }
          }
        }
        return vector;
      }
      var SIGN = "[+-]";
      var INTEGER = "\\d+";
      var SIGNED_INTEGER = SIGN + "?" + INTEGER;
      var FRACTION = "\\." + INTEGER;
      var FLOAT = "(?:" + INTEGER + "(?:" + FRACTION + ")?)|(?:" + FRACTION + ")";
      var EXPONENT = "[Ee]" + SIGNED_INTEGER;
      var SCI_NUMBER = "(?:" + FLOAT + ")(?:" + EXPONENT + ")?";
      var SIGNED_NUMBER = SIGN + "?\\s*" + SCI_NUMBER;
      var QTY_STRING = "(" + SIGNED_NUMBER + ")?\\s*([^/]*)(?:/(.+))?";
      var QTY_STRING_REGEX = new RegExp("^" + QTY_STRING + "$");
      var POWER_OP = "\\^|\\*{2}";
      var SAFE_POWER = "[01234]";
      var TOP_REGEX = new RegExp("([^ \\*\\d]+?)(?:" + POWER_OP + ")?(-?" + SAFE_POWER + "(?![a-zA-Z]))");
      var BOTTOM_REGEX = new RegExp("([^ \\*\\d]+?)(?:" + POWER_OP + ")?(" + SAFE_POWER + "(?![a-zA-Z]))");
      function parse2(val) {
        if (!isString(val)) {
          val = val.toString();
        }
        val = val.trim();
        var result = QTY_STRING_REGEX.exec(val);
        if (!result) {
          throw new QtyError(val + ": Quantity not recognized");
        }
        var scalarMatch = result[1];
        if (scalarMatch) {
          scalarMatch = scalarMatch.replace(/\s/g, "");
          this.scalar = parseFloat(scalarMatch);
        } else {
          this.scalar = 1;
        }
        var top = result[2];
        var bottom = result[3];
        var n3, x2, nx;
        while (result = TOP_REGEX.exec(top)) {
          n3 = parseFloat(result[2]);
          if (isNaN(n3)) {
            throw new QtyError("Unit exponent is not a number");
          }
          if (n3 === 0 && !UNIT_TEST_REGEX.test(result[1])) {
            throw new QtyError("Unit not recognized");
          }
          x2 = result[1] + " ";
          nx = "";
          for (var i4 = 0; i4 < Math.abs(n3); i4++) {
            nx += x2;
          }
          if (n3 >= 0) {
            top = top.replace(result[0], nx);
          } else {
            bottom = bottom ? bottom + nx : nx;
            top = top.replace(result[0], "");
          }
        }
        while (result = BOTTOM_REGEX.exec(bottom)) {
          n3 = parseFloat(result[2]);
          if (isNaN(n3)) {
            throw new QtyError("Unit exponent is not a number");
          }
          if (n3 === 0 && !UNIT_TEST_REGEX.test(result[1])) {
            throw new QtyError("Unit not recognized");
          }
          x2 = result[1] + " ";
          nx = "";
          for (var j3 = 0; j3 < n3; j3++) {
            nx += x2;
          }
          bottom = bottom.replace(result[0], nx);
        }
        if (top) {
          this.numerator = parseUnits(top.trim());
        }
        if (bottom) {
          this.denominator = parseUnits(bottom.trim());
        }
      }
      var PREFIX_REGEX = Object.keys(PREFIX_MAP).sort(function(a3, b2) {
        return b2.length - a3.length;
      }).join("|");
      var UNIT_REGEX = Object.keys(UNIT_MAP).sort(function(a3, b2) {
        return b2.length - a3.length;
      }).join("|");
      var BOUNDARY_REGEX = "\\b|$";
      var UNIT_MATCH = "(" + PREFIX_REGEX + ")??(" + UNIT_REGEX + ")(?:" + BOUNDARY_REGEX + ")";
      var UNIT_TEST_REGEX = new RegExp("^\\s*(" + UNIT_MATCH + "[\\s\\*]*)+$");
      var UNIT_MATCH_REGEX = new RegExp(UNIT_MATCH, "g");
      var parsedUnitsCache = {};
      function parseUnits(units) {
        var cached = parsedUnitsCache[units];
        if (cached) {
          return cached;
        }
        var unitMatch, normalizedUnits = [];
        if (!UNIT_TEST_REGEX.test(units)) {
          throw new QtyError("Unit not recognized");
        }
        while (unitMatch = UNIT_MATCH_REGEX.exec(units)) {
          normalizedUnits.push(unitMatch.slice(1));
        }
        normalizedUnits = normalizedUnits.map(function(item) {
          return PREFIX_MAP[item[0]] ? [PREFIX_MAP[item[0]], UNIT_MAP[item[1]]] : [UNIT_MAP[item[1]]];
        });
        normalizedUnits = normalizedUnits.reduce(function(a3, b2) {
          return a3.concat(b2);
        }, []);
        normalizedUnits = normalizedUnits.filter(function(item) {
          return item;
        });
        parsedUnitsCache[units] = normalizedUnits;
        return normalizedUnits;
      }
      function globalParse(value) {
        if (!isString(value)) {
          throw new QtyError("Argument should be a string");
        }
        try {
          return this(value);
        } catch (e2) {
          return null;
        }
      }
      function isQty(value) {
        return value instanceof Qty2;
      }
      function Qty2(initValue, initUnits) {
        assertValidConstructorArgs.apply(null, arguments);
        if (!isQty(this)) {
          return new Qty2(initValue, initUnits);
        }
        this.scalar = null;
        this.baseScalar = null;
        this.signature = null;
        this._conversionCache = {};
        this.numerator = UNITY_ARRAY;
        this.denominator = UNITY_ARRAY;
        if (isDefinitionObject(initValue)) {
          this.scalar = initValue.scalar;
          this.numerator = initValue.numerator && initValue.numerator.length !== 0 ? initValue.numerator : UNITY_ARRAY;
          this.denominator = initValue.denominator && initValue.denominator.length !== 0 ? initValue.denominator : UNITY_ARRAY;
        } else if (initUnits) {
          parse2.call(this, initUnits);
          this.scalar = initValue;
        } else {
          parse2.call(this, initValue);
        }
        if (this.denominator.join("*").indexOf("temp") >= 0) {
          throw new QtyError("Cannot divide with temperatures");
        }
        if (this.numerator.join("*").indexOf("temp") >= 0) {
          if (this.numerator.length > 1) {
            throw new QtyError("Cannot multiply by temperatures");
          }
          if (!compareArray(this.denominator, UNITY_ARRAY)) {
            throw new QtyError("Cannot divide with temperatures");
          }
        }
        this.initValue = initValue;
        updateBaseScalar.call(this);
        if (this.isTemperature() && this.baseScalar < 0) {
          throw new QtyError("Temperatures must not be less than absolute zero");
        }
      }
      Qty2.prototype = {
        // Properly set up constructor
        constructor: Qty2
      };
      function assertValidConstructorArgs(value, units) {
        if (units) {
          if (!(isNumber(value) && isString(units))) {
            throw new QtyError("Only number accepted as initialization value when units are explicitly provided");
          }
        } else {
          if (!(isString(value) || isNumber(value) || isQty(value) || isDefinitionObject(value))) {
            throw new QtyError("Only string, number or quantity accepted as single initialization value");
          }
        }
      }
      function isDefinitionObject(value) {
        return value && typeof value === "object" && value.hasOwnProperty("scalar");
      }
      function updateBaseScalar() {
        if (this.baseScalar) {
          return this.baseScalar;
        }
        if (this.isBase()) {
          this.baseScalar = this.scalar;
          this.signature = unitSignature.call(this);
        } else {
          var base = this.toBase();
          this.baseScalar = base.scalar;
          this.signature = base.signature;
        }
      }
      var KINDS = {
        "-312078": "elastance",
        "-312058": "resistance",
        "-312038": "inductance",
        "-152058": "potential",
        "-152040": "magnetism",
        "-152038": "magnetism",
        "-7997": "specific_volume",
        "-79": "snap",
        "-59": "jolt",
        "-39": "acceleration",
        "-38": "radiation",
        "-20": "frequency",
        "-19": "speed",
        "-18": "viscosity",
        "-17": "volumetric_flow",
        "-1": "wavenumber",
        "0": "unitless",
        "1": "length",
        "2": "area",
        "3": "volume",
        "20": "time",
        "400": "temperature",
        "7941": "yank",
        "7942": "power",
        "7959": "pressure",
        "7961": "force",
        "7962": "energy",
        "7979": "viscosity",
        "7981": "momentum",
        "7982": "angular_momentum",
        "7997": "density",
        "7998": "area_density",
        "8000": "mass",
        "152020": "radiation_exposure",
        "159999": "magnetism",
        "160000": "current",
        "160020": "charge",
        "312058": "conductance",
        "312078": "capacitance",
        "3199980": "activity",
        "3199997": "molar_concentration",
        "3200000": "substance",
        "63999998": "illuminance",
        "64000000": "luminous_power",
        "1280000000": "currency",
        "25599999980": "information_rate",
        "25600000000": "information",
        "511999999980": "angular_velocity",
        "512000000000": "angle"
      };
      function getKinds() {
        return uniq(Object.keys(KINDS).map(function(knownSignature) {
          return KINDS[knownSignature];
        }));
      }
      Qty2.prototype.kind = function() {
        return KINDS[this.signature.toString()];
      };
      assign2(Qty2.prototype, {
        isDegrees: function() {
          return (this.signature === null || this.signature === 400) && this.numerator.length === 1 && compareArray(this.denominator, UNITY_ARRAY) && (this.numerator[0].match(/<temp-[CFRK]>/) || this.numerator[0].match(/<(kelvin|celsius|rankine|fahrenheit)>/));
        },
        isTemperature: function() {
          return this.isDegrees() && this.numerator[0].match(/<temp-[CFRK]>/);
        }
      });
      function subtractTemperatures(lhs, rhs) {
        var lhsUnits = lhs.units();
        var rhsConverted = rhs.to(lhsUnits);
        var dstDegrees = Qty2(getDegreeUnits(lhsUnits));
        return Qty2({ "scalar": lhs.scalar - rhsConverted.scalar, "numerator": dstDegrees.numerator, "denominator": dstDegrees.denominator });
      }
      function subtractTempDegrees(temp, deg) {
        var tempDegrees = deg.to(getDegreeUnits(temp.units()));
        return Qty2({ "scalar": temp.scalar - tempDegrees.scalar, "numerator": temp.numerator, "denominator": temp.denominator });
      }
      function addTempDegrees(temp, deg) {
        var tempDegrees = deg.to(getDegreeUnits(temp.units()));
        return Qty2({ "scalar": temp.scalar + tempDegrees.scalar, "numerator": temp.numerator, "denominator": temp.denominator });
      }
      function getDegreeUnits(units) {
        if (units === "tempK") {
          return "degK";
        } else if (units === "tempC") {
          return "degC";
        } else if (units === "tempF") {
          return "degF";
        } else if (units === "tempR") {
          return "degR";
        } else {
          throw new QtyError("Unknown type for temp conversion from: " + units);
        }
      }
      function toDegrees(src, dst) {
        var srcDegK = toDegK(src);
        var dstUnits = dst.units();
        var dstScalar;
        if (dstUnits === "degK") {
          dstScalar = srcDegK.scalar;
        } else if (dstUnits === "degC") {
          dstScalar = srcDegK.scalar;
        } else if (dstUnits === "degF") {
          dstScalar = srcDegK.scalar * 9 / 5;
        } else if (dstUnits === "degR") {
          dstScalar = srcDegK.scalar * 9 / 5;
        } else {
          throw new QtyError("Unknown type for degree conversion to: " + dstUnits);
        }
        return Qty2({ "scalar": dstScalar, "numerator": dst.numerator, "denominator": dst.denominator });
      }
      function toDegK(qty) {
        var units = qty.units();
        var q2;
        if (units.match(/(deg)[CFRK]/)) {
          q2 = qty.baseScalar;
        } else if (units === "tempK") {
          q2 = qty.scalar;
        } else if (units === "tempC") {
          q2 = qty.scalar;
        } else if (units === "tempF") {
          q2 = qty.scalar * 5 / 9;
        } else if (units === "tempR") {
          q2 = qty.scalar * 5 / 9;
        } else {
          throw new QtyError("Unknown type for temp conversion from: " + units);
        }
        return Qty2({ "scalar": q2, "numerator": ["<kelvin>"], "denominator": UNITY_ARRAY });
      }
      function toTemp(src, dst) {
        var dstUnits = dst.units();
        var dstScalar;
        if (dstUnits === "tempK") {
          dstScalar = src.baseScalar;
        } else if (dstUnits === "tempC") {
          dstScalar = src.baseScalar - 273.15;
        } else if (dstUnits === "tempF") {
          dstScalar = src.baseScalar * 9 / 5 - 459.67;
        } else if (dstUnits === "tempR") {
          dstScalar = src.baseScalar * 9 / 5;
        } else {
          throw new QtyError("Unknown type for temp conversion to: " + dstUnits);
        }
        return Qty2({ "scalar": dstScalar, "numerator": dst.numerator, "denominator": dst.denominator });
      }
      function toTempK(qty) {
        var units = qty.units();
        var q2;
        if (units.match(/(deg)[CFRK]/)) {
          q2 = qty.baseScalar;
        } else if (units === "tempK") {
          q2 = qty.scalar;
        } else if (units === "tempC") {
          q2 = qty.scalar + 273.15;
        } else if (units === "tempF") {
          q2 = (qty.scalar + 459.67) * 5 / 9;
        } else if (units === "tempR") {
          q2 = qty.scalar * 5 / 9;
        } else {
          throw new QtyError("Unknown type for temp conversion from: " + units);
        }
        return Qty2({ "scalar": q2, "numerator": ["<temp-K>"], "denominator": UNITY_ARRAY });
      }
      assign2(Qty2.prototype, {
        /**
         * Converts to other compatible units.
         * Instance's converted quantities are cached for faster subsequent calls.
         *
         * @param {(string|Qty)} other - Target units as string or retrieved from
         *                               other Qty instance (scalar is ignored)
         *
         * @returns {Qty} New converted Qty instance with target units
         *
         * @throws {QtyError} if target units are incompatible
         *
         * @example
         * var weight = Qty("25 kg");
         * weight.to("lb"); // => Qty("55.11556554621939 lbs");
         * weight.to(Qty("3 g")); // => Qty("25000 g"); // scalar of passed Qty is ignored
         */
        to: function(other) {
          var cached, target;
          if (other === void 0 || other === null) {
            return this;
          }
          if (!isString(other)) {
            return this.to(other.units());
          }
          cached = this._conversionCache[other];
          if (cached) {
            return cached;
          }
          target = Qty2(other);
          if (target.units() === this.units()) {
            return this;
          }
          if (!this.isCompatible(target)) {
            if (this.isInverse(target)) {
              target = this.inverse().to(other);
            } else {
              throwIncompatibleUnits(this.units(), target.units());
            }
          } else {
            if (target.isTemperature()) {
              target = toTemp(this, target);
            } else if (target.isDegrees()) {
              target = toDegrees(this, target);
            } else {
              var q2 = divSafe(this.baseScalar, target.baseScalar);
              target = Qty2({ "scalar": q2, "numerator": target.numerator, "denominator": target.denominator });
            }
          }
          this._conversionCache[other] = target;
          return target;
        },
        // convert to base SI units
        // results of the conversion are cached so subsequent calls to this will be fast
        toBase: function() {
          if (this.isBase()) {
            return this;
          }
          if (this.isTemperature()) {
            return toTempK(this);
          }
          var cached = baseUnitCache[this.units()];
          if (!cached) {
            cached = toBaseUnits(this.numerator, this.denominator);
            baseUnitCache[this.units()] = cached;
          }
          return cached.mul(this.scalar);
        },
        // Converts the unit back to a float if it is unitless.  Otherwise raises an exception
        toFloat: function() {
          if (this.isUnitless()) {
            return this.scalar;
          }
          throw new QtyError("Can't convert to Float unless unitless.  Use Unit#scalar");
        },
        /**
         * Returns the nearest multiple of quantity passed as
         * precision
         *
         * @param {(Qty|string|number)} precQuantity - Quantity, string formated
         *   quantity or number as expected precision
         *
         * @returns {Qty} Nearest multiple of precQuantity
         *
         * @example
         * Qty('5.5 ft').toPrec('2 ft'); // returns 6 ft
         * Qty('0.8 cu').toPrec('0.25 cu'); // returns 0.75 cu
         * Qty('6.3782 m').toPrec('cm'); // returns 6.38 m
         * Qty('1.146 MPa').toPrec('0.1 bar'); // returns 1.15 MPa
         *
         */
        toPrec: function(precQuantity) {
          if (isString(precQuantity)) {
            precQuantity = Qty2(precQuantity);
          }
          if (isNumber(precQuantity)) {
            precQuantity = Qty2(precQuantity + " " + this.units());
          }
          if (!this.isUnitless()) {
            precQuantity = precQuantity.to(this.units());
          } else if (!precQuantity.isUnitless()) {
            throwIncompatibleUnits(this.units(), precQuantity.units());
          }
          if (precQuantity.scalar === 0) {
            throw new QtyError("Divide by zero");
          }
          var precRoundedResult = mulSafe(
            Math.round(this.scalar / precQuantity.scalar),
            precQuantity.scalar
          );
          return Qty2(precRoundedResult + this.units());
        }
      });
      function swiftConverter(srcUnits, dstUnits) {
        var srcQty = Qty2(srcUnits);
        var dstQty = Qty2(dstUnits);
        if (srcQty.eq(dstQty)) {
          return identity;
        }
        var convert;
        if (!srcQty.isTemperature()) {
          convert = function(value) {
            return value * srcQty.baseScalar / dstQty.baseScalar;
          };
        } else {
          convert = function(value) {
            return srcQty.mul(value).to(dstQty).scalar;
          };
        }
        return function converter(value) {
          var i4, length, result;
          if (!Array.isArray(value)) {
            return convert(value);
          } else {
            length = value.length;
            result = [];
            for (i4 = 0; i4 < length; i4++) {
              result.push(convert(value[i4]));
            }
            return result;
          }
        };
      }
      var baseUnitCache = {};
      function toBaseUnits(numerator, denominator) {
        var num = [];
        var den = [];
        var q2 = 1;
        var unit;
        for (var i4 = 0; i4 < numerator.length; i4++) {
          unit = numerator[i4];
          if (PREFIX_VALUES[unit]) {
            q2 = mulSafe(q2, PREFIX_VALUES[unit]);
          } else {
            if (UNIT_VALUES[unit]) {
              q2 *= UNIT_VALUES[unit].scalar;
              if (UNIT_VALUES[unit].numerator) {
                num.push(UNIT_VALUES[unit].numerator);
              }
              if (UNIT_VALUES[unit].denominator) {
                den.push(UNIT_VALUES[unit].denominator);
              }
            }
          }
        }
        for (var j3 = 0; j3 < denominator.length; j3++) {
          unit = denominator[j3];
          if (PREFIX_VALUES[unit]) {
            q2 /= PREFIX_VALUES[unit];
          } else {
            if (UNIT_VALUES[unit]) {
              q2 /= UNIT_VALUES[unit].scalar;
              if (UNIT_VALUES[unit].numerator) {
                den.push(UNIT_VALUES[unit].numerator);
              }
              if (UNIT_VALUES[unit].denominator) {
                num.push(UNIT_VALUES[unit].denominator);
              }
            }
          }
        }
        num = num.reduce(function(a3, b2) {
          return a3.concat(b2);
        }, []);
        den = den.reduce(function(a3, b2) {
          return a3.concat(b2);
        }, []);
        return Qty2({ "scalar": q2, "numerator": num, "denominator": den });
      }
      Qty2.parse = globalParse;
      Qty2.getUnits = getUnits;
      Qty2.getAliases = getAliases;
      Qty2.mulSafe = mulSafe;
      Qty2.divSafe = divSafe;
      Qty2.getKinds = getKinds;
      Qty2.swiftConverter = swiftConverter;
      Qty2.Error = QtyError;
      assign2(Qty2.prototype, {
        // Returns new instance with units of this
        add: function(other) {
          if (isString(other)) {
            other = Qty2(other);
          }
          if (!this.isCompatible(other)) {
            throwIncompatibleUnits(this.units(), other.units());
          }
          if (this.isTemperature() && other.isTemperature()) {
            throw new QtyError("Cannot add two temperatures");
          } else if (this.isTemperature()) {
            return addTempDegrees(this, other);
          } else if (other.isTemperature()) {
            return addTempDegrees(other, this);
          }
          return Qty2({ "scalar": this.scalar + other.to(this).scalar, "numerator": this.numerator, "denominator": this.denominator });
        },
        sub: function(other) {
          if (isString(other)) {
            other = Qty2(other);
          }
          if (!this.isCompatible(other)) {
            throwIncompatibleUnits(this.units(), other.units());
          }
          if (this.isTemperature() && other.isTemperature()) {
            return subtractTemperatures(this, other);
          } else if (this.isTemperature()) {
            return subtractTempDegrees(this, other);
          } else if (other.isTemperature()) {
            throw new QtyError("Cannot subtract a temperature from a differential degree unit");
          }
          return Qty2({ "scalar": this.scalar - other.to(this).scalar, "numerator": this.numerator, "denominator": this.denominator });
        },
        mul: function(other) {
          if (isNumber(other)) {
            return Qty2({ "scalar": mulSafe(this.scalar, other), "numerator": this.numerator, "denominator": this.denominator });
          } else if (isString(other)) {
            other = Qty2(other);
          }
          if ((this.isTemperature() || other.isTemperature()) && !(this.isUnitless() || other.isUnitless())) {
            throw new QtyError("Cannot multiply by temperatures");
          }
          var op1 = this;
          var op2 = other;
          if (op1.isCompatible(op2) && op1.signature !== 400) {
            op2 = op2.to(op1);
          }
          var numdenscale = cleanTerms(op1.numerator, op1.denominator, op2.numerator, op2.denominator);
          return Qty2({ "scalar": mulSafe(op1.scalar, op2.scalar, numdenscale[2]), "numerator": numdenscale[0], "denominator": numdenscale[1] });
        },
        div: function(other) {
          if (isNumber(other)) {
            if (other === 0) {
              throw new QtyError("Divide by zero");
            }
            return Qty2({ "scalar": this.scalar / other, "numerator": this.numerator, "denominator": this.denominator });
          } else if (isString(other)) {
            other = Qty2(other);
          }
          if (other.scalar === 0) {
            throw new QtyError("Divide by zero");
          }
          if (other.isTemperature()) {
            throw new QtyError("Cannot divide with temperatures");
          } else if (this.isTemperature() && !other.isUnitless()) {
            throw new QtyError("Cannot divide with temperatures");
          }
          var op1 = this;
          var op2 = other;
          if (op1.isCompatible(op2) && op1.signature !== 400) {
            op2 = op2.to(op1);
          }
          var numdenscale = cleanTerms(op1.numerator, op1.denominator, op2.denominator, op2.numerator);
          return Qty2({ "scalar": mulSafe(op1.scalar, numdenscale[2]) / op2.scalar, "numerator": numdenscale[0], "denominator": numdenscale[1] });
        },
        // Returns a Qty that is the inverse of this Qty,
        inverse: function() {
          if (this.isTemperature()) {
            throw new QtyError("Cannot divide with temperatures");
          }
          if (this.scalar === 0) {
            throw new QtyError("Divide by zero");
          }
          return Qty2({ "scalar": 1 / this.scalar, "numerator": this.denominator, "denominator": this.numerator });
        }
      });
      function cleanTerms(num1, den1, num2, den2) {
        function notUnity(val) {
          return val !== UNITY;
        }
        num1 = num1.filter(notUnity);
        num2 = num2.filter(notUnity);
        den1 = den1.filter(notUnity);
        den2 = den2.filter(notUnity);
        var combined = {};
        function combineTerms(terms, direction) {
          var k2;
          var prefix;
          var prefixValue;
          for (var i4 = 0; i4 < terms.length; i4++) {
            if (PREFIX_VALUES[terms[i4]]) {
              k2 = terms[i4 + 1];
              prefix = terms[i4];
              prefixValue = PREFIX_VALUES[prefix];
              i4++;
            } else {
              k2 = terms[i4];
              prefix = null;
              prefixValue = 1;
            }
            if (k2 && k2 !== UNITY) {
              if (combined[k2]) {
                combined[k2][0] += direction;
                var combinedPrefixValue = combined[k2][2] ? PREFIX_VALUES[combined[k2][2]] : 1;
                combined[k2][direction === 1 ? 3 : 4] *= divSafe(prefixValue, combinedPrefixValue);
              } else {
                combined[k2] = [direction, k2, prefix, 1, 1];
              }
            }
          }
        }
        combineTerms(num1, 1);
        combineTerms(den1, -1);
        combineTerms(num2, 1);
        combineTerms(den2, -1);
        var num = [];
        var den = [];
        var scale = 1;
        for (var prop in combined) {
          if (combined.hasOwnProperty(prop)) {
            var item = combined[prop];
            var n3;
            if (item[0] > 0) {
              for (n3 = 0; n3 < item[0]; n3++) {
                num.push(item[2] === null ? item[1] : [item[2], item[1]]);
              }
            } else if (item[0] < 0) {
              for (n3 = 0; n3 < -item[0]; n3++) {
                den.push(item[2] === null ? item[1] : [item[2], item[1]]);
              }
            }
            scale *= divSafe(item[3], item[4]);
          }
        }
        if (num.length === 0) {
          num = UNITY_ARRAY;
        }
        if (den.length === 0) {
          den = UNITY_ARRAY;
        }
        num = num.reduce(function(a3, b2) {
          return a3.concat(b2);
        }, []);
        den = den.reduce(function(a3, b2) {
          return a3.concat(b2);
        }, []);
        return [num, den, scale];
      }
      assign2(Qty2.prototype, {
        eq: function(other) {
          return this.compareTo(other) === 0;
        },
        lt: function(other) {
          return this.compareTo(other) === -1;
        },
        lte: function(other) {
          return this.eq(other) || this.lt(other);
        },
        gt: function(other) {
          return this.compareTo(other) === 1;
        },
        gte: function(other) {
          return this.eq(other) || this.gt(other);
        },
        // Compare two Qty objects. Throws an exception if they are not of compatible types.
        // Comparisons are done based on the value of the quantity in base SI units.
        //
        // NOTE: We cannot compare inverses as that breaks the general compareTo contract:
        //   if a.compareTo(b) < 0 then b.compareTo(a) > 0
        //   if a.compareTo(b) == 0 then b.compareTo(a) == 0
        //
        //   Since "10S" == ".1ohm" (10 > .1) and "10ohm" == ".1S" (10 > .1)
        //     Qty("10S").inverse().compareTo("10ohm") == -1
        //     Qty("10ohm").inverse().compareTo("10S") == -1
        //
        //   If including inverses in the sort is needed, I suggest writing: Qty.sort(qtyArray,units)
        compareTo: function(other) {
          if (isString(other)) {
            return this.compareTo(Qty2(other));
          }
          if (!this.isCompatible(other)) {
            throwIncompatibleUnits(this.units(), other.units());
          }
          if (this.baseScalar < other.baseScalar) {
            return -1;
          } else if (this.baseScalar === other.baseScalar) {
            return 0;
          } else if (this.baseScalar > other.baseScalar) {
            return 1;
          }
        },
        // Return true if quantities and units match
        // Unit("100 cm").same(Unit("100 cm"))  # => true
        // Unit("100 cm").same(Unit("1 m"))     # => false
        same: function(other) {
          return this.scalar === other.scalar && this.units() === other.units();
        }
      });
      assign2(Qty2.prototype, {
        // returns true if no associated units
        // false, even if the units are "unitless" like 'radians, each, etc'
        isUnitless: function() {
          return [this.numerator, this.denominator].every(function(item) {
            return compareArray(item, UNITY_ARRAY);
          });
        },
        /*
        check to see if units are compatible, but not the scalar part
        this check is done by comparing signatures for performance reasons
        if passed a string, it will create a unit object with the string and then do the comparison
        this permits a syntax like:
        unit =~ "mm"
        if you want to do a regexp on the unit string do this ...
        unit.units =~ /regexp/
        */
        isCompatible: function(other) {
          if (isString(other)) {
            return this.isCompatible(Qty2(other));
          }
          if (!isQty(other)) {
            return false;
          }
          if (other.signature !== void 0) {
            return this.signature === other.signature;
          } else {
            return false;
          }
        },
        /*
        check to see if units are inverse of each other, but not the scalar part
        this check is done by comparing signatures for performance reasons
        if passed a string, it will create a unit object with the string and then do the comparison
        this permits a syntax like:
        unit =~ "mm"
        if you want to do a regexp on the unit string do this ...
        unit.units =~ /regexp/
        */
        isInverse: function(other) {
          return this.inverse().isCompatible(other);
        },
        // Returns 'true' if the Unit is represented in base units
        isBase: function() {
          if (this._isBase !== void 0) {
            return this._isBase;
          }
          if (this.isDegrees() && this.numerator[0].match(/<(kelvin|temp-K)>/)) {
            this._isBase = true;
            return this._isBase;
          }
          this.numerator.concat(this.denominator).forEach(function(item) {
            if (item !== UNITY && BASE_UNITS.indexOf(item) === -1) {
              this._isBase = false;
            }
          }, this);
          if (this._isBase === false) {
            return this._isBase;
          }
          this._isBase = true;
          return this._isBase;
        }
      });
      function NestedMap() {
      }
      NestedMap.prototype.get = function(keys) {
        if (arguments.length > 1) {
          keys = Array.apply(null, arguments);
        }
        return keys.reduce(
          function(map, key, index2) {
            if (map) {
              var childMap = map[key];
              if (index2 === keys.length - 1) {
                return childMap ? childMap.data : void 0;
              } else {
                return childMap;
              }
            }
          },
          this
        );
      };
      NestedMap.prototype.set = function(keys, value) {
        if (arguments.length > 2) {
          keys = Array.prototype.slice.call(arguments, 0, -1);
          value = arguments[arguments.length - 1];
        }
        return keys.reduce(function(map, key, index2) {
          var childMap = map[key];
          if (childMap === void 0) {
            childMap = map[key] = {};
          }
          if (index2 === keys.length - 1) {
            childMap.data = value;
            return value;
          } else {
            return childMap;
          }
        }, this);
      };
      function defaultFormatter(scalar, units) {
        return (scalar + " " + units).trim();
      }
      Qty2.formatter = defaultFormatter;
      assign2(Qty2.prototype, {
        // returns the 'unit' part of the Unit object without the scalar
        units: function() {
          if (this._units !== void 0) {
            return this._units;
          }
          var numIsUnity = compareArray(this.numerator, UNITY_ARRAY);
          var denIsUnity = compareArray(this.denominator, UNITY_ARRAY);
          if (numIsUnity && denIsUnity) {
            this._units = "";
            return this._units;
          }
          var numUnits = stringifyUnits(this.numerator);
          var denUnits = stringifyUnits(this.denominator);
          this._units = numUnits + (denIsUnity ? "" : "/" + denUnits);
          return this._units;
        },
        /**
         * Stringifies the quantity
         * Deprecation notice: only units parameter is supported.
         *
         * @param {(number|string|Qty)} targetUnitsOrMaxDecimalsOrPrec -
         *                              target units if string,
         *                              max number of decimals if number,
         *                              passed to #toPrec before converting if Qty
         *
         * @param {number=} maxDecimals - Maximum number of decimals of
         *                                formatted output
         *
         * @returns {string} reparseable quantity as string
         */
        toString: function(targetUnitsOrMaxDecimalsOrPrec, maxDecimals) {
          var targetUnits;
          if (isNumber(targetUnitsOrMaxDecimalsOrPrec)) {
            targetUnits = this.units();
            maxDecimals = targetUnitsOrMaxDecimalsOrPrec;
          } else if (isString(targetUnitsOrMaxDecimalsOrPrec)) {
            targetUnits = targetUnitsOrMaxDecimalsOrPrec;
          } else if (isQty(targetUnitsOrMaxDecimalsOrPrec)) {
            return this.toPrec(targetUnitsOrMaxDecimalsOrPrec).toString(maxDecimals);
          }
          var out = this.to(targetUnits);
          var outScalar = maxDecimals !== void 0 ? round2(out.scalar, maxDecimals) : out.scalar;
          out = (outScalar + " " + out.units()).trim();
          return out;
        },
        /**
         * Format the quantity according to optional passed target units
         * and formatter
         *
         * @param {string} [targetUnits=current units] -
         *                 optional units to convert to before formatting
         *
         * @param {function} [formatter=Qty.formatter] -
         *                   delegates formatting to formatter callback.
         *                   formatter is called back with two parameters (scalar, units)
         *                   and should return formatted result.
         *                   If unspecified, formatting is delegated to default formatter
         *                   set to Qty.formatter
         *
         * @example
         * var roundingAndLocalizingFormatter = function(scalar, units) {
         *   // localize or limit scalar to n max decimals for instance
         *   // return formatted result
         * };
         * var qty = Qty('1.1234 m');
         * qty.format(); // same units, default formatter => "1.234 m"
         * qty.format("cm"); // converted to "cm", default formatter => "123.45 cm"
         * qty.format(roundingAndLocalizingFormatter); // same units, custom formatter => "1,2 m"
         * qty.format("cm", roundingAndLocalizingFormatter); // convert to "cm", custom formatter => "123,4 cm"
         *
         * @returns {string} quantity as string
         */
        format: function(targetUnits, formatter) {
          if (arguments.length === 1) {
            if (typeof targetUnits === "function") {
              formatter = targetUnits;
              targetUnits = void 0;
            }
          }
          formatter = formatter || Qty2.formatter;
          var targetQty = this.to(targetUnits);
          return formatter.call(this, targetQty.scalar, targetQty.units());
        }
      });
      var stringifiedUnitsCache = new NestedMap();
      function stringifyUnits(units) {
        var stringified = stringifiedUnitsCache.get(units);
        if (stringified) {
          return stringified;
        }
        var isUnity = compareArray(units, UNITY_ARRAY);
        if (isUnity) {
          stringified = "1";
        } else {
          stringified = simplify(getOutputNames(units)).join("*");
        }
        stringifiedUnitsCache.set(units, stringified);
        return stringified;
      }
      function getOutputNames(units) {
        var unitNames = [], token, tokenNext;
        for (var i4 = 0; i4 < units.length; i4++) {
          token = units[i4];
          tokenNext = units[i4 + 1];
          if (PREFIX_VALUES[token]) {
            unitNames.push(OUTPUT_MAP[token] + OUTPUT_MAP[tokenNext]);
            i4++;
          } else {
            unitNames.push(OUTPUT_MAP[token]);
          }
        }
        return unitNames;
      }
      function simplify(units) {
        var unitCounts = units.reduce(function(acc, unit) {
          var unitCounter = acc[unit];
          if (!unitCounter) {
            acc.push(unitCounter = acc[unit] = [unit, 0]);
          }
          unitCounter[1]++;
          return acc;
        }, []);
        return unitCounts.map(function(unitCount) {
          return unitCount[0] + (unitCount[1] > 1 ? unitCount[1] : "");
        });
      }
      Qty2.version = "1.8.0";
      return Qty2;
    });
  }
});

// node_modules/two-product/two-product.js
var require_two_product = __commonJS({
  "node_modules/two-product/two-product.js"(exports2, module2) {
    "use strict";
    module2.exports = twoProduct;
    var SPLITTER = +(Math.pow(2, 27) + 1);
    function twoProduct(a3, b2, result) {
      var x2 = a3 * b2;
      var c4 = SPLITTER * a3;
      var abig = c4 - a3;
      var ahi = c4 - abig;
      var alo = a3 - ahi;
      var d2 = SPLITTER * b2;
      var bbig = d2 - b2;
      var bhi = d2 - bbig;
      var blo = b2 - bhi;
      var err1 = x2 - ahi * bhi;
      var err22 = err1 - alo * bhi;
      var err3 = err22 - ahi * blo;
      var y3 = alo * blo - err3;
      if (result) {
        result[0] = y3;
        result[1] = x2;
        return result;
      }
      return [y3, x2];
    }
  }
});

// node_modules/robust-sum/robust-sum.js
var require_robust_sum = __commonJS({
  "node_modules/robust-sum/robust-sum.js"(exports2, module2) {
    "use strict";
    module2.exports = linearExpansionSum;
    function scalarScalar(a3, b2) {
      var x2 = a3 + b2;
      var bv = x2 - a3;
      var av = x2 - bv;
      var br = b2 - bv;
      var ar = a3 - av;
      var y3 = ar + br;
      if (y3) {
        return [y3, x2];
      }
      return [x2];
    }
    function linearExpansionSum(e2, f3) {
      var ne2 = e2.length | 0;
      var nf = f3.length | 0;
      if (ne2 === 1 && nf === 1) {
        return scalarScalar(e2[0], f3[0]);
      }
      var n3 = ne2 + nf;
      var g2 = new Array(n3);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs2 = Math.abs;
      var ei = e2[eptr];
      var ea = abs2(ei);
      var fi = f3[fptr];
      var fa = abs2(fi);
      var a3, b2;
      if (ea < fa) {
        b2 = ei;
        eptr += 1;
        if (eptr < ne2) {
          ei = e2[eptr];
          ea = abs2(ei);
        }
      } else {
        b2 = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f3[fptr];
          fa = abs2(fi);
        }
      }
      if (eptr < ne2 && ea < fa || fptr >= nf) {
        a3 = ei;
        eptr += 1;
        if (eptr < ne2) {
          ei = e2[eptr];
          ea = abs2(ei);
        }
      } else {
        a3 = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f3[fptr];
          fa = abs2(fi);
        }
      }
      var x2 = a3 + b2;
      var bv = x2 - a3;
      var y3 = b2 - bv;
      var q0 = y3;
      var q1 = x2;
      var _x, _bv, _av, _br, _ar;
      while (eptr < ne2 && fptr < nf) {
        if (ea < fa) {
          a3 = ei;
          eptr += 1;
          if (eptr < ne2) {
            ei = e2[eptr];
            ea = abs2(ei);
          }
        } else {
          a3 = fi;
          fptr += 1;
          if (fptr < nf) {
            fi = f3[fptr];
            fa = abs2(fi);
          }
        }
        b2 = q0;
        x2 = a3 + b2;
        bv = x2 - a3;
        y3 = b2 - bv;
        if (y3) {
          g2[count++] = y3;
        }
        _x = q1 + x2;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x2 - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while (eptr < ne2) {
        a3 = ei;
        b2 = q0;
        x2 = a3 + b2;
        bv = x2 - a3;
        y3 = b2 - bv;
        if (y3) {
          g2[count++] = y3;
        }
        _x = q1 + x2;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x2 - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne2) {
          ei = e2[eptr];
        }
      }
      while (fptr < nf) {
        a3 = fi;
        b2 = q0;
        x2 = a3 + b2;
        bv = x2 - a3;
        y3 = b2 - bv;
        if (y3) {
          g2[count++] = y3;
        }
        _x = q1 + x2;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x2 - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) {
          fi = f3[fptr];
        }
      }
      if (q0) {
        g2[count++] = q0;
      }
      if (q1) {
        g2[count++] = q1;
      }
      if (!count) {
        g2[count++] = 0;
      }
      g2.length = count;
      return g2;
    }
  }
});

// node_modules/two-sum/two-sum.js
var require_two_sum = __commonJS({
  "node_modules/two-sum/two-sum.js"(exports2, module2) {
    "use strict";
    module2.exports = fastTwoSum;
    function fastTwoSum(a3, b2, result) {
      var x2 = a3 + b2;
      var bv = x2 - a3;
      var av = x2 - bv;
      var br = b2 - bv;
      var ar = a3 - av;
      if (result) {
        result[0] = ar + br;
        result[1] = x2;
        return result;
      }
      return [ar + br, x2];
    }
  }
});

// node_modules/robust-scale/robust-scale.js
var require_robust_scale = __commonJS({
  "node_modules/robust-scale/robust-scale.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var twoSum = require_two_sum();
    module2.exports = scaleLinearExpansion;
    function scaleLinearExpansion(e2, scale) {
      var n3 = e2.length;
      if (n3 === 1) {
        var ts = twoProduct(e2[0], scale);
        if (ts[0]) {
          return ts;
        }
        return [ts[1]];
      }
      var g2 = new Array(2 * n3);
      var q2 = [0.1, 0.1];
      var t3 = [0.1, 0.1];
      var count = 0;
      twoProduct(e2[0], scale, q2);
      if (q2[0]) {
        g2[count++] = q2[0];
      }
      for (var i3 = 1; i3 < n3; ++i3) {
        twoProduct(e2[i3], scale, t3);
        var pq = q2[1];
        twoSum(pq, t3[0], q2);
        if (q2[0]) {
          g2[count++] = q2[0];
        }
        var a3 = t3[1];
        var b2 = q2[1];
        var x2 = a3 + b2;
        var bv = x2 - a3;
        var y3 = b2 - bv;
        q2[1] = x2;
        if (y3) {
          g2[count++] = y3;
        }
      }
      if (q2[1]) {
        g2[count++] = q2[1];
      }
      if (count === 0) {
        g2[count++] = 0;
      }
      g2.length = count;
      return g2;
    }
  }
});

// node_modules/robust-subtract/robust-diff.js
var require_robust_diff = __commonJS({
  "node_modules/robust-subtract/robust-diff.js"(exports2, module2) {
    "use strict";
    module2.exports = robustSubtract;
    function scalarScalar(a3, b2) {
      var x2 = a3 + b2;
      var bv = x2 - a3;
      var av = x2 - bv;
      var br = b2 - bv;
      var ar = a3 - av;
      var y3 = ar + br;
      if (y3) {
        return [y3, x2];
      }
      return [x2];
    }
    function robustSubtract(e2, f3) {
      var ne2 = e2.length | 0;
      var nf = f3.length | 0;
      if (ne2 === 1 && nf === 1) {
        return scalarScalar(e2[0], -f3[0]);
      }
      var n3 = ne2 + nf;
      var g2 = new Array(n3);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs2 = Math.abs;
      var ei = e2[eptr];
      var ea = abs2(ei);
      var fi = -f3[fptr];
      var fa = abs2(fi);
      var a3, b2;
      if (ea < fa) {
        b2 = ei;
        eptr += 1;
        if (eptr < ne2) {
          ei = e2[eptr];
          ea = abs2(ei);
        }
      } else {
        b2 = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f3[fptr];
          fa = abs2(fi);
        }
      }
      if (eptr < ne2 && ea < fa || fptr >= nf) {
        a3 = ei;
        eptr += 1;
        if (eptr < ne2) {
          ei = e2[eptr];
          ea = abs2(ei);
        }
      } else {
        a3 = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f3[fptr];
          fa = abs2(fi);
        }
      }
      var x2 = a3 + b2;
      var bv = x2 - a3;
      var y3 = b2 - bv;
      var q0 = y3;
      var q1 = x2;
      var _x, _bv, _av, _br, _ar;
      while (eptr < ne2 && fptr < nf) {
        if (ea < fa) {
          a3 = ei;
          eptr += 1;
          if (eptr < ne2) {
            ei = e2[eptr];
            ea = abs2(ei);
          }
        } else {
          a3 = fi;
          fptr += 1;
          if (fptr < nf) {
            fi = -f3[fptr];
            fa = abs2(fi);
          }
        }
        b2 = q0;
        x2 = a3 + b2;
        bv = x2 - a3;
        y3 = b2 - bv;
        if (y3) {
          g2[count++] = y3;
        }
        _x = q1 + x2;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x2 - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while (eptr < ne2) {
        a3 = ei;
        b2 = q0;
        x2 = a3 + b2;
        bv = x2 - a3;
        y3 = b2 - bv;
        if (y3) {
          g2[count++] = y3;
        }
        _x = q1 + x2;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x2 - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne2) {
          ei = e2[eptr];
        }
      }
      while (fptr < nf) {
        a3 = fi;
        b2 = q0;
        x2 = a3 + b2;
        bv = x2 - a3;
        y3 = b2 - bv;
        if (y3) {
          g2[count++] = y3;
        }
        _x = q1 + x2;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x2 - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) {
          fi = -f3[fptr];
        }
      }
      if (q0) {
        g2[count++] = q0;
      }
      if (q1) {
        g2[count++] = q1;
      }
      if (!count) {
        g2[count++] = 0;
      }
      g2.length = count;
      return g2;
    }
  }
});

// node_modules/robust-orientation/orientation.js
var require_orientation = __commonJS({
  "node_modules/robust-orientation/orientation.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var robustSum = require_robust_sum();
    var robustScale = require_robust_scale();
    var robustSubtract = require_robust_diff();
    var NUM_EXPAND = 5;
    var EPSILON = 11102230246251565e-32;
    var ERRBOUND3 = (3 + 16 * EPSILON) * EPSILON;
    var ERRBOUND4 = (7 + 56 * EPSILON) * EPSILON;
    function orientation_3(sum2, prod, scale, sub) {
      return function orientation3Exact2(m0, m1, m22) {
        var p3 = sum2(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])));
        var n3 = sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0]));
        var d2 = sub(p3, n3);
        return d2[d2.length - 1];
      };
    }
    function orientation_4(sum2, prod, scale, sub) {
      return function orientation4Exact2(m0, m1, m22, m32) {
        var p3 = sum2(sum2(scale(sum2(prod(m22[1], m32[0]), prod(-m32[1], m22[0])), m1[2]), sum2(scale(sum2(prod(m1[1], m32[0]), prod(-m32[1], m1[0])), -m22[2]), scale(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m32[2]))), sum2(scale(sum2(prod(m1[1], m32[0]), prod(-m32[1], m1[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m32[0]), prod(-m32[1], m0[0])), -m1[2]), scale(sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m32[2]))));
        var n3 = sum2(sum2(scale(sum2(prod(m22[1], m32[0]), prod(-m32[1], m22[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m32[0]), prod(-m32[1], m0[0])), -m22[2]), scale(sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m32[2]))), sum2(scale(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), -m1[2]), scale(sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m22[2]))));
        var d2 = sub(p3, n3);
        return d2[d2.length - 1];
      };
    }
    function orientation_5(sum2, prod, scale, sub) {
      return function orientation5Exact(m0, m1, m22, m32, m4) {
        var p3 = sum2(sum2(sum2(scale(sum2(scale(sum2(prod(m32[1], m4[0]), prod(-m4[1], m32[0])), m22[2]), sum2(scale(sum2(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), -m32[2]), scale(sum2(prod(m22[1], m32[0]), prod(-m32[1], m22[0])), m4[2]))), m1[3]), sum2(scale(sum2(scale(sum2(prod(m32[1], m4[0]), prod(-m4[1], m32[0])), m1[2]), sum2(scale(sum2(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m32[2]), scale(sum2(prod(m1[1], m32[0]), prod(-m32[1], m1[0])), m4[2]))), -m22[3]), scale(sum2(scale(sum2(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), m1[2]), sum2(scale(sum2(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m22[2]), scale(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m4[2]))), m32[3]))), sum2(scale(sum2(scale(sum2(prod(m22[1], m32[0]), prod(-m32[1], m22[0])), m1[2]), sum2(scale(sum2(prod(m1[1], m32[0]), prod(-m32[1], m1[0])), -m22[2]), scale(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m32[2]))), -m4[3]), sum2(scale(sum2(scale(sum2(prod(m32[1], m4[0]), prod(-m4[1], m32[0])), m1[2]), sum2(scale(sum2(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m32[2]), scale(sum2(prod(m1[1], m32[0]), prod(-m32[1], m1[0])), m4[2]))), m0[3]), scale(sum2(scale(sum2(prod(m32[1], m4[0]), prod(-m4[1], m32[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m32[2]), scale(sum2(prod(m0[1], m32[0]), prod(-m32[1], m0[0])), m4[2]))), -m1[3])))), sum2(sum2(scale(sum2(scale(sum2(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m32[3]), sum2(scale(sum2(scale(sum2(prod(m1[1], m32[0]), prod(-m32[1], m1[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m32[0]), prod(-m32[1], m0[0])), -m1[2]), scale(sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m32[2]))), -m4[3]), scale(sum2(scale(sum2(prod(m22[1], m32[0]), prod(-m32[1], m22[0])), m1[2]), sum2(scale(sum2(prod(m1[1], m32[0]), prod(-m32[1], m1[0])), -m22[2]), scale(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m32[2]))), m0[3]))), sum2(scale(sum2(scale(sum2(prod(m22[1], m32[0]), prod(-m32[1], m22[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m32[0]), prod(-m32[1], m0[0])), -m22[2]), scale(sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m32[2]))), -m1[3]), sum2(scale(sum2(scale(sum2(prod(m1[1], m32[0]), prod(-m32[1], m1[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m32[0]), prod(-m32[1], m0[0])), -m1[2]), scale(sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m32[2]))), m22[3]), scale(sum2(scale(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), -m1[2]), scale(sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m22[2]))), -m32[3])))));
        var n3 = sum2(sum2(sum2(scale(sum2(scale(sum2(prod(m32[1], m4[0]), prod(-m4[1], m32[0])), m22[2]), sum2(scale(sum2(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), -m32[2]), scale(sum2(prod(m22[1], m32[0]), prod(-m32[1], m22[0])), m4[2]))), m0[3]), scale(sum2(scale(sum2(prod(m32[1], m4[0]), prod(-m4[1], m32[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m32[2]), scale(sum2(prod(m0[1], m32[0]), prod(-m32[1], m0[0])), m4[2]))), -m22[3])), sum2(scale(sum2(scale(sum2(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m22[2]), scale(sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m4[2]))), m32[3]), scale(sum2(scale(sum2(prod(m22[1], m32[0]), prod(-m32[1], m22[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m32[0]), prod(-m32[1], m0[0])), -m22[2]), scale(sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m32[2]))), -m4[3]))), sum2(sum2(scale(sum2(scale(sum2(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), m1[2]), sum2(scale(sum2(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m22[2]), scale(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m4[2]))), m0[3]), scale(sum2(scale(sum2(prod(m22[1], m4[0]), prod(-m4[1], m22[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m22[2]), scale(sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), m4[2]))), -m1[3])), sum2(scale(sum2(scale(sum2(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m22[3]), scale(sum2(scale(sum2(prod(m1[1], m22[0]), prod(-m22[1], m1[0])), m0[2]), sum2(scale(sum2(prod(m0[1], m22[0]), prod(-m22[1], m0[0])), -m1[2]), scale(sum2(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m22[2]))), -m4[3]))));
        var d2 = sub(p3, n3);
        return d2[d2.length - 1];
      };
    }
    function orientation(n3) {
      var fn = n3 === 3 ? orientation_3 : n3 === 4 ? orientation_4 : orientation_5;
      return fn(robustSum, twoProduct, robustScale, robustSubtract);
    }
    var orientation3Exact = orientation(3);
    var orientation4Exact = orientation(4);
    var CACHED = [
      function orientation0() {
        return 0;
      },
      function orientation1() {
        return 0;
      },
      function orientation2(a3, b2) {
        return b2[0] - a3[0];
      },
      function orientation3(a3, b2, c4) {
        var l3 = (a3[1] - c4[1]) * (b2[0] - c4[0]);
        var r2 = (a3[0] - c4[0]) * (b2[1] - c4[1]);
        var det = l3 - r2;
        var s3;
        if (l3 > 0) {
          if (r2 <= 0) {
            return det;
          } else {
            s3 = l3 + r2;
          }
        } else if (l3 < 0) {
          if (r2 >= 0) {
            return det;
          } else {
            s3 = -(l3 + r2);
          }
        } else {
          return det;
        }
        var tol = ERRBOUND3 * s3;
        if (det >= tol || det <= -tol) {
          return det;
        }
        return orientation3Exact(a3, b2, c4);
      },
      function orientation4(a3, b2, c4, d2) {
        var adx = a3[0] - d2[0];
        var bdx = b2[0] - d2[0];
        var cdx = c4[0] - d2[0];
        var ady = a3[1] - d2[1];
        var bdy = b2[1] - d2[1];
        var cdy = c4[1] - d2[1];
        var adz = a3[2] - d2[2];
        var bdz = b2[2] - d2[2];
        var cdz = c4[2] - d2[2];
        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;
        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
        var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
        var tol = ERRBOUND4 * permanent;
        if (det > tol || -det > tol) {
          return det;
        }
        return orientation4Exact(a3, b2, c4, d2);
      }
    ];
    function slowOrient(args) {
      var proc2 = CACHED[args.length];
      if (!proc2) {
        proc2 = CACHED[args.length] = orientation(args.length);
      }
      return proc2.apply(void 0, args);
    }
    function proc(slow, o0, o1, o22, o3, o4, o5) {
      return function getOrientation(a0, a1, a22, a3, a4) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return o22(a0, a1);
          case 3:
            return o3(a0, a1, a22);
          case 4:
            return o4(a0, a1, a22, a3);
          case 5:
            return o5(a0, a1, a22, a3, a4);
        }
        var s3 = new Array(arguments.length);
        for (var i3 = 0; i3 < arguments.length; ++i3) {
          s3[i3] = arguments[i3];
        }
        return slow(s3);
      };
    }
    function generateOrientationProc() {
      while (CACHED.length <= NUM_EXPAND) {
        CACHED.push(orientation(CACHED.length));
      }
      module2.exports = proc.apply(void 0, [slowOrient].concat(CACHED));
      for (var i3 = 0; i3 <= NUM_EXPAND; ++i3) {
        module2.exports[i3] = CACHED[i3];
      }
    }
    generateOrientationProc();
  }
});

// node_modules/robust-point-in-polygon/robust-pnp.js
var require_robust_pnp = __commonJS({
  "node_modules/robust-point-in-polygon/robust-pnp.js"(exports2, module2) {
    module2.exports = robustPointInPolygon2;
    var orient = require_orientation();
    function robustPointInPolygon2(vs, point) {
      var x2 = point[0];
      var y3 = point[1];
      var n3 = vs.length;
      var inside = 1;
      var lim = n3;
      for (var i3 = 0, j2 = n3 - 1; i3 < lim; j2 = i3++) {
        var a3 = vs[i3];
        var b2 = vs[j2];
        var yi = a3[1];
        var yj = b2[1];
        if (yj < yi) {
          if (yj < y3 && y3 < yi) {
            var s3 = orient(a3, b2, point);
            if (s3 === 0) {
              return 0;
            } else {
              inside ^= 0 < s3 | 0;
            }
          } else if (y3 === yi) {
            var c4 = vs[(i3 + 1) % n3];
            var yk = c4[1];
            if (yi < yk) {
              var s3 = orient(a3, b2, point);
              if (s3 === 0) {
                return 0;
              } else {
                inside ^= 0 < s3 | 0;
              }
            }
          }
        } else if (yi < yj) {
          if (yi < y3 && y3 < yj) {
            var s3 = orient(a3, b2, point);
            if (s3 === 0) {
              return 0;
            } else {
              inside ^= s3 < 0 | 0;
            }
          } else if (y3 === yi) {
            var c4 = vs[(i3 + 1) % n3];
            var yk = c4[1];
            if (yk < yi) {
              var s3 = orient(a3, b2, point);
              if (s3 === 0) {
                return 0;
              } else {
                inside ^= s3 < 0 | 0;
              }
            }
          }
        } else if (y3 === yi) {
          var x0 = Math.min(a3[0], b2[0]);
          var x1 = Math.max(a3[0], b2[0]);
          if (i3 === 0) {
            while (j2 > 0) {
              var k2 = (j2 + n3 - 1) % n3;
              var p3 = vs[k2];
              if (p3[1] !== y3) {
                break;
              }
              var px = p3[0];
              x0 = Math.min(x0, px);
              x1 = Math.max(x1, px);
              j2 = k2;
            }
            if (j2 === 0) {
              if (x0 <= x2 && x2 <= x1) {
                return 0;
              }
              return 1;
            }
            lim = j2 + 1;
          }
          var y0 = vs[(j2 + n3 - 1) % n3][1];
          while (i3 + 1 < lim) {
            var p3 = vs[i3 + 1];
            if (p3[1] !== y3) {
              break;
            }
            var px = p3[0];
            x0 = Math.min(x0, px);
            x1 = Math.max(x1, px);
            i3 += 1;
          }
          if (x0 <= x2 && x2 <= x1) {
            return 0;
          }
          var y1 = vs[(i3 + 1) % n3][1];
          if (x2 < x0 && y0 < y3 !== y1 < y3) {
            inside ^= 1;
          }
        }
      }
      return 2 * inside - 1;
    }
  }
});

// node_modules/ml-disjoint-set/src/DisjointSet.js
var require_DisjointSet = __commonJS({
  "node_modules/ml-disjoint-set/src/DisjointSet.js"(exports2, module2) {
    "use strict";
    var DisjointSet2 = class {
      constructor() {
        this.nodes = /* @__PURE__ */ new Map();
      }
      /**
       * Adds an element as a new set
       * @param {*} value
       * @return {DisjointSetNode} Object holding the element
       */
      add(value) {
        var node2 = this.nodes.get(value);
        if (!node2) {
          node2 = new DisjointSetNode(value);
          this.nodes.set(value, node2);
        }
        return node2;
      }
      /**
       * Merges the sets that contain x and y
       * @param {DisjointSetNode} x
       * @param {DisjointSetNode} y
       */
      union(x2, y3) {
        const rootX = this.find(x2);
        const rootY = this.find(y3);
        if (rootX === rootY) {
          return;
        }
        if (rootX.rank < rootY.rank) {
          rootX.parent = rootY;
        } else if (rootX.rank > rootY.rank) {
          rootY.parent = rootX;
        } else {
          rootY.parent = rootX;
          rootX.rank++;
        }
      }
      /**
       * Finds and returns the root node of the set that contains node
       * @param {DisjointSetNode} node
       * @return {DisjointSetNode}
       */
      find(node2) {
        var rootX = node2;
        while (rootX.parent !== null) {
          rootX = rootX.parent;
        }
        var toUpdateX = node2;
        while (toUpdateX.parent !== null) {
          var toUpdateParent = toUpdateX;
          toUpdateX = toUpdateX.parent;
          toUpdateParent.parent = rootX;
        }
        return rootX;
      }
      /**
       * Returns true if x and y belong to the same set
       * @param {DisjointSetNode} x
       * @param {DisjointSetNode} y
       */
      connected(x2, y3) {
        return this.find(x2) === this.find(y3);
      }
    };
    module2.exports = DisjointSet2;
    function DisjointSetNode(value) {
      this.value = value;
      this.parent = null;
      this.rank = 0;
    }
  }
});

// node_modules/js-priority-queue/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/js-priority-queue/priority-queue.js"(exports2, module2) {
    (function(f3) {
      if (typeof exports2 === "object" && typeof module2 !== "undefined") {
        module2.exports = f3();
      } else if (typeof define === "function" && define.amd) {
        define([], f3);
      } else {
        var g2;
        if (typeof window !== "undefined") {
          g2 = window;
        } else if (typeof global !== "undefined") {
          g2 = global;
        } else if (typeof self !== "undefined") {
          g2 = self;
        } else {
          g2 = this;
        }
        g2.PriorityQueue = f3();
      }
    })(function() {
      var define2, module3, exports3;
      return function e2(t3, n3, r2) {
        function s3(o4, u3) {
          if (!n3[o4]) {
            if (!t3[o4]) {
              var a3 = typeof require == "function" && require;
              if (!u3 && a3)
                return a3(o4, true);
              if (i3)
                return i3(o4, true);
              var f3 = new Error("Cannot find module '" + o4 + "'");
              throw f3.code = "MODULE_NOT_FOUND", f3;
            }
            var l3 = n3[o4] = { exports: {} };
            t3[o4][0].call(l3.exports, function(e3) {
              var n4 = t3[o4][1][e3];
              return s3(n4 ? n4 : e3);
            }, l3, l3.exports, e2, t3, n3, r2);
          }
          return n3[o4].exports;
        }
        var i3 = typeof require == "function" && require;
        for (var o3 = 0; o3 < r2.length; o3++)
          s3(r2[o3]);
        return s3;
      }({ 1: [function(_dereq_, module4, exports4) {
        var AbstractPriorityQueue, ArrayStrategy, BHeapStrategy, BinaryHeapStrategy, PriorityQueue2, extend4 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        AbstractPriorityQueue = _dereq_("./PriorityQueue/AbstractPriorityQueue");
        ArrayStrategy = _dereq_("./PriorityQueue/ArrayStrategy");
        BinaryHeapStrategy = _dereq_("./PriorityQueue/BinaryHeapStrategy");
        BHeapStrategy = _dereq_("./PriorityQueue/BHeapStrategy");
        PriorityQueue2 = function(superClass) {
          extend4(PriorityQueue3, superClass);
          function PriorityQueue3(options) {
            options || (options = {});
            options.strategy || (options.strategy = BinaryHeapStrategy);
            options.comparator || (options.comparator = function(a3, b2) {
              return (a3 || 0) - (b2 || 0);
            });
            PriorityQueue3.__super__.constructor.call(this, options);
          }
          return PriorityQueue3;
        }(AbstractPriorityQueue);
        PriorityQueue2.ArrayStrategy = ArrayStrategy;
        PriorityQueue2.BinaryHeapStrategy = BinaryHeapStrategy;
        PriorityQueue2.BHeapStrategy = BHeapStrategy;
        module4.exports = PriorityQueue2;
      }, { "./PriorityQueue/AbstractPriorityQueue": 2, "./PriorityQueue/ArrayStrategy": 3, "./PriorityQueue/BHeapStrategy": 4, "./PriorityQueue/BinaryHeapStrategy": 5 }], 2: [function(_dereq_, module4, exports4) {
        var AbstractPriorityQueue;
        module4.exports = AbstractPriorityQueue = function() {
          function AbstractPriorityQueue2(options) {
            var ref;
            if ((options != null ? options.strategy : void 0) == null) {
              throw "Must pass options.strategy, a strategy";
            }
            if ((options != null ? options.comparator : void 0) == null) {
              throw "Must pass options.comparator, a comparator";
            }
            this.priv = new options.strategy(options);
            this.length = (options != null ? (ref = options.initialValues) != null ? ref.length : void 0 : void 0) || 0;
          }
          AbstractPriorityQueue2.prototype.queue = function(value) {
            this.length++;
            this.priv.queue(value);
            return void 0;
          };
          AbstractPriorityQueue2.prototype.dequeue = function(value) {
            if (!this.length) {
              throw "Empty queue";
            }
            this.length--;
            return this.priv.dequeue();
          };
          AbstractPriorityQueue2.prototype.peek = function(value) {
            if (!this.length) {
              throw "Empty queue";
            }
            return this.priv.peek();
          };
          AbstractPriorityQueue2.prototype.clear = function() {
            this.length = 0;
            return this.priv.clear();
          };
          return AbstractPriorityQueue2;
        }();
      }, {}], 3: [function(_dereq_, module4, exports4) {
        var ArrayStrategy, binarySearchForIndexReversed;
        binarySearchForIndexReversed = function(array3, value, comparator) {
          var high, low, mid;
          low = 0;
          high = array3.length;
          while (low < high) {
            mid = low + high >>> 1;
            if (comparator(array3[mid], value) >= 0) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return low;
        };
        module4.exports = ArrayStrategy = function() {
          function ArrayStrategy2(options) {
            var ref;
            this.options = options;
            this.comparator = this.options.comparator;
            this.data = ((ref = this.options.initialValues) != null ? ref.slice(0) : void 0) || [];
            this.data.sort(this.comparator).reverse();
          }
          ArrayStrategy2.prototype.queue = function(value) {
            var pos;
            pos = binarySearchForIndexReversed(this.data, value, this.comparator);
            this.data.splice(pos, 0, value);
            return void 0;
          };
          ArrayStrategy2.prototype.dequeue = function() {
            return this.data.pop();
          };
          ArrayStrategy2.prototype.peek = function() {
            return this.data[this.data.length - 1];
          };
          ArrayStrategy2.prototype.clear = function() {
            this.data.length = 0;
            return void 0;
          };
          return ArrayStrategy2;
        }();
      }, {}], 4: [function(_dereq_, module4, exports4) {
        var BHeapStrategy;
        module4.exports = BHeapStrategy = function() {
          function BHeapStrategy2(options) {
            var arr, i3, j2, k2, len, ref, ref1, shift, value;
            this.comparator = (options != null ? options.comparator : void 0) || function(a3, b2) {
              return a3 - b2;
            };
            this.pageSize = (options != null ? options.pageSize : void 0) || 512;
            this.length = 0;
            shift = 0;
            while (1 << shift < this.pageSize) {
              shift += 1;
            }
            if (1 << shift !== this.pageSize) {
              throw "pageSize must be a power of two";
            }
            this._shift = shift;
            this._emptyMemoryPageTemplate = arr = [];
            for (i3 = j2 = 0, ref = this.pageSize; 0 <= ref ? j2 < ref : j2 > ref; i3 = 0 <= ref ? ++j2 : --j2) {
              arr.push(null);
            }
            this._memory = [];
            this._mask = this.pageSize - 1;
            if (options.initialValues) {
              ref1 = options.initialValues;
              for (k2 = 0, len = ref1.length; k2 < len; k2++) {
                value = ref1[k2];
                this.queue(value);
              }
            }
          }
          BHeapStrategy2.prototype.queue = function(value) {
            this.length += 1;
            this._write(this.length, value);
            this._bubbleUp(this.length, value);
            return void 0;
          };
          BHeapStrategy2.prototype.dequeue = function() {
            var ret, val;
            ret = this._read(1);
            val = this._read(this.length);
            this.length -= 1;
            if (this.length > 0) {
              this._write(1, val);
              this._bubbleDown(1, val);
            }
            return ret;
          };
          BHeapStrategy2.prototype.peek = function() {
            return this._read(1);
          };
          BHeapStrategy2.prototype.clear = function() {
            this.length = 0;
            this._memory.length = 0;
            return void 0;
          };
          BHeapStrategy2.prototype._write = function(index2, value) {
            var page;
            page = index2 >> this._shift;
            while (page >= this._memory.length) {
              this._memory.push(this._emptyMemoryPageTemplate.slice(0));
            }
            return this._memory[page][index2 & this._mask] = value;
          };
          BHeapStrategy2.prototype._read = function(index2) {
            return this._memory[index2 >> this._shift][index2 & this._mask];
          };
          BHeapStrategy2.prototype._bubbleUp = function(index2, value) {
            var compare, indexInPage, parentIndex, parentValue;
            compare = this.comparator;
            while (index2 > 1) {
              indexInPage = index2 & this._mask;
              if (index2 < this.pageSize || indexInPage > 3) {
                parentIndex = index2 & ~this._mask | indexInPage >> 1;
              } else if (indexInPage < 2) {
                parentIndex = index2 - this.pageSize >> this._shift;
                parentIndex += parentIndex & ~(this._mask >> 1);
                parentIndex |= this.pageSize >> 1;
              } else {
                parentIndex = index2 - 2;
              }
              parentValue = this._read(parentIndex);
              if (compare(parentValue, value) < 0) {
                break;
              }
              this._write(parentIndex, value);
              this._write(index2, parentValue);
              index2 = parentIndex;
            }
            return void 0;
          };
          BHeapStrategy2.prototype._bubbleDown = function(index2, value) {
            var childIndex1, childIndex2, childValue1, childValue2, compare;
            compare = this.comparator;
            while (index2 < this.length) {
              if (index2 > this._mask && !(index2 & this._mask - 1)) {
                childIndex1 = childIndex2 = index2 + 2;
              } else if (index2 & this.pageSize >> 1) {
                childIndex1 = (index2 & ~this._mask) >> 1;
                childIndex1 |= index2 & this._mask >> 1;
                childIndex1 = childIndex1 + 1 << this._shift;
                childIndex2 = childIndex1 + 1;
              } else {
                childIndex1 = index2 + (index2 & this._mask);
                childIndex2 = childIndex1 + 1;
              }
              if (childIndex1 !== childIndex2 && childIndex2 <= this.length) {
                childValue1 = this._read(childIndex1);
                childValue2 = this._read(childIndex2);
                if (compare(childValue1, value) < 0 && compare(childValue1, childValue2) <= 0) {
                  this._write(childIndex1, value);
                  this._write(index2, childValue1);
                  index2 = childIndex1;
                } else if (compare(childValue2, value) < 0) {
                  this._write(childIndex2, value);
                  this._write(index2, childValue2);
                  index2 = childIndex2;
                } else {
                  break;
                }
              } else if (childIndex1 <= this.length) {
                childValue1 = this._read(childIndex1);
                if (compare(childValue1, value) < 0) {
                  this._write(childIndex1, value);
                  this._write(index2, childValue1);
                  index2 = childIndex1;
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            return void 0;
          };
          return BHeapStrategy2;
        }();
      }, {}], 5: [function(_dereq_, module4, exports4) {
        var BinaryHeapStrategy;
        module4.exports = BinaryHeapStrategy = function() {
          function BinaryHeapStrategy2(options) {
            var ref;
            this.comparator = (options != null ? options.comparator : void 0) || function(a3, b2) {
              return a3 - b2;
            };
            this.length = 0;
            this.data = ((ref = options.initialValues) != null ? ref.slice(0) : void 0) || [];
            this._heapify();
          }
          BinaryHeapStrategy2.prototype._heapify = function() {
            var i3, j2, ref;
            if (this.data.length > 0) {
              for (i3 = j2 = 1, ref = this.data.length; 1 <= ref ? j2 < ref : j2 > ref; i3 = 1 <= ref ? ++j2 : --j2) {
                this._bubbleUp(i3);
              }
            }
            return void 0;
          };
          BinaryHeapStrategy2.prototype.queue = function(value) {
            this.data.push(value);
            this._bubbleUp(this.data.length - 1);
            return void 0;
          };
          BinaryHeapStrategy2.prototype.dequeue = function() {
            var last, ret;
            ret = this.data[0];
            last = this.data.pop();
            if (this.data.length > 0) {
              this.data[0] = last;
              this._bubbleDown(0);
            }
            return ret;
          };
          BinaryHeapStrategy2.prototype.peek = function() {
            return this.data[0];
          };
          BinaryHeapStrategy2.prototype.clear = function() {
            this.length = 0;
            this.data.length = 0;
            return void 0;
          };
          BinaryHeapStrategy2.prototype._bubbleUp = function(pos) {
            var parent, x2;
            while (pos > 0) {
              parent = pos - 1 >>> 1;
              if (this.comparator(this.data[pos], this.data[parent]) < 0) {
                x2 = this.data[parent];
                this.data[parent] = this.data[pos];
                this.data[pos] = x2;
                pos = parent;
              } else {
                break;
              }
            }
            return void 0;
          };
          BinaryHeapStrategy2.prototype._bubbleDown = function(pos) {
            var last, left, minIndex, right, x2;
            last = this.data.length - 1;
            while (true) {
              left = (pos << 1) + 1;
              right = left + 1;
              minIndex = pos;
              if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {
                minIndex = left;
              }
              if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {
                minIndex = right;
              }
              if (minIndex !== pos) {
                x2 = this.data[minIndex];
                this.data[minIndex] = this.data[pos];
                this.data[pos] = x2;
                pos = minIndex;
              } else {
                break;
              }
            }
            return void 0;
          };
          return BinaryHeapStrategy2;
        }();
      }, {}] }, {}, [1])(1);
    });
  }
});

// node_modules/web-worker-manager/src/workerTemplate.js
var require_workerTemplate = __commonJS({
  "node_modules/web-worker-manager/src/workerTemplate.js"(exports2) {
    "use strict";
    var worker2 = function() {
      var window2 = self.window = self;
      function ManagedWorker() {
        this._listeners = {};
      }
      ManagedWorker.prototype.on = function(event, callback) {
        if (this._listeners[event])
          throw new RangeError("there is already a listener for " + event);
        if (typeof callback !== "function")
          throw new TypeError("callback argument must be a function");
        this._listeners[event] = callback;
      };
      ManagedWorker.prototype._send = function(id, data, transferable) {
        if (transferable === void 0) {
          transferable = [];
        } else if (!Array.isArray(transferable)) {
          transferable = [transferable];
        }
        self.postMessage({
          id,
          data
        }, transferable);
      };
      ManagedWorker.prototype._trigger = function(event, args) {
        if (!this._listeners[event])
          throw new Error("event " + event + " is not defined");
        this._listeners[event].apply(null, args);
      };
      var worker3 = new ManagedWorker();
      self.onmessage = function(event) {
        switch (event.data.action) {
          case "exec":
            event.data.args.unshift(function(data, transferable) {
              worker3._send(event.data.id, data, transferable);
            });
            worker3._trigger(event.data.event, event.data.args);
            break;
          case "ping":
            worker3._send(event.data.id, "pong");
            break;
          default:
            throw new Error("unexpected action: " + event.data.action);
        }
      };
      "CODE";
    };
    var workerStr = worker2.toString().split('"CODE";');
    exports2.newWorkerURL = function newWorkerURL(code, deps) {
      var blob = new Blob(["(", workerStr[0], "importScripts.apply(self, " + JSON.stringify(deps) + ");\n", "(", code, ")();", workerStr[1], ")();"], { type: "application/javascript" });
      return URL.createObjectURL(blob);
    };
  }
});

// node_modules/web-worker-manager/src/index.js
var require_src6 = __commonJS({
  "node_modules/web-worker-manager/src/index.js"(exports2, module2) {
    "use strict";
    var workerTemplate = require_workerTemplate();
    var CORES = navigator.hardwareConcurrency || 1;
    var noop2 = Function.prototype;
    function WorkerManager2(func, options) {
      if (typeof func !== "string" && typeof func !== "function")
        throw new TypeError("func argument must be a function");
      if (options === void 0)
        options = {};
      if (typeof options !== "object" || options === null)
        throw new TypeError("options argument must be an object");
      this._workerCode = func.toString();
      if (options.maxWorkers === void 0 || options.maxWorkers === "auto") {
        this._numWorkers = Math.min(CORES - 1, 1);
      } else if (options.maxWorkers > 0) {
        this._numWorkers = Math.min(options.maxWorkers, CORES);
      } else {
        this._numWorkers = CORES;
      }
      this._workers = /* @__PURE__ */ new Map();
      this._timeout = options.timeout || 0;
      this._terminateOnError = !!options.terminateOnError;
      var deps = options.deps;
      if (typeof deps === "string")
        deps = [deps];
      if (!Array.isArray(deps))
        deps = void 0;
      this._id = 0;
      this._terminated = false;
      this._working = 0;
      this._waiting = [];
      this._init(deps);
    }
    WorkerManager2.prototype._init = function(deps) {
      var workerURL = workerTemplate.newWorkerURL(this._workerCode, deps);
      for (var i3 = 0; i3 < this._numWorkers; i3++) {
        var worker2 = new Worker(workerURL);
        worker2.onmessage = this._onmessage.bind(this, worker2);
        worker2.onerror = this._onerror.bind(this, worker2);
        worker2.running = false;
        worker2.id = i3;
        this._workers.set(worker2, null);
      }
      URL.revokeObjectURL(workerURL);
    };
    WorkerManager2.prototype._onerror = function(worker2, error) {
      if (this._terminated)
        return;
      this._working--;
      worker2.running = false;
      var callback = this._workers.get(worker2);
      if (callback) {
        callback[1](error.message);
      }
      this._workers.set(worker2, null);
      if (this._terminateOnError) {
        this.terminate();
      } else {
        this._exec();
      }
    };
    WorkerManager2.prototype._onmessage = function(worker2, event) {
      if (this._terminated)
        return;
      this._working--;
      worker2.running = false;
      var callback = this._workers.get(worker2);
      if (callback) {
        callback[0](event.data.data);
      }
      this._workers.set(worker2, null);
      this._exec();
    };
    WorkerManager2.prototype._exec = function() {
      for (var worker2 of this._workers.keys()) {
        if (this._working === this._numWorkers || this._waiting.length === 0) {
          return;
        }
        if (!worker2.running) {
          for (var i3 = 0; i3 < this._waiting.length; i3++) {
            var execInfo = this._waiting[i3];
            if (typeof execInfo[4] === "number" && execInfo[4] !== worker2.id) {
              continue;
            }
            this._waiting.splice(i3, 1);
            worker2.postMessage({
              action: "exec",
              event: execInfo[0],
              args: execInfo[1]
            }, execInfo[2]);
            worker2.running = true;
            worker2.time = Date.now();
            this._workers.set(worker2, execInfo[3]);
            this._working++;
            break;
          }
        }
      }
    };
    WorkerManager2.prototype.terminate = function() {
      if (this._terminated)
        return;
      for (var entry of this._workers) {
        entry[0].terminate();
        if (entry[1]) {
          entry[1][1](new Error("Terminated"));
        }
      }
      this._workers.clear();
      this._waiting = [];
      this._working = 0;
      this._terminated = true;
    };
    WorkerManager2.prototype.postAll = function(event, args) {
      if (this._terminated)
        throw new Error("Cannot post (terminated)");
      var promises = [];
      for (var worker2 of this._workers.keys()) {
        promises.push(this.post(event, args, [], worker2.id));
      }
      return Promise.all(promises);
    };
    WorkerManager2.prototype.post = function(event, args, transferable, id) {
      if (args === void 0)
        args = [];
      if (transferable === void 0)
        transferable = [];
      if (!Array.isArray(args)) {
        args = [args];
      }
      if (!Array.isArray(transferable)) {
        transferable = [transferable];
      }
      var self2 = this;
      return new Promise(function(resolve2, reject2) {
        if (self2._terminated)
          throw new Error("Cannot post (terminated)");
        self2._waiting.push([event, args, transferable, [resolve2, reject2], id]);
        self2._exec();
      });
    };
    module2.exports = WorkerManager2;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i3 = 0, len = args.length; i3 < len; i3++) {
        var arg = args[i3];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb2 = [0, 0, 0, 1];
      var match;
      var i3;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i3 = 0; i3 < 3; i3++) {
          var i22 = i3 * 2;
          rgb2[i3] = parseInt(match.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb2[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i3 = 0; i3 < 3; i3++) {
          rgb2[i3] = parseInt(match[i3] + match[i3], 16);
        }
        if (hexAlpha) {
          rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i3 = 0; i3 < 3; i3++) {
          rgb2[i3] = parseInt(match[i3 + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb2[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb2[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i3 = 0; i3 < 3; i3++) {
          rgb2[i3] = Math.round(parseFloat(match[i3 + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb2[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb2[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb2 = colorNames[match[1]];
        rgb2[3] = 1;
        return rgb2;
      } else {
        return null;
      }
      for (i3 = 0; i3 < 3; i3++) {
        rgb2[i3] = clamp2(rgb2[i3], 0, 255);
      }
      rgb2[3] = clamp2(rgb2[3], 0, 1);
      return rgb2;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl3 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl3);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h3 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s3 = clamp2(parseFloat(match[2]), 0, 100);
        var l3 = clamp2(parseFloat(match[3]), 0, 100);
        var a3 = clamp2(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h3, s3, l3, a3];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h3 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w2 = clamp2(parseFloat(match[2]), 0, 100);
        var b2 = clamp2(parseFloat(match[3]), 0, 100);
        var a3 = clamp2(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h3, w2, b2, a3];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r2 = Math.round(rgba[0] / 255 * 100);
      var g2 = Math.round(rgba[1] / 255 * 100);
      var b2 = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b2 + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b2 + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla2 = swizzle(arguments);
      return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a3 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a3 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a3 + ")";
    };
    cs.to.keyword = function(rgb2) {
      return reverseNames[rgb2.slice(0, 3)];
    };
    function clamp2(num, min3, max4) {
      return Math.min(Math.max(min3, num), max4);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb2) {
      const r2 = rgb2[0] / 255;
      const g2 = rgb2[1] / 255;
      const b2 = rgb2[2] / 255;
      const min3 = Math.min(r2, g2, b2);
      const max4 = Math.max(r2, g2, b2);
      const delta = max4 - min3;
      let h3;
      let s3;
      if (max4 === min3) {
        h3 = 0;
      } else if (r2 === max4) {
        h3 = (g2 - b2) / delta;
      } else if (g2 === max4) {
        h3 = 2 + (b2 - r2) / delta;
      } else if (b2 === max4) {
        h3 = 4 + (r2 - g2) / delta;
      }
      h3 = Math.min(h3 * 60, 360);
      if (h3 < 0) {
        h3 += 360;
      }
      const l3 = (min3 + max4) / 2;
      if (max4 === min3) {
        s3 = 0;
      } else if (l3 <= 0.5) {
        s3 = delta / (max4 + min3);
      } else {
        s3 = delta / (2 - max4 - min3);
      }
      return [h3, s3 * 100, l3 * 100];
    };
    convert.rgb.hsv = function(rgb2) {
      let rdif;
      let gdif;
      let bdif;
      let h3;
      let s3;
      const r2 = rgb2[0] / 255;
      const g2 = rgb2[1] / 255;
      const b2 = rgb2[2] / 255;
      const v3 = Math.max(r2, g2, b2);
      const diff = v3 - Math.min(r2, g2, b2);
      const diffc = function(c4) {
        return (v3 - c4) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h3 = 0;
        s3 = 0;
      } else {
        s3 = diff / v3;
        rdif = diffc(r2);
        gdif = diffc(g2);
        bdif = diffc(b2);
        if (r2 === v3) {
          h3 = bdif - gdif;
        } else if (g2 === v3) {
          h3 = 1 / 3 + rdif - bdif;
        } else if (b2 === v3) {
          h3 = 2 / 3 + gdif - rdif;
        }
        if (h3 < 0) {
          h3 += 1;
        } else if (h3 > 1) {
          h3 -= 1;
        }
      }
      return [
        h3 * 360,
        s3 * 100,
        v3 * 100
      ];
    };
    convert.rgb.hwb = function(rgb2) {
      const r2 = rgb2[0];
      const g2 = rgb2[1];
      let b2 = rgb2[2];
      const h3 = convert.rgb.hsl(rgb2)[0];
      const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
      b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
      return [h3, w2 * 100, b2 * 100];
    };
    convert.rgb.cmyk = function(rgb2) {
      const r2 = rgb2[0] / 255;
      const g2 = rgb2[1] / 255;
      const b2 = rgb2[2] / 255;
      const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
      const c4 = (1 - r2 - k2) / (1 - k2) || 0;
      const m4 = (1 - g2 - k2) / (1 - k2) || 0;
      const y3 = (1 - b2 - k2) / (1 - k2) || 0;
      return [c4 * 100, m4 * 100, y3 * 100, k2 * 100];
    };
    function comparativeDistance(x2, y3) {
      return (x2[0] - y3[0]) ** 2 + (x2[1] - y3[1]) ** 2 + (x2[2] - y3[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb2) {
      const reversed = reverseKeywords[rgb2];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb2, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb2) {
      let r2 = rgb2[0] / 255;
      let g2 = rgb2[1] / 255;
      let b2 = rgb2[2] / 255;
      r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
      g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
      b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
      const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
      const y3 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
      const z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
      return [x2 * 100, y3 * 100, z2 * 100];
    };
    convert.rgb.lab = function(rgb2) {
      const xyz = convert.rgb.xyz(rgb2);
      let x2 = xyz[0];
      let y3 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y3 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l3 = 116 * y3 - 16;
      const a3 = 500 * (x2 - y3);
      const b2 = 200 * (y3 - z2);
      return [l3, a3, b2];
    };
    convert.hsl.rgb = function(hsl3) {
      const h3 = hsl3[0] / 360;
      const s3 = hsl3[1] / 100;
      const l3 = hsl3[2] / 100;
      let t22;
      let t3;
      let val;
      if (s3 === 0) {
        val = l3 * 255;
        return [val, val, val];
      }
      if (l3 < 0.5) {
        t22 = l3 * (1 + s3);
      } else {
        t22 = l3 + s3 - l3 * s3;
      }
      const t1 = 2 * l3 - t22;
      const rgb2 = [0, 0, 0];
      for (let i3 = 0; i3 < 3; i3++) {
        t3 = h3 + 1 / 3 * -(i3 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t22 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t22;
        } else if (3 * t3 < 2) {
          val = t1 + (t22 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb2[i3] = val * 255;
      }
      return rgb2;
    };
    convert.hsl.hsv = function(hsl3) {
      const h3 = hsl3[0];
      let s3 = hsl3[1] / 100;
      let l3 = hsl3[2] / 100;
      let smin = s3;
      const lmin = Math.max(l3, 0.01);
      l3 *= 2;
      s3 *= l3 <= 1 ? l3 : 2 - l3;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v3 = (l3 + s3) / 2;
      const sv = l3 === 0 ? 2 * smin / (lmin + smin) : 2 * s3 / (l3 + s3);
      return [h3, sv * 100, v3 * 100];
    };
    convert.hsv.rgb = function(hsv2) {
      const h3 = hsv2[0] / 60;
      const s3 = hsv2[1] / 100;
      let v3 = hsv2[2] / 100;
      const hi = Math.floor(h3) % 6;
      const f3 = h3 - Math.floor(h3);
      const p3 = 255 * v3 * (1 - s3);
      const q2 = 255 * v3 * (1 - s3 * f3);
      const t3 = 255 * v3 * (1 - s3 * (1 - f3));
      v3 *= 255;
      switch (hi) {
        case 0:
          return [v3, t3, p3];
        case 1:
          return [q2, v3, p3];
        case 2:
          return [p3, v3, t3];
        case 3:
          return [p3, q2, v3];
        case 4:
          return [t3, p3, v3];
        case 5:
          return [v3, p3, q2];
      }
    };
    convert.hsv.hsl = function(hsv2) {
      const h3 = hsv2[0];
      const s3 = hsv2[1] / 100;
      const v3 = hsv2[2] / 100;
      const vmin = Math.max(v3, 0.01);
      let sl;
      let l3;
      l3 = (2 - s3) * v3;
      const lmin = (2 - s3) * vmin;
      sl = s3 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l3 /= 2;
      return [h3, sl * 100, l3 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h3 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f3;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i3 = Math.floor(6 * h3);
      const v3 = 1 - bl;
      f3 = 6 * h3 - i3;
      if ((i3 & 1) !== 0) {
        f3 = 1 - f3;
      }
      const n3 = wh + f3 * (v3 - wh);
      let r2;
      let g2;
      let b2;
      switch (i3) {
        default:
        case 6:
        case 0:
          r2 = v3;
          g2 = n3;
          b2 = wh;
          break;
        case 1:
          r2 = n3;
          g2 = v3;
          b2 = wh;
          break;
        case 2:
          r2 = wh;
          g2 = v3;
          b2 = n3;
          break;
        case 3:
          r2 = wh;
          g2 = n3;
          b2 = v3;
          break;
        case 4:
          r2 = n3;
          g2 = wh;
          b2 = v3;
          break;
        case 5:
          r2 = v3;
          g2 = wh;
          b2 = n3;
          break;
      }
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert.cmyk.rgb = function(cmyk2) {
      const c4 = cmyk2[0] / 100;
      const m4 = cmyk2[1] / 100;
      const y3 = cmyk2[2] / 100;
      const k2 = cmyk2[3] / 100;
      const r2 = 1 - Math.min(1, c4 * (1 - k2) + k2);
      const g2 = 1 - Math.min(1, m4 * (1 - k2) + k2);
      const b2 = 1 - Math.min(1, y3 * (1 - k2) + k2);
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x2 = xyz[0] / 100;
      const y3 = xyz[1] / 100;
      const z2 = xyz[2] / 100;
      let r2;
      let g2;
      let b2;
      r2 = x2 * 3.2406 + y3 * -1.5372 + z2 * -0.4986;
      g2 = x2 * -0.9689 + y3 * 1.8758 + z2 * 0.0415;
      b2 = x2 * 0.0557 + y3 * -0.204 + z2 * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
      b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b2 = Math.min(Math.max(0, b2), 1);
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x2 = xyz[0];
      let y3 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y3 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l3 = 116 * y3 - 16;
      const a3 = 500 * (x2 - y3);
      const b2 = 200 * (y3 - z2);
      return [l3, a3, b2];
    };
    convert.lab.xyz = function(lab) {
      const l3 = lab[0];
      const a3 = lab[1];
      const b2 = lab[2];
      let x2;
      let y3;
      let z2;
      y3 = (l3 + 16) / 116;
      x2 = a3 / 500 + y3;
      z2 = y3 - b2 / 200;
      const y22 = y3 ** 3;
      const x22 = x2 ** 3;
      const z22 = z2 ** 3;
      y3 = y22 > 8856e-6 ? y22 : (y3 - 16 / 116) / 7.787;
      x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x2 *= 95.047;
      y3 *= 100;
      z2 *= 108.883;
      return [x2, y3, z2];
    };
    convert.lab.lch = function(lab) {
      const l3 = lab[0];
      const a3 = lab[1];
      const b2 = lab[2];
      let h3;
      const hr = Math.atan2(b2, a3);
      h3 = hr * 360 / 2 / Math.PI;
      if (h3 < 0) {
        h3 += 360;
      }
      const c4 = Math.sqrt(a3 * a3 + b2 * b2);
      return [l3, c4, h3];
    };
    convert.lch.lab = function(lch) {
      const l3 = lch[0];
      const c4 = lch[1];
      const h3 = lch[2];
      const hr = h3 / 360 * 2 * Math.PI;
      const a3 = c4 * Math.cos(hr);
      const b2 = c4 * Math.sin(hr);
      return [l3, a3, b2];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r2, g2, b2] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r2 = args[0];
      const g2 = args[1];
      const b2 = args[2];
      if (r2 === g2 && g2 === b2) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r2 = (color & 1) * mult * 255;
      const g2 = (color >> 1 & 1) * mult * 255;
      const b2 = (color >> 2 & 1) * mult * 255;
      return [r2, g2, b2];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c4 = (args - 232) * 10 + 8;
        return [c4, c4, c4];
      }
      args -= 16;
      let rem;
      const r2 = Math.floor(args / 36) / 5 * 255;
      const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b2 = rem % 6 / 5 * 255;
      return [r2, g2, b2];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r2 = integer >> 16 & 255;
      const g2 = integer >> 8 & 255;
      const b2 = integer & 255;
      return [r2, g2, b2];
    };
    convert.rgb.hcg = function(rgb2) {
      const r2 = rgb2[0] / 255;
      const g2 = rgb2[1] / 255;
      const b2 = rgb2[2] / 255;
      const max4 = Math.max(Math.max(r2, g2), b2);
      const min3 = Math.min(Math.min(r2, g2), b2);
      const chroma = max4 - min3;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min3 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max4 === r2) {
        hue = (g2 - b2) / chroma % 6;
      } else if (max4 === g2) {
        hue = 2 + (b2 - r2) / chroma;
      } else {
        hue = 4 + (r2 - g2) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl3) {
      const s3 = hsl3[1] / 100;
      const l3 = hsl3[2] / 100;
      const c4 = l3 < 0.5 ? 2 * s3 * l3 : 2 * s3 * (1 - l3);
      let f3 = 0;
      if (c4 < 1) {
        f3 = (l3 - 0.5 * c4) / (1 - c4);
      }
      return [hsl3[0], c4 * 100, f3 * 100];
    };
    convert.hsv.hcg = function(hsv2) {
      const s3 = hsv2[1] / 100;
      const v3 = hsv2[2] / 100;
      const c4 = s3 * v3;
      let f3 = 0;
      if (c4 < 1) {
        f3 = (v3 - c4) / (1 - c4);
      }
      return [hsv2[0], c4 * 100, f3 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h3 = hcg[0] / 360;
      const c4 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      if (c4 === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      const pure = [0, 0, 0];
      const hi = h3 % 1 * 6;
      const v3 = hi % 1;
      const w2 = 1 - v3;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v3;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v3;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v3;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg = (1 - c4) * g2;
      return [
        (c4 * pure[0] + mg) * 255,
        (c4 * pure[1] + mg) * 255,
        (c4 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c4 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v3 = c4 + g2 * (1 - c4);
      let f3 = 0;
      if (v3 > 0) {
        f3 = c4 / v3;
      }
      return [hcg[0], f3 * 100, v3 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c4 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const l3 = g2 * (1 - c4) + 0.5 * c4;
      let s3 = 0;
      if (l3 > 0 && l3 < 0.5) {
        s3 = c4 / (2 * l3);
      } else if (l3 >= 0.5 && l3 < 1) {
        s3 = c4 / (2 * (1 - l3));
      }
      return [hcg[0], s3 * 100, l3 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c4 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v3 = c4 + g2 * (1 - c4);
      return [hcg[0], (v3 - c4) * 100, (1 - v3) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w2 = hwb[1] / 100;
      const b2 = hwb[2] / 100;
      const v3 = 1 - b2;
      const c4 = v3 - w2;
      let g2 = 0;
      if (c4 < 1) {
        g2 = (v3 - c4) / (1 - c4);
      }
      return [hwb[0], c4 * 100, g2 * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb2) {
      return [rgb2[0] / 255 * 65535, rgb2[1] / 255 * 65535, rgb2[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb2) {
      const val = (rgb2[0] + rgb2[1] + rgb2[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i3 = 0; i3 < len; i3++) {
        graph[models[i3]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i3 = 0; i3 < len; i3++) {
          const adjacent = adjacents[i3];
          const node2 = graph[adjacent];
          if (node2.distance === -1) {
            node2.distance = graph[current].distance + 1;
            node2.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i3 = 0; i3 < len; i3++) {
        const toModel = models[i3];
        const node2 = graph[toModel];
        if (node2.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i3 = 0; i3 < len; i3++) {
            result[i3] = Math.round(result[i3]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports2, module2) {
    var colorString = require_color_string();
    var convert = require_color_convert();
    var skippedModels = [
      // To be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // Gray conflicts with some method names, and has its own method defined.
      "gray",
      // Shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    for (const model of Object.keys(convert)) {
      hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
    }
    var limiters = {};
    function Color2(object, model) {
      if (!(this instanceof Color2)) {
        return new Color2(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      let i3;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color2) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = colorString.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        const newArray8 = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray8, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys = Object.keys(object);
        if ("alpha" in object) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = convert[this.model];
        const color = [];
        for (i3 = 0; i3 < labels.length; i3++) {
          color.push(object[labels[i3]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i3 = 0; i3 < channels; i3++) {
          const limit = limiters[this.model][i3];
          if (limit) {
            this.color[i3] = limit(this.color[i3]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color2.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return colorString.to[self2.model](args);
      },
      percentString(places) {
        const self2 = this.rgb().round(typeof places === "number" ? places : 1);
        const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return colorString.to.rgb.percent(args);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = convert[this.model];
        const { labels } = convert[this.model];
        for (let i3 = 0; i3 < channels; i3++) {
          result[labels[i3]] = this.color[i3];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb2 = this.rgb().color;
        rgb2[0] /= 255;
        rgb2[1] /= 255;
        rgb2[2] /= 255;
        if (this.valpha !== 1) {
          rgb2.push(this.valpha);
        }
        return rgb2;
      },
      unitObject() {
        const rgb2 = this.rgb().object();
        rgb2.r /= 255;
        rgb2.g /= 255;
        rgb2.b /= 255;
        if (this.valpha !== 1) {
          rgb2.alpha = this.valpha;
        }
        return rgb2;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color2([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value) {
        if (value !== void 0) {
          return new Color2([...this.color, Math.max(0, Math.min(1, value))], this.model);
        }
        return this.valpha;
      },
      // Rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value) {
        if (value !== void 0) {
          return new Color2(value);
        }
        return convert[this.model].keyword(this.color);
      },
      hex(value) {
        if (value !== void 0) {
          return new Color2(value);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      hexa(value) {
        if (value !== void 0) {
          return new Color2(value);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return colorString.to.hex(rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb2 = this.rgb().color;
        return (rgb2[0] & 255) << 16 | (rgb2[1] & 255) << 8 | rgb2[2] & 255;
      },
      luminosity() {
        const rgb2 = this.rgb().color;
        const lum = [];
        for (const [i3, element] of rgb2.entries()) {
          const chan = element / 255;
          lum[i3] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb2 = this.rgb().color;
        const yiq = (rgb2[0] * 2126 + rgb2[1] * 7152 + rgb2[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb2 = this.rgb();
        for (let i3 = 0; i3 < 3; i3++) {
          rgb2.color[i3] = 255 - rgb2.color[i3];
        }
        return rgb2;
      },
      lighten(ratio) {
        const hsl3 = this.hsl();
        hsl3.color[2] += hsl3.color[2] * ratio;
        return hsl3;
      },
      darken(ratio) {
        const hsl3 = this.hsl();
        hsl3.color[2] -= hsl3.color[2] * ratio;
        return hsl3;
      },
      saturate(ratio) {
        const hsl3 = this.hsl();
        hsl3.color[1] += hsl3.color[1] * ratio;
        return hsl3;
      },
      desaturate(ratio) {
        const hsl3 = this.hsl();
        hsl3.color[1] -= hsl3.color[1] * ratio;
        return hsl3;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb2 = this.rgb().color;
        const value = rgb2[0] * 0.3 + rgb2[1] * 0.59 + rgb2[2] * 0.11;
        return Color2.rgb(value, value, value);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl3 = this.hsl();
        let hue = hsl3.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl3.color[0] = hue;
        return hsl3;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p3 = weight === void 0 ? 0.5 : weight;
        const w2 = 2 * p3 - 1;
        const a3 = color1.alpha() - color2.alpha();
        const w1 = ((w2 * a3 === -1 ? w2 : (w2 + a3) / (1 + w2 * a3)) + 1) / 2;
        const w22 = 1 - w1;
        return Color2.rgb(
          w1 * color1.red() + w22 * color2.red(),
          w1 * color1.green() + w22 * color2.green(),
          w1 * color1.blue() + w22 * color2.blue(),
          color1.alpha() * p3 + color2.alpha() * (1 - p3)
        );
      }
    };
    for (const model of Object.keys(convert)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = convert[model];
      Color2.prototype[model] = function(...args) {
        if (this.model === model) {
          return new Color2(this);
        }
        if (args.length > 0) {
          return new Color2(args, model);
        }
        return new Color2([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color2[model] = function(...args) {
        let color = args[0];
        if (typeof color === "number") {
          color = zeroArray(args, channels);
        }
        return new Color2(color, model);
      };
    }
    function roundTo(number, places) {
      return Number(number.toFixed(places));
    }
    function roundToPlace(places) {
      return function(number) {
        return roundTo(number, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m4 of model) {
        (limiters[m4] || (limiters[m4] = []))[channel] = modifier;
      }
      model = model[0];
      return function(value) {
        let result;
        if (value !== void 0) {
          if (modifier) {
            value = modifier(value);
          }
          result = this[model]();
          result.color[channel] = value;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max4) {
      return function(v3) {
        return Math.max(0, Math.min(max4, v3));
      };
    }
    function assertArray(value) {
      return Array.isArray(value) ? value : [value];
    }
    function zeroArray(array3, length) {
      for (let i3 = 0; i3 < length; i3++) {
        if (typeof array3[i3] !== "number") {
          array3[i3] = 0;
        }
      }
      return array3;
    }
    module2.exports = Color2;
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o3) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof(o3);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/html2canvas/dist/html2canvas.js
var require_html2canvas = __commonJS({
  "node_modules/html2canvas/dist/html2canvas.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.html2canvas = factory());
    })(exports2, function() {
      "use strict";
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p3 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p3))
              d3[p3] = b3[p3];
        };
        return extendStatics(d2, b2);
      };
      function __extends(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      }
      var __assign = function() {
        __assign = Object.assign || function __assign2(t3) {
          for (var s3, i4 = 1, n3 = arguments.length; i4 < n3; i4++) {
            s3 = arguments[i4];
            for (var p3 in s3)
              if (Object.prototype.hasOwnProperty.call(s3, p3))
                t3[p3] = s3[p3];
          }
          return t3;
        };
        return __assign.apply(this, arguments);
      };
      function __awaiter(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve2, reject2) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject2(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject2(e3);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _3 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f4, y3, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n3) {
          return function(v3) {
            return step([n3, v3]);
          };
        }
        function step(op) {
          if (f4)
            throw new TypeError("Generator is already executing.");
          while (_3)
            try {
              if (f4 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
                return t3;
              if (y3 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _3.label++;
                  return { value: op[1], done: false };
                case 5:
                  _3.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _3.ops.pop();
                  _3.trys.pop();
                  continue;
                default:
                  if (!(t3 = _3.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _3 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _3.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _3.label < t3[1]) {
                    _3.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _3.label < t3[2]) {
                    _3.label = t3[2];
                    _3.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _3.ops.pop();
                  _3.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _3);
            } catch (e3) {
              op = [6, e3];
              y3 = 0;
            } finally {
              f4 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      function __spreadArray(to, from, pack2) {
        if (pack2 || arguments.length === 2)
          for (var i4 = 0, l3 = from.length, ar; i4 < l3; i4++) {
            if (ar || !(i4 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i4);
              ar[i4] = from[i4];
            }
          }
        return to.concat(ar || from);
      }
      var Bounds = (
        /** @class */
        function() {
          function Bounds2(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
          }
          Bounds2.prototype.add = function(x2, y3, w2, h3) {
            return new Bounds2(this.left + x2, this.top + y3, this.width + w2, this.height + h3);
          };
          Bounds2.fromClientRect = function(context, clientRect) {
            return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
          };
          Bounds2.fromDOMRectList = function(context, domRectList) {
            var domRect = Array.from(domRectList).find(function(rect) {
              return rect.width !== 0;
            });
            return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
          };
          Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
          return Bounds2;
        }()
      );
      var parseBounds = function(context, node2) {
        return Bounds.fromClientRect(context, node2.getBoundingClientRect());
      };
      var parseDocumentSize = function(document2) {
        var body = document2.body;
        var documentElement = document2.documentElement;
        if (!body || !documentElement) {
          throw new Error("Unable to get document size");
        }
        var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
        var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
        return new Bounds(0, 0, width, height);
      };
      var toCodePoints$1 = function(str) {
        var codePoints = [];
        var i4 = 0;
        var length = str.length;
        while (i4 < length) {
          var value = str.charCodeAt(i4++);
          if (value >= 55296 && value <= 56319 && i4 < length) {
            var extra = str.charCodeAt(i4++);
            if ((extra & 64512) === 56320) {
              codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              codePoints.push(value);
              i4--;
            }
          } else {
            codePoints.push(value);
          }
        }
        return codePoints;
      };
      var fromCodePoint$1 = function() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
        }
        var length = codePoints.length;
        if (!length) {
          return "";
        }
        var codeUnits = [];
        var index2 = -1;
        var result = "";
        while (++index2 < length) {
          var codePoint = codePoints[index2];
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (index2 + 1 === length || codeUnits.length > 16384) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
        lookup$2[chars$2.charCodeAt(i$2)] = i$2;
      }
      var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
        lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
      }
      var decode$1 = function(base642) {
        var bufferLength = base642.length * 0.75, len = base642.length, i4, p3 = 0, encoded1, encoded2, encoded3, encoded4;
        if (base642[base642.length - 1] === "=") {
          bufferLength--;
          if (base642[base642.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i4 = 0; i4 < len; i4 += 4) {
          encoded1 = lookup$1$1[base642.charCodeAt(i4)];
          encoded2 = lookup$1$1[base642.charCodeAt(i4 + 1)];
          encoded3 = lookup$1$1[base642.charCodeAt(i4 + 2)];
          encoded4 = lookup$1$1[base642.charCodeAt(i4 + 3)];
          bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      };
      var polyUint16Array$1 = function(buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i4 = 0; i4 < length; i4 += 2) {
          bytes.push(buffer[i4 + 1] << 8 | buffer[i4]);
        }
        return bytes;
      };
      var polyUint32Array$1 = function(buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i4 = 0; i4 < length; i4 += 4) {
          bytes.push(buffer[i4 + 3] << 24 | buffer[i4 + 2] << 16 | buffer[i4 + 1] << 8 | buffer[i4]);
        }
        return bytes;
      };
      var UTRIE2_SHIFT_2$1 = 5;
      var UTRIE2_SHIFT_1$1 = 6 + 5;
      var UTRIE2_INDEX_SHIFT$1 = 2;
      var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
      var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
      var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
      var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
      var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
      var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
      var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
      var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
      var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
      var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
      var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
      var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
      var slice16$1 = function(view, start, end) {
        if (view.slice) {
          return view.slice(start, end);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start, end));
      };
      var slice32$1 = function(view, start, end) {
        if (view.slice) {
          return view.slice(start, end);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start, end));
      };
      var createTrieFromBase64$1 = function(base642, _byteLength) {
        var buffer = decode$1(base642);
        var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
        var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data);
      };
      var Trie$1 = (
        /** @class */
        function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index2;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }()
      );
      var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
        lookup$3[chars$3.charCodeAt(i$3)] = i$3;
      }
      var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
      var LETTER_NUMBER_MODIFIER = 50;
      var BK = 1;
      var CR$1 = 2;
      var LF$1 = 3;
      var CM = 4;
      var NL = 5;
      var WJ = 7;
      var ZW = 8;
      var GL = 9;
      var SP = 10;
      var ZWJ$1 = 11;
      var B2 = 12;
      var BA = 13;
      var BB = 14;
      var HY = 15;
      var CB = 16;
      var CL = 17;
      var CP = 18;
      var EX = 19;
      var IN = 20;
      var NS = 21;
      var OP = 22;
      var QU = 23;
      var IS = 24;
      var NU = 25;
      var PO = 26;
      var PR = 27;
      var SY = 28;
      var AI = 29;
      var AL = 30;
      var CJ = 31;
      var EB = 32;
      var EM = 33;
      var H2 = 34;
      var H3 = 35;
      var HL = 36;
      var ID = 37;
      var JL = 38;
      var JV = 39;
      var JT = 40;
      var RI$1 = 41;
      var SA = 42;
      var XX = 43;
      var ea_OP = [9001, 65288];
      var BREAK_MANDATORY = "!";
      var BREAK_NOT_ALLOWED$1 = "\xD7";
      var BREAK_ALLOWED$1 = "\xF7";
      var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
      var ALPHABETICS = [AL, HL];
      var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
      var SPACE$1 = [SP, ZW];
      var PREFIX_POSTFIX = [PR, PO];
      var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
      var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
      var HYPHEN = [HY, BA];
      var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
        if (lineBreak2 === void 0) {
          lineBreak2 = "strict";
        }
        var types2 = [];
        var indices = [];
        var categories = [];
        codePoints.forEach(function(codePoint, index2) {
          var classType = UnicodeTrie$1.get(codePoint);
          if (classType > LETTER_NUMBER_MODIFIER) {
            categories.push(true);
            classType -= LETTER_NUMBER_MODIFIER;
          } else {
            categories.push(false);
          }
          if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
            if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
              indices.push(index2);
              return types2.push(CB);
            }
          }
          if (classType === CM || classType === ZWJ$1) {
            if (index2 === 0) {
              indices.push(index2);
              return types2.push(AL);
            }
            var prev = types2[index2 - 1];
            if (LINE_BREAKS.indexOf(prev) === -1) {
              indices.push(indices[index2 - 1]);
              return types2.push(prev);
            }
            indices.push(index2);
            return types2.push(AL);
          }
          indices.push(index2);
          if (classType === CJ) {
            return types2.push(lineBreak2 === "strict" ? NS : ID);
          }
          if (classType === SA) {
            return types2.push(AL);
          }
          if (classType === AI) {
            return types2.push(AL);
          }
          if (classType === XX) {
            if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
              return types2.push(ID);
            } else {
              return types2.push(AL);
            }
          }
          types2.push(classType);
        });
        return [indices, types2, categories];
      };
      var isAdjacentWithSpaceIgnored = function(a4, b2, currentIndex, classTypes) {
        var current = classTypes[currentIndex];
        if (Array.isArray(a4) ? a4.indexOf(current) !== -1 : a4 === current) {
          var i4 = currentIndex;
          while (i4 <= classTypes.length) {
            i4++;
            var next = classTypes[i4];
            if (next === b2) {
              return true;
            }
            if (next !== SP) {
              break;
            }
          }
        }
        if (current === SP) {
          var i4 = currentIndex;
          while (i4 > 0) {
            i4--;
            var prev = classTypes[i4];
            if (Array.isArray(a4) ? a4.indexOf(prev) !== -1 : a4 === prev) {
              var n3 = currentIndex;
              while (n3 <= classTypes.length) {
                n3++;
                var next = classTypes[n3];
                if (next === b2) {
                  return true;
                }
                if (next !== SP) {
                  break;
                }
              }
            }
            if (prev !== SP) {
              break;
            }
          }
        }
        return false;
      };
      var previousNonSpaceClassType = function(currentIndex, classTypes) {
        var i4 = currentIndex;
        while (i4 >= 0) {
          var type = classTypes[i4];
          if (type === SP) {
            i4--;
          } else {
            return type;
          }
        }
        return 0;
      };
      var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
        if (indicies[index2] === 0) {
          return BREAK_NOT_ALLOWED$1;
        }
        var currentIndex = index2 - 1;
        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
          return BREAK_NOT_ALLOWED$1;
        }
        var beforeIndex = currentIndex - 1;
        var afterIndex = currentIndex + 1;
        var current = classTypes[currentIndex];
        var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
        var next = classTypes[afterIndex];
        if (current === CR$1 && next === LF$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
          return BREAK_MANDATORY;
        }
        if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (SPACE$1.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
          return BREAK_ALLOWED$1;
        }
        if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === WJ || next === WJ) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === GL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === SP) {
          return BREAK_ALLOWED$1;
        }
        if (current === QU || next === QU) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (next === CB || current === CB) {
          return BREAK_ALLOWED$1;
        }
        if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (before === HL && HYPHEN.indexOf(current) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === SY && next === HL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (next === IN) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (
          // (PR | PO) × ( OP | HY )? NU
          [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) × NU
          [OP, HY].indexOf(current) !== -1 && next === NU || // NU ×	(NU | SY | IS)
          current === NU && [NU, SY, IS].indexOf(next) !== -1
        ) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
          var prevIndex = currentIndex;
          while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
              return BREAK_NOT_ALLOWED$1;
            } else if ([SY, IS].indexOf(type) !== -1) {
              prevIndex--;
            } else {
              break;
            }
          }
        }
        if ([PR, PO].indexOf(next) !== -1) {
          var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
          while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
              return BREAK_NOT_ALLOWED$1;
            } else if ([SY, IS].indexOf(type) !== -1) {
              prevIndex--;
            } else {
              break;
            }
          }
        }
        if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === RI$1 && next === RI$1) {
          var i4 = indicies[currentIndex];
          var count = 1;
          while (i4 > 0) {
            i4--;
            if (classTypes[i4] === RI$1) {
              count++;
            } else {
              break;
            }
          }
          if (count % 2 !== 0) {
            return BREAK_NOT_ALLOWED$1;
          }
        }
        if (current === EB && next === EM) {
          return BREAK_NOT_ALLOWED$1;
        }
        return BREAK_ALLOWED$1;
      };
      var cssFormattedClasses = function(codePoints, options) {
        if (!options) {
          options = { lineBreak: "normal", wordBreak: "normal" };
        }
        var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
        if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
          classTypes = classTypes.map(function(type) {
            return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
          });
        }
        var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i4) {
          return letterNumber && codePoints[i4] >= 19968 && codePoints[i4] <= 40959;
        }) : void 0;
        return [indicies, classTypes, forbiddenBreakpoints];
      };
      var Break = (
        /** @class */
        function() {
          function Break2(codePoints, lineBreak2, start, end) {
            this.codePoints = codePoints;
            this.required = lineBreak2 === BREAK_MANDATORY;
            this.start = start;
            this.end = end;
          }
          Break2.prototype.slice = function() {
            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
          };
          return Break2;
        }()
      );
      var LineBreaker = function(str, options) {
        var codePoints = toCodePoints$1(str);
        var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
        var length = codePoints.length;
        var lastEnd = 0;
        var nextIndex = 0;
        return {
          next: function() {
            if (nextIndex >= length) {
              return { done: true, value: null };
            }
            var lineBreak2 = BREAK_NOT_ALLOWED$1;
            while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
            }
            if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
              var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
              lastEnd = nextIndex;
              return { value, done: false };
            }
            return { done: true, value: null };
          }
        };
      };
      var FLAG_UNRESTRICTED = 1 << 0;
      var FLAG_ID = 1 << 1;
      var FLAG_INTEGER = 1 << 2;
      var FLAG_NUMBER = 1 << 3;
      var LINE_FEED = 10;
      var SOLIDUS = 47;
      var REVERSE_SOLIDUS = 92;
      var CHARACTER_TABULATION = 9;
      var SPACE = 32;
      var QUOTATION_MARK = 34;
      var EQUALS_SIGN = 61;
      var NUMBER_SIGN = 35;
      var DOLLAR_SIGN = 36;
      var PERCENTAGE_SIGN = 37;
      var APOSTROPHE = 39;
      var LEFT_PARENTHESIS = 40;
      var RIGHT_PARENTHESIS = 41;
      var LOW_LINE = 95;
      var HYPHEN_MINUS = 45;
      var EXCLAMATION_MARK = 33;
      var LESS_THAN_SIGN = 60;
      var GREATER_THAN_SIGN = 62;
      var COMMERCIAL_AT = 64;
      var LEFT_SQUARE_BRACKET = 91;
      var RIGHT_SQUARE_BRACKET = 93;
      var CIRCUMFLEX_ACCENT = 61;
      var LEFT_CURLY_BRACKET = 123;
      var QUESTION_MARK = 63;
      var RIGHT_CURLY_BRACKET = 125;
      var VERTICAL_LINE = 124;
      var TILDE = 126;
      var CONTROL = 128;
      var REPLACEMENT_CHARACTER = 65533;
      var ASTERISK = 42;
      var PLUS_SIGN = 43;
      var COMMA = 44;
      var COLON = 58;
      var SEMICOLON = 59;
      var FULL_STOP = 46;
      var NULL2 = 0;
      var BACKSPACE = 8;
      var LINE_TABULATION = 11;
      var SHIFT_OUT = 14;
      var INFORMATION_SEPARATOR_ONE = 31;
      var DELETE = 127;
      var EOF = -1;
      var ZERO = 48;
      var a3 = 97;
      var e2 = 101;
      var f3 = 102;
      var u3 = 117;
      var z2 = 122;
      var A2 = 65;
      var E2 = 69;
      var F2 = 70;
      var U2 = 85;
      var Z2 = 90;
      var isDigit = function(codePoint) {
        return codePoint >= ZERO && codePoint <= 57;
      };
      var isSurrogateCodePoint = function(codePoint) {
        return codePoint >= 55296 && codePoint <= 57343;
      };
      var isHex = function(codePoint) {
        return isDigit(codePoint) || codePoint >= A2 && codePoint <= F2 || codePoint >= a3 && codePoint <= f3;
      };
      var isLowerCaseLetter = function(codePoint) {
        return codePoint >= a3 && codePoint <= z2;
      };
      var isUpperCaseLetter = function(codePoint) {
        return codePoint >= A2 && codePoint <= Z2;
      };
      var isLetter = function(codePoint) {
        return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
      };
      var isNonASCIICodePoint = function(codePoint) {
        return codePoint >= CONTROL;
      };
      var isWhiteSpace = function(codePoint) {
        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
      };
      var isNameStartCodePoint = function(codePoint) {
        return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
      };
      var isNameCodePoint = function(codePoint) {
        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
      };
      var isNonPrintableCodePoint = function(codePoint) {
        return codePoint >= NULL2 && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
      };
      var isValidEscape = function(c1, c22) {
        if (c1 !== REVERSE_SOLIDUS) {
          return false;
        }
        return c22 !== LINE_FEED;
      };
      var isIdentifierStart = function(c1, c22, c32) {
        if (c1 === HYPHEN_MINUS) {
          return isNameStartCodePoint(c22) || isValidEscape(c22, c32);
        } else if (isNameStartCodePoint(c1)) {
          return true;
        } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c22)) {
          return true;
        }
        return false;
      };
      var isNumberStart = function(c1, c22, c32) {
        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          if (isDigit(c22)) {
            return true;
          }
          return c22 === FULL_STOP && isDigit(c32);
        }
        if (c1 === FULL_STOP) {
          return isDigit(c22);
        }
        return isDigit(c1);
      };
      var stringToNumber = function(codePoints) {
        var c4 = 0;
        var sign = 1;
        if (codePoints[c4] === PLUS_SIGN || codePoints[c4] === HYPHEN_MINUS) {
          if (codePoints[c4] === HYPHEN_MINUS) {
            sign = -1;
          }
          c4++;
        }
        var integers = [];
        while (isDigit(codePoints[c4])) {
          integers.push(codePoints[c4++]);
        }
        var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
        if (codePoints[c4] === FULL_STOP) {
          c4++;
        }
        var fraction = [];
        while (isDigit(codePoints[c4])) {
          fraction.push(codePoints[c4++]);
        }
        var fracd = fraction.length;
        var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
        if (codePoints[c4] === E2 || codePoints[c4] === e2) {
          c4++;
        }
        var expsign = 1;
        if (codePoints[c4] === PLUS_SIGN || codePoints[c4] === HYPHEN_MINUS) {
          if (codePoints[c4] === HYPHEN_MINUS) {
            expsign = -1;
          }
          c4++;
        }
        var exponent = [];
        while (isDigit(codePoints[c4])) {
          exponent.push(codePoints[c4++]);
        }
        var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
      };
      var LEFT_PARENTHESIS_TOKEN = {
        type: 2
        /* LEFT_PARENTHESIS_TOKEN */
      };
      var RIGHT_PARENTHESIS_TOKEN = {
        type: 3
        /* RIGHT_PARENTHESIS_TOKEN */
      };
      var COMMA_TOKEN = {
        type: 4
        /* COMMA_TOKEN */
      };
      var SUFFIX_MATCH_TOKEN = {
        type: 13
        /* SUFFIX_MATCH_TOKEN */
      };
      var PREFIX_MATCH_TOKEN = {
        type: 8
        /* PREFIX_MATCH_TOKEN */
      };
      var COLUMN_TOKEN = {
        type: 21
        /* COLUMN_TOKEN */
      };
      var DASH_MATCH_TOKEN = {
        type: 9
        /* DASH_MATCH_TOKEN */
      };
      var INCLUDE_MATCH_TOKEN = {
        type: 10
        /* INCLUDE_MATCH_TOKEN */
      };
      var LEFT_CURLY_BRACKET_TOKEN = {
        type: 11
        /* LEFT_CURLY_BRACKET_TOKEN */
      };
      var RIGHT_CURLY_BRACKET_TOKEN = {
        type: 12
        /* RIGHT_CURLY_BRACKET_TOKEN */
      };
      var SUBSTRING_MATCH_TOKEN = {
        type: 14
        /* SUBSTRING_MATCH_TOKEN */
      };
      var BAD_URL_TOKEN = {
        type: 23
        /* BAD_URL_TOKEN */
      };
      var BAD_STRING_TOKEN = {
        type: 1
        /* BAD_STRING_TOKEN */
      };
      var CDO_TOKEN = {
        type: 25
        /* CDO_TOKEN */
      };
      var CDC_TOKEN = {
        type: 24
        /* CDC_TOKEN */
      };
      var COLON_TOKEN = {
        type: 26
        /* COLON_TOKEN */
      };
      var SEMICOLON_TOKEN = {
        type: 27
        /* SEMICOLON_TOKEN */
      };
      var LEFT_SQUARE_BRACKET_TOKEN = {
        type: 28
        /* LEFT_SQUARE_BRACKET_TOKEN */
      };
      var RIGHT_SQUARE_BRACKET_TOKEN = {
        type: 29
        /* RIGHT_SQUARE_BRACKET_TOKEN */
      };
      var WHITESPACE_TOKEN = {
        type: 31
        /* WHITESPACE_TOKEN */
      };
      var EOF_TOKEN = {
        type: 32
        /* EOF_TOKEN */
      };
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2() {
            this._value = [];
          }
          Tokenizer2.prototype.write = function(chunk) {
            this._value = this._value.concat(toCodePoints$1(chunk));
          };
          Tokenizer2.prototype.read = function() {
            var tokens = [];
            var token = this.consumeToken();
            while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
            }
            return tokens;
          };
          Tokenizer2.prototype.consumeToken = function() {
            var codePoint = this.consumeCodePoint();
            switch (codePoint) {
              case QUOTATION_MARK:
                return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                var c1 = this.peekCodePoint(0);
                var c22 = this.peekCodePoint(1);
                var c32 = this.peekCodePoint(2);
                if (isNameCodePoint(c1) || isValidEscape(c22, c32)) {
                  var flags = isIdentifierStart(c1, c22, c32) ? FLAG_ID : FLAG_UNRESTRICTED;
                  var value = this.consumeName();
                  return { type: 5, value, flags };
                }
                break;
              case DOLLAR_SIGN:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUFFIX_MATCH_TOKEN;
                }
                break;
              case APOSTROPHE:
                return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUBSTRING_MATCH_TOKEN;
                }
                break;
              case PLUS_SIGN:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case COMMA:
                return COMMA_TOKEN;
              case HYPHEN_MINUS:
                var e1 = codePoint;
                var e22 = this.peekCodePoint(0);
                var e3 = this.peekCodePoint(1);
                if (isNumberStart(e1, e22, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                if (isIdentifierStart(e1, e22, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                if (e22 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDC_TOKEN;
                }
                break;
              case FULL_STOP:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case SOLIDUS:
                if (this.peekCodePoint(0) === ASTERISK) {
                  this.consumeCodePoint();
                  while (true) {
                    var c4 = this.consumeCodePoint();
                    if (c4 === ASTERISK) {
                      c4 = this.consumeCodePoint();
                      if (c4 === SOLIDUS) {
                        return this.consumeToken();
                      }
                    }
                    if (c4 === EOF) {
                      return this.consumeToken();
                    }
                  }
                }
                break;
              case COLON:
                return COLON_TOKEN;
              case SEMICOLON:
                return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDO_TOKEN;
                }
                break;
              case COMMERCIAL_AT:
                var a1 = this.peekCodePoint(0);
                var a22 = this.peekCodePoint(1);
                var a32 = this.peekCodePoint(2);
                if (isIdentifierStart(a1, a22, a32)) {
                  var value = this.consumeName();
                  return { type: 7, value };
                }
                break;
              case LEFT_SQUARE_BRACKET:
                return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                break;
              case RIGHT_SQUARE_BRACKET:
                return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return PREFIX_MATCH_TOKEN;
                }
                break;
              case LEFT_CURLY_BRACKET:
                return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                return RIGHT_CURLY_BRACKET_TOKEN;
              case u3:
              case U2:
                var u1 = this.peekCodePoint(0);
                var u22 = this.peekCodePoint(1);
                if (u1 === PLUS_SIGN && (isHex(u22) || u22 === QUESTION_MARK)) {
                  this.consumeCodePoint();
                  this.consumeUnicodeRangeToken();
                }
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return DASH_MATCH_TOKEN;
                }
                if (this.peekCodePoint(0) === VERTICAL_LINE) {
                  this.consumeCodePoint();
                  return COLUMN_TOKEN;
                }
                break;
              case TILDE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return INCLUDE_MATCH_TOKEN;
                }
                break;
              case EOF:
                return EOF_TOKEN;
            }
            if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
            }
            if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            return { type: 6, value: fromCodePoint$1(codePoint) };
          };
          Tokenizer2.prototype.consumeCodePoint = function() {
            var value = this._value.shift();
            return typeof value === "undefined" ? -1 : value;
          };
          Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
            this._value.unshift(codePoint);
          };
          Tokenizer2.prototype.peekCodePoint = function(delta) {
            if (delta >= this._value.length) {
              return -1;
            }
            return this._value[delta];
          };
          Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
            var digits = [];
            var codePoint = this.consumeCodePoint();
            while (isHex(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
            }
            var questionMarks = false;
            while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
            }
            if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? ZERO : digit;
              })), 16);
              var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? F2 : digit;
              })), 16);
              return { type: 30, start: start_1, end };
            }
            var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex(codePoint) && endDigits.length < 6) {
                endDigits.push(codePoint);
                codePoint = this.consumeCodePoint();
              }
              var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return { type: 30, start, end };
            } else {
              return { type: 30, start, end: start };
            }
          };
          Tokenizer2.prototype.consumeIdentLikeToken = function() {
            var value = this.consumeName();
            if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
            } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 19, value };
            }
            return { type: 20, value };
          };
          Tokenizer2.prototype.consumeUrlToken = function() {
            var value = [];
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF) {
              return { type: 22, value: "" };
            }
            var next = this.peekCodePoint(0);
            if (next === APOSTROPHE || next === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return { type: 22, value: stringToken.value };
                }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
              } else if (isWhiteSpace(codePoint)) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
                }
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === REVERSE_SOLIDUS) {
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  value.push(this.consumeEscapedCodePoint());
                } else {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
                }
              } else {
                value.push(codePoint);
              }
            }
          };
          Tokenizer2.prototype.consumeWhiteSpace = function() {
            while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
            }
          };
          Tokenizer2.prototype.consumeBadUrlRemnants = function() {
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                this.consumeEscapedCodePoint();
              }
            }
          };
          Tokenizer2.prototype.consumeStringSlice = function(count) {
            var SLICE_STACK_SIZE = 5e4;
            var value = "";
            while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
            }
            this._value.shift();
            return value;
          };
          Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
            var value = "";
            var i4 = 0;
            do {
              var codePoint = this._value[i4];
              if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
                value += this.consumeStringSlice(i4);
                return { type: 0, value };
              }
              if (codePoint === LINE_FEED) {
                this._value.splice(0, i4);
                return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                var next = this._value[i4 + 1];
                if (next !== EOF && next !== void 0) {
                  if (next === LINE_FEED) {
                    value += this.consumeStringSlice(i4);
                    i4 = -1;
                    this._value.shift();
                  } else if (isValidEscape(codePoint, next)) {
                    value += this.consumeStringSlice(i4);
                    value += fromCodePoint$1(this.consumeEscapedCodePoint());
                    i4 = -1;
                  }
                }
              }
              i4++;
            } while (true);
          };
          Tokenizer2.prototype.consumeNumber = function() {
            var repr = [];
            var type = FLAG_INTEGER;
            var c1 = this.peekCodePoint(0);
            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
            }
            while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
            }
            c1 = this.peekCodePoint(0);
            var c22 = this.peekCodePoint(1);
            if (c1 === FULL_STOP && isDigit(c22)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            c1 = this.peekCodePoint(0);
            c22 = this.peekCodePoint(1);
            var c32 = this.peekCodePoint(2);
            if ((c1 === E2 || c1 === e2) && ((c22 === PLUS_SIGN || c22 === HYPHEN_MINUS) && isDigit(c32) || isDigit(c22))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            return [stringToNumber(repr), type];
          };
          Tokenizer2.prototype.consumeNumericToken = function() {
            var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
            var c1 = this.peekCodePoint(0);
            var c22 = this.peekCodePoint(1);
            var c32 = this.peekCodePoint(2);
            if (isIdentifierStart(c1, c22, c32)) {
              var unit = this.consumeName();
              return { type: 15, number, flags, unit };
            }
            if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return { type: 16, number, flags };
            }
            return { type: 17, number, flags };
          };
          Tokenizer2.prototype.consumeEscapedCodePoint = function() {
            var codePoint = this.consumeCodePoint();
            if (isHex(codePoint)) {
              var hex = fromCodePoint$1(codePoint);
              while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                hex += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
                return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
            }
            if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
            }
            return codePoint;
          };
          Tokenizer2.prototype.consumeName = function() {
            var result = "";
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                result += fromCodePoint$1(codePoint);
              } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                result += fromCodePoint$1(this.consumeEscapedCodePoint());
              } else {
                this.reconsumeCodePoint(codePoint);
                return result;
              }
            }
          };
          return Tokenizer2;
        }()
      );
      var Parser2 = (
        /** @class */
        function() {
          function Parser3(tokens) {
            this._tokens = tokens;
          }
          Parser3.create = function(value) {
            var tokenizer = new Tokenizer();
            tokenizer.write(value);
            return new Parser3(tokenizer.read());
          };
          Parser3.parseValue = function(value) {
            return Parser3.create(value).parseComponentValue();
          };
          Parser3.parseValues = function(value) {
            return Parser3.create(value).parseComponentValues();
          };
          Parser3.prototype.parseComponentValue = function() {
            var token = this.consumeToken();
            while (token.type === 31) {
              token = this.consumeToken();
            }
            if (token.type === 32) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
            }
            this.reconsumeToken(token);
            var value = this.consumeComponentValue();
            do {
              token = this.consumeToken();
            } while (token.type === 31);
            if (token.type === 32) {
              return value;
            }
            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
          };
          Parser3.prototype.parseComponentValues = function() {
            var values = [];
            while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32) {
                return values;
              }
              values.push(value);
              values.push();
            }
          };
          Parser3.prototype.consumeComponentValue = function() {
            var token = this.consumeToken();
            switch (token.type) {
              case 11:
              case 28:
              case 2:
                return this.consumeSimpleBlock(token.type);
              case 19:
                return this.consumeFunction(token);
            }
            return token;
          };
          Parser3.prototype.consumeSimpleBlock = function(type) {
            var block = { type, values: [] };
            var token = this.consumeToken();
            while (true) {
              if (token.type === 32 || isEndingTokenFor(token, type)) {
                return block;
              }
              this.reconsumeToken(token);
              block.values.push(this.consumeComponentValue());
              token = this.consumeToken();
            }
          };
          Parser3.prototype.consumeFunction = function(functionToken) {
            var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18
              /* FUNCTION */
            };
            while (true) {
              var token = this.consumeToken();
              if (token.type === 32 || token.type === 3) {
                return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
            }
          };
          Parser3.prototype.consumeToken = function() {
            var token = this._tokens.shift();
            return typeof token === "undefined" ? EOF_TOKEN : token;
          };
          Parser3.prototype.reconsumeToken = function(token) {
            this._tokens.unshift(token);
          };
          return Parser3;
        }()
      );
      var isDimensionToken = function(token) {
        return token.type === 15;
      };
      var isNumberToken = function(token) {
        return token.type === 17;
      };
      var isIdentToken = function(token) {
        return token.type === 20;
      };
      var isStringToken = function(token) {
        return token.type === 0;
      };
      var isIdentWithValue = function(token, value) {
        return isIdentToken(token) && token.value === value;
      };
      var nonWhiteSpace = function(token) {
        return token.type !== 31;
      };
      var nonFunctionArgSeparator = function(token) {
        return token.type !== 31 && token.type !== 4;
      };
      var parseFunctionArgs = function(tokens) {
        var args = [];
        var arg = [];
        tokens.forEach(function(token) {
          if (token.type === 4) {
            if (arg.length === 0) {
              throw new Error("Error parsing function args, zero tokens for arg");
            }
            args.push(arg);
            arg = [];
            return;
          }
          if (token.type !== 31) {
            arg.push(token);
          }
        });
        if (arg.length) {
          args.push(arg);
        }
        return args;
      };
      var isEndingTokenFor = function(token, type) {
        if (type === 11 && token.type === 12) {
          return true;
        }
        if (type === 28 && token.type === 29) {
          return true;
        }
        return type === 2 && token.type === 3;
      };
      var isLength = function(token) {
        return token.type === 17 || token.type === 15;
      };
      var isLengthPercentage = function(token) {
        return token.type === 16 || isLength(token);
      };
      var parseLengthPercentageTuple = function(tokens) {
        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
      };
      var ZERO_LENGTH = {
        type: 17,
        number: 0,
        flags: FLAG_INTEGER
      };
      var FIFTY_PERCENT = {
        type: 16,
        number: 50,
        flags: FLAG_INTEGER
      };
      var HUNDRED_PERCENT = {
        type: 16,
        number: 100,
        flags: FLAG_INTEGER
      };
      var getAbsoluteValueForTuple = function(tuple, width, height) {
        var x2 = tuple[0], y3 = tuple[1];
        return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y3 !== "undefined" ? y3 : x2, height)];
      };
      var getAbsoluteValue = function(token, parent) {
        if (token.type === 16) {
          return token.number / 100 * parent;
        }
        if (isDimensionToken(token)) {
          switch (token.unit) {
            case "rem":
            case "em":
              return 16 * token.number;
            case "px":
            default:
              return token.number;
          }
        }
        return token.number;
      };
      var DEG = "deg";
      var GRAD = "grad";
      var RAD = "rad";
      var TURN = "turn";
      var angle = {
        name: "angle",
        parse: function(_context, value) {
          if (value.type === 15) {
            switch (value.unit) {
              case DEG:
                return Math.PI * value.number / 180;
              case GRAD:
                return Math.PI / 200 * value.number;
              case RAD:
                return value.number;
              case TURN:
                return Math.PI * 2 * value.number;
            }
          }
          throw new Error("Unsupported angle type");
        }
      };
      var isAngle = function(value) {
        if (value.type === 15) {
          if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
            return true;
          }
        }
        return false;
      };
      var parseNamedSide = function(tokens) {
        var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
          return ident.value;
        }).join(" ");
        switch (sideOrCorner) {
          case "to bottom right":
          case "to right bottom":
          case "left top":
          case "top left":
            return [ZERO_LENGTH, ZERO_LENGTH];
          case "to top":
          case "bottom":
            return deg(0);
          case "to bottom left":
          case "to left bottom":
          case "right top":
          case "top right":
            return [ZERO_LENGTH, HUNDRED_PERCENT];
          case "to right":
          case "left":
            return deg(90);
          case "to top left":
          case "to left top":
          case "right bottom":
          case "bottom right":
            return [HUNDRED_PERCENT, HUNDRED_PERCENT];
          case "to bottom":
          case "top":
            return deg(180);
          case "to top right":
          case "to right top":
          case "left bottom":
          case "bottom left":
            return [HUNDRED_PERCENT, ZERO_LENGTH];
          case "to left":
          case "right":
            return deg(270);
        }
        return 0;
      };
      var deg = function(deg2) {
        return Math.PI * deg2 / 180;
      };
      var color$1 = {
        name: "color",
        parse: function(context, value) {
          if (value.type === 18) {
            var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
            if (typeof colorFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
            }
            return colorFunction(context, value.values);
          }
          if (value.type === 5) {
            if (value.value.length === 3) {
              var r2 = value.value.substring(0, 1);
              var g2 = value.value.substring(1, 2);
              var b2 = value.value.substring(2, 3);
              return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
            }
            if (value.value.length === 4) {
              var r2 = value.value.substring(0, 1);
              var g2 = value.value.substring(1, 2);
              var b2 = value.value.substring(2, 3);
              var a4 = value.value.substring(3, 4);
              return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a4 + a4, 16) / 255);
            }
            if (value.value.length === 6) {
              var r2 = value.value.substring(0, 2);
              var g2 = value.value.substring(2, 4);
              var b2 = value.value.substring(4, 6);
              return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
            }
            if (value.value.length === 8) {
              var r2 = value.value.substring(0, 2);
              var g2 = value.value.substring(2, 4);
              var b2 = value.value.substring(4, 6);
              var a4 = value.value.substring(6, 8);
              return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a4, 16) / 255);
            }
          }
          if (value.type === 20) {
            var namedColor = COLORS[value.value.toUpperCase()];
            if (typeof namedColor !== "undefined") {
              return namedColor;
            }
          }
          return COLORS.TRANSPARENT;
        }
      };
      var isTransparent = function(color2) {
        return (255 & color2) === 0;
      };
      var asString = function(color2) {
        var alpha = 255 & color2;
        var blue = 255 & color2 >> 8;
        var green = 255 & color2 >> 16;
        var red = 255 & color2 >> 24;
        return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
      };
      var pack = function(r2, g2, b2, a4) {
        return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a4 * 255) << 0) >>> 0;
      };
      var getTokenColorValue = function(token, i4) {
        if (token.type === 17) {
          return token.number;
        }
        if (token.type === 16) {
          var max4 = i4 === 3 ? 1 : 255;
          return i4 === 3 ? token.number / 100 * max4 : Math.round(token.number / 100 * max4);
        }
        return 0;
      };
      var rgb2 = function(_context, args) {
        var tokens = args.filter(nonFunctionArgSeparator);
        if (tokens.length === 3) {
          var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g2 = _a2[1], b2 = _a2[2];
          return pack(r2, g2, b2, 1);
        }
        if (tokens.length === 4) {
          var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g2 = _b2[1], b2 = _b2[2], a4 = _b2[3];
          return pack(r2, g2, b2, a4);
        }
        return 0;
      };
      function hue2rgb2(t1, t22, hue) {
        if (hue < 0) {
          hue += 1;
        }
        if (hue >= 1) {
          hue -= 1;
        }
        if (hue < 1 / 6) {
          return (t22 - t1) * hue * 6 + t1;
        } else if (hue < 1 / 2) {
          return t22;
        } else if (hue < 2 / 3) {
          return (t22 - t1) * 6 * (2 / 3 - hue) + t1;
        } else {
          return t1;
        }
      }
      var hsl3 = function(context, args) {
        var tokens = args.filter(nonFunctionArgSeparator);
        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
        var h3 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
        var s3 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
        var l3 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
        var a4 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
        if (s3 === 0) {
          return pack(l3 * 255, l3 * 255, l3 * 255, 1);
        }
        var t22 = l3 <= 0.5 ? l3 * (s3 + 1) : l3 + s3 - l3 * s3;
        var t1 = l3 * 2 - t22;
        var r2 = hue2rgb2(t1, t22, h3 + 1 / 3);
        var g2 = hue2rgb2(t1, t22, h3);
        var b2 = hue2rgb2(t1, t22, h3 - 1 / 3);
        return pack(r2 * 255, g2 * 255, b2 * 255, a4);
      };
      var SUPPORTED_COLOR_FUNCTIONS = {
        hsl: hsl3,
        hsla: hsl3,
        rgb: rgb2,
        rgba: rgb2
      };
      var parseColor = function(context, value) {
        return color$1.parse(context, Parser2.create(value).parseComponentValue());
      };
      var COLORS = {
        ALICEBLUE: 4042850303,
        ANTIQUEWHITE: 4209760255,
        AQUA: 16777215,
        AQUAMARINE: 2147472639,
        AZURE: 4043309055,
        BEIGE: 4126530815,
        BISQUE: 4293182719,
        BLACK: 255,
        BLANCHEDALMOND: 4293643775,
        BLUE: 65535,
        BLUEVIOLET: 2318131967,
        BROWN: 2771004159,
        BURLYWOOD: 3736635391,
        CADETBLUE: 1604231423,
        CHARTREUSE: 2147418367,
        CHOCOLATE: 3530104575,
        CORAL: 4286533887,
        CORNFLOWERBLUE: 1687547391,
        CORNSILK: 4294499583,
        CRIMSON: 3692313855,
        CYAN: 16777215,
        DARKBLUE: 35839,
        DARKCYAN: 9145343,
        DARKGOLDENROD: 3095837695,
        DARKGRAY: 2846468607,
        DARKGREEN: 6553855,
        DARKGREY: 2846468607,
        DARKKHAKI: 3182914559,
        DARKMAGENTA: 2332068863,
        DARKOLIVEGREEN: 1433087999,
        DARKORANGE: 4287365375,
        DARKORCHID: 2570243327,
        DARKRED: 2332033279,
        DARKSALMON: 3918953215,
        DARKSEAGREEN: 2411499519,
        DARKSLATEBLUE: 1211993087,
        DARKSLATEGRAY: 793726975,
        DARKSLATEGREY: 793726975,
        DARKTURQUOISE: 13554175,
        DARKVIOLET: 2483082239,
        DEEPPINK: 4279538687,
        DEEPSKYBLUE: 12582911,
        DIMGRAY: 1768516095,
        DIMGREY: 1768516095,
        DODGERBLUE: 512819199,
        FIREBRICK: 2988581631,
        FLORALWHITE: 4294635775,
        FORESTGREEN: 579543807,
        FUCHSIA: 4278255615,
        GAINSBORO: 3705462015,
        GHOSTWHITE: 4177068031,
        GOLD: 4292280575,
        GOLDENROD: 3668254975,
        GRAY: 2155905279,
        GREEN: 8388863,
        GREENYELLOW: 2919182335,
        GREY: 2155905279,
        HONEYDEW: 4043305215,
        HOTPINK: 4285117695,
        INDIANRED: 3445382399,
        INDIGO: 1258324735,
        IVORY: 4294963455,
        KHAKI: 4041641215,
        LAVENDER: 3873897215,
        LAVENDERBLUSH: 4293981695,
        LAWNGREEN: 2096890111,
        LEMONCHIFFON: 4294626815,
        LIGHTBLUE: 2916673279,
        LIGHTCORAL: 4034953471,
        LIGHTCYAN: 3774873599,
        LIGHTGOLDENRODYELLOW: 4210742015,
        LIGHTGRAY: 3553874943,
        LIGHTGREEN: 2431553791,
        LIGHTGREY: 3553874943,
        LIGHTPINK: 4290167295,
        LIGHTSALMON: 4288707327,
        LIGHTSEAGREEN: 548580095,
        LIGHTSKYBLUE: 2278488831,
        LIGHTSLATEGRAY: 2005441023,
        LIGHTSLATEGREY: 2005441023,
        LIGHTSTEELBLUE: 2965692159,
        LIGHTYELLOW: 4294959359,
        LIME: 16711935,
        LIMEGREEN: 852308735,
        LINEN: 4210091775,
        MAGENTA: 4278255615,
        MAROON: 2147483903,
        MEDIUMAQUAMARINE: 1724754687,
        MEDIUMBLUE: 52735,
        MEDIUMORCHID: 3126187007,
        MEDIUMPURPLE: 2473647103,
        MEDIUMSEAGREEN: 1018393087,
        MEDIUMSLATEBLUE: 2070474495,
        MEDIUMSPRINGGREEN: 16423679,
        MEDIUMTURQUOISE: 1221709055,
        MEDIUMVIOLETRED: 3340076543,
        MIDNIGHTBLUE: 421097727,
        MINTCREAM: 4127193855,
        MISTYROSE: 4293190143,
        MOCCASIN: 4293178879,
        NAVAJOWHITE: 4292783615,
        NAVY: 33023,
        OLDLACE: 4260751103,
        OLIVE: 2155872511,
        OLIVEDRAB: 1804477439,
        ORANGE: 4289003775,
        ORANGERED: 4282712319,
        ORCHID: 3664828159,
        PALEGOLDENROD: 4008225535,
        PALEGREEN: 2566625535,
        PALETURQUOISE: 2951671551,
        PALEVIOLETRED: 3681588223,
        PAPAYAWHIP: 4293907967,
        PEACHPUFF: 4292524543,
        PERU: 3448061951,
        PINK: 4290825215,
        PLUM: 3718307327,
        POWDERBLUE: 2967529215,
        PURPLE: 2147516671,
        REBECCAPURPLE: 1714657791,
        RED: 4278190335,
        ROSYBROWN: 3163525119,
        ROYALBLUE: 1097458175,
        SADDLEBROWN: 2336560127,
        SALMON: 4202722047,
        SANDYBROWN: 4104413439,
        SEAGREEN: 780883967,
        SEASHELL: 4294307583,
        SIENNA: 2689740287,
        SILVER: 3233857791,
        SKYBLUE: 2278484991,
        SLATEBLUE: 1784335871,
        SLATEGRAY: 1887473919,
        SLATEGREY: 1887473919,
        SNOW: 4294638335,
        SPRINGGREEN: 16744447,
        STEELBLUE: 1182971135,
        TAN: 3535047935,
        TEAL: 8421631,
        THISTLE: 3636451583,
        TOMATO: 4284696575,
        TRANSPARENT: 0,
        TURQUOISE: 1088475391,
        VIOLET: 4001558271,
        WHEAT: 4125012991,
        WHITE: 4294967295,
        WHITESMOKE: 4126537215,
        YELLOW: 4294902015,
        YELLOWGREEN: 2597139199
      };
      var backgroundClip = {
        name: "background-clip",
        initialValue: "border-box",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.map(function(token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "padding-box":
                  return 1;
                case "content-box":
                  return 2;
              }
            }
            return 0;
          });
        }
      };
      var backgroundColor = {
        name: "background-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var parseColorStop = function(context, args) {
        var color2 = color$1.parse(context, args[0]);
        var stop = args[1];
        return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
      };
      var processColorStops = function(stops, lineLength) {
        var first = stops[0];
        var last = stops[stops.length - 1];
        if (first.stop === null) {
          first.stop = ZERO_LENGTH;
        }
        if (last.stop === null) {
          last.stop = HUNDRED_PERCENT;
        }
        var processStops = [];
        var previous = 0;
        for (var i4 = 0; i4 < stops.length; i4++) {
          var stop_1 = stops[i4].stop;
          if (stop_1 !== null) {
            var absoluteValue = getAbsoluteValue(stop_1, lineLength);
            if (absoluteValue > previous) {
              processStops.push(absoluteValue);
            } else {
              processStops.push(previous);
            }
            previous = absoluteValue;
          } else {
            processStops.push(null);
          }
        }
        var gapBegin = null;
        for (var i4 = 0; i4 < processStops.length; i4++) {
          var stop_2 = processStops[i4];
          if (stop_2 === null) {
            if (gapBegin === null) {
              gapBegin = i4;
            }
          } else if (gapBegin !== null) {
            var gapLength = i4 - gapBegin;
            var beforeGap = processStops[gapBegin - 1];
            var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
            for (var g2 = 1; g2 <= gapLength; g2++) {
              processStops[gapBegin + g2 - 1] = gapValue * g2;
            }
            gapBegin = null;
          }
        }
        return stops.map(function(_a2, i5) {
          var color2 = _a2.color;
          return { color: color2, stop: Math.max(Math.min(1, processStops[i5] / lineLength), 0) };
        });
      };
      var getAngleFromCorner = function(corner, width, height) {
        var centerX = width / 2;
        var centerY = height / 2;
        var x2 = getAbsoluteValue(corner[0], width) - centerX;
        var y3 = centerY - getAbsoluteValue(corner[1], height);
        return (Math.atan2(y3, x2) + Math.PI * 2) % (Math.PI * 2);
      };
      var calculateGradientDirection = function(angle2, width, height) {
        var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
        var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfLineLength = lineLength / 2;
        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
      };
      var distance = function(a4, b2) {
        return Math.sqrt(a4 * a4 + b2 * b2);
      };
      var findCorner = function(width, height, x2, y3, closest) {
        var corners = [
          [0, 0],
          [0, height],
          [width, 0],
          [width, height]
        ];
        return corners.reduce(function(stat, corner) {
          var cx = corner[0], cy = corner[1];
          var d2 = distance(x2 - cx, y3 - cy);
          if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {
            return {
              optimumCorner: corner,
              optimumDistance: d2
            };
          }
          return stat;
        }, {
          optimumDistance: closest ? Infinity : -Infinity,
          optimumCorner: null
        }).optimumCorner;
      };
      var calculateRadius = function(gradient, x2, y3, width, height) {
        var rx = 0;
        var ry = 0;
        switch (gradient.size) {
          case 0:
            if (gradient.shape === 0) {
              rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y3), Math.abs(y3 - height));
            } else if (gradient.shape === 1) {
              rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
              ry = Math.min(Math.abs(y3), Math.abs(y3 - height));
            }
            break;
          case 2:
            if (gradient.shape === 0) {
              rx = ry = Math.min(distance(x2, y3), distance(x2, y3 - height), distance(x2 - width, y3), distance(x2 - width, y3 - height));
            } else if (gradient.shape === 1) {
              var c4 = Math.min(Math.abs(y3), Math.abs(y3 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
              var _a2 = findCorner(width, height, x2, y3, true), cx = _a2[0], cy = _a2[1];
              rx = distance(cx - x2, (cy - y3) / c4);
              ry = c4 * rx;
            }
            break;
          case 1:
            if (gradient.shape === 0) {
              rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y3), Math.abs(y3 - height));
            } else if (gradient.shape === 1) {
              rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
              ry = Math.max(Math.abs(y3), Math.abs(y3 - height));
            }
            break;
          case 3:
            if (gradient.shape === 0) {
              rx = ry = Math.max(distance(x2, y3), distance(x2, y3 - height), distance(x2 - width, y3), distance(x2 - width, y3 - height));
            } else if (gradient.shape === 1) {
              var c4 = Math.max(Math.abs(y3), Math.abs(y3 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
              var _b2 = findCorner(width, height, x2, y3, false), cx = _b2[0], cy = _b2[1];
              rx = distance(cx - x2, (cy - y3) / c4);
              ry = c4 * rx;
            }
            break;
        }
        if (Array.isArray(gradient.size)) {
          rx = getAbsoluteValue(gradient.size[0], width);
          ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
        }
        return [rx, ry];
      };
      var linearGradient = function(context, tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          if (i4 === 0) {
            var firstToken = arg[0];
            if (firstToken.type === 20 && firstToken.value === "to") {
              angle$1 = parseNamedSide(arg);
              return;
            } else if (isAngle(firstToken)) {
              angle$1 = angle.parse(context, firstToken);
              return;
            }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        });
        return {
          angle: angle$1,
          stops,
          type: 1
          /* LINEAR_GRADIENT */
        };
      };
      var prefixLinearGradient = function(context, tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          if (i4 === 0) {
            var firstToken = arg[0];
            if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
              angle$1 = parseNamedSide(arg);
              return;
            } else if (isAngle(firstToken)) {
              angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
              return;
            }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        });
        return {
          angle: angle$1,
          stops,
          type: 1
          /* LINEAR_GRADIENT */
        };
      };
      var webkitGradient = function(context, tokens) {
        var angle2 = deg(180);
        var stops = [];
        var type = 1;
        var shape = 0;
        var size = 3;
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          var firstToken = arg[0];
          if (i4 === 0) {
            if (isIdentToken(firstToken) && firstToken.value === "linear") {
              type = 1;
              return;
            } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
              type = 2;
              return;
            }
          }
          if (firstToken.type === 18) {
            if (firstToken.name === "from") {
              var color2 = color$1.parse(context, firstToken.values[0]);
              stops.push({ stop: ZERO_LENGTH, color: color2 });
            } else if (firstToken.name === "to") {
              var color2 = color$1.parse(context, firstToken.values[0]);
              stops.push({ stop: HUNDRED_PERCENT, color: color2 });
            } else if (firstToken.name === "color-stop") {
              var values = firstToken.values.filter(nonFunctionArgSeparator);
              if (values.length === 2) {
                var color2 = color$1.parse(context, values[1]);
                var stop_1 = values[0];
                if (isNumberToken(stop_1)) {
                  stops.push({
                    stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
                    color: color2
                  });
                }
              }
            }
          }
        });
        return type === 1 ? {
          angle: (angle2 + deg(180)) % deg(360),
          stops,
          type
        } : { size, shape, stops, position: position2, type };
      };
      var CLOSEST_SIDE = "closest-side";
      var FARTHEST_SIDE = "farthest-side";
      var CLOSEST_CORNER = "closest-corner";
      var FARTHEST_CORNER = "farthest-corner";
      var CIRCLE = "circle";
      var ELLIPSE = "ellipse";
      var COVER = "cover";
      var CONTAIN = "contain";
      var radialGradient = function(context, tokens) {
        var shape = 0;
        var size = 3;
        var stops = [];
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          var isColorStop = true;
          if (i4 === 0) {
            var isAtPosition_1 = false;
            isColorStop = arg.reduce(function(acc, token) {
              if (isAtPosition_1) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case "center":
                      position2.push(FIFTY_PERCENT);
                      return acc;
                    case "top":
                    case "left":
                      position2.push(ZERO_LENGTH);
                      return acc;
                    case "right":
                    case "bottom":
                      position2.push(HUNDRED_PERCENT);
                      return acc;
                  }
                } else if (isLengthPercentage(token) || isLength(token)) {
                  position2.push(token);
                }
              } else if (isIdentToken(token)) {
                switch (token.value) {
                  case CIRCLE:
                    shape = 0;
                    return false;
                  case ELLIPSE:
                    shape = 1;
                    return false;
                  case "at":
                    isAtPosition_1 = true;
                    return false;
                  case CLOSEST_SIDE:
                    size = 0;
                    return false;
                  case COVER:
                  case FARTHEST_SIDE:
                    size = 1;
                    return false;
                  case CONTAIN:
                  case CLOSEST_CORNER:
                    size = 2;
                    return false;
                  case FARTHEST_CORNER:
                    size = 3;
                    return false;
                }
              } else if (isLength(token) || isLengthPercentage(token)) {
                if (!Array.isArray(size)) {
                  size = [];
                }
                size.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          }
          if (isColorStop) {
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          }
        });
        return {
          size,
          shape,
          stops,
          position: position2,
          type: 2
          /* RADIAL_GRADIENT */
        };
      };
      var prefixRadialGradient = function(context, tokens) {
        var shape = 0;
        var size = 3;
        var stops = [];
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i4) {
          var isColorStop = true;
          if (i4 === 0) {
            isColorStop = arg.reduce(function(acc, token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "center":
                    position2.push(FIFTY_PERCENT);
                    return false;
                  case "top":
                  case "left":
                    position2.push(ZERO_LENGTH);
                    return false;
                  case "right":
                  case "bottom":
                    position2.push(HUNDRED_PERCENT);
                    return false;
                }
              } else if (isLengthPercentage(token) || isLength(token)) {
                position2.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          } else if (i4 === 1) {
            isColorStop = arg.reduce(function(acc, token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case CIRCLE:
                    shape = 0;
                    return false;
                  case ELLIPSE:
                    shape = 1;
                    return false;
                  case CONTAIN:
                  case CLOSEST_SIDE:
                    size = 0;
                    return false;
                  case FARTHEST_SIDE:
                    size = 1;
                    return false;
                  case CLOSEST_CORNER:
                    size = 2;
                    return false;
                  case COVER:
                  case FARTHEST_CORNER:
                    size = 3;
                    return false;
                }
              } else if (isLength(token) || isLengthPercentage(token)) {
                if (!Array.isArray(size)) {
                  size = [];
                }
                size.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          }
          if (isColorStop) {
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          }
        });
        return {
          size,
          shape,
          stops,
          position: position2,
          type: 2
          /* RADIAL_GRADIENT */
        };
      };
      var isLinearGradient = function(background3) {
        return background3.type === 1;
      };
      var isRadialGradient = function(background3) {
        return background3.type === 2;
      };
      var image = {
        name: "image",
        parse: function(context, value) {
          if (value.type === 22) {
            var image_1 = {
              url: value.value,
              type: 0
              /* URL */
            };
            context.cache.addImage(value.value);
            return image_1;
          }
          if (value.type === 18) {
            var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
            if (typeof imageFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
            }
            return imageFunction(context, value.values);
          }
          throw new Error("Unsupported image type " + value.type);
        }
      };
      function isSupportedImage(value) {
        return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
      }
      var SUPPORTED_IMAGE_FUNCTIONS = {
        "linear-gradient": linearGradient,
        "-moz-linear-gradient": prefixLinearGradient,
        "-ms-linear-gradient": prefixLinearGradient,
        "-o-linear-gradient": prefixLinearGradient,
        "-webkit-linear-gradient": prefixLinearGradient,
        "radial-gradient": radialGradient,
        "-moz-radial-gradient": prefixRadialGradient,
        "-ms-radial-gradient": prefixRadialGradient,
        "-o-radial-gradient": prefixRadialGradient,
        "-webkit-radial-gradient": prefixRadialGradient,
        "-webkit-gradient": webkitGradient
      };
      var backgroundImage = {
        name: "background-image",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return [];
          }
          return tokens.filter(function(value) {
            return nonFunctionArgSeparator(value) && isSupportedImage(value);
          }).map(function(value) {
            return image.parse(context, value);
          });
        }
      };
      var backgroundOrigin = {
        name: "background-origin",
        initialValue: "border-box",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.map(function(token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "padding-box":
                  return 1;
                case "content-box":
                  return 2;
              }
            }
            return 0;
          });
        }
      };
      var backgroundPosition = {
        name: "background-position",
        initialValue: "0% 0%",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isLengthPercentage);
          }).map(parseLengthPercentageTuple);
        }
      };
      var backgroundRepeat = {
        name: "background-repeat",
        initialValue: "repeat",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isIdentToken).map(function(token) {
              return token.value;
            }).join(" ");
          }).map(parseBackgroundRepeat);
        }
      };
      var parseBackgroundRepeat = function(value) {
        switch (value) {
          case "no-repeat":
            return 1;
          case "repeat-x":
          case "repeat no-repeat":
            return 2;
          case "repeat-y":
          case "no-repeat repeat":
            return 3;
          case "repeat":
          default:
            return 0;
        }
      };
      var BACKGROUND_SIZE;
      (function(BACKGROUND_SIZE2) {
        BACKGROUND_SIZE2["AUTO"] = "auto";
        BACKGROUND_SIZE2["CONTAIN"] = "contain";
        BACKGROUND_SIZE2["COVER"] = "cover";
      })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
      var backgroundSize = {
        name: "background-size",
        initialValue: "0",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isBackgroundSizeInfoToken);
          });
        }
      };
      var isBackgroundSizeInfoToken = function(value) {
        return isIdentToken(value) || isLengthPercentage(value);
      };
      var borderColorForSide = function(side) {
        return {
          name: "border-" + side + "-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
      };
      var borderTopColor = borderColorForSide("top");
      var borderRightColor = borderColorForSide("right");
      var borderBottomColor = borderColorForSide("bottom");
      var borderLeftColor = borderColorForSide("left");
      var borderRadiusForSide = function(side) {
        return {
          name: "border-radius-" + side,
          initialValue: "0 0",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
          }
        };
      };
      var borderTopLeftRadius = borderRadiusForSide("top-left");
      var borderTopRightRadius = borderRadiusForSide("top-right");
      var borderBottomRightRadius = borderRadiusForSide("bottom-right");
      var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
      var borderStyleForSide = function(side) {
        return {
          name: "border-" + side + "-style",
          initialValue: "solid",
          prefix: false,
          type: 2,
          parse: function(_context, style) {
            switch (style) {
              case "none":
                return 0;
              case "dashed":
                return 2;
              case "dotted":
                return 3;
              case "double":
                return 4;
            }
            return 1;
          }
        };
      };
      var borderTopStyle = borderStyleForSide("top");
      var borderRightStyle = borderStyleForSide("right");
      var borderBottomStyle = borderStyleForSide("bottom");
      var borderLeftStyle = borderStyleForSide("left");
      var borderWidthForSide = function(side) {
        return {
          name: "border-" + side + "-width",
          initialValue: "0",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isDimensionToken(token)) {
              return token.number;
            }
            return 0;
          }
        };
      };
      var borderTopWidth = borderWidthForSide("top");
      var borderRightWidth = borderWidthForSide("right");
      var borderBottomWidth = borderWidthForSide("bottom");
      var borderLeftWidth = borderWidthForSide("left");
      var color = {
        name: "color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var direction = {
        name: "direction",
        initialValue: "ltr",
        prefix: false,
        type: 2,
        parse: function(_context, direction2) {
          switch (direction2) {
            case "rtl":
              return 1;
            case "ltr":
            default:
              return 0;
          }
        }
      };
      var display = {
        name: "display",
        initialValue: "inline-block",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).reduce(
            function(bit, token) {
              return bit | parseDisplayValue(token.value);
            },
            0
            /* NONE */
          );
        }
      };
      var parseDisplayValue = function(display2) {
        switch (display2) {
          case "block":
          case "-webkit-box":
            return 2;
          case "inline":
            return 4;
          case "run-in":
            return 8;
          case "flow":
            return 16;
          case "flow-root":
            return 32;
          case "table":
            return 64;
          case "flex":
          case "-webkit-flex":
            return 128;
          case "grid":
          case "-ms-grid":
            return 256;
          case "ruby":
            return 512;
          case "subgrid":
            return 1024;
          case "list-item":
            return 2048;
          case "table-row-group":
            return 4096;
          case "table-header-group":
            return 8192;
          case "table-footer-group":
            return 16384;
          case "table-row":
            return 32768;
          case "table-cell":
            return 65536;
          case "table-column-group":
            return 131072;
          case "table-column":
            return 262144;
          case "table-caption":
            return 524288;
          case "ruby-base":
            return 1048576;
          case "ruby-text":
            return 2097152;
          case "ruby-base-container":
            return 4194304;
          case "ruby-text-container":
            return 8388608;
          case "contents":
            return 16777216;
          case "inline-block":
            return 33554432;
          case "inline-list-item":
            return 67108864;
          case "inline-table":
            return 134217728;
          case "inline-flex":
            return 268435456;
          case "inline-grid":
            return 536870912;
        }
        return 0;
      };
      var float = {
        name: "float",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, float2) {
          switch (float2) {
            case "left":
              return 1;
            case "right":
              return 2;
            case "inline-start":
              return 3;
            case "inline-end":
              return 4;
          }
          return 0;
        }
      };
      var letterSpacing = {
        name: "letter-spacing",
        initialValue: "0",
        prefix: false,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20 && token.value === "normal") {
            return 0;
          }
          if (token.type === 17) {
            return token.number;
          }
          if (token.type === 15) {
            return token.number;
          }
          return 0;
        }
      };
      var LINE_BREAK;
      (function(LINE_BREAK2) {
        LINE_BREAK2["NORMAL"] = "normal";
        LINE_BREAK2["STRICT"] = "strict";
      })(LINE_BREAK || (LINE_BREAK = {}));
      var lineBreak = {
        name: "line-break",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, lineBreak2) {
          switch (lineBreak2) {
            case "strict":
              return LINE_BREAK.STRICT;
            case "normal":
            default:
              return LINE_BREAK.NORMAL;
          }
        }
      };
      var lineHeight = {
        name: "line-height",
        initialValue: "normal",
        prefix: false,
        type: 4
        /* TOKEN_VALUE */
      };
      var computeLineHeight = function(token, fontSize2) {
        if (isIdentToken(token) && token.value === "normal") {
          return 1.2 * fontSize2;
        } else if (token.type === 17) {
          return fontSize2 * token.number;
        } else if (isLengthPercentage(token)) {
          return getAbsoluteValue(token, fontSize2);
        }
        return fontSize2;
      };
      var listStyleImage = {
        name: "list-style-image",
        initialValue: "none",
        type: 0,
        prefix: false,
        parse: function(context, token) {
          if (token.type === 20 && token.value === "none") {
            return null;
          }
          return image.parse(context, token);
        }
      };
      var listStylePosition = {
        name: "list-style-position",
        initialValue: "outside",
        prefix: false,
        type: 2,
        parse: function(_context, position2) {
          switch (position2) {
            case "inside":
              return 0;
            case "outside":
            default:
              return 1;
          }
        }
      };
      var listStyleType = {
        name: "list-style-type",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, type) {
          switch (type) {
            case "disc":
              return 0;
            case "circle":
              return 1;
            case "square":
              return 2;
            case "decimal":
              return 3;
            case "cjk-decimal":
              return 4;
            case "decimal-leading-zero":
              return 5;
            case "lower-roman":
              return 6;
            case "upper-roman":
              return 7;
            case "lower-greek":
              return 8;
            case "lower-alpha":
              return 9;
            case "upper-alpha":
              return 10;
            case "arabic-indic":
              return 11;
            case "armenian":
              return 12;
            case "bengali":
              return 13;
            case "cambodian":
              return 14;
            case "cjk-earthly-branch":
              return 15;
            case "cjk-heavenly-stem":
              return 16;
            case "cjk-ideographic":
              return 17;
            case "devanagari":
              return 18;
            case "ethiopic-numeric":
              return 19;
            case "georgian":
              return 20;
            case "gujarati":
              return 21;
            case "gurmukhi":
              return 22;
            case "hebrew":
              return 22;
            case "hiragana":
              return 23;
            case "hiragana-iroha":
              return 24;
            case "japanese-formal":
              return 25;
            case "japanese-informal":
              return 26;
            case "kannada":
              return 27;
            case "katakana":
              return 28;
            case "katakana-iroha":
              return 29;
            case "khmer":
              return 30;
            case "korean-hangul-formal":
              return 31;
            case "korean-hanja-formal":
              return 32;
            case "korean-hanja-informal":
              return 33;
            case "lao":
              return 34;
            case "lower-armenian":
              return 35;
            case "malayalam":
              return 36;
            case "mongolian":
              return 37;
            case "myanmar":
              return 38;
            case "oriya":
              return 39;
            case "persian":
              return 40;
            case "simp-chinese-formal":
              return 41;
            case "simp-chinese-informal":
              return 42;
            case "tamil":
              return 43;
            case "telugu":
              return 44;
            case "thai":
              return 45;
            case "tibetan":
              return 46;
            case "trad-chinese-formal":
              return 47;
            case "trad-chinese-informal":
              return 48;
            case "upper-armenian":
              return 49;
            case "disclosure-open":
              return 50;
            case "disclosure-closed":
              return 51;
            case "none":
            default:
              return -1;
          }
        }
      };
      var marginForSide = function(side) {
        return {
          name: "margin-" + side,
          initialValue: "0",
          prefix: false,
          type: 4
          /* TOKEN_VALUE */
        };
      };
      var marginTop = marginForSide("top");
      var marginRight = marginForSide("right");
      var marginBottom = marginForSide("bottom");
      var marginLeft = marginForSide("left");
      var overflow = {
        name: "overflow",
        initialValue: "visible",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(overflow2) {
            switch (overflow2.value) {
              case "hidden":
                return 1;
              case "scroll":
                return 2;
              case "clip":
                return 3;
              case "auto":
                return 4;
              case "visible":
              default:
                return 0;
            }
          });
        }
      };
      var overflowWrap = {
        name: "overflow-wrap",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, overflow2) {
          switch (overflow2) {
            case "break-word":
              return "break-word";
            case "normal":
            default:
              return "normal";
          }
        }
      };
      var paddingForSide = function(side) {
        return {
          name: "padding-" + side,
          initialValue: "0",
          prefix: false,
          type: 3,
          format: "length-percentage"
        };
      };
      var paddingTop = paddingForSide("top");
      var paddingRight = paddingForSide("right");
      var paddingBottom = paddingForSide("bottom");
      var paddingLeft = paddingForSide("left");
      var textAlign = {
        name: "text-align",
        initialValue: "left",
        prefix: false,
        type: 2,
        parse: function(_context, textAlign2) {
          switch (textAlign2) {
            case "right":
              return 2;
            case "center":
            case "justify":
              return 1;
            case "left":
            default:
              return 0;
          }
        }
      };
      var position = {
        name: "position",
        initialValue: "static",
        prefix: false,
        type: 2,
        parse: function(_context, position2) {
          switch (position2) {
            case "relative":
              return 1;
            case "absolute":
              return 2;
            case "fixed":
              return 3;
            case "sticky":
              return 4;
          }
          return 0;
        }
      };
      var textShadow = {
        name: "text-shadow",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
            return [];
          }
          return parseFunctionArgs(tokens).map(function(values) {
            var shadow = {
              color: COLORS.TRANSPARENT,
              offsetX: ZERO_LENGTH,
              offsetY: ZERO_LENGTH,
              blur: ZERO_LENGTH
            };
            var c4 = 0;
            for (var i4 = 0; i4 < values.length; i4++) {
              var token = values[i4];
              if (isLength(token)) {
                if (c4 === 0) {
                  shadow.offsetX = token;
                } else if (c4 === 1) {
                  shadow.offsetY = token;
                } else {
                  shadow.blur = token;
                }
                c4++;
              } else {
                shadow.color = color$1.parse(context, token);
              }
            }
            return shadow;
          });
        }
      };
      var textTransform = {
        name: "text-transform",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, textTransform2) {
          switch (textTransform2) {
            case "uppercase":
              return 2;
            case "lowercase":
              return 1;
            case "capitalize":
              return 3;
          }
          return 0;
        }
      };
      var transform$1 = {
        name: "transform",
        initialValue: "none",
        prefix: true,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20 && token.value === "none") {
            return null;
          }
          if (token.type === 18) {
            var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
            if (typeof transformFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
            }
            return transformFunction(token.values);
          }
          return null;
        }
      };
      var matrix2 = function(args) {
        var values = args.filter(function(arg) {
          return arg.type === 17;
        }).map(function(arg) {
          return arg.number;
        });
        return values.length === 6 ? values : null;
      };
      var matrix3d = function(args) {
        var values = args.filter(function(arg) {
          return arg.type === 17;
        }).map(function(arg) {
          return arg.number;
        });
        var a1 = values[0], b1 = values[1];
        values[2];
        values[3];
        var a22 = values[4], b2 = values[5];
        values[6];
        values[7];
        values[8];
        values[9];
        values[10];
        values[11];
        var a4 = values[12], b4 = values[13];
        values[14];
        values[15];
        return values.length === 16 ? [a1, b1, a22, b2, a4, b4] : null;
      };
      var SUPPORTED_TRANSFORM_FUNCTIONS = {
        matrix: matrix2,
        matrix3d
      };
      var DEFAULT_VALUE = {
        type: 16,
        number: 50,
        flags: FLAG_INTEGER
      };
      var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
      var transformOrigin = {
        name: "transform-origin",
        initialValue: "50% 50%",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          var origins = tokens.filter(isLengthPercentage);
          if (origins.length !== 2) {
            return DEFAULT;
          }
          return [origins[0], origins[1]];
        }
      };
      var visibility = {
        name: "visible",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, visibility2) {
          switch (visibility2) {
            case "hidden":
              return 1;
            case "collapse":
              return 2;
            case "visible":
            default:
              return 0;
          }
        }
      };
      var WORD_BREAK;
      (function(WORD_BREAK2) {
        WORD_BREAK2["NORMAL"] = "normal";
        WORD_BREAK2["BREAK_ALL"] = "break-all";
        WORD_BREAK2["KEEP_ALL"] = "keep-all";
      })(WORD_BREAK || (WORD_BREAK = {}));
      var wordBreak = {
        name: "word-break",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, wordBreak2) {
          switch (wordBreak2) {
            case "break-all":
              return WORD_BREAK.BREAK_ALL;
            case "keep-all":
              return WORD_BREAK.KEEP_ALL;
            case "normal":
            default:
              return WORD_BREAK.NORMAL;
          }
        }
      };
      var zIndex = {
        name: "z-index",
        initialValue: "auto",
        prefix: false,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20) {
            return { auto: true, order: 0 };
          }
          if (isNumberToken(token)) {
            return { auto: false, order: token.number };
          }
          throw new Error("Invalid z-index number parsed");
        }
      };
      var time = {
        name: "time",
        parse: function(_context, value) {
          if (value.type === 15) {
            switch (value.unit.toLowerCase()) {
              case "s":
                return 1e3 * value.number;
              case "ms":
                return value.number;
            }
          }
          throw new Error("Unsupported time type");
        }
      };
      var opacity = {
        name: "opacity",
        initialValue: "1",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isNumberToken(token)) {
            return token.number;
          }
          return 1;
        }
      };
      var textDecorationColor = {
        name: "text-decoration-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var textDecorationLine = {
        name: "text-decoration-line",
        initialValue: "none",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(token) {
            switch (token.value) {
              case "underline":
                return 1;
              case "overline":
                return 2;
              case "line-through":
                return 3;
              case "none":
                return 4;
            }
            return 0;
          }).filter(function(line) {
            return line !== 0;
          });
        }
      };
      var fontFamily = {
        name: "font-family",
        initialValue: "",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          var accumulator = [];
          var results = [];
          tokens.forEach(function(token) {
            switch (token.type) {
              case 20:
              case 0:
                accumulator.push(token.value);
                break;
              case 17:
                accumulator.push(token.number.toString());
                break;
              case 4:
                results.push(accumulator.join(" "));
                accumulator.length = 0;
                break;
            }
          });
          if (accumulator.length) {
            results.push(accumulator.join(" "));
          }
          return results.map(function(result) {
            return result.indexOf(" ") === -1 ? result : "'" + result + "'";
          });
        }
      };
      var fontSize = {
        name: "font-size",
        initialValue: "0",
        prefix: false,
        type: 3,
        format: "length"
      };
      var fontWeight = {
        name: "font-weight",
        initialValue: "normal",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isNumberToken(token)) {
            return token.number;
          }
          if (isIdentToken(token)) {
            switch (token.value) {
              case "bold":
                return 700;
              case "normal":
              default:
                return 400;
            }
          }
          return 400;
        }
      };
      var fontVariant = {
        name: "font-variant",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(token) {
            return token.value;
          });
        }
      };
      var fontStyle = {
        name: "font-style",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, overflow2) {
          switch (overflow2) {
            case "oblique":
              return "oblique";
            case "italic":
              return "italic";
            case "normal":
            default:
              return "normal";
          }
        }
      };
      var contains = function(bit, value) {
        return (bit & value) !== 0;
      };
      var content = {
        name: "content",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return [];
          }
          return tokens;
        }
      };
      var counterIncrement = {
        name: "counter-increment",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return null;
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return null;
          }
          var increments = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i4 = 0; i4 < filtered.length; i4++) {
            var counter = filtered[i4];
            var next = filtered[i4 + 1];
            if (counter.type === 20) {
              var increment = next && isNumberToken(next) ? next.number : 1;
              increments.push({ counter: counter.value, increment });
            }
          }
          return increments;
        }
      };
      var counterReset = {
        name: "counter-reset",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var resets = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i4 = 0; i4 < filtered.length; i4++) {
            var counter = filtered[i4];
            var next = filtered[i4 + 1];
            if (isIdentToken(counter) && counter.value !== "none") {
              var reset = next && isNumberToken(next) ? next.number : 0;
              resets.push({ counter: counter.value, reset });
            }
          }
          return resets;
        }
      };
      var duration = {
        name: "duration",
        initialValue: "0s",
        prefix: false,
        type: 1,
        parse: function(context, tokens) {
          return tokens.filter(isDimensionToken).map(function(token) {
            return time.parse(context, token);
          });
        }
      };
      var quotes = {
        name: "quotes",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return null;
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return null;
          }
          var quotes2 = [];
          var filtered = tokens.filter(isStringToken);
          if (filtered.length % 2 !== 0) {
            return null;
          }
          for (var i4 = 0; i4 < filtered.length; i4 += 2) {
            var open_1 = filtered[i4].value;
            var close_1 = filtered[i4 + 1].value;
            quotes2.push({ open: open_1, close: close_1 });
          }
          return quotes2;
        }
      };
      var getQuote = function(quotes2, depth, open3) {
        if (!quotes2) {
          return "";
        }
        var quote = quotes2[Math.min(depth, quotes2.length - 1)];
        if (!quote) {
          return "";
        }
        return open3 ? quote.open : quote.close;
      };
      var boxShadow = {
        name: "box-shadow",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
            return [];
          }
          return parseFunctionArgs(tokens).map(function(values) {
            var shadow = {
              color: 255,
              offsetX: ZERO_LENGTH,
              offsetY: ZERO_LENGTH,
              blur: ZERO_LENGTH,
              spread: ZERO_LENGTH,
              inset: false
            };
            var c4 = 0;
            for (var i4 = 0; i4 < values.length; i4++) {
              var token = values[i4];
              if (isIdentWithValue(token, "inset")) {
                shadow.inset = true;
              } else if (isLength(token)) {
                if (c4 === 0) {
                  shadow.offsetX = token;
                } else if (c4 === 1) {
                  shadow.offsetY = token;
                } else if (c4 === 2) {
                  shadow.blur = token;
                } else {
                  shadow.spread = token;
                }
                c4++;
              } else {
                shadow.color = color$1.parse(context, token);
              }
            }
            return shadow;
          });
        }
      };
      var paintOrder = {
        name: "paint-order",
        initialValue: "normal",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          var DEFAULT_VALUE2 = [
            0,
            1,
            2
            /* MARKERS */
          ];
          var layers = [];
          tokens.filter(isIdentToken).forEach(function(token) {
            switch (token.value) {
              case "stroke":
                layers.push(
                  1
                  /* STROKE */
                );
                break;
              case "fill":
                layers.push(
                  0
                  /* FILL */
                );
                break;
              case "markers":
                layers.push(
                  2
                  /* MARKERS */
                );
                break;
            }
          });
          DEFAULT_VALUE2.forEach(function(value) {
            if (layers.indexOf(value) === -1) {
              layers.push(value);
            }
          });
          return layers;
        }
      };
      var webkitTextStrokeColor = {
        name: "-webkit-text-stroke-color",
        initialValue: "currentcolor",
        prefix: false,
        type: 3,
        format: "color"
      };
      var webkitTextStrokeWidth = {
        name: "-webkit-text-stroke-width",
        initialValue: "0",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isDimensionToken(token)) {
            return token.number;
          }
          return 0;
        }
      };
      var CSSParsedDeclaration = (
        /** @class */
        function() {
          function CSSParsedDeclaration2(context, declaration) {
            var _a2, _b2;
            this.animationDuration = parse2(context, duration, declaration.animationDuration);
            this.backgroundClip = parse2(context, backgroundClip, declaration.backgroundClip);
            this.backgroundColor = parse2(context, backgroundColor, declaration.backgroundColor);
            this.backgroundImage = parse2(context, backgroundImage, declaration.backgroundImage);
            this.backgroundOrigin = parse2(context, backgroundOrigin, declaration.backgroundOrigin);
            this.backgroundPosition = parse2(context, backgroundPosition, declaration.backgroundPosition);
            this.backgroundRepeat = parse2(context, backgroundRepeat, declaration.backgroundRepeat);
            this.backgroundSize = parse2(context, backgroundSize, declaration.backgroundSize);
            this.borderTopColor = parse2(context, borderTopColor, declaration.borderTopColor);
            this.borderRightColor = parse2(context, borderRightColor, declaration.borderRightColor);
            this.borderBottomColor = parse2(context, borderBottomColor, declaration.borderBottomColor);
            this.borderLeftColor = parse2(context, borderLeftColor, declaration.borderLeftColor);
            this.borderTopLeftRadius = parse2(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
            this.borderTopRightRadius = parse2(context, borderTopRightRadius, declaration.borderTopRightRadius);
            this.borderBottomRightRadius = parse2(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
            this.borderBottomLeftRadius = parse2(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
            this.borderTopStyle = parse2(context, borderTopStyle, declaration.borderTopStyle);
            this.borderRightStyle = parse2(context, borderRightStyle, declaration.borderRightStyle);
            this.borderBottomStyle = parse2(context, borderBottomStyle, declaration.borderBottomStyle);
            this.borderLeftStyle = parse2(context, borderLeftStyle, declaration.borderLeftStyle);
            this.borderTopWidth = parse2(context, borderTopWidth, declaration.borderTopWidth);
            this.borderRightWidth = parse2(context, borderRightWidth, declaration.borderRightWidth);
            this.borderBottomWidth = parse2(context, borderBottomWidth, declaration.borderBottomWidth);
            this.borderLeftWidth = parse2(context, borderLeftWidth, declaration.borderLeftWidth);
            this.boxShadow = parse2(context, boxShadow, declaration.boxShadow);
            this.color = parse2(context, color, declaration.color);
            this.direction = parse2(context, direction, declaration.direction);
            this.display = parse2(context, display, declaration.display);
            this.float = parse2(context, float, declaration.cssFloat);
            this.fontFamily = parse2(context, fontFamily, declaration.fontFamily);
            this.fontSize = parse2(context, fontSize, declaration.fontSize);
            this.fontStyle = parse2(context, fontStyle, declaration.fontStyle);
            this.fontVariant = parse2(context, fontVariant, declaration.fontVariant);
            this.fontWeight = parse2(context, fontWeight, declaration.fontWeight);
            this.letterSpacing = parse2(context, letterSpacing, declaration.letterSpacing);
            this.lineBreak = parse2(context, lineBreak, declaration.lineBreak);
            this.lineHeight = parse2(context, lineHeight, declaration.lineHeight);
            this.listStyleImage = parse2(context, listStyleImage, declaration.listStyleImage);
            this.listStylePosition = parse2(context, listStylePosition, declaration.listStylePosition);
            this.listStyleType = parse2(context, listStyleType, declaration.listStyleType);
            this.marginTop = parse2(context, marginTop, declaration.marginTop);
            this.marginRight = parse2(context, marginRight, declaration.marginRight);
            this.marginBottom = parse2(context, marginBottom, declaration.marginBottom);
            this.marginLeft = parse2(context, marginLeft, declaration.marginLeft);
            this.opacity = parse2(context, opacity, declaration.opacity);
            var overflowTuple = parse2(context, overflow, declaration.overflow);
            this.overflowX = overflowTuple[0];
            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
            this.overflowWrap = parse2(context, overflowWrap, declaration.overflowWrap);
            this.paddingTop = parse2(context, paddingTop, declaration.paddingTop);
            this.paddingRight = parse2(context, paddingRight, declaration.paddingRight);
            this.paddingBottom = parse2(context, paddingBottom, declaration.paddingBottom);
            this.paddingLeft = parse2(context, paddingLeft, declaration.paddingLeft);
            this.paintOrder = parse2(context, paintOrder, declaration.paintOrder);
            this.position = parse2(context, position, declaration.position);
            this.textAlign = parse2(context, textAlign, declaration.textAlign);
            this.textDecorationColor = parse2(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
            this.textDecorationLine = parse2(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
            this.textShadow = parse2(context, textShadow, declaration.textShadow);
            this.textTransform = parse2(context, textTransform, declaration.textTransform);
            this.transform = parse2(context, transform$1, declaration.transform);
            this.transformOrigin = parse2(context, transformOrigin, declaration.transformOrigin);
            this.visibility = parse2(context, visibility, declaration.visibility);
            this.webkitTextStrokeColor = parse2(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
            this.webkitTextStrokeWidth = parse2(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
            this.wordBreak = parse2(context, wordBreak, declaration.wordBreak);
            this.zIndex = parse2(context, zIndex, declaration.zIndex);
          }
          CSSParsedDeclaration2.prototype.isVisible = function() {
            return this.display > 0 && this.opacity > 0 && this.visibility === 0;
          };
          CSSParsedDeclaration2.prototype.isTransparent = function() {
            return isTransparent(this.backgroundColor);
          };
          CSSParsedDeclaration2.prototype.isTransformed = function() {
            return this.transform !== null;
          };
          CSSParsedDeclaration2.prototype.isPositioned = function() {
            return this.position !== 0;
          };
          CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
            return this.isPositioned() && !this.zIndex.auto;
          };
          CSSParsedDeclaration2.prototype.isFloating = function() {
            return this.float !== 0;
          };
          CSSParsedDeclaration2.prototype.isInlineLevel = function() {
            return contains(
              this.display,
              4
              /* INLINE */
            ) || contains(
              this.display,
              33554432
              /* INLINE_BLOCK */
            ) || contains(
              this.display,
              268435456
              /* INLINE_FLEX */
            ) || contains(
              this.display,
              536870912
              /* INLINE_GRID */
            ) || contains(
              this.display,
              67108864
              /* INLINE_LIST_ITEM */
            ) || contains(
              this.display,
              134217728
              /* INLINE_TABLE */
            );
          };
          return CSSParsedDeclaration2;
        }()
      );
      var CSSParsedPseudoDeclaration = (
        /** @class */
        function() {
          function CSSParsedPseudoDeclaration2(context, declaration) {
            this.content = parse2(context, content, declaration.content);
            this.quotes = parse2(context, quotes, declaration.quotes);
          }
          return CSSParsedPseudoDeclaration2;
        }()
      );
      var CSSParsedCounterDeclaration = (
        /** @class */
        function() {
          function CSSParsedCounterDeclaration2(context, declaration) {
            this.counterIncrement = parse2(context, counterIncrement, declaration.counterIncrement);
            this.counterReset = parse2(context, counterReset, declaration.counterReset);
          }
          return CSSParsedCounterDeclaration2;
        }()
      );
      var parse2 = function(context, descriptor, style) {
        var tokenizer = new Tokenizer();
        var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
        tokenizer.write(value);
        var parser = new Parser2(tokenizer.read());
        switch (descriptor.type) {
          case 2:
            var token = parser.parseComponentValue();
            return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
          case 0:
            return descriptor.parse(context, parser.parseComponentValue());
          case 1:
            return descriptor.parse(context, parser.parseComponentValues());
          case 4:
            return parser.parseComponentValue();
          case 3:
            switch (descriptor.format) {
              case "angle":
                return angle.parse(context, parser.parseComponentValue());
              case "color":
                return color$1.parse(context, parser.parseComponentValue());
              case "image":
                return image.parse(context, parser.parseComponentValue());
              case "length":
                var length_1 = parser.parseComponentValue();
                return isLength(length_1) ? length_1 : ZERO_LENGTH;
              case "length-percentage":
                var value_1 = parser.parseComponentValue();
                return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
              case "time":
                return time.parse(context, parser.parseComponentValue());
            }
            break;
        }
      };
      var elementDebuggerAttribute = "data-html2canvas-debug";
      var getElementDebugType = function(element) {
        var attribute = element.getAttribute(elementDebuggerAttribute);
        switch (attribute) {
          case "all":
            return 1;
          case "clone":
            return 2;
          case "parse":
            return 3;
          case "render":
            return 4;
          default:
            return 0;
        }
      };
      var isDebugging = function(element, type) {
        var elementType = getElementDebugType(element);
        return elementType === 1 || type === elementType;
      };
      var ElementContainer = (
        /** @class */
        function() {
          function ElementContainer2(context, element) {
            this.context = context;
            this.textNodes = [];
            this.elements = [];
            this.flags = 0;
            if (isDebugging(
              element,
              3
              /* PARSE */
            )) {
              debugger;
            }
            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
            if (isHTMLElementNode(element)) {
              if (this.styles.animationDuration.some(function(duration2) {
                return duration2 > 0;
              })) {
                element.style.animationDuration = "0s";
              }
              if (this.styles.transform !== null) {
                element.style.transform = "none";
              }
            }
            this.bounds = parseBounds(this.context, element);
            if (isDebugging(
              element,
              4
              /* RENDER */
            )) {
              this.flags |= 16;
            }
          }
          return ElementContainer2;
        }()
      );
      var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
      var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
        lookup$1[chars$1.charCodeAt(i$1)] = i$1;
      }
      var decode2 = function(base642) {
        var bufferLength = base642.length * 0.75, len = base642.length, i4, p3 = 0, encoded1, encoded2, encoded3, encoded4;
        if (base642[base642.length - 1] === "=") {
          bufferLength--;
          if (base642[base642.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i4 = 0; i4 < len; i4 += 4) {
          encoded1 = lookup$1[base642.charCodeAt(i4)];
          encoded2 = lookup$1[base642.charCodeAt(i4 + 1)];
          encoded3 = lookup$1[base642.charCodeAt(i4 + 2)];
          encoded4 = lookup$1[base642.charCodeAt(i4 + 3)];
          bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      };
      var polyUint16Array = function(buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i4 = 0; i4 < length; i4 += 2) {
          bytes.push(buffer[i4 + 1] << 8 | buffer[i4]);
        }
        return bytes;
      };
      var polyUint32Array = function(buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i4 = 0; i4 < length; i4 += 4) {
          bytes.push(buffer[i4 + 3] << 24 | buffer[i4 + 2] << 16 | buffer[i4 + 1] << 8 | buffer[i4]);
        }
        return bytes;
      };
      var UTRIE2_SHIFT_2 = 5;
      var UTRIE2_SHIFT_1 = 6 + 5;
      var UTRIE2_INDEX_SHIFT = 2;
      var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
      var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
      var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
      var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
      var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
      var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
      var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
      var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
      var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
      var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
      var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
      var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
      var slice16 = function(view, start, end) {
        if (view.slice) {
          return view.slice(start, end);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start, end));
      };
      var slice32 = function(view, start, end) {
        if (view.slice) {
          return view.slice(start, end);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start, end));
      };
      var createTrieFromBase64 = function(base642, _byteLength) {
        var buffer = decode2(base642);
        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
        var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data);
      };
      var Trie = (
        /** @class */
        function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index2;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }()
      );
      var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i3 = 0; i3 < chars2.length; i3++) {
        lookup2[chars2.charCodeAt(i3)] = i3;
      }
      var Prepend = 1;
      var CR = 2;
      var LF = 3;
      var Control = 4;
      var Extend = 5;
      var SpacingMark = 7;
      var L2 = 8;
      var V2 = 9;
      var T3 = 10;
      var LV = 11;
      var LVT = 12;
      var ZWJ = 13;
      var Extended_Pictographic = 14;
      var RI = 15;
      var toCodePoints = function(str) {
        var codePoints = [];
        var i4 = 0;
        var length = str.length;
        while (i4 < length) {
          var value = str.charCodeAt(i4++);
          if (value >= 55296 && value <= 56319 && i4 < length) {
            var extra = str.charCodeAt(i4++);
            if ((extra & 64512) === 56320) {
              codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              codePoints.push(value);
              i4--;
            }
          } else {
            codePoints.push(value);
          }
        }
        return codePoints;
      };
      var fromCodePoint = function() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
        }
        var length = codePoints.length;
        if (!length) {
          return "";
        }
        var codeUnits = [];
        var index2 = -1;
        var result = "";
        while (++index2 < length) {
          var codePoint = codePoints[index2];
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (index2 + 1 === length || codeUnits.length > 16384) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      var UnicodeTrie = createTrieFromBase64(base64);
      var BREAK_NOT_ALLOWED = "\xD7";
      var BREAK_ALLOWED = "\xF7";
      var codePointToClass = function(codePoint) {
        return UnicodeTrie.get(codePoint);
      };
      var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
        var prevIndex = index2 - 2;
        var prev = classTypes[prevIndex];
        var current = classTypes[index2 - 1];
        var next = classTypes[index2];
        if (current === CR && next === LF) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === CR || current === LF || current === Control) {
          return BREAK_ALLOWED;
        }
        if (next === CR || next === LF || next === Control) {
          return BREAK_ALLOWED;
        }
        if (current === L2 && [L2, V2, LV, LVT].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED;
        }
        if ((current === LV || current === V2) && (next === V2 || next === T3)) {
          return BREAK_NOT_ALLOWED;
        }
        if ((current === LVT || current === T3) && next === T3) {
          return BREAK_NOT_ALLOWED;
        }
        if (next === ZWJ || next === Extend) {
          return BREAK_NOT_ALLOWED;
        }
        if (next === SpacingMark) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === Prepend) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === ZWJ && next === Extended_Pictographic) {
          while (prev === Extend) {
            prev = classTypes[--prevIndex];
          }
          if (prev === Extended_Pictographic) {
            return BREAK_NOT_ALLOWED;
          }
        }
        if (current === RI && next === RI) {
          var countRI = 0;
          while (prev === RI) {
            countRI++;
            prev = classTypes[--prevIndex];
          }
          if (countRI % 2 === 0) {
            return BREAK_NOT_ALLOWED;
          }
        }
        return BREAK_ALLOWED;
      };
      var GraphemeBreaker = function(str) {
        var codePoints = toCodePoints(str);
        var length = codePoints.length;
        var index2 = 0;
        var lastEnd = 0;
        var classTypes = codePoints.map(codePointToClass);
        return {
          next: function() {
            if (index2 >= length) {
              return { done: true, value: null };
            }
            var graphemeBreak = BREAK_NOT_ALLOWED;
            while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
            }
            if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
              var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
              lastEnd = index2;
              return { value, done: false };
            }
            return { done: true, value: null };
          }
        };
      };
      var splitGraphemes = function(str) {
        var breaker = GraphemeBreaker(str);
        var graphemes = [];
        var bk;
        while (!(bk = breaker.next()).done) {
          if (bk.value) {
            graphemes.push(bk.value.slice());
          }
        }
        return graphemes;
      };
      var testRangeBounds = function(document2) {
        var TEST_HEIGHT = 123;
        if (document2.createRange) {
          var range = document2.createRange();
          if (range.getBoundingClientRect) {
            var testElement = document2.createElement("boundtest");
            testElement.style.height = TEST_HEIGHT + "px";
            testElement.style.display = "block";
            document2.body.appendChild(testElement);
            range.selectNode(testElement);
            var rangeBounds = range.getBoundingClientRect();
            var rangeHeight = Math.round(rangeBounds.height);
            document2.body.removeChild(testElement);
            if (rangeHeight === TEST_HEIGHT) {
              return true;
            }
          }
        }
        return false;
      };
      var testIOSLineBreak = function(document2) {
        var testElement = document2.createElement("boundtest");
        testElement.style.width = "50px";
        testElement.style.display = "block";
        testElement.style.fontSize = "12px";
        testElement.style.letterSpacing = "0px";
        testElement.style.wordSpacing = "0px";
        document2.body.appendChild(testElement);
        var range = document2.createRange();
        testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
        var node2 = testElement.firstChild;
        var textList = toCodePoints$1(node2.data).map(function(i4) {
          return fromCodePoint$1(i4);
        });
        var offset = 0;
        var prev = {};
        var supports = textList.every(function(text, i4) {
          range.setStart(node2, offset);
          range.setEnd(node2, offset + text.length);
          var rect = range.getBoundingClientRect();
          offset += text.length;
          var boundAhead = rect.x > prev.x || rect.y > prev.y;
          prev = rect;
          if (i4 === 0) {
            return true;
          }
          return boundAhead;
        });
        document2.body.removeChild(testElement);
        return supports;
      };
      var testCORS = function() {
        return typeof new Image().crossOrigin !== "undefined";
      };
      var testResponseType = function() {
        return typeof new XMLHttpRequest().responseType === "string";
      };
      var testSVG = function(document2) {
        var img = new Image();
        var canvas = document2.createElement("canvas");
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return false;
        }
        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
        try {
          ctx.drawImage(img, 0, 0);
          canvas.toDataURL();
        } catch (e3) {
          return false;
        }
        return true;
      };
      var isGreenPixel = function(data) {
        return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
      };
      var testForeignObject = function(document2) {
        var canvas = document2.createElement("canvas");
        var size = 100;
        canvas.width = size;
        canvas.height = size;
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return Promise.reject(false);
        }
        ctx.fillStyle = "rgb(0, 255, 0)";
        ctx.fillRect(0, 0, size, size);
        var img = new Image();
        var greenImageSrc = canvas.toDataURL();
        img.src = greenImageSrc;
        var svg = createForeignObjectSVG(size, size, 0, 0, img);
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, size, size);
        return loadSerializedSVG$1(svg).then(function(img2) {
          ctx.drawImage(img2, 0, 0);
          var data = ctx.getImageData(0, 0, size, size).data;
          ctx.fillStyle = "red";
          ctx.fillRect(0, 0, size, size);
          var node2 = document2.createElement("div");
          node2.style.backgroundImage = "url(" + greenImageSrc + ")";
          node2.style.height = size + "px";
          return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);
        }).then(function(img2) {
          ctx.drawImage(img2, 0, 0);
          return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
        }).catch(function() {
          return false;
        });
      };
      var createForeignObjectSVG = function(width, height, x2, y3, node2) {
        var xmlns = "http://www.w3.org/2000/svg";
        var svg = document.createElementNS(xmlns, "svg");
        var foreignObject = document.createElementNS(xmlns, "foreignObject");
        svg.setAttributeNS(null, "width", width.toString());
        svg.setAttributeNS(null, "height", height.toString());
        foreignObject.setAttributeNS(null, "width", "100%");
        foreignObject.setAttributeNS(null, "height", "100%");
        foreignObject.setAttributeNS(null, "x", x2.toString());
        foreignObject.setAttributeNS(null, "y", y3.toString());
        foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
        svg.appendChild(foreignObject);
        foreignObject.appendChild(node2);
        return svg;
      };
      var loadSerializedSVG$1 = function(svg) {
        return new Promise(function(resolve2, reject2) {
          var img = new Image();
          img.onload = function() {
            return resolve2(img);
          };
          img.onerror = reject2;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
        });
      };
      var FEATURES = {
        get SUPPORT_RANGE_BOUNDS() {
          var value = testRangeBounds(document);
          Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
          return value;
        },
        get SUPPORT_WORD_BREAKING() {
          var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
          Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
          return value;
        },
        get SUPPORT_SVG_DRAWING() {
          var value = testSVG(document);
          Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
          return value;
        },
        get SUPPORT_FOREIGNOBJECT_DRAWING() {
          var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
          Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
          return value;
        },
        get SUPPORT_CORS_IMAGES() {
          var value = testCORS();
          Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
          return value;
        },
        get SUPPORT_RESPONSE_TYPE() {
          var value = testResponseType();
          Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
          return value;
        },
        get SUPPORT_CORS_XHR() {
          var value = "withCredentials" in new XMLHttpRequest();
          Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
          return value;
        },
        get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
          var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
          Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
          return value;
        }
      };
      var TextBounds = (
        /** @class */
        function() {
          function TextBounds2(text, bounds) {
            this.text = text;
            this.bounds = bounds;
          }
          return TextBounds2;
        }()
      );
      var parseTextBounds = function(context, value, styles, node2) {
        var textList = breakText(value, styles);
        var textBounds = [];
        var offset = 0;
        textList.forEach(function(text) {
          if (styles.textDecorationLine.length || text.trim().length > 0) {
            if (FEATURES.SUPPORT_RANGE_BOUNDS) {
              var clientRects = createRange(node2, offset, text.length).getClientRects();
              if (clientRects.length > 1) {
                var subSegments = segmentGraphemes(text);
                var subOffset_1 = 0;
                subSegments.forEach(function(subSegment) {
                  textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node2, subOffset_1 + offset, subSegment.length).getClientRects())));
                  subOffset_1 += subSegment.length;
                });
              } else {
                textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
              }
            } else {
              var replacementNode = node2.splitText(text.length);
              textBounds.push(new TextBounds(text, getWrapperBounds(context, node2)));
              node2 = replacementNode;
            }
          } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
            node2 = node2.splitText(text.length);
          }
          offset += text.length;
        });
        return textBounds;
      };
      var getWrapperBounds = function(context, node2) {
        var ownerDocument = node2.ownerDocument;
        if (ownerDocument) {
          var wrapper = ownerDocument.createElement("html2canvaswrapper");
          wrapper.appendChild(node2.cloneNode(true));
          var parentNode = node2.parentNode;
          if (parentNode) {
            parentNode.replaceChild(wrapper, node2);
            var bounds = parseBounds(context, wrapper);
            if (wrapper.firstChild) {
              parentNode.replaceChild(wrapper.firstChild, wrapper);
            }
            return bounds;
          }
        }
        return Bounds.EMPTY;
      };
      var createRange = function(node2, offset, length) {
        var ownerDocument = node2.ownerDocument;
        if (!ownerDocument) {
          throw new Error("Node has no owner document");
        }
        var range = ownerDocument.createRange();
        range.setStart(node2, offset);
        range.setEnd(node2, offset + length);
        return range;
      };
      var segmentGraphemes = function(value) {
        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
          return Array.from(segmenter.segment(value)).map(function(segment) {
            return segment.segment;
          });
        }
        return splitGraphemes(value);
      };
      var segmentWords = function(value, styles) {
        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          var segmenter = new Intl.Segmenter(void 0, {
            granularity: "word"
          });
          return Array.from(segmenter.segment(value)).map(function(segment) {
            return segment.segment;
          });
        }
        return breakWords(value, styles);
      };
      var breakText = function(value, styles) {
        return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
      };
      var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
      var breakWords = function(str, styles) {
        var breaker = LineBreaker(str, {
          lineBreak: styles.lineBreak,
          wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
        });
        var words = [];
        var bk;
        var _loop_1 = function() {
          if (bk.value) {
            var value = bk.value.slice();
            var codePoints = toCodePoints$1(value);
            var word_1 = "";
            codePoints.forEach(function(codePoint) {
              if (wordSeparators.indexOf(codePoint) === -1) {
                word_1 += fromCodePoint$1(codePoint);
              } else {
                if (word_1.length) {
                  words.push(word_1);
                }
                words.push(fromCodePoint$1(codePoint));
                word_1 = "";
              }
            });
            if (word_1.length) {
              words.push(word_1);
            }
          }
        };
        while (!(bk = breaker.next()).done) {
          _loop_1();
        }
        return words;
      };
      var TextContainer = (
        /** @class */
        function() {
          function TextContainer2(context, node2, styles) {
            this.text = transform(node2.data, styles.textTransform);
            this.textBounds = parseTextBounds(context, this.text, styles, node2);
          }
          return TextContainer2;
        }()
      );
      var transform = function(text, transform2) {
        switch (transform2) {
          case 1:
            return text.toLowerCase();
          case 3:
            return text.replace(CAPITALIZE, capitalize);
          case 2:
            return text.toUpperCase();
          default:
            return text;
        }
      };
      var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
      var capitalize = function(m4, p1, p22) {
        if (m4.length > 0) {
          return p1 + p22.toUpperCase();
        }
        return m4;
      };
      var ImageElementContainer = (
        /** @class */
        function(_super) {
          __extends(ImageElementContainer2, _super);
          function ImageElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            _this.src = img.currentSrc || img.src;
            _this.intrinsicWidth = img.naturalWidth;
            _this.intrinsicHeight = img.naturalHeight;
            _this.context.cache.addImage(_this.src);
            return _this;
          }
          return ImageElementContainer2;
        }(ElementContainer)
      );
      var CanvasElementContainer = (
        /** @class */
        function(_super) {
          __extends(CanvasElementContainer2, _super);
          function CanvasElementContainer2(context, canvas) {
            var _this = _super.call(this, context, canvas) || this;
            _this.canvas = canvas;
            _this.intrinsicWidth = canvas.width;
            _this.intrinsicHeight = canvas.height;
            return _this;
          }
          return CanvasElementContainer2;
        }(ElementContainer)
      );
      var SVGElementContainer = (
        /** @class */
        function(_super) {
          __extends(SVGElementContainer2, _super);
          function SVGElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            var s3 = new XMLSerializer();
            var bounds = parseBounds(context, img);
            img.setAttribute("width", bounds.width + "px");
            img.setAttribute("height", bounds.height + "px");
            _this.svg = "data:image/svg+xml," + encodeURIComponent(s3.serializeToString(img));
            _this.intrinsicWidth = img.width.baseVal.value;
            _this.intrinsicHeight = img.height.baseVal.value;
            _this.context.cache.addImage(_this.svg);
            return _this;
          }
          return SVGElementContainer2;
        }(ElementContainer)
      );
      var LIElementContainer = (
        /** @class */
        function(_super) {
          __extends(LIElementContainer2, _super);
          function LIElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.value = element.value;
            return _this;
          }
          return LIElementContainer2;
        }(ElementContainer)
      );
      var OLElementContainer = (
        /** @class */
        function(_super) {
          __extends(OLElementContainer2, _super);
          function OLElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.start = element.start;
            _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
            return _this;
          }
          return OLElementContainer2;
        }(ElementContainer)
      );
      var CHECKBOX_BORDER_RADIUS = [
        {
          type: 15,
          flags: 0,
          unit: "px",
          number: 3
        }
      ];
      var RADIO_BORDER_RADIUS = [
        {
          type: 16,
          flags: 0,
          number: 50
        }
      ];
      var reformatInputBounds = function(bounds) {
        if (bounds.width > bounds.height) {
          return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
        } else if (bounds.width < bounds.height) {
          return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
        }
        return bounds;
      };
      var getInputValue = function(node2) {
        var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join("\u2022") : node2.value;
        return value.length === 0 ? node2.placeholder || "" : value;
      };
      var CHECKBOX = "checkbox";
      var RADIO = "radio";
      var PASSWORD = "password";
      var INPUT_COLOR = 707406591;
      var InputElementContainer = (
        /** @class */
        function(_super) {
          __extends(InputElementContainer2, _super);
          function InputElementContainer2(context, input) {
            var _this = _super.call(this, context, input) || this;
            _this.type = input.type.toLowerCase();
            _this.checked = input.checked;
            _this.value = getInputValue(input);
            if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 3739148031;
              _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
              _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
              _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
              _this.styles.backgroundClip = [
                0
                /* BORDER_BOX */
              ];
              _this.styles.backgroundOrigin = [
                0
                /* BORDER_BOX */
              ];
              _this.bounds = reformatInputBounds(_this.bounds);
            }
            switch (_this.type) {
              case CHECKBOX:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                break;
              case RADIO:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                break;
            }
            return _this;
          }
          return InputElementContainer2;
        }(ElementContainer)
      );
      var SelectElementContainer = (
        /** @class */
        function(_super) {
          __extends(SelectElementContainer2, _super);
          function SelectElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            var option = element.options[element.selectedIndex || 0];
            _this.value = option ? option.text || "" : "";
            return _this;
          }
          return SelectElementContainer2;
        }(ElementContainer)
      );
      var TextareaElementContainer = (
        /** @class */
        function(_super) {
          __extends(TextareaElementContainer2, _super);
          function TextareaElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.value = element.value;
            return _this;
          }
          return TextareaElementContainer2;
        }(ElementContainer)
      );
      var IFrameElementContainer = (
        /** @class */
        function(_super) {
          __extends(IFrameElementContainer2, _super);
          function IFrameElementContainer2(context, iframe) {
            var _this = _super.call(this, context, iframe) || this;
            _this.src = iframe.src;
            _this.width = parseInt(iframe.width, 10) || 0;
            _this.height = parseInt(iframe.height, 10) || 0;
            _this.backgroundColor = _this.styles.backgroundColor;
            try {
              if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
                _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
                var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
                _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
              }
            } catch (e3) {
            }
            return _this;
          }
          return IFrameElementContainer2;
        }(ElementContainer)
      );
      var LIST_OWNERS = ["OL", "UL", "MENU"];
      var parseNodeTree = function(context, node2, parent, root) {
        for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
          nextNode = childNode.nextSibling;
          if (isTextNode(childNode) && childNode.data.trim().length > 0) {
            parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
          } else if (isElementNode(childNode)) {
            if (isSlotElement(childNode) && childNode.assignedNodes) {
              childNode.assignedNodes().forEach(function(childNode2) {
                return parseNodeTree(context, childNode2, parent, root);
              });
            } else {
              var container = createContainer(context, childNode);
              if (container.styles.isVisible()) {
                if (createsRealStackingContext(childNode, container, root)) {
                  container.flags |= 4;
                } else if (createsStackingContext(container.styles)) {
                  container.flags |= 2;
                }
                if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                  container.flags |= 8;
                }
                parent.elements.push(container);
                childNode.slot;
                if (childNode.shadowRoot) {
                  parseNodeTree(context, childNode.shadowRoot, container, root);
                } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                  parseNodeTree(context, childNode, container, root);
                }
              }
            }
          }
        }
      };
      var createContainer = function(context, element) {
        if (isImageElement(element)) {
          return new ImageElementContainer(context, element);
        }
        if (isCanvasElement(element)) {
          return new CanvasElementContainer(context, element);
        }
        if (isSVGElement(element)) {
          return new SVGElementContainer(context, element);
        }
        if (isLIElement(element)) {
          return new LIElementContainer(context, element);
        }
        if (isOLElement(element)) {
          return new OLElementContainer(context, element);
        }
        if (isInputElement(element)) {
          return new InputElementContainer(context, element);
        }
        if (isSelectElement(element)) {
          return new SelectElementContainer(context, element);
        }
        if (isTextareaElement(element)) {
          return new TextareaElementContainer(context, element);
        }
        if (isIFrameElement(element)) {
          return new IFrameElementContainer(context, element);
        }
        return new ElementContainer(context, element);
      };
      var parseTree = function(context, element) {
        var container = createContainer(context, element);
        container.flags |= 4;
        parseNodeTree(context, element, container, container);
        return container;
      };
      var createsRealStackingContext = function(node2, container, root) {
        return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root.styles.isTransparent();
      };
      var createsStackingContext = function(styles) {
        return styles.isPositioned() || styles.isFloating();
      };
      var isTextNode = function(node2) {
        return node2.nodeType === Node.TEXT_NODE;
      };
      var isElementNode = function(node2) {
        return node2.nodeType === Node.ELEMENT_NODE;
      };
      var isHTMLElementNode = function(node2) {
        return isElementNode(node2) && typeof node2.style !== "undefined" && !isSVGElementNode(node2);
      };
      var isSVGElementNode = function(element) {
        return typeof element.className === "object";
      };
      var isLIElement = function(node2) {
        return node2.tagName === "LI";
      };
      var isOLElement = function(node2) {
        return node2.tagName === "OL";
      };
      var isInputElement = function(node2) {
        return node2.tagName === "INPUT";
      };
      var isHTMLElement = function(node2) {
        return node2.tagName === "HTML";
      };
      var isSVGElement = function(node2) {
        return node2.tagName === "svg";
      };
      var isBodyElement = function(node2) {
        return node2.tagName === "BODY";
      };
      var isCanvasElement = function(node2) {
        return node2.tagName === "CANVAS";
      };
      var isVideoElement = function(node2) {
        return node2.tagName === "VIDEO";
      };
      var isImageElement = function(node2) {
        return node2.tagName === "IMG";
      };
      var isIFrameElement = function(node2) {
        return node2.tagName === "IFRAME";
      };
      var isStyleElement = function(node2) {
        return node2.tagName === "STYLE";
      };
      var isScriptElement = function(node2) {
        return node2.tagName === "SCRIPT";
      };
      var isTextareaElement = function(node2) {
        return node2.tagName === "TEXTAREA";
      };
      var isSelectElement = function(node2) {
        return node2.tagName === "SELECT";
      };
      var isSlotElement = function(node2) {
        return node2.tagName === "SLOT";
      };
      var isCustomElement = function(node2) {
        return node2.tagName.indexOf("-") > 0;
      };
      var CounterState = (
        /** @class */
        function() {
          function CounterState2() {
            this.counters = {};
          }
          CounterState2.prototype.getCounterValue = function(name) {
            var counter = this.counters[name];
            if (counter && counter.length) {
              return counter[counter.length - 1];
            }
            return 1;
          };
          CounterState2.prototype.getCounterValues = function(name) {
            var counter = this.counters[name];
            return counter ? counter : [];
          };
          CounterState2.prototype.pop = function(counters) {
            var _this = this;
            counters.forEach(function(counter) {
              return _this.counters[counter].pop();
            });
          };
          CounterState2.prototype.parse = function(style) {
            var _this = this;
            var counterIncrement2 = style.counterIncrement;
            var counterReset2 = style.counterReset;
            var canReset = true;
            if (counterIncrement2 !== null) {
              counterIncrement2.forEach(function(entry) {
                var counter = _this.counters[entry.counter];
                if (counter && entry.increment !== 0) {
                  canReset = false;
                  if (!counter.length) {
                    counter.push(1);
                  }
                  counter[Math.max(0, counter.length - 1)] += entry.increment;
                }
              });
            }
            var counterNames = [];
            if (canReset) {
              counterReset2.forEach(function(entry) {
                var counter = _this.counters[entry.counter];
                counterNames.push(entry.counter);
                if (!counter) {
                  counter = _this.counters[entry.counter] = [];
                }
                counter.push(entry.reset);
              });
            }
            return counterNames;
          };
          return CounterState2;
        }()
      );
      var ROMAN_UPPER = {
        integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
        values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
      };
      var ARMENIAN = {
        integers: [
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          900,
          800,
          700,
          600,
          500,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u0554",
          "\u0553",
          "\u0552",
          "\u0551",
          "\u0550",
          "\u054F",
          "\u054E",
          "\u054D",
          "\u054C",
          "\u054B",
          "\u054A",
          "\u0549",
          "\u0548",
          "\u0547",
          "\u0546",
          "\u0545",
          "\u0544",
          "\u0543",
          "\u0542",
          "\u0541",
          "\u0540",
          "\u053F",
          "\u053E",
          "\u053D",
          "\u053C",
          "\u053B",
          "\u053A",
          "\u0539",
          "\u0538",
          "\u0537",
          "\u0536",
          "\u0535",
          "\u0534",
          "\u0533",
          "\u0532",
          "\u0531"
        ]
      };
      var HEBREW = {
        integers: [
          1e4,
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          19,
          18,
          17,
          16,
          15,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u05D9\u05F3",
          "\u05D8\u05F3",
          "\u05D7\u05F3",
          "\u05D6\u05F3",
          "\u05D5\u05F3",
          "\u05D4\u05F3",
          "\u05D3\u05F3",
          "\u05D2\u05F3",
          "\u05D1\u05F3",
          "\u05D0\u05F3",
          "\u05EA",
          "\u05E9",
          "\u05E8",
          "\u05E7",
          "\u05E6",
          "\u05E4",
          "\u05E2",
          "\u05E1",
          "\u05E0",
          "\u05DE",
          "\u05DC",
          "\u05DB",
          "\u05D9\u05D8",
          "\u05D9\u05D7",
          "\u05D9\u05D6",
          "\u05D8\u05D6",
          "\u05D8\u05D5",
          "\u05D9",
          "\u05D8",
          "\u05D7",
          "\u05D6",
          "\u05D5",
          "\u05D4",
          "\u05D3",
          "\u05D2",
          "\u05D1",
          "\u05D0"
        ]
      };
      var GEORGIAN = {
        integers: [
          1e4,
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          900,
          800,
          700,
          600,
          500,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u10F5",
          "\u10F0",
          "\u10EF",
          "\u10F4",
          "\u10EE",
          "\u10ED",
          "\u10EC",
          "\u10EB",
          "\u10EA",
          "\u10E9",
          "\u10E8",
          "\u10E7",
          "\u10E6",
          "\u10E5",
          "\u10E4",
          "\u10F3",
          "\u10E2",
          "\u10E1",
          "\u10E0",
          "\u10DF",
          "\u10DE",
          "\u10DD",
          "\u10F2",
          "\u10DC",
          "\u10DB",
          "\u10DA",
          "\u10D9",
          "\u10D8",
          "\u10D7",
          "\u10F1",
          "\u10D6",
          "\u10D5",
          "\u10D4",
          "\u10D3",
          "\u10D2",
          "\u10D1",
          "\u10D0"
        ]
      };
      var createAdditiveCounter = function(value, min3, max4, symbols, fallback, suffix) {
        if (value < min3 || value > max4) {
          return createCounterText(value, fallback, suffix.length > 0);
        }
        return symbols.integers.reduce(function(string, integer, index2) {
          while (value >= integer) {
            value -= integer;
            string += symbols.values[index2];
          }
          return string;
        }, "") + suffix;
      };
      var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
        var string = "";
        do {
          if (!isNumeric) {
            value--;
          }
          string = resolver(value) + string;
          value /= codePointRangeLength;
        } while (value * codePointRangeLength >= codePointRangeLength);
        return string;
      };
      var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
        return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
          return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
        }) + suffix);
      };
      var createCounterStyleFromSymbols = function(value, symbols, suffix) {
        if (suffix === void 0) {
          suffix = ". ";
        }
        var codePointRangeLength = symbols.length;
        return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
          return symbols[Math.floor(codePoint % codePointRangeLength)];
        }) + suffix;
      };
      var CJK_ZEROS = 1 << 0;
      var CJK_TEN_COEFFICIENTS = 1 << 1;
      var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
      var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
      var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
        if (value < -9999 || value > 9999) {
          return createCounterText(value, 4, suffix.length > 0);
        }
        var tmp = Math.abs(value);
        var string = suffix;
        if (tmp === 0) {
          return numbers[0] + string;
        }
        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
          var coefficient = tmp % 10;
          if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
            string = numbers[coefficient] + string;
          } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
            string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
          } else if (coefficient === 1 && digit > 0) {
            string = multipliers[digit - 1] + string;
          }
          tmp = Math.floor(tmp / 10);
        }
        return (value < 0 ? negativeSign : "") + string;
      };
      var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
      var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
      var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
      var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
      var createCounterText = function(value, type, appendSuffix) {
        var defaultSuffix = appendSuffix ? ". " : "";
        var cjkSuffix = appendSuffix ? "\u3001" : "";
        var koreanSuffix = appendSuffix ? ", " : "";
        var spaceSuffix = appendSuffix ? " " : "";
        switch (type) {
          case 0:
            return "\u2022" + spaceSuffix;
          case 1:
            return "\u25E6" + spaceSuffix;
          case 2:
            return "\u25FE" + spaceSuffix;
          case 5:
            var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
            return string.length < 4 ? "0" + string : string;
          case 4:
            return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
          case 6:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
          case 7:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
          case 8:
            return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
          case 9:
            return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
          case 10:
            return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
          case 11:
            return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
          case 12:
          case 49:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
          case 35:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
          case 13:
            return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
          case 14:
          case 30:
            return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
          case 15:
            return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
          case 16:
            return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
          case 17:
          case 48:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 47:
            return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 42:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 41:
            return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 26:
            return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
          case 25:
            return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 31:
            return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 33:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
          case 32:
            return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 18:
            return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
          case 20:
            return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
          case 21:
            return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
          case 22:
            return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
          case 22:
            return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
          case 23:
            return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
          case 24:
            return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
          case 27:
            return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
          case 28:
            return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
          case 29:
            return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
          case 34:
            return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
          case 37:
            return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
          case 38:
            return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
          case 39:
            return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
          case 40:
            return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
          case 43:
            return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
          case 44:
            return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
          case 45:
            return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
          case 46:
            return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
          case 3:
          default:
            return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
        }
      };
      var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
      var DocumentCloner = (
        /** @class */
        function() {
          function DocumentCloner2(context, element, options) {
            this.context = context;
            this.options = options;
            this.scrolledElements = [];
            this.referenceElement = element;
            this.counters = new CounterState();
            this.quoteDepth = 0;
            if (!element.ownerDocument) {
              throw new Error("Cloned element does not have an owner document");
            }
            this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
          }
          DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
            var _this = this;
            var iframe = createIFrameContainer(ownerDocument, windowSize);
            if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
            }
            var scrollX = ownerDocument.defaultView.pageXOffset;
            var scrollY = ownerDocument.defaultView.pageYOffset;
            var cloneWindow = iframe.contentWindow;
            var documentClone = cloneWindow.document;
            var iframeLoad = iframeLoader(iframe).then(function() {
              return __awaiter(_this, void 0, void 0, function() {
                var onclone, referenceElement;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      this.scrolledElements.forEach(restoreNodeScroll);
                      if (cloneWindow) {
                        cloneWindow.scrollTo(windowSize.left, windowSize.top);
                        if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                          this.context.logger.warn("Unable to restore scroll position for cloned document");
                          this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                        }
                      }
                      onclone = this.options.onclone;
                      referenceElement = this.clonedReferenceElement;
                      if (typeof referenceElement === "undefined") {
                        return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                      }
                      if (!(documentClone.fonts && documentClone.fonts.ready))
                        return [3, 2];
                      return [4, documentClone.fonts.ready];
                    case 1:
                      _a2.sent();
                      _a2.label = 2;
                    case 2:
                      if (!/(AppleWebKit)/g.test(navigator.userAgent))
                        return [3, 4];
                      return [4, imagesReady(documentClone)];
                    case 3:
                      _a2.sent();
                      _a2.label = 4;
                    case 4:
                      if (typeof onclone === "function") {
                        return [2, Promise.resolve().then(function() {
                          return onclone(documentClone, referenceElement);
                        }).then(function() {
                          return iframe;
                        })];
                      }
                      return [2, iframe];
                  }
                });
              });
            });
            documentClone.open();
            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
            documentClone.close();
            return iframeLoad;
          };
          DocumentCloner2.prototype.createElementClone = function(node2) {
            if (isDebugging(
              node2,
              2
              /* CLONE */
            )) {
              debugger;
            }
            if (isCanvasElement(node2)) {
              return this.createCanvasClone(node2);
            }
            if (isVideoElement(node2)) {
              return this.createVideoClone(node2);
            }
            if (isStyleElement(node2)) {
              return this.createStyleClone(node2);
            }
            var clone = node2.cloneNode(false);
            if (isImageElement(clone)) {
              if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {
                clone.src = node2.currentSrc;
                clone.srcset = "";
              }
              if (clone.loading === "lazy") {
                clone.loading = "eager";
              }
            }
            if (isCustomElement(clone)) {
              return this.createCustomElementClone(clone);
            }
            return clone;
          };
          DocumentCloner2.prototype.createCustomElementClone = function(node2) {
            var clone = document.createElement("html2canvascustomelement");
            copyCSSStyles(node2.style, clone);
            return clone;
          };
          DocumentCloner2.prototype.createStyleClone = function(node2) {
            try {
              var sheet = node2.sheet;
              if (sheet && sheet.cssRules) {
                var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
                  if (rule && typeof rule.cssText === "string") {
                    return css2 + rule.cssText;
                  }
                  return css2;
                }, "");
                var style = node2.cloneNode(false);
                style.textContent = css;
                return style;
              }
            } catch (e3) {
              this.context.logger.error("Unable to access cssRules property", e3);
              if (e3.name !== "SecurityError") {
                throw e3;
              }
            }
            return node2.cloneNode(false);
          };
          DocumentCloner2.prototype.createCanvasClone = function(canvas) {
            var _a2;
            if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement("img");
              try {
                img.src = canvas.toDataURL();
                return img;
              } catch (e3) {
                this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
            }
            var clonedCanvas = canvas.cloneNode(false);
            try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext("2d");
              var clonedCtx = clonedCanvas.getContext("2d");
              if (clonedCtx) {
                if (!this.options.allowTaint && ctx) {
                  clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                } else {
                  var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
                  if (gl) {
                    var attribs = gl.getContextAttributes();
                    if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                      this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                    }
                  }
                  clonedCtx.drawImage(canvas, 0, 0);
                }
              }
              return clonedCanvas;
            } catch (e3) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
            }
            return clonedCanvas;
          };
          DocumentCloner2.prototype.createVideoClone = function(video) {
            var canvas = video.ownerDocument.createElement("canvas");
            canvas.width = video.offsetWidth;
            canvas.height = video.offsetHeight;
            var ctx = canvas.getContext("2d");
            try {
              if (ctx) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                if (!this.options.allowTaint) {
                  ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
              }
              return canvas;
            } catch (e3) {
              this.context.logger.info("Unable to clone video as it is tainted", video);
            }
            var blankCanvas = video.ownerDocument.createElement("canvas");
            blankCanvas.width = video.offsetWidth;
            blankCanvas.height = video.offsetHeight;
            return blankCanvas;
          };
          DocumentCloner2.prototype.appendChildNode = function(clone, child, copyStyles) {
            if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
              if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                clone.appendChild(this.cloneNode(child, copyStyles));
              }
            }
          };
          DocumentCloner2.prototype.cloneChildNodes = function(node2, clone, copyStyles) {
            var _this = this;
            for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {
              if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
                var assignedNodes = child.assignedNodes();
                if (assignedNodes.length) {
                  assignedNodes.forEach(function(assignedNode) {
                    return _this.appendChildNode(clone, assignedNode, copyStyles);
                  });
                }
              } else {
                this.appendChildNode(clone, child, copyStyles);
              }
            }
          };
          DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {
            if (isTextNode(node2)) {
              return document.createTextNode(node2.data);
            }
            if (!node2.ownerDocument) {
              return node2.cloneNode(false);
            }
            var window2 = node2.ownerDocument.defaultView;
            if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {
              var clone = this.createElementClone(node2);
              clone.style.transitionProperty = "none";
              var style = window2.getComputedStyle(node2);
              var styleBefore = window2.getComputedStyle(node2, ":before");
              var styleAfter = window2.getComputedStyle(node2, ":after");
              if (this.referenceElement === node2 && isHTMLElementNode(clone)) {
                this.clonedReferenceElement = clone;
              }
              if (isBodyElement(clone)) {
                createPseudoHideStyles(clone);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before = this.resolvePseudoContent(node2, clone, styleBefore, PseudoElementType.BEFORE);
              if (isCustomElement(node2)) {
                copyStyles = true;
              }
              if (!isVideoElement(node2)) {
                this.cloneChildNodes(node2, clone, copyStyles);
              }
              if (before) {
                clone.insertBefore(before, clone.firstChild);
              }
              var after = this.resolvePseudoContent(node2, clone, styleAfter, PseudoElementType.AFTER);
              if (after) {
                clone.appendChild(after);
              }
              this.counters.pop(counters);
              if (style && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {
                copyCSSStyles(style, clone);
              }
              if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {
                this.scrolledElements.push([clone, node2.scrollLeft, node2.scrollTop]);
              }
              if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone) || isSelectElement(clone))) {
                clone.value = node2.value;
              }
              return clone;
            }
            return node2.cloneNode(false);
          };
          DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone, style, pseudoElt) {
            var _this = this;
            if (!style) {
              return;
            }
            var value = style.content;
            var document2 = clone.ownerDocument;
            if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
              return;
            }
            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
            var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
            copyCSSStyles(style, anonymousReplacedElement);
            declaration.content.forEach(function(token) {
              if (token.type === 0) {
                anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
              } else if (token.type === 22) {
                var img = document2.createElement("img");
                img.src = token.value;
                img.style.opacity = "1";
                anonymousReplacedElement.appendChild(img);
              } else if (token.type === 18) {
                if (token.name === "attr") {
                  var attr = token.values.filter(isIdentToken);
                  if (attr.length) {
                    anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || ""));
                  }
                } else if (token.name === "counter") {
                  var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
                  if (counter && isIdentToken(counter)) {
                    var counterState = _this.counters.getCounterValue(counter.value);
                    var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                    anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
                  }
                } else if (token.name === "counters") {
                  var _b2 = token.values.filter(nonFunctionArgSeparator), counter = _b2[0], delim = _b2[1], counterStyle = _b2[2];
                  if (counter && isIdentToken(counter)) {
                    var counterStates = _this.counters.getCounterValues(counter.value);
                    var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                    var separator = delim && delim.type === 0 ? delim.value : "";
                    var text = counterStates.map(function(value2) {
                      return createCounterText(value2, counterType_1, false);
                    }).join(separator);
                    anonymousReplacedElement.appendChild(document2.createTextNode(text));
                  }
                } else
                  ;
              } else if (token.type === 20) {
                switch (token.value) {
                  case "open-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                    break;
                  case "close-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                    break;
                  default:
                    anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
                }
              }
            });
            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            if (isSVGElementNode(clone)) {
              clone.className.baseValue += newClassName;
            } else {
              clone.className += newClassName;
            }
            return anonymousReplacedElement;
          };
          DocumentCloner2.destroy = function(container) {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
            }
            return false;
          };
          return DocumentCloner2;
        }()
      );
      var PseudoElementType;
      (function(PseudoElementType2) {
        PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
        PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
      })(PseudoElementType || (PseudoElementType = {}));
      var createIFrameContainer = function(ownerDocument, bounds) {
        var cloneIframeContainer = ownerDocument.createElement("iframe");
        cloneIframeContainer.className = "html2canvas-container";
        cloneIframeContainer.style.visibility = "hidden";
        cloneIframeContainer.style.position = "fixed";
        cloneIframeContainer.style.left = "-10000px";
        cloneIframeContainer.style.top = "0px";
        cloneIframeContainer.style.border = "0";
        cloneIframeContainer.width = bounds.width.toString();
        cloneIframeContainer.height = bounds.height.toString();
        cloneIframeContainer.scrolling = "no";
        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
        ownerDocument.body.appendChild(cloneIframeContainer);
        return cloneIframeContainer;
      };
      var imageReady = function(img) {
        return new Promise(function(resolve2) {
          if (img.complete) {
            resolve2();
            return;
          }
          if (!img.src) {
            resolve2();
            return;
          }
          img.onload = resolve2;
          img.onerror = resolve2;
        });
      };
      var imagesReady = function(document2) {
        return Promise.all([].slice.call(document2.images, 0).map(imageReady));
      };
      var iframeLoader = function(iframe) {
        return new Promise(function(resolve2, reject2) {
          var cloneWindow = iframe.contentWindow;
          if (!cloneWindow) {
            return reject2("No window assigned for iframe");
          }
          var documentClone = cloneWindow.document;
          cloneWindow.onload = iframe.onload = function() {
            cloneWindow.onload = iframe.onload = null;
            var interval = setInterval(function() {
              if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
                clearInterval(interval);
                resolve2(iframe);
              }
            }, 50);
          };
        });
      };
      var ignoredStyleProperties = [
        "all",
        "d",
        "content"
        // Safari shows pseudoelements if content is set
      ];
      var copyCSSStyles = function(style, target) {
        for (var i4 = style.length - 1; i4 >= 0; i4--) {
          var property = style.item(i4);
          if (ignoredStyleProperties.indexOf(property) === -1) {
            target.style.setProperty(property, style.getPropertyValue(property));
          }
        }
        return target;
      };
      var serializeDoctype = function(doctype) {
        var str = "";
        if (doctype) {
          str += "<!DOCTYPE ";
          if (doctype.name) {
            str += doctype.name;
          }
          if (doctype.internalSubset) {
            str += doctype.internalSubset;
          }
          if (doctype.publicId) {
            str += '"' + doctype.publicId + '"';
          }
          if (doctype.systemId) {
            str += '"' + doctype.systemId + '"';
          }
          str += ">";
        }
        return str;
      };
      var restoreOwnerScroll = function(ownerDocument, x2, y3) {
        if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y3 !== ownerDocument.defaultView.pageYOffset)) {
          ownerDocument.defaultView.scrollTo(x2, y3);
        }
      };
      var restoreNodeScroll = function(_a2) {
        var element = _a2[0], x2 = _a2[1], y3 = _a2[2];
        element.scrollLeft = x2;
        element.scrollTop = y3;
      };
      var PSEUDO_BEFORE = ":before";
      var PSEUDO_AFTER = ":after";
      var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
      var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
      var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
      var createPseudoHideStyles = function(body) {
        createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
      };
      var createStyles = function(body, styles) {
        var document2 = body.ownerDocument;
        if (document2) {
          var style = document2.createElement("style");
          style.textContent = styles;
          body.appendChild(style);
        }
      };
      var CacheStorage = (
        /** @class */
        function() {
          function CacheStorage2() {
          }
          CacheStorage2.getOrigin = function(url) {
            var link = CacheStorage2._link;
            if (!link) {
              return "about:blank";
            }
            link.href = url;
            link.href = link.href;
            return link.protocol + link.hostname + link.port;
          };
          CacheStorage2.isSameOrigin = function(src) {
            return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
          };
          CacheStorage2.setContext = function(window2) {
            CacheStorage2._link = window2.document.createElement("a");
            CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
          };
          CacheStorage2._origin = "about:blank";
          return CacheStorage2;
        }()
      );
      var Cache = (
        /** @class */
        function() {
          function Cache2(context, _options) {
            this.context = context;
            this._options = _options;
            this._cache = {};
          }
          Cache2.prototype.addImage = function(src) {
            var result = Promise.resolve();
            if (this.has(src)) {
              return result;
            }
            if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function() {
              });
              return result;
            }
            return result;
          };
          Cache2.prototype.match = function(src) {
            return this._cache[src];
          };
          Cache2.prototype.loadImage = function(key) {
            return __awaiter(this, void 0, void 0, function() {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isSameOrigin = CacheStorage.isSameOrigin(key);
                    useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                    useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                    if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    src = key;
                    if (!useProxy)
                      return [3, 2];
                    return [4, this.proxy(src)];
                  case 1:
                    src = _a2.sent();
                    _a2.label = 2;
                  case 2:
                    this.context.logger.debug("Added image " + key.substring(0, 256));
                    return [4, new Promise(function(resolve2, reject2) {
                      var img = new Image();
                      img.onload = function() {
                        return resolve2(img);
                      };
                      img.onerror = reject2;
                      if (isInlineBase64Image(src) || useCORS) {
                        img.crossOrigin = "anonymous";
                      }
                      img.src = src;
                      if (img.complete === true) {
                        setTimeout(function() {
                          return resolve2(img);
                        }, 500);
                      }
                      if (_this._options.imageTimeout > 0) {
                        setTimeout(function() {
                          return reject2("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                        }, _this._options.imageTimeout);
                      }
                    })];
                  case 3:
                    return [2, _a2.sent()];
                }
              });
            });
          };
          Cache2.prototype.has = function(key) {
            return typeof this._cache[key] !== "undefined";
          };
          Cache2.prototype.keys = function() {
            return Promise.resolve(Object.keys(this._cache));
          };
          Cache2.prototype.proxy = function(src) {
            var _this = this;
            var proxy = this._options.proxy;
            if (!proxy) {
              throw new Error("No proxy defined");
            }
            var key = src.substring(0, 256);
            return new Promise(function(resolve2, reject2) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
              var xhr = new XMLHttpRequest();
              xhr.onload = function() {
                if (xhr.status === 200) {
                  if (responseType === "text") {
                    resolve2(xhr.response);
                  } else {
                    var reader_1 = new FileReader();
                    reader_1.addEventListener("load", function() {
                      return resolve2(reader_1.result);
                    }, false);
                    reader_1.addEventListener("error", function(e3) {
                      return reject2(e3);
                    }, false);
                    reader_1.readAsDataURL(xhr.response);
                  }
                } else {
                  reject2("Failed to proxy resource " + key + " with status code " + xhr.status);
                }
              };
              xhr.onerror = reject2;
              var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
              xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
                xhr.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                var timeout_1 = _this._options.imageTimeout;
                xhr.timeout = timeout_1;
                xhr.ontimeout = function() {
                  return reject2("Timed out (" + timeout_1 + "ms) proxying " + key);
                };
              }
              xhr.send();
            });
          };
          return Cache2;
        }()
      );
      var INLINE_SVG = /^data:image\/svg\+xml/i;
      var INLINE_BASE64 = /^data:image\/.*;base64,/i;
      var INLINE_IMG = /^data:image\/.*/i;
      var isRenderable = function(src) {
        return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
      };
      var isInlineImage = function(src) {
        return INLINE_IMG.test(src);
      };
      var isInlineBase64Image = function(src) {
        return INLINE_BASE64.test(src);
      };
      var isBlobImage = function(src) {
        return src.substr(0, 4) === "blob";
      };
      var isSVG = function(src) {
        return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
      };
      var Vector = (
        /** @class */
        function() {
          function Vector2(x2, y3) {
            this.type = 0;
            this.x = x2;
            this.y = y3;
          }
          Vector2.prototype.add = function(deltaX, deltaY) {
            return new Vector2(this.x + deltaX, this.y + deltaY);
          };
          return Vector2;
        }()
      );
      var lerp = function(a4, b2, t3) {
        return new Vector(a4.x + (b2.x - a4.x) * t3, a4.y + (b2.y - a4.y) * t3);
      };
      var BezierCurve = (
        /** @class */
        function() {
          function BezierCurve2(start, startControl, endControl, end) {
            this.type = 1;
            this.start = start;
            this.startControl = startControl;
            this.endControl = endControl;
            this.end = end;
          }
          BezierCurve2.prototype.subdivide = function(t3, firstHalf) {
            var ab = lerp(this.start, this.startControl, t3);
            var bc = lerp(this.startControl, this.endControl, t3);
            var cd = lerp(this.endControl, this.end, t3);
            var abbc = lerp(ab, bc, t3);
            var bccd = lerp(bc, cd, t3);
            var dest = lerp(abbc, bccd, t3);
            return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
          };
          BezierCurve2.prototype.add = function(deltaX, deltaY) {
            return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
          };
          BezierCurve2.prototype.reverse = function() {
            return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
          };
          return BezierCurve2;
        }()
      );
      var isBezierCurve = function(path) {
        return path.type === 1;
      };
      var BoundCurves = (
        /** @class */
        function() {
          function BoundCurves2(element) {
            var styles = element.styles;
            var bounds = element.bounds;
            var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
            var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
            var factors = [];
            factors.push((tlh + trh) / bounds.width);
            factors.push((blh + brh) / bounds.width);
            factors.push((tlv + blv) / bounds.height);
            factors.push((trv + brv) / bounds.height);
            var maxFactor = Math.max.apply(Math, factors);
            if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
            }
            var topWidth = bounds.width - trh;
            var rightHeight = bounds.height - brv;
            var bottomWidth = bounds.width - brh;
            var leftHeight = bounds.height - blv;
            var borderTopWidth2 = styles.borderTopWidth;
            var borderRightWidth2 = styles.borderRightWidth;
            var borderBottomWidth2 = styles.borderBottomWidth;
            var borderLeftWidth2 = styles.borderLeftWidth;
            var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
            var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
            var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
            var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
            this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
            this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
            this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
            this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
            this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
            this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
            this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
            this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
            this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
            this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
          }
          return BoundCurves2;
        }()
      );
      var CORNER;
      (function(CORNER2) {
        CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
        CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
        CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
        CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
      })(CORNER || (CORNER = {}));
      var getCurvePoints = function(x2, y3, r1, r2, position2) {
        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
        var ox = r1 * kappa;
        var oy = r2 * kappa;
        var xm = x2 + r1;
        var ym = y3 + r2;
        switch (position2) {
          case CORNER.TOP_LEFT:
            return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y3), new Vector(xm, y3));
          case CORNER.TOP_RIGHT:
            return new BezierCurve(new Vector(x2, y3), new Vector(x2 + ox, y3), new Vector(xm, ym - oy), new Vector(xm, ym));
          case CORNER.BOTTOM_RIGHT:
            return new BezierCurve(new Vector(xm, y3), new Vector(xm, y3 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
          case CORNER.BOTTOM_LEFT:
          default:
            return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y3 + oy), new Vector(x2, y3));
        }
      };
      var calculateBorderBoxPath = function(curves) {
        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
      };
      var calculateContentBoxPath = function(curves) {
        return [
          curves.topLeftContentBox,
          curves.topRightContentBox,
          curves.bottomRightContentBox,
          curves.bottomLeftContentBox
        ];
      };
      var calculatePaddingBoxPath = function(curves) {
        return [
          curves.topLeftPaddingBox,
          curves.topRightPaddingBox,
          curves.bottomRightPaddingBox,
          curves.bottomLeftPaddingBox
        ];
      };
      var TransformEffect = (
        /** @class */
        function() {
          function TransformEffect2(offsetX, offsetY, matrix3) {
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.matrix = matrix3;
            this.type = 0;
            this.target = 2 | 4;
          }
          return TransformEffect2;
        }()
      );
      var ClipEffect = (
        /** @class */
        function() {
          function ClipEffect2(path, target) {
            this.path = path;
            this.target = target;
            this.type = 1;
          }
          return ClipEffect2;
        }()
      );
      var OpacityEffect = (
        /** @class */
        function() {
          function OpacityEffect2(opacity2) {
            this.opacity = opacity2;
            this.type = 2;
            this.target = 2 | 4;
          }
          return OpacityEffect2;
        }()
      );
      var isTransformEffect = function(effect) {
        return effect.type === 0;
      };
      var isClipEffect = function(effect) {
        return effect.type === 1;
      };
      var isOpacityEffect = function(effect) {
        return effect.type === 2;
      };
      var equalPath = function(a4, b2) {
        if (a4.length === b2.length) {
          return a4.some(function(v3, i4) {
            return v3 === b2[i4];
          });
        }
        return false;
      };
      var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
        return path.map(function(point, index2) {
          switch (index2) {
            case 0:
              return point.add(deltaX, deltaY);
            case 1:
              return point.add(deltaX + deltaW, deltaY);
            case 2:
              return point.add(deltaX + deltaW, deltaY + deltaH);
            case 3:
              return point.add(deltaX, deltaY + deltaH);
          }
          return point;
        });
      };
      var StackingContext = (
        /** @class */
        function() {
          function StackingContext2(container) {
            this.element = container;
            this.inlineLevel = [];
            this.nonInlineLevel = [];
            this.negativeZIndex = [];
            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
            this.positiveZIndex = [];
            this.nonPositionedFloats = [];
            this.nonPositionedInlineLevel = [];
          }
          return StackingContext2;
        }()
      );
      var ElementPaint = (
        /** @class */
        function() {
          function ElementPaint2(container, parent) {
            this.container = container;
            this.parent = parent;
            this.effects = [];
            this.curves = new BoundCurves(this.container);
            if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
            }
            if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix3 = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix3));
            }
            if (this.container.styles.overflowX !== 0) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox2 = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox2)) {
                this.effects.push(new ClipEffect(
                  borderBox,
                  2 | 4
                  /* CONTENT */
                ));
              } else {
                this.effects.push(new ClipEffect(
                  borderBox,
                  2
                  /* BACKGROUND_BORDERS */
                ));
                this.effects.push(new ClipEffect(
                  paddingBox2,
                  4
                  /* CONTENT */
                ));
              }
            }
          }
          ElementPaint2.prototype.getEffects = function(target) {
            var inFlow = [
              2,
              3
              /* FIXED */
            ].indexOf(this.container.styles.position) === -1;
            var parent = this.parent;
            var effects = this.effects.slice(0);
            while (parent) {
              var croplessEffects = parent.effects.filter(function(effect) {
                return !isClipEffect(effect);
              });
              if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
                effects.unshift.apply(effects, croplessEffects);
                inFlow = [
                  2,
                  3
                  /* FIXED */
                ].indexOf(parent.container.styles.position) === -1;
                if (parent.container.styles.overflowX !== 0) {
                  var borderBox = calculateBorderBoxPath(parent.curves);
                  var paddingBox2 = calculatePaddingBoxPath(parent.curves);
                  if (!equalPath(borderBox, paddingBox2)) {
                    effects.unshift(new ClipEffect(
                      paddingBox2,
                      2 | 4
                      /* CONTENT */
                    ));
                  }
                }
              } else {
                effects.unshift.apply(effects, croplessEffects);
              }
              parent = parent.parent;
            }
            return effects.filter(function(effect) {
              return contains(effect.target, target);
            });
          };
          return ElementPaint2;
        }()
      );
      var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
        parent.container.elements.forEach(function(child) {
          var treatAsRealStackingContext = contains(
            child.flags,
            4
            /* CREATES_REAL_STACKING_CONTEXT */
          );
          var createsStackingContext2 = contains(
            child.flags,
            2
            /* CREATES_STACKING_CONTEXT */
          );
          var paintContainer = new ElementPaint(child, parent);
          if (contains(
            child.styles.display,
            2048
            /* LIST_ITEM */
          )) {
            listItems.push(paintContainer);
          }
          var listOwnerItems = contains(
            child.flags,
            8
            /* IS_LIST_OWNER */
          ) ? [] : listItems;
          if (treatAsRealStackingContext || createsStackingContext2) {
            var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
            var stack = new StackingContext(paintContainer);
            if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
              var order_1 = child.styles.zIndex.order;
              if (order_1 < 0) {
                var index_1 = 0;
                parentStack.negativeZIndex.some(function(current, i4) {
                  if (order_1 > current.element.container.styles.zIndex.order) {
                    index_1 = i4;
                    return false;
                  } else if (index_1 > 0) {
                    return true;
                  }
                  return false;
                });
                parentStack.negativeZIndex.splice(index_1, 0, stack);
              } else if (order_1 > 0) {
                var index_2 = 0;
                parentStack.positiveZIndex.some(function(current, i4) {
                  if (order_1 >= current.element.container.styles.zIndex.order) {
                    index_2 = i4 + 1;
                    return false;
                  } else if (index_2 > 0) {
                    return true;
                  }
                  return false;
                });
                parentStack.positiveZIndex.splice(index_2, 0, stack);
              } else {
                parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
              }
            } else {
              if (child.styles.isFloating()) {
                parentStack.nonPositionedFloats.push(stack);
              } else {
                parentStack.nonPositionedInlineLevel.push(stack);
              }
            }
            parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
          } else {
            if (child.styles.isInlineLevel()) {
              stackingContext.inlineLevel.push(paintContainer);
            } else {
              stackingContext.nonInlineLevel.push(paintContainer);
            }
            parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
          }
          if (contains(
            child.flags,
            8
            /* IS_LIST_OWNER */
          )) {
            processListItems(child, listOwnerItems);
          }
        });
      };
      var processListItems = function(owner, elements2) {
        var numbering = owner instanceof OLElementContainer ? owner.start : 1;
        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
        for (var i4 = 0; i4 < elements2.length; i4++) {
          var item = elements2[i4];
          if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
            numbering = item.container.value;
          }
          item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
          numbering += reversed ? -1 : 1;
        }
      };
      var parseStackingContexts = function(container) {
        var paintContainer = new ElementPaint(container, null);
        var root = new StackingContext(paintContainer);
        var listItems = [];
        parseStackTree(paintContainer, root, root, listItems);
        processListItems(paintContainer.container, listItems);
        return root;
      };
      var parsePathForBorder = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
        }
      };
      var parsePathForBorderDoubleOuter = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
        }
      };
      var parsePathForBorderDoubleInner = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
        }
      };
      var parsePathForBorderStroke = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
          case 1:
            return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
          case 2:
            return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
          case 3:
          default:
            return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
        }
      };
      var createStrokePathFromCurves = function(outer1, outer2) {
        var path = [];
        if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
        } else {
          path.push(outer1);
        }
        if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
        } else {
          path.push(outer2);
        }
        return path;
      };
      var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
        var path = [];
        if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
        } else {
          path.push(outer1);
        }
        if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
        } else {
          path.push(outer2);
        }
        if (isBezierCurve(inner2)) {
          path.push(inner2.subdivide(0.5, true).reverse());
        } else {
          path.push(inner2);
        }
        if (isBezierCurve(inner1)) {
          path.push(inner1.subdivide(0.5, false).reverse());
        } else {
          path.push(inner1);
        }
        return path;
      };
      var paddingBox = function(element) {
        var bounds = element.bounds;
        var styles = element.styles;
        return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
      };
      var contentBox = function(element) {
        var styles = element.styles;
        var bounds = element.bounds;
        var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
        var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
        var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
        var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
        return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
      };
      var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
        if (backgroundOrigin2 === 0) {
          return element.bounds;
        }
        if (backgroundOrigin2 === 2) {
          return contentBox(element);
        }
        return paddingBox(element);
      };
      var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
        if (backgroundClip2 === 0) {
          return element.bounds;
        }
        if (backgroundClip2 === 2) {
          return contentBox(element);
        }
        return paddingBox(element);
      };
      var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
        var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
        var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
        var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
        var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
        return [path, offsetX, offsetY, sizeWidth, sizeHeight];
      };
      var isAuto = function(token) {
        return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
      };
      var hasIntrinsicValue = function(value) {
        return typeof value === "number";
      };
      var calculateBackgroundSize = function(size, _a2, bounds) {
        var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
        var first = size[0], second = size[1];
        if (!first) {
          return [0, 0];
        }
        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
          return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
        }
        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
          if (hasIntrinsicValue(intrinsicProportion)) {
            var targetRatio = bounds.width / bounds.height;
            return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
          }
          return [bounds.width, bounds.height];
        }
        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
        if (isAuto(first) && (!second || isAuto(second))) {
          if (hasIntrinsicWidth && hasIntrinsicHeight) {
            return [intrinsicWidth, intrinsicHeight];
          }
          if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
            return [bounds.width, bounds.height];
          }
          if (hasIntrinsicDimensions && hasIntrinsicProportion) {
            var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
            var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
            return [width_1, height_1];
          }
          var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
          var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
          return [width_2, height_2];
        }
        if (hasIntrinsicProportion) {
          var width_3 = 0;
          var height_3 = 0;
          if (isLengthPercentage(first)) {
            width_3 = getAbsoluteValue(first, bounds.width);
          } else if (isLengthPercentage(second)) {
            height_3 = getAbsoluteValue(second, bounds.height);
          }
          if (isAuto(first)) {
            width_3 = height_3 * intrinsicProportion;
          } else if (!second || isAuto(second)) {
            height_3 = width_3 / intrinsicProportion;
          }
          return [width_3, height_3];
        }
        var width = null;
        var height = null;
        if (isLengthPercentage(first)) {
          width = getAbsoluteValue(first, bounds.width);
        } else if (second && isLengthPercentage(second)) {
          height = getAbsoluteValue(second, bounds.height);
        }
        if (width !== null && (!second || isAuto(second))) {
          height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
        }
        if (height !== null && isAuto(first)) {
          width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
        }
        if (width !== null && height !== null) {
          return [width, height];
        }
        throw new Error("Unable to calculate background-size for element");
      };
      var getBackgroundValueForIndex = function(values, index2) {
        var value = values[index2];
        if (typeof value === "undefined") {
          return values[0];
        }
        return value;
      };
      var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
        var x2 = _a2[0], y3 = _a2[1];
        var width = _b2[0], height = _b2[1];
        switch (repeat) {
          case 2:
            return [
              new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y3))
            ];
          case 3:
            return [
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
            ];
          case 1:
            return [
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y3 + height)),
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y3 + height))
            ];
          default:
            return [
              new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
            ];
        }
      };
      var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
      var SAMPLE_TEXT = "Hidden Text";
      var FontMetrics = (
        /** @class */
        function() {
          function FontMetrics2(document2) {
            this._data = {};
            this._document = document2;
          }
          FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
            var container = this._document.createElement("div");
            var img = this._document.createElement("img");
            var span = this._document.createElement("span");
            var body = this._document.body;
            container.style.visibility = "hidden";
            container.style.fontFamily = fontFamily2;
            container.style.fontSize = fontSize2;
            container.style.margin = "0";
            container.style.padding = "0";
            container.style.whiteSpace = "nowrap";
            body.appendChild(container);
            img.src = SMALL_IMAGE;
            img.width = 1;
            img.height = 1;
            img.style.margin = "0";
            img.style.padding = "0";
            img.style.verticalAlign = "baseline";
            span.style.fontFamily = fontFamily2;
            span.style.fontSize = fontSize2;
            span.style.margin = "0";
            span.style.padding = "0";
            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.appendChild(span);
            container.appendChild(img);
            var baseline = img.offsetTop - span.offsetTop + 2;
            container.removeChild(span);
            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.style.lineHeight = "normal";
            img.style.verticalAlign = "super";
            var middle = img.offsetTop - container.offsetTop + 2;
            body.removeChild(container);
            return { baseline, middle };
          };
          FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
            var key = fontFamily2 + " " + fontSize2;
            if (typeof this._data[key] === "undefined") {
              this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
            }
            return this._data[key];
          };
          return FontMetrics2;
        }()
      );
      var Renderer = (
        /** @class */
        function() {
          function Renderer2(context, options) {
            this.context = context;
            this.options = options;
          }
          return Renderer2;
        }()
      );
      var MASK_OFFSET = 1e4;
      var CanvasRenderer = (
        /** @class */
        function(_super) {
          __extends(CanvasRenderer2, _super);
          function CanvasRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this._activeEffects = [];
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            if (!options.canvas) {
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
            }
            _this.fontMetrics = new FontMetrics(document);
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.ctx.textBaseline = "bottom";
            _this._activeEffects = [];
            _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
            return _this;
          }
          CanvasRenderer2.prototype.applyEffects = function(effects) {
            var _this = this;
            while (this._activeEffects.length) {
              this.popEffect();
            }
            effects.forEach(function(effect) {
              return _this.applyEffect(effect);
            });
          };
          CanvasRenderer2.prototype.applyEffect = function(effect) {
            this.ctx.save();
            if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
            }
            if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
            }
            if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
            }
            this._activeEffects.push(effect);
          };
          CanvasRenderer2.prototype.popEffect = function() {
            this._activeEffects.pop();
            this.ctx.restore();
          };
          CanvasRenderer2.prototype.renderStack = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var styles;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    styles = stack.element.container.styles;
                    if (!styles.isVisible())
                      return [3, 2];
                    return [4, this.renderStackContent(stack)];
                  case 1:
                    _a2.sent();
                    _a2.label = 2;
                  case 2:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNode = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (contains(
                      paint.container.flags,
                      16
                      /* DEBUG_RENDER */
                    )) {
                      debugger;
                    }
                    if (!paint.container.styles.isVisible())
                      return [3, 3];
                    return [4, this.renderNodeBackgroundAndBorders(paint)];
                  case 1:
                    _a2.sent();
                    return [4, this.renderNodeContent(paint)];
                  case 2:
                    _a2.sent();
                    _a2.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
            var _this = this;
            if (letterSpacing2 === 0) {
              this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
            } else {
              var letters = segmentGraphemes(text.text);
              letters.reduce(function(left, letter) {
                _this.ctx.fillText(letter, left, text.bounds.top + baseline);
                return left + _this.ctx.measureText(letter).width;
              }, text.bounds.left);
            }
          };
          CanvasRenderer2.prototype.createFontStyle = function(styles) {
            var fontVariant2 = styles.fontVariant.filter(function(variant) {
              return variant === "normal" || variant === "small-caps";
            }).join("");
            var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
            var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
            return [
              [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
              fontFamily2,
              fontSize2
            ];
          };
          CanvasRenderer2.prototype.renderTextNode = function(text, styles) {
            return __awaiter(this, void 0, void 0, function() {
              var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
              var _this = this;
              return __generator(this, function(_c) {
                _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
                this.ctx.font = font;
                this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
                this.ctx.textAlign = "left";
                this.ctx.textBaseline = "alphabetic";
                _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
                paintOrder2 = styles.paintOrder;
                text.textBounds.forEach(function(text2) {
                  paintOrder2.forEach(function(paintOrderLayer) {
                    switch (paintOrderLayer) {
                      case 0:
                        _this.ctx.fillStyle = asString(styles.color);
                        _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                        var textShadows = styles.textShadow;
                        if (textShadows.length && text2.text.trim().length) {
                          textShadows.slice(0).reverse().forEach(function(textShadow2) {
                            _this.ctx.shadowColor = asString(textShadow2.color);
                            _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                            _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                            _this.ctx.shadowBlur = textShadow2.blur.number;
                            _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                          });
                          _this.ctx.shadowColor = "";
                          _this.ctx.shadowOffsetX = 0;
                          _this.ctx.shadowOffsetY = 0;
                          _this.ctx.shadowBlur = 0;
                        }
                        if (styles.textDecorationLine.length) {
                          _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                          styles.textDecorationLine.forEach(function(textDecorationLine2) {
                            switch (textDecorationLine2) {
                              case 1:
                                _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                                break;
                              case 2:
                                _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                                break;
                              case 3:
                                _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                                break;
                            }
                          });
                        }
                        break;
                      case 1:
                        if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                          _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                          _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                          _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                          _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                        }
                        _this.ctx.strokeStyle = "";
                        _this.ctx.lineWidth = 0;
                        _this.ctx.lineJoin = "miter";
                        break;
                    }
                  });
                });
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
            if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path = calculatePaddingBoxPath(curves);
              this.path(path);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
            }
          };
          CanvasRenderer2.prototype.renderNodeContent = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(
                      4
                      /* CONTENT */
                    ));
                    container = paint.container;
                    curves = paint.curves;
                    styles = container.styles;
                    _i = 0, _a2 = container.textNodes;
                    _c.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    child = _a2[_i];
                    return [4, this.renderTextNode(child, styles)];
                  case 2:
                    _c.sent();
                    _c.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    if (!(container instanceof ImageElementContainer))
                      return [3, 8];
                    _c.label = 5;
                  case 5:
                    _c.trys.push([5, 7, , 8]);
                    return [4, this.context.cache.match(container.src)];
                  case 6:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 8];
                  case 7:
                    _c.sent();
                    this.context.logger.error("Error loading image " + container.src);
                    return [3, 8];
                  case 8:
                    if (container instanceof CanvasElementContainer) {
                      this.renderReplacedElement(container, curves, container.canvas);
                    }
                    if (!(container instanceof SVGElementContainer))
                      return [3, 12];
                    _c.label = 9;
                  case 9:
                    _c.trys.push([9, 11, , 12]);
                    return [4, this.context.cache.match(container.svg)];
                  case 10:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 12];
                  case 11:
                    _c.sent();
                    this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                    return [3, 12];
                  case 12:
                    if (!(container instanceof IFrameElementContainer && container.tree))
                      return [3, 14];
                    iframeRenderer = new CanvasRenderer2(this.context, {
                      scale: this.options.scale,
                      backgroundColor: container.backgroundColor,
                      x: 0,
                      y: 0,
                      width: container.width,
                      height: container.height
                    });
                    return [4, iframeRenderer.render(container.tree)];
                  case 13:
                    canvas = _c.sent();
                    if (container.width && container.height) {
                      this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                    }
                    _c.label = 14;
                  case 14:
                    if (container instanceof InputElementContainer) {
                      size = Math.min(container.bounds.width, container.bounds.height);
                      if (container.type === CHECKBOX) {
                        if (container.checked) {
                          this.ctx.save();
                          this.path([
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                          ]);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      } else if (container.type === RADIO) {
                        if (container.checked) {
                          this.ctx.save();
                          this.ctx.beginPath();
                          this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      }
                    }
                    if (isTextInputElement(container) && container.value.length) {
                      _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                      baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                      bounds = contentBox(container);
                      x2 = 0;
                      switch (container.styles.textAlign) {
                        case 1:
                          x2 += bounds.width / 2;
                          break;
                        case 2:
                          x2 += bounds.width;
                          break;
                      }
                      textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                      this.ctx.save();
                      this.path([
                        new Vector(bounds.left, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                        new Vector(bounds.left, bounds.top + bounds.height)
                      ]);
                      this.ctx.clip();
                      this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                      this.ctx.restore();
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = "left";
                    }
                    if (!contains(
                      container.styles.display,
                      2048
                      /* LIST_ITEM */
                    ))
                      return [3, 20];
                    if (!(container.styles.listStyleImage !== null))
                      return [3, 19];
                    img = container.styles.listStyleImage;
                    if (!(img.type === 0))
                      return [3, 18];
                    image2 = void 0;
                    url = img.url;
                    _c.label = 15;
                  case 15:
                    _c.trys.push([15, 17, , 18]);
                    return [4, this.context.cache.match(url)];
                  case 16:
                    image2 = _c.sent();
                    this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                    return [3, 18];
                  case 17:
                    _c.sent();
                    this.context.logger.error("Error loading list-style-image " + url);
                    return [3, 18];
                  case 18:
                    return [3, 20];
                  case 19:
                    if (paint.listValue && container.styles.listStyleType !== -1) {
                      fontFamily2 = this.createFontStyle(styles)[0];
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "middle";
                      this.ctx.textAlign = "right";
                      bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                      this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                      this.ctx.textBaseline = "bottom";
                      this.ctx.textAlign = "left";
                    }
                    _c.label = 20;
                  case 20:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderStackContent = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator(this, function(_p) {
                switch (_p.label) {
                  case 0:
                    if (contains(
                      stack.element.container.flags,
                      16
                      /* DEBUG_RENDER */
                    )) {
                      debugger;
                    }
                    return [4, this.renderNodeBackgroundAndBorders(stack.element)];
                  case 1:
                    _p.sent();
                    _i = 0, _a2 = stack.negativeZIndex;
                    _p.label = 2;
                  case 2:
                    if (!(_i < _a2.length))
                      return [3, 5];
                    child = _a2[_i];
                    return [4, this.renderStack(child)];
                  case 3:
                    _p.sent();
                    _p.label = 4;
                  case 4:
                    _i++;
                    return [3, 2];
                  case 5:
                    return [4, this.renderNodeContent(stack.element)];
                  case 6:
                    _p.sent();
                    _b2 = 0, _c = stack.nonInlineLevel;
                    _p.label = 7;
                  case 7:
                    if (!(_b2 < _c.length))
                      return [3, 10];
                    child = _c[_b2];
                    return [4, this.renderNode(child)];
                  case 8:
                    _p.sent();
                    _p.label = 9;
                  case 9:
                    _b2++;
                    return [3, 7];
                  case 10:
                    _d = 0, _e = stack.nonPositionedFloats;
                    _p.label = 11;
                  case 11:
                    if (!(_d < _e.length))
                      return [3, 14];
                    child = _e[_d];
                    return [4, this.renderStack(child)];
                  case 12:
                    _p.sent();
                    _p.label = 13;
                  case 13:
                    _d++;
                    return [3, 11];
                  case 14:
                    _f = 0, _g = stack.nonPositionedInlineLevel;
                    _p.label = 15;
                  case 15:
                    if (!(_f < _g.length))
                      return [3, 18];
                    child = _g[_f];
                    return [4, this.renderStack(child)];
                  case 16:
                    _p.sent();
                    _p.label = 17;
                  case 17:
                    _f++;
                    return [3, 15];
                  case 18:
                    _h = 0, _j = stack.inlineLevel;
                    _p.label = 19;
                  case 19:
                    if (!(_h < _j.length))
                      return [3, 22];
                    child = _j[_h];
                    return [4, this.renderNode(child)];
                  case 20:
                    _p.sent();
                    _p.label = 21;
                  case 21:
                    _h++;
                    return [3, 19];
                  case 22:
                    _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                    _p.label = 23;
                  case 23:
                    if (!(_k < _l.length))
                      return [3, 26];
                    child = _l[_k];
                    return [4, this.renderStack(child)];
                  case 24:
                    _p.sent();
                    _p.label = 25;
                  case 25:
                    _k++;
                    return [3, 23];
                  case 26:
                    _m = 0, _o = stack.positiveZIndex;
                    _p.label = 27;
                  case 27:
                    if (!(_m < _o.length))
                      return [3, 30];
                    child = _o[_m];
                    return [4, this.renderStack(child)];
                  case 28:
                    _p.sent();
                    _p.label = 29;
                  case 29:
                    _m++;
                    return [3, 27];
                  case 30:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.mask = function(paths) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width, 0);
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.lineTo(0, 0);
            this.formatPath(paths.slice(0).reverse());
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.path = function(paths) {
            this.ctx.beginPath();
            this.formatPath(paths);
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.formatPath = function(paths) {
            var _this = this;
            paths.forEach(function(point, index2) {
              var start = isBezierCurve(point) ? point.start : point;
              if (index2 === 0) {
                _this.ctx.moveTo(start.x, start.y);
              } else {
                _this.ctx.lineTo(start.x, start.y);
              }
              if (isBezierCurve(point)) {
                _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
              }
            });
          };
          CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
            this.path(path);
            this.ctx.fillStyle = pattern;
            this.ctx.translate(offsetX, offsetY);
            this.ctx.fill();
            this.ctx.translate(-offsetX, -offsetY);
          };
          CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
            var _a2;
            if (image2.width === width && image2.height === height) {
              return image2;
            }
            var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
            var canvas = ownerDocument.createElement("canvas");
            canvas.width = Math.max(1, width);
            canvas.height = Math.max(1, height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
            return canvas;
          };
          CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
            return __awaiter(this, void 0, void 0, function() {
              var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
              return __generator(this, function(_b2) {
                switch (_b2.label) {
                  case 0:
                    index2 = container.styles.backgroundImage.length - 1;
                    _loop_1 = function(backgroundImage3) {
                      var image2, url, _c, path, x2, y3, width, height, pattern, _d, path, x2, y3, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x2, y3, _g, rx, ry, radialGradient_1, midX, midY, f4, invF;
                      return __generator(this, function(_h) {
                        switch (_h.label) {
                          case 0:
                            if (!(backgroundImage3.type === 0))
                              return [3, 5];
                            image2 = void 0;
                            url = backgroundImage3.url;
                            _h.label = 1;
                          case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4, this_1.context.cache.match(url)];
                          case 2:
                            image2 = _h.sent();
                            return [3, 4];
                          case 3:
                            _h.sent();
                            this_1.context.logger.error("Error loading background-image " + url);
                            return [3, 4];
                          case 4:
                            if (image2) {
                              _c = calculateBackgroundRendering(container, index2, [
                                image2.width,
                                image2.height,
                                image2.width / image2.height
                              ]), path = _c[0], x2 = _c[1], y3 = _c[2], width = _c[3], height = _c[4];
                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                              this_1.renderRepeat(path, pattern, x2, y3);
                            }
                            return [3, 6];
                          case 5:
                            if (isLinearGradient(backgroundImage3)) {
                              _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x2 = _d[1], y3 = _d[2], width = _d[3], height = _d[4];
                              _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                              canvas = document.createElement("canvas");
                              canvas.width = width;
                              canvas.height = height;
                              ctx = canvas.getContext("2d");
                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                              processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                                return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                              });
                              ctx.fillStyle = gradient_1;
                              ctx.fillRect(0, 0, width, height);
                              if (width > 0 && height > 0) {
                                pattern = this_1.ctx.createPattern(canvas, "repeat");
                                this_1.renderRepeat(path, pattern, x2, y3);
                              }
                            } else if (isRadialGradient(backgroundImage3)) {
                              _f = calculateBackgroundRendering(container, index2, [
                                null,
                                null,
                                null
                              ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                              position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                              x2 = getAbsoluteValue(position2[0], width);
                              y3 = getAbsoluteValue(position2[position2.length - 1], height);
                              _g = calculateRadius(backgroundImage3, x2, y3, width, height), rx = _g[0], ry = _g[1];
                              if (rx > 0 && ry > 0) {
                                radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y3, 0, left + x2, top_1 + y3, rx);
                                processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                                  return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                });
                                this_1.path(path);
                                this_1.ctx.fillStyle = radialGradient_1;
                                if (rx !== ry) {
                                  midX = container.bounds.left + 0.5 * container.bounds.width;
                                  midY = container.bounds.top + 0.5 * container.bounds.height;
                                  f4 = ry / rx;
                                  invF = 1 / f4;
                                  this_1.ctx.save();
                                  this_1.ctx.translate(midX, midY);
                                  this_1.ctx.transform(1, 0, 0, f4, 0, 0);
                                  this_1.ctx.translate(-midX, -midY);
                                  this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                  this_1.ctx.restore();
                                } else {
                                  this_1.ctx.fill();
                                }
                              }
                            }
                            _h.label = 6;
                          case 6:
                            index2--;
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    };
                    this_1 = this;
                    _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                    _b2.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    backgroundImage2 = _a2[_i];
                    return [5, _loop_1(backgroundImage2)];
                  case 2:
                    _b2.sent();
                    _b2.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                this.path(parsePathForBorder(curvePoints, side));
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              var outerPaths, innerPaths;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (!(width < 3))
                      return [3, 2];
                    return [4, this.renderSolidBorder(color2, side, curvePoints)];
                  case 1:
                    _a2.sent();
                    return [
                      2
                      /*return*/
                    ];
                  case 2:
                    outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                    this.path(outerPaths);
                    this.ctx.fillStyle = asString(color2);
                    this.ctx.fill();
                    innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                    this.path(innerPaths);
                    this.ctx.fill();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(
                      2
                      /* BACKGROUND_BORDERS */
                    ));
                    styles = paint.container.styles;
                    hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                    borders = [
                      { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                      { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                      { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                      { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                    ];
                    backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                    if (!(hasBackground || styles.boxShadow.length))
                      return [3, 2];
                    this.ctx.save();
                    this.path(backgroundPaintingArea);
                    this.ctx.clip();
                    if (!isTransparent(styles.backgroundColor)) {
                      this.ctx.fillStyle = asString(styles.backgroundColor);
                      this.ctx.fill();
                    }
                    return [4, this.renderBackgroundImage(paint.container)];
                  case 1:
                    _a2.sent();
                    this.ctx.restore();
                    styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                      _this.ctx.save();
                      var borderBoxArea = calculateBorderBoxPath(paint.curves);
                      var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                      var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                      if (shadow.inset) {
                        _this.path(borderBoxArea);
                        _this.ctx.clip();
                        _this.mask(shadowPaintingArea);
                      } else {
                        _this.mask(borderBoxArea);
                        _this.ctx.clip();
                        _this.path(shadowPaintingArea);
                      }
                      _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                      _this.ctx.shadowOffsetY = shadow.offsetY.number;
                      _this.ctx.shadowColor = asString(shadow.color);
                      _this.ctx.shadowBlur = shadow.blur.number;
                      _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                      _this.ctx.fill();
                      _this.ctx.restore();
                    });
                    _a2.label = 2;
                  case 2:
                    side = 0;
                    _i = 0, borders_1 = borders;
                    _a2.label = 3;
                  case 3:
                    if (!(_i < borders_1.length))
                      return [3, 13];
                    border = borders_1[_i];
                    if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
                      return [3, 11];
                    if (!(border.style === 2))
                      return [3, 5];
                    return [4, this.renderDashedDottedBorder(
                      border.color,
                      border.width,
                      side,
                      paint.curves,
                      2
                      /* DASHED */
                    )];
                  case 4:
                    _a2.sent();
                    return [3, 11];
                  case 5:
                    if (!(border.style === 3))
                      return [3, 7];
                    return [4, this.renderDashedDottedBorder(
                      border.color,
                      border.width,
                      side,
                      paint.curves,
                      3
                      /* DOTTED */
                    )];
                  case 6:
                    _a2.sent();
                    return [3, 11];
                  case 7:
                    if (!(border.style === 4))
                      return [3, 9];
                    return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                  case 8:
                    _a2.sent();
                    return [3, 11];
                  case 9:
                    return [4, this.renderSolidBorder(border.color, side, paint.curves)];
                  case 10:
                    _a2.sent();
                    _a2.label = 11;
                  case 11:
                    side++;
                    _a2.label = 12;
                  case 12:
                    _i++;
                    return [3, 3];
                  case 13:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
            return __awaiter(this, void 0, void 0, function() {
              var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator(this, function(_a2) {
                this.ctx.save();
                strokePaths = parsePathForBorderStroke(curvePoints, side);
                boxPaths = parsePathForBorder(curvePoints, side);
                if (style === 2) {
                  this.path(boxPaths);
                  this.ctx.clip();
                }
                if (isBezierCurve(boxPaths[0])) {
                  startX = boxPaths[0].start.x;
                  startY = boxPaths[0].start.y;
                } else {
                  startX = boxPaths[0].x;
                  startY = boxPaths[0].y;
                }
                if (isBezierCurve(boxPaths[1])) {
                  endX = boxPaths[1].end.x;
                  endY = boxPaths[1].end.y;
                } else {
                  endX = boxPaths[1].x;
                  endY = boxPaths[1].y;
                }
                if (side === 0 || side === 2) {
                  length = Math.abs(startX - endX);
                } else {
                  length = Math.abs(startY - endY);
                }
                this.ctx.beginPath();
                if (style === 3) {
                  this.formatPath(strokePaths);
                } else {
                  this.formatPath(boxPaths.slice(0, 2));
                }
                dashLength = width < 3 ? width * 3 : width * 2;
                spaceLength = width < 3 ? width * 2 : width;
                if (style === 3) {
                  dashLength = width;
                  spaceLength = width;
                }
                useLineDash = true;
                if (length <= dashLength * 2) {
                  useLineDash = false;
                } else if (length <= dashLength * 2 + spaceLength) {
                  multiplier = length / (2 * dashLength + spaceLength);
                  dashLength *= multiplier;
                  spaceLength *= multiplier;
                } else {
                  numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                  minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                  maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                  spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
                }
                if (useLineDash) {
                  if (style === 3) {
                    this.ctx.setLineDash([0, dashLength + spaceLength]);
                  } else {
                    this.ctx.setLineDash([dashLength, spaceLength]);
                  }
                }
                if (style === 3) {
                  this.ctx.lineCap = "round";
                  this.ctx.lineWidth = width;
                } else {
                  this.ctx.lineWidth = width * 2 + 1.1;
                }
                this.ctx.strokeStyle = asString(color2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                if (style === 2) {
                  if (isBezierCurve(boxPaths[0])) {
                    path1 = boxPaths[3];
                    path2 = boxPaths[0];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                  if (isBezierCurve(boxPaths[1])) {
                    path1 = boxPaths[1];
                    path2 = boxPaths[2];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                }
                this.ctx.restore();
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.render = function(element) {
            return __awaiter(this, void 0, void 0, function() {
              var stack;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                    }
                    stack = parseStackingContexts(element);
                    return [4, this.renderStack(stack)];
                  case 1:
                    _a2.sent();
                    this.applyEffects([]);
                    return [2, this.canvas];
                }
              });
            });
          };
          return CanvasRenderer2;
        }(Renderer)
      );
      var isTextInputElement = function(container) {
        if (container instanceof TextareaElementContainer) {
          return true;
        } else if (container instanceof SelectElementContainer) {
          return true;
        } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
          return true;
        }
        return false;
      };
      var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
        switch (clip) {
          case 0:
            return calculateBorderBoxPath(curves);
          case 2:
            return calculateContentBoxPath(curves);
          case 1:
          default:
            return calculatePaddingBoxPath(curves);
        }
      };
      var canvasTextAlign = function(textAlign2) {
        switch (textAlign2) {
          case 1:
            return "center";
          case 2:
            return "right";
          case 0:
          default:
            return "left";
        }
      };
      var iOSBrokenFonts = ["-apple-system", "system-ui"];
      var fixIOSSystemFonts = function(fontFamilies) {
        return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
          return iOSBrokenFonts.indexOf(fontFamily2) === -1;
        }) : fontFamilies;
      };
      var ForeignObjectRenderer = (
        /** @class */
        function(_super) {
          __extends(ForeignObjectRenderer2, _super);
          function ForeignObjectRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            _this.options = options;
            _this.canvas.width = Math.floor(options.width * options.scale);
            _this.canvas.height = Math.floor(options.height * options.scale);
            _this.canvas.style.width = options.width + "px";
            _this.canvas.style.height = options.height + "px";
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
            return _this;
          }
          ForeignObjectRenderer2.prototype.render = function(element) {
            return __awaiter(this, void 0, void 0, function() {
              var svg, img;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                    return [4, loadSerializedSVG(svg)];
                  case 1:
                    img = _a2.sent();
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                    }
                    this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                    return [2, this.canvas];
                }
              });
            });
          };
          return ForeignObjectRenderer2;
        }(Renderer)
      );
      var loadSerializedSVG = function(svg) {
        return new Promise(function(resolve2, reject2) {
          var img = new Image();
          img.onload = function() {
            resolve2(img);
          };
          img.onerror = reject2;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
        });
      };
      var Logger = (
        /** @class */
        function() {
          function Logger2(_a2) {
            var id = _a2.id, enabled = _a2.enabled;
            this.id = id;
            this.enabled = enabled;
            this.start = Date.now();
          }
          Logger2.prototype.debug = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
                console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.getTime = function() {
            return Date.now() - this.start;
          };
          Logger2.prototype.info = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
                console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
            }
          };
          Logger2.prototype.warn = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
                console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.error = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
                console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.instances = {};
          return Logger2;
        }()
      );
      var Context = (
        /** @class */
        function() {
          function Context2(options, windowBounds) {
            var _a2;
            this.windowBounds = windowBounds;
            this.instanceName = "#" + Context2.instanceCount++;
            this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
            this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
          }
          Context2.instanceCount = 1;
          return Context2;
        }()
      );
      var html2canvas = function(element, options) {
        if (options === void 0) {
          options = {};
        }
        return renderElement(element, options);
      };
      if (typeof window !== "undefined") {
        CacheStorage.setContext(window);
      }
      var renderElement = function(element, opts) {
        return __awaiter(void 0, void 0, void 0, function() {
          var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
          var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
          return __generator(this, function(_u) {
            switch (_u.label) {
              case 0:
                if (!element || typeof element !== "object") {
                  return [2, Promise.reject("Invalid element provided as first argument")];
                }
                ownerDocument = element.ownerDocument;
                if (!ownerDocument) {
                  throw new Error("Element is not attached to a Document");
                }
                defaultView = ownerDocument.defaultView;
                if (!defaultView) {
                  throw new Error("Document is not attached to a Window");
                }
                resourceOptions = {
                  allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
                  imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                  proxy: opts.proxy,
                  useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                };
                contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
                windowOptions = {
                  windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                  windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                  scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                  scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                };
                windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                context = new Context(contextOptions, windowBounds);
                foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                cloneOptions = {
                  allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                  onclone: opts.onclone,
                  ignoreElements: opts.ignoreElements,
                  inlineImages: foreignObjectRendering,
                  copyStyles: foreignObjectRendering
                };
                context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                documentCloner = new DocumentCloner(context, element, cloneOptions);
                clonedElement = documentCloner.clonedReferenceElement;
                if (!clonedElement) {
                  return [2, Promise.reject("Unable to find element in cloned iframe")];
                }
                return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
              case 1:
                container = _u.sent();
                _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
                backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                renderOptions = {
                  canvas: opts.canvas,
                  backgroundColor: backgroundColor2,
                  scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                  x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                  y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                  width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                  height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                };
                if (!foreignObjectRendering)
                  return [3, 3];
                context.logger.debug("Document cloned, using foreign object rendering");
                renderer = new ForeignObjectRenderer(context, renderOptions);
                return [4, renderer.render(clonedElement)];
              case 2:
                canvas = _u.sent();
                return [3, 5];
              case 3:
                context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                context.logger.debug("Starting DOM parsing");
                root = parseTree(context, clonedElement);
                if (backgroundColor2 === root.styles.backgroundColor) {
                  root.styles.backgroundColor = COLORS.TRANSPARENT;
                }
                context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                renderer = new CanvasRenderer(context, renderOptions);
                return [4, renderer.render(root)];
              case 4:
                canvas = _u.sent();
                _u.label = 5;
              case 5:
                if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
                  if (!DocumentCloner.destroy(container)) {
                    context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                  }
                }
                context.logger.debug("Finished rendering");
                return [2, canvas];
            }
          });
        });
      };
      var parseBackgroundColor = function(context, element, backgroundColorOverride) {
        var ownerDocument = element.ownerDocument;
        var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
        var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
        var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
        return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
      };
      return html2canvas;
    });
  }
});

// node_modules/dompurify/dist/purify.js
var require_purify = __commonJS({
  "node_modules/dompurify/dist/purify.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.DOMPurify = factory());
    })(exports2, function() {
      "use strict";
      function _typeof3(obj) {
        "@babel/helpers - typeof";
        return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof3(obj);
      }
      function _setPrototypeOf(o3, p3) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p4) {
          o4.__proto__ = p4;
          return o4;
        };
        return _setPrototypeOf(o3, p3);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a3 = [null];
            a3.push.apply(a3, args2);
            var Constructor = Function.bind.apply(Parent2, a3);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _unsupportedIterableToArray(o3, minLen) {
        if (!o3)
          return;
        if (typeof o3 === "string")
          return _arrayLikeToArray(o3, minLen);
        var n3 = Object.prototype.toString.call(o3).slice(8, -1);
        if (n3 === "Object" && o3.constructor)
          n3 = o3.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o3);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o3, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
          arr2[i3] = arr[i3];
        return arr2;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var freeze = Object.freeze, seal = Object.seal, create = Object.create;
      var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
      if (!apply) {
        apply = function apply2(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        };
      }
      if (!freeze) {
        freeze = function freeze2(x2) {
          return x2;
        };
      }
      if (!seal) {
        seal = function seal2(x2) {
          return x2;
        };
      }
      if (!construct) {
        construct = function construct2(Func, args) {
          return _construct(Func, _toConsumableArray(args));
        };
      }
      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);
      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringToString = unapply(String.prototype.toString);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);
      var regExpTest = unapply(RegExp.prototype.test);
      var typeErrorCreate = unconstruct(TypeError);
      function unapply(func) {
        return function(thisArg) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return apply(func, thisArg, args);
        };
      }
      function unconstruct(func) {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return construct(func, args);
        };
      }
      function addToSet(set, array3, transformCaseFunc) {
        var _transformCaseFunc;
        transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
        if (setPrototypeOf) {
          setPrototypeOf(set, null);
        }
        var l3 = array3.length;
        while (l3--) {
          var element = array3[l3];
          if (typeof element === "string") {
            var lcElement = transformCaseFunc(element);
            if (lcElement !== element) {
              if (!isFrozen(array3)) {
                array3[l3] = lcElement;
              }
              element = lcElement;
            }
          }
          set[element] = true;
        }
        return set;
      }
      function clone(object) {
        var newObject = create(null);
        var property;
        for (property in object) {
          if (apply(hasOwnProperty, object, [property]) === true) {
            newObject[property] = object[property];
          }
        }
        return newObject;
      }
      function lookupGetter(object, prop) {
        while (object !== null) {
          var desc = getOwnPropertyDescriptor(object, prop);
          if (desc) {
            if (desc.get) {
              return unapply(desc.get);
            }
            if (typeof desc.value === "function") {
              return unapply(desc.value);
            }
          }
          object = getPrototypeOf(object);
        }
        function fallbackValue(element) {
          console.warn("fallback value for", element);
          return null;
        }
        return fallbackValue;
      }
      var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
      var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
      var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
      var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
      var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
      var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
      var text = freeze(["#text"]);
      var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
      var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
      var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
      var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
      var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
      var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
      var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
      var IS_ALLOWED_URI = seal(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      );
      var DOCTYPE_NAME = seal(/^html$/i);
      var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
      var getGlobal = function getGlobal2() {
        return typeof window === "undefined" ? null : window;
      };
      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
        if (_typeof3(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
          return null;
        }
        var suffix = null;
        var ATTR_NAME = "data-tt-policy-suffix";
        if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
          suffix = document2.currentScript.getAttribute(ATTR_NAME);
        }
        var policyName = "dompurify" + (suffix ? "#" + suffix : "");
        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML: function createHTML(html2) {
              return html2;
            },
            createScriptURL: function createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_3) {
          console.warn("TrustedTypes policy " + policyName + " could not be created.");
          return null;
        }
      };
      function createDOMPurify() {
        var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
        var DOMPurify = function DOMPurify2(root) {
          return createDOMPurify(root);
        };
        DOMPurify.version = "2.5.8";
        DOMPurify.removed = [];
        if (!window2 || !window2.document || window2.document.nodeType !== 9) {
          DOMPurify.isSupported = false;
          return DOMPurify;
        }
        var originalDocument = window2.document;
        var document2 = window2.document;
        var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node3 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
        var ElementPrototype = Element2.prototype;
        var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
        var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
        var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
        var getParentNode = lookupGetter(ElementPrototype, "parentNode");
        if (typeof HTMLTemplateElement === "function") {
          var template = document2.createElement("template");
          if (template.content && template.content.ownerDocument) {
            document2 = template.content.ownerDocument;
          }
        }
        var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
        var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
        var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
        var importNode = originalDocument.importNode;
        var documentMode = {};
        try {
          documentMode = clone(document2).documentMode ? document2.documentMode : {};
        } catch (_3) {
        }
        var hooks = {};
        DOMPurify.isSupported = typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0 && documentMode !== 9;
        var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE, CUSTOM_ELEMENT$1 = CUSTOM_ELEMENT;
        var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
        var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        }));
        var FORBID_TAGS = null;
        var FORBID_ATTR = null;
        var ALLOW_ARIA_ATTR = true;
        var ALLOW_DATA_ATTR = true;
        var ALLOW_UNKNOWN_PROTOCOLS = false;
        var ALLOW_SELF_CLOSE_IN_ATTR = true;
        var SAFE_FOR_TEMPLATES = false;
        var SAFE_FOR_XML = true;
        var WHOLE_DOCUMENT = false;
        var SET_CONFIG = false;
        var FORCE_BODY = false;
        var RETURN_DOM = false;
        var RETURN_DOM_FRAGMENT = false;
        var RETURN_TRUSTED_TYPE = false;
        var SANITIZE_DOM = true;
        var SANITIZE_NAMED_PROPS = false;
        var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
        var KEEP_CONTENT = true;
        var IN_PLACE = false;
        var USE_PROFILES = {};
        var FORBID_CONTENTS = null;
        var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        var DATA_URI_TAGS = null;
        var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
        var URI_SAFE_ATTRIBUTES = null;
        var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
        var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var NAMESPACE = HTML_NAMESPACE;
        var IS_EMPTY_INPUT = false;
        var ALLOWED_NAMESPACES = null;
        var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
        var PARSER_MEDIA_TYPE;
        var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
        var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
        var transformCaseFunc;
        var CONFIG = null;
        var formElement = document2.createElement("form");
        var isRegexOrFunction = function isRegexOrFunction2(testValue) {
          return testValue instanceof RegExp || testValue instanceof Function;
        };
        var _parseConfig = function _parseConfig2(cfg) {
          if (CONFIG && CONFIG === cfg) {
            return;
          }
          if (!cfg || _typeof3(cfg) !== "object") {
            cfg = {};
          }
          cfg = clone(cfg);
          PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
          SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
          transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
          ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
          ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
          URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
            clone(DEFAULT_URI_SAFE_ATTRIBUTES),
            // eslint-disable-line indent
            cfg.ADD_URI_SAFE_ATTR,
            // eslint-disable-line indent
            transformCaseFunc
            // eslint-disable-line indent
          ) : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
            clone(DEFAULT_DATA_URI_TAGS),
            // eslint-disable-line indent
            cfg.ADD_DATA_URI_TAGS,
            // eslint-disable-line indent
            transformCaseFunc
            // eslint-disable-line indent
          ) : DEFAULT_DATA_URI_TAGS;
          FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
          FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
          FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
          USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
          ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
          SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
          RETURN_DOM = cfg.RETURN_DOM || false;
          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
          FORCE_BODY = cfg.FORCE_BODY || false;
          SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
          SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
          KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
          IN_PLACE = cfg.IN_PLACE || false;
          IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
          NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
          CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
          }
          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }
          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }
          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
            ALLOWED_ATTR = [];
            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html$1);
              addToSet(ALLOWED_ATTR, html);
            }
            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg$1);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl$1);
              addToSet(ALLOWED_ATTR, mathMl);
              addToSet(ALLOWED_ATTR, xml);
            }
          }
          if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }
            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }
          if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }
            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }
          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
          }
          if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }
            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
          }
          if (KEEP_CONTENT) {
            ALLOWED_TAGS["#text"] = true;
          }
          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
          }
          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ["tbody"]);
            delete FORBID_TAGS.tbody;
          }
          if (freeze) {
            freeze(cfg);
          }
          CONFIG = cfg;
        };
        var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
        var HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
        var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
        var ALL_SVG_TAGS = addToSet({}, svg$1);
        addToSet(ALL_SVG_TAGS, svgFilters);
        addToSet(ALL_SVG_TAGS, svgDisallowed);
        var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
        addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
        var _checkValidNamespace = function _checkValidNamespace2(element) {
          var parent = getParentNode(element);
          if (!parent || !parent.tagName) {
            parent = {
              namespaceURI: NAMESPACE,
              tagName: "template"
            };
          }
          var tagName = stringToLowerCase(element.tagName);
          var parentTagName = stringToLowerCase(parent.tagName);
          if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
            return false;
          }
          if (element.namespaceURI === SVG_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "svg";
            }
            if (parent.namespaceURI === MATHML_NAMESPACE) {
              return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            }
            return Boolean(ALL_SVG_TAGS[tagName]);
          }
          if (element.namespaceURI === MATHML_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "math";
            }
            if (parent.namespaceURI === SVG_NAMESPACE) {
              return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
            }
            return Boolean(ALL_MATHML_TAGS[tagName]);
          }
          if (element.namespaceURI === HTML_NAMESPACE) {
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
            return true;
          }
          return false;
        };
        var _forceRemove = function _forceRemove2(node2) {
          arrayPush(DOMPurify.removed, {
            element: node2
          });
          try {
            node2.parentNode.removeChild(node2);
          } catch (_3) {
            try {
              node2.outerHTML = emptyHTML;
            } catch (_4) {
              node2.remove();
            }
          }
        };
        var _removeAttribute = function _removeAttribute2(name, node2) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: node2.getAttributeNode(name),
              from: node2
            });
          } catch (_3) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: node2
            });
          }
          node2.removeAttribute(name);
          if (name === "is" && !ALLOWED_ATTR[name]) {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
              try {
                _forceRemove(node2);
              } catch (_3) {
              }
            } else {
              try {
                node2.setAttribute(name, "");
              } catch (_3) {
              }
            }
          }
        };
        var _initDocument = function _initDocument2(dirty) {
          var doc;
          var leadingWhitespace;
          if (FORCE_BODY) {
            dirty = "<remove></remove>" + dirty;
          } else {
            var matches = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches && matches[0];
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
          }
          var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          if (NAMESPACE === HTML_NAMESPACE) {
            try {
              doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_3) {
            }
          }
          if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, "template", null);
            try {
              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
            } catch (_3) {
            }
          }
          var body = doc.body || doc.documentElement;
          if (dirty && leadingWhitespace) {
            body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
          }
          if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
          }
          return WHOLE_DOCUMENT ? doc.documentElement : body;
        };
        var _createIterator = function _createIterator2(root) {
          return createNodeIterator.call(
            root.ownerDocument || root,
            root,
            // eslint-disable-next-line no-bitwise
            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
            null,
            false
          );
        };
        var _isClobbered = function _isClobbered2(elm) {
          return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
        };
        var _isNode = function _isNode2(object) {
          return _typeof3(Node3) === "object" ? object instanceof Node3 : object && _typeof3(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
        };
        var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
          if (!hooks[entryPoint]) {
            return;
          }
          arrayForEach(hooks[entryPoint], function(hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
          });
        };
        var _sanitizeElements = function _sanitizeElements2(currentNode) {
          var content;
          _executeHook("beforeSanitizeElements", currentNode, null);
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
            _forceRemove(currentNode);
            return true;
          }
          var tagName = transformCaseFunc(currentNode.nodeName);
          _executeHook("uponSanitizeElement", currentNode, {
            tagName,
            allowedTags: ALLOWED_TAGS
          });
          if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
            _forceRemove(currentNode);
            return true;
          }
          if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode.nodeType === 7) {
            _forceRemove(currentNode);
            return true;
          }
          if (SAFE_FOR_XML && currentNode.nodeType === 8 && regExpTest(/<[/\w]/g, currentNode.data)) {
            _forceRemove(currentNode);
            return true;
          }
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
                return false;
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
                return false;
            }
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
              var parentNode = getParentNode(currentNode) || currentNode.parentNode;
              var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
              if (childNodes && parentNode) {
                var childCount = childNodes.length;
                for (var i3 = childCount - 1; i3 >= 0; --i3) {
                  var childClone = cloneNode(childNodes[i3], true);
                  childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                  parentNode.insertBefore(childClone, getNextSibling(currentNode));
                }
              }
            }
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            content = currentNode.textContent;
            content = stringReplace(content, MUSTACHE_EXPR$1, " ");
            content = stringReplace(content, ERB_EXPR$1, " ");
            content = stringReplace(content, TMPLIT_EXPR$1, " ");
            if (currentNode.textContent !== content) {
              arrayPush(DOMPurify.removed, {
                element: currentNode.cloneNode()
              });
              currentNode.textContent = content;
            }
          }
          _executeHook("afterSanitizeElements", currentNode, null);
          return false;
        };
        var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
          if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
            return false;
          }
          if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
            ;
          else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
            ;
          else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
            )
              ;
            else {
              return false;
            }
          } else if (URI_SAFE_ATTRIBUTES[lcName])
            ;
          else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
            ;
          else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if (value) {
            return false;
          } else
            ;
          return true;
        };
        var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
          return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT$1);
        };
        var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
          var attr;
          var value;
          var lcName;
          var l3;
          _executeHook("beforeSanitizeAttributes", currentNode, null);
          var attributes = currentNode.attributes;
          if (!attributes || _isClobbered(currentNode)) {
            return;
          }
          var hookEvent = {
            attrName: "",
            attrValue: "",
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
          };
          l3 = attributes.length;
          while (l3--) {
            attr = attributes[l3];
            var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
            value = name === "value" ? attr.value : stringTrim(attr.value);
            lcName = transformCaseFunc(name);
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = void 0;
            _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
            value = hookEvent.attrValue;
            if (hookEvent.forceKeepAttr) {
              continue;
            }
            _removeAttribute(name, currentNode);
            if (!hookEvent.keepAttr) {
              continue;
            }
            if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (SAFE_FOR_TEMPLATES) {
              value = stringReplace(value, MUSTACHE_EXPR$1, " ");
              value = stringReplace(value, ERB_EXPR$1, " ");
              value = stringReplace(value, TMPLIT_EXPR$1, " ");
            }
            var lcTag = transformCaseFunc(currentNode.nodeName);
            if (!_isValidAttribute(lcTag, lcName, value)) {
              continue;
            }
            if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
              _removeAttribute(name, currentNode);
              value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (trustedTypesPolicy && _typeof3(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
              if (namespaceURI)
                ;
              else {
                switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                  case "TrustedHTML": {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                  case "TrustedScriptURL": {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
                }
              }
            }
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                currentNode.setAttribute(name, value);
              }
              if (_isClobbered(currentNode)) {
                _forceRemove(currentNode);
              } else {
                arrayPop(DOMPurify.removed);
              }
            } catch (_3) {
            }
          }
          _executeHook("afterSanitizeAttributes", currentNode, null);
        };
        var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
          var shadowNode;
          var shadowIterator = _createIterator(fragment);
          _executeHook("beforeSanitizeShadowDOM", fragment, null);
          while (shadowNode = shadowIterator.nextNode()) {
            _executeHook("uponSanitizeShadowNode", shadowNode, null);
            _sanitizeElements(shadowNode);
            _sanitizeAttributes(shadowNode);
            if (shadowNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM2(shadowNode.content);
            }
          }
          _executeHook("afterSanitizeShadowDOM", fragment, null);
        };
        DOMPurify.sanitize = function(dirty) {
          var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var body;
          var importedNode;
          var currentNode;
          var oldNode;
          var returnNode;
          IS_EMPTY_INPUT = !dirty;
          if (IS_EMPTY_INPUT) {
            dirty = "<!-->";
          }
          if (typeof dirty !== "string" && !_isNode(dirty)) {
            if (typeof dirty.toString === "function") {
              dirty = dirty.toString();
              if (typeof dirty !== "string") {
                throw typeErrorCreate("dirty is not a string, aborting");
              }
            } else {
              throw typeErrorCreate("toString is not a function");
            }
          }
          if (!DOMPurify.isSupported) {
            if (_typeof3(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
              if (typeof dirty === "string") {
                return window2.toStaticHTML(dirty);
              }
              if (_isNode(dirty)) {
                return window2.toStaticHTML(dirty.outerHTML);
              }
            }
            return dirty;
          }
          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }
          DOMPurify.removed = [];
          if (typeof dirty === "string") {
            IN_PLACE = false;
          }
          if (IN_PLACE) {
            if (dirty.nodeName) {
              var tagName = transformCaseFunc(dirty.nodeName);
              if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
              }
            }
          } else if (dirty instanceof Node3) {
            body = _initDocument("<!---->");
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
              body = importedNode;
            } else if (importedNode.nodeName === "HTML") {
              body = importedNode;
            } else {
              body.appendChild(importedNode);
            }
          } else {
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf("<") === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            body = _initDocument(dirty);
            if (!body) {
              return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
            }
          }
          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }
          var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
          while (currentNode = nodeIterator.nextNode()) {
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
              continue;
            }
            _sanitizeElements(currentNode);
            _sanitizeAttributes(currentNode);
            if (currentNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(currentNode.content);
            }
            oldNode = currentNode;
          }
          oldNode = null;
          if (IN_PLACE) {
            return dirty;
          }
          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);
              while (body.firstChild) {
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }
            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
              returnNode = importNode.call(originalDocument, returnNode, true);
            }
            return returnNode;
          }
          var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
          if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
          }
          if (SAFE_FOR_TEMPLATES) {
            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
          }
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };
        DOMPurify.setConfig = function(cfg) {
          _parseConfig(cfg);
          SET_CONFIG = true;
        };
        DOMPurify.clearConfig = function() {
          CONFIG = null;
          SET_CONFIG = false;
        };
        DOMPurify.isValidAttribute = function(tag, attr, value) {
          if (!CONFIG) {
            _parseConfig({});
          }
          var lcTag = transformCaseFunc(tag);
          var lcName = transformCaseFunc(attr);
          return _isValidAttribute(lcTag, lcName, value);
        };
        DOMPurify.addHook = function(entryPoint, hookFunction) {
          if (typeof hookFunction !== "function") {
            return;
          }
          hooks[entryPoint] = hooks[entryPoint] || [];
          arrayPush(hooks[entryPoint], hookFunction);
        };
        DOMPurify.removeHook = function(entryPoint) {
          if (hooks[entryPoint]) {
            return arrayPop(hooks[entryPoint]);
          }
        };
        DOMPurify.removeHooks = function(entryPoint) {
          if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
          }
        };
        DOMPurify.removeAllHooks = function() {
          hooks = {};
        };
        return DOMPurify;
      }
      var purify = createDOMPurify();
      return purify;
    });
  }
});

// node_modules/core-js/internals/global-this.js
var require_global_this = __commonJS({
  "node_modules/core-js/internals/global-this.js"(exports2, module2) {
    "use strict";
    var check = function(it2) {
      return it2 && it2.Math === Math && it2;
    };
    module2.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports2 == "object" && exports2) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js/internals/fails.js"(exports2, module2) {
    "use strict";
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/internals/descriptors.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js/internals/function-bind-native.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      var test = function() {
      }.bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js/internals/function-call.js"(exports2, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module2.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports2) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
      var descriptor = getOwnPropertyDescriptor(this, V2);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js/internals/create-property-descriptor.js"(exports2, module2) {
    "use strict";
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this.js"(exports2, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js/internals/classof-raw.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString2 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module2.exports = function(it2) {
      return stringSlice(toString2(it2), 8, -1);
    };
  }
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js/internals/indexed-object.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split2 = uncurryThis("".split);
    module2.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it2) {
      return classof(it2) === "String" ? split2(it2, "") : $Object(it2);
    } : $Object;
  }
});

// node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js/internals/is-null-or-undefined.js"(exports2, module2) {
    "use strict";
    module2.exports = function(it2) {
      return it2 === null || it2 === void 0;
    };
  }
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js/internals/require-object-coercible.js"(exports2, module2) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module2.exports = function(it2) {
      if (isNullOrUndefined(it2))
        throw new $TypeError("Can't call method on " + it2);
      return it2;
    };
  }
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js/internals/to-indexed-object.js"(exports2, module2) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module2.exports = function(it2) {
      return IndexedObject(requireObjectCoercible(it2));
    };
  }
});

// node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js/internals/is-callable.js"(exports2, module2) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    module2.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/internals/is-object.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(it2) {
      return typeof it2 == "object" ? it2 !== null : isCallable(it2);
    };
  }
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js/internals/get-built-in.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module2.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
    };
  }
});

// node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-is-prototype-of.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js/internals/environment-user-agent.js
var require_environment_user_agent = __commonJS({
  "node_modules/core-js/internals/environment-user-agent.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var navigator2 = globalThis2.navigator;
    var userAgent = navigator2 && navigator2.userAgent;
    module2.exports = userAgent ? String(userAgent) : "";
  }
});

// node_modules/core-js/internals/environment-v8-version.js
var require_environment_v8_version = __commonJS({
  "node_modules/core-js/internals/environment-v8-version.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var process2 = globalThis2.process;
    var Deno2 = globalThis2.Deno;
    var versions = process2 && process2.versions || Deno2 && Deno2.version;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version = +match[1];
      }
    }
    module2.exports = version;
  }
});

// node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js/internals/symbol-constructor-detection.js"(exports2, module2) {
    "use strict";
    var V8_VERSION = require_environment_v8_version();
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $String = globalThis2.String;
    module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports2, module2) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js/internals/is-symbol.js"(exports2, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module2.exports = USE_SYMBOL_AS_UID ? function(it2) {
      return typeof it2 == "symbol";
    } : function(it2) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it2));
    };
  }
});

// node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js/internals/try-to-string.js"(exports2, module2) {
    "use strict";
    var $String = String;
    module2.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js/internals/a-callable.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js/internals/get-method.js"(exports2, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module2.exports = function(V2, P2) {
      var func = V2[P2];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js/internals/ordinary-to-primitive.js"(exports2, module2) {
    "use strict";
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module2.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
        return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js/internals/is-pure.js"(exports2, module2) {
    "use strict";
    module2.exports = false;
  }
});

// node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js/internals/define-global-property.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var defineProperty = Object.defineProperty;
    module2.exports = function(key, value) {
      try {
        defineProperty(globalThis2, key, { value, configurable: true, writable: true });
      } catch (error) {
        globalThis2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js/internals/shared-store.js"(exports2, module2) {
    "use strict";
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global_this();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module2.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.40.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2014-2025 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.40.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js/internals/shared.js"(exports2, module2) {
    "use strict";
    var store = require_shared_store();
    module2.exports = function(key, value) {
      return store[key] || (store[key] = value || {});
    };
  }
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/internals/to-object.js"(exports2, module2) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module2.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js/internals/has-own-property.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module2.exports = Object.hasOwn || function hasOwn3(it2, key) {
      return hasOwnProperty(toObject(it2), key);
    };
  }
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js/internals/uid.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString2 = uncurryThis(1 .toString);
    module2.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
    };
  }
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/well-known-symbol.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var shared = require_shared();
    var hasOwn3 = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module2.exports = function(name) {
      if (!hasOwn3(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn3(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/internals/to-primitive.js"(exports2, module2) {
    "use strict";
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module2.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result))
          return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js/internals/to-property-key.js"(exports2, module2) {
    "use strict";
    var toPrimitive2 = require_to_primitive();
    var isSymbol = require_is_symbol();
    module2.exports = function(argument) {
      var key = toPrimitive2(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js/internals/document-create-element.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var document2 = globalThis2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module2.exports = function(it2) {
      return EXISTS ? document2.createElement(it2) : {};
    };
  }
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/internals/ie8-dom-define.js"(exports2, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module2.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey2 = require_to_property_key();
    var hasOwn3 = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O3, P2) {
      O3 = toIndexedObject(O3);
      P2 = toPropertyKey2(P2);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O3, P2);
        } catch (error) {
        }
      if (hasOwn3(O3, P2))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O3, P2), O3[P2]);
    };
  }
});

// node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports2, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module2.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/internals/an-object.js"(exports2, module2) {
    "use strict";
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isObject(argument))
        return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js/internals/object-define-property.js"(exports2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey2 = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O3, P2, Attributes) {
      anObject(O3);
      P2 = toPropertyKey2(P2);
      anObject(Attributes);
      if (typeof O3 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O3, P2);
        if (current && current[WRITABLE]) {
          O3[P2] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O3, P2, Attributes);
    } : $defineProperty : function defineProperty(O3, P2, Attributes) {
      anObject(O3);
      P2 = toPropertyKey2(P2);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O3, P2, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw new $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O3[P2] = Attributes.value;
      return O3;
    };
  }
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports2, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js/internals/function-name.js"(exports2, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn3 = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn3(FunctionPrototype, "name");
    var PROPER = EXISTS && function something() {
    }.name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module2.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js/internals/inspect-source.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it2) {
        return functionToString(it2);
      };
    }
    module2.exports = store.inspectSource;
  }
});

// node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js/internals/weak-map-basic-detection.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var WeakMap2 = globalThis2.WeakMap;
    module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/internals/shared-key.js"(exports2, module2) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module2.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js/internals/hidden-keys.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js/internals/internal-state.js"(exports2, module2) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn3 = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = globalThis2.TypeError;
    var WeakMap2 = globalThis2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it2) {
      return has(it2) ? get(it2) : set(it2, {});
    };
    var getterFor = function(TYPE2) {
      return function(it2) {
        var state;
        if (!isObject(it2) || (state = get(it2)).type !== TYPE2) {
          throw new TypeError2("Incompatible receiver, " + TYPE2 + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it2, metadata) {
        if (store.has(it2))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it2;
        store.set(it2, metadata);
        return metadata;
      };
      get = function(it2) {
        return store.get(it2) || {};
      };
      has = function(it2) {
        return store.has(it2);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it2, metadata) {
        if (hasOwn3(it2, STATE))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it2;
        createNonEnumerableProperty(it2, STATE, metadata);
        return metadata;
      };
      get = function(it2) {
        return hasOwn3(it2, STATE) ? it2[STATE] : {};
      };
      has = function(it2) {
        return hasOwn3(it2, STATE);
      };
    }
    var store;
    var STATE;
    module2.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "node_modules/core-js/internals/make-built-in.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn3 = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace = uncurryThis("".replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module2.exports = function(value, name, options) {
      if (stringSlice($String(name), 0, 7) === "Symbol(") {
        name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn3(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS)
          defineProperty(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn3(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn3(options, "constructor") && options.constructor) {
          if (DESCRIPTORS)
            defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn3(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString2() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js/internals/define-built-in.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module2.exports = function(O3, key, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable(value))
        makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple)
          O3[key] = value;
        else
          defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe)
            delete O3[key];
          else if (O3[key])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O3[key] = value;
        else
          definePropertyModule.f(O3, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O3;
    };
  }
});

// node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js/internals/math-trunc.js"(exports2, module2) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = Math.trunc || function trunc(x2) {
      var n3 = +x2;
      return (n3 > 0 ? floor : ceil)(n3);
    };
  }
});

// node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js/internals/to-integer-or-infinity.js"(exports2, module2) {
    "use strict";
    var trunc = require_math_trunc();
    module2.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/internals/to-absolute-index.js"(exports2, module2) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max4 = Math.max;
    var min3 = Math.min;
    module2.exports = function(index2, length) {
      var integer = toIntegerOrInfinity(index2);
      return integer < 0 ? max4(integer + length, 0) : min3(integer, length);
    };
  }
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/internals/to-length.js"(exports2, module2) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min3 = Math.min;
    module2.exports = function(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min3(len, 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js/internals/length-of-array-like.js"(exports2, module2) {
    "use strict";
    var toLength = require_to_length();
    module2.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/internals/array-includes.js"(exports2, module2) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O3 = toIndexedObject($this);
        var length = lengthOfArrayLike(O3);
        if (length === 0)
          return !IS_INCLUDES && -1;
        var index2 = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el)
          while (length > index2) {
            value = O3[index2++];
            if (value !== value)
              return true;
          }
        else
          for (; length > index2; index2++) {
            if ((IS_INCLUDES || index2 in O3) && O3[index2] === el)
              return IS_INCLUDES || index2 || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module2.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/internals/object-keys-internal.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn3 = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module2.exports = function(object, names3) {
      var O3 = toIndexedObject(object);
      var i3 = 0;
      var result = [];
      var key;
      for (key in O3)
        !hasOwn3(hiddenKeys, key) && hasOwn3(O3, key) && push(result, key);
      while (names3.length > i3)
        if (hasOwn3(O3, key = names3[i3++])) {
          ~indexOf(result, key) || push(result, key);
        }
      return result;
    };
  }
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/internals/enum-bug-keys.js"(exports2, module2) {
    "use strict";
    module2.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names.js"(exports2) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O3) {
      return internalObjectKeys(O3, hiddenKeys);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports2) {
    "use strict";
    exports2.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/internals/own-keys.js"(exports2, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it2) {
      var keys = getOwnPropertyNamesModule.f(anObject(it2));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it2)) : keys;
    };
  }
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js/internals/copy-constructor-properties.js"(exports2, module2) {
    "use strict";
    var hasOwn3 = require_has_own_property();
    var ownKeys2 = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module2.exports = function(target, source, exceptions) {
      var keys = ownKeys2(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i3 = 0; i3 < keys.length; i3++) {
        var key = keys[i3];
        if (!hasOwn3(target, key) && !(exceptions && hasOwn3(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
  }
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js/internals/is-forced.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize2(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize2 = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module2.exports = isForced;
  }
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js/internals/export.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module2.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = globalThis2;
      } else if (STATIC) {
        target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options);
        }
    };
  }
});

// node_modules/core-js/internals/environment.js
var require_environment = __commonJS({
  "node_modules/core-js/internals/environment.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var classof = require_classof_raw();
    var userAgentStartsWith = function(string) {
      return userAgent.slice(0, string.length) === string;
    };
    module2.exports = function() {
      if (userAgentStartsWith("Bun/"))
        return "BUN";
      if (userAgentStartsWith("Cloudflare-Workers"))
        return "CLOUDFLARE";
      if (userAgentStartsWith("Deno/"))
        return "DENO";
      if (userAgentStartsWith("Node.js/"))
        return "NODE";
      if (globalThis2.Bun && typeof Bun.version == "string")
        return "BUN";
      if (globalThis2.Deno && typeof Deno.version == "object")
        return "DENO";
      if (classof(globalThis2.process) === "process")
        return "NODE";
      if (globalThis2.window && globalThis2.document)
        return "BROWSER";
      return "REST";
    }();
  }
});

// node_modules/core-js/internals/environment-is-node.js
var require_environment_is_node = __commonJS({
  "node_modules/core-js/internals/environment-is-node.js"(exports2, module2) {
    "use strict";
    var ENVIRONMENT = require_environment();
    module2.exports = ENVIRONMENT === "NODE";
  }
});

// node_modules/core-js/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module2.exports = function(object, key, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/is-possible-prototype.js
var require_is_possible_prototype = __commonJS({
  "node_modules/core-js/internals/is-possible-prototype.js"(exports2, module2) {
    "use strict";
    var isObject = require_is_object();
    module2.exports = function(argument) {
      return isObject(argument) || argument === null;
    };
  }
});

// node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js/internals/a-possible-prototype.js"(exports2, module2) {
    "use strict";
    var isPossiblePrototype = require_is_possible_prototype();
    var $String = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isPossiblePrototype(argument))
        return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-set-prototype-of.js"(exports2, module2) {
    "use strict";
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var isObject = require_is_object();
    var requireObjectCoercible = require_require_object_coercible();
    var aPossiblePrototype = require_a_possible_prototype();
    module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O3, proto) {
        requireObjectCoercible(O3);
        aPossiblePrototype(proto);
        if (!isObject(O3))
          return O3;
        if (CORRECT_SETTER)
          setter(O3, proto);
        else
          O3.__proto__ = proto;
        return O3;
      };
    }() : void 0);
  }
});

// node_modules/core-js/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/internals/set-to-string-tag.js"(exports2, module2) {
    "use strict";
    var defineProperty = require_object_define_property().f;
    var hasOwn3 = require_has_own_property();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module2.exports = function(target, TAG, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn3(target, TO_STRING_TAG)) {
        defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
  }
});

// node_modules/core-js/internals/define-built-in-accessor.js
var require_define_built_in_accessor = __commonJS({
  "node_modules/core-js/internals/define-built-in-accessor.js"(exports2, module2) {
    "use strict";
    var makeBuiltIn = require_make_built_in();
    var defineProperty = require_object_define_property();
    module2.exports = function(target, name, descriptor) {
      if (descriptor.get)
        makeBuiltIn(descriptor.get, name, { getter: true });
      if (descriptor.set)
        makeBuiltIn(descriptor.set, name, { setter: true });
      return defineProperty.f(target, name, descriptor);
    };
  }
});

// node_modules/core-js/internals/set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js/internals/set-species.js"(exports2, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});

// node_modules/core-js/internals/an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js/internals/an-instance.js"(exports2, module2) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var $TypeError = TypeError;
    module2.exports = function(it2, Prototype) {
      if (isPrototypeOf(Prototype, it2))
        return it2;
      throw new $TypeError("Incorrect invocation");
    };
  }
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js/internals/to-string-tag-support.js"(exports2, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module2.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js/internals/classof.js"(exports2, module2) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it2, key) {
      try {
        return it2[key];
      } catch (error) {
      }
    };
    module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
      var O3, tag, result;
      return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O3 = $Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O3) : (result = classofRaw(O3)) === "Object" && isCallable(O3.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "node_modules/core-js/internals/is-constructor.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop2 = function() {
    };
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop2);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      try {
        construct(noop2, [], argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module2.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// node_modules/core-js/internals/a-constructor.js
var require_a_constructor = __commonJS({
  "node_modules/core-js/internals/a-constructor.js"(exports2, module2) {
    "use strict";
    var isConstructor = require_is_constructor();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isConstructor(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a constructor");
    };
  }
});

// node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "node_modules/core-js/internals/species-constructor.js"(exports2, module2) {
    "use strict";
    var anObject = require_an_object();
    var aConstructor = require_a_constructor();
    var isNullOrUndefined = require_is_null_or_undefined();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(O3, defaultConstructor) {
      var C2 = anObject(O3).constructor;
      var S2;
      return C2 === void 0 || isNullOrUndefined(S2 = anObject(C2)[SPECIES]) ? defaultConstructor : aConstructor(S2);
    };
  }
});

// node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js/internals/function-apply.js"(exports2, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports2, module2) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module2.exports = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis(fn);
    };
  }
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js/internals/function-bind-context.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module2.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js/internals/html.js"(exports2, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module2.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js/internals/array-slice.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis([].slice);
  }
});

// node_modules/core-js/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS({
  "node_modules/core-js/internals/validate-arguments-length.js"(exports2, module2) {
    "use strict";
    var $TypeError = TypeError;
    module2.exports = function(passed, required) {
      if (passed < required)
        throw new $TypeError("Not enough arguments");
      return passed;
    };
  }
});

// node_modules/core-js/internals/environment-is-ios.js
var require_environment_is_ios = __commonJS({
  "node_modules/core-js/internals/environment-is-ios.js"(exports2, module2) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js/internals/task.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var apply = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn3 = require_has_own_property();
    var fails = require_fails();
    var html = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_environment_is_ios();
    var IS_NODE = require_environment_is_node();
    var set = globalThis2.setImmediate;
    var clear = globalThis2.clearImmediate;
    var process2 = globalThis2.process;
    var Dispatch = globalThis2.Dispatch;
    var Function2 = globalThis2.Function;
    var MessageChannel = globalThis2.MessageChannel;
    var String2 = globalThis2.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location;
    var defer;
    var channel;
    var port;
    fails(function() {
      $location = globalThis2.location;
    });
    var run2 = function(id) {
      if (hasOwn3(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run2(id);
      };
    };
    var eventListener = function(event) {
      run2(event.data);
    };
    var globalPostMessageDefer = function(id) {
      globalThis2.postMessage(String2(id), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function2(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process2.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (globalThis2.addEventListener && isCallable(globalThis2.postMessage) && !globalThis2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        globalThis2.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run2(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module2.exports = {
      set,
      clear
    };
  }
});

// node_modules/core-js/internals/safe-get-built-in.js
var require_safe_get_built_in = __commonJS({
  "node_modules/core-js/internals/safe-get-built-in.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var DESCRIPTORS = require_descriptors();
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    module2.exports = function(name) {
      if (!DESCRIPTORS)
        return globalThis2[name];
      var descriptor = getOwnPropertyDescriptor(globalThis2, name);
      return descriptor && descriptor.value;
    };
  }
});

// node_modules/core-js/internals/queue.js
var require_queue = __commonJS({
  "node_modules/core-js/internals/queue.js"(exports2, module2) {
    "use strict";
    var Queue = function() {
      this.head = null;
      this.tail = null;
    };
    Queue.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    module2.exports = Queue;
  }
});

// node_modules/core-js/internals/environment-is-ios-pebble.js
var require_environment_is_ios_pebble = __commonJS({
  "node_modules/core-js/internals/environment-is-ios-pebble.js"(exports2, module2) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module2.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
  }
});

// node_modules/core-js/internals/environment-is-webos-webkit.js
var require_environment_is_webos_webkit = __commonJS({
  "node_modules/core-js/internals/environment-is-webos-webkit.js"(exports2, module2) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module2.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS({
  "node_modules/core-js/internals/microtask.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var safeGetBuiltIn = require_safe_get_built_in();
    var bind = require_function_bind_context();
    var macrotask = require_task().set;
    var Queue = require_queue();
    var IS_IOS = require_environment_is_ios();
    var IS_IOS_PEBBLE = require_environment_is_ios_pebble();
    var IS_WEBOS_WEBKIT = require_environment_is_webos_webkit();
    var IS_NODE = require_environment_is_node();
    var MutationObserver = globalThis2.MutationObserver || globalThis2.WebKitMutationObserver;
    var document2 = globalThis2.document;
    var process2 = globalThis2.process;
    var Promise2 = globalThis2.Promise;
    var microtask = safeGetBuiltIn("queueMicrotask");
    var notify;
    var toggle;
    var node2;
    var promise;
    var then;
    if (!microtask) {
      queue = new Queue();
      flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process2.domain))
          parent.exit();
        while (fn = queue.get())
          try {
            fn();
          } catch (error) {
            if (queue.head)
              notify();
            throw error;
          }
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node2 = document2.createTextNode("");
        new MutationObserver(flush).observe(node2, { characterData: true });
        notify = function() {
          node2.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind(promise.then, promise);
        notify = function() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process2.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, globalThis2);
        notify = function() {
          macrotask(flush);
        };
      }
      microtask = function(fn) {
        if (!queue.head)
          notify();
        queue.add(fn);
      };
    }
    var queue;
    var flush;
    module2.exports = microtask;
  }
});

// node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "node_modules/core-js/internals/host-report-errors.js"(exports2, module2) {
    "use strict";
    module2.exports = function(a3, b2) {
      try {
        arguments.length === 1 ? console.error(a3) : console.error(a3, b2);
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/perform.js
var require_perform = __commonJS({
  "node_modules/core-js/internals/perform.js"(exports2, module2) {
    "use strict";
    module2.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// node_modules/core-js/internals/promise-native-constructor.js
var require_promise_native_constructor = __commonJS({
  "node_modules/core-js/internals/promise-native-constructor.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    module2.exports = globalThis2.Promise;
  }
});

// node_modules/core-js/internals/promise-constructor-detection.js
var require_promise_constructor_detection = __commonJS({
  "node_modules/core-js/internals/promise-constructor-detection.js"(exports2, module2) {
    "use strict";
    var globalThis2 = require_global_this();
    var NativePromiseConstructor = require_promise_native_constructor();
    var isCallable = require_is_callable();
    var isForced = require_is_forced();
    var inspectSource = require_inspect_source();
    var wellKnownSymbol = require_well_known_symbol();
    var ENVIRONMENT = require_environment();
    var IS_PURE = require_is_pure();
    var V8_VERSION = require_environment_v8_version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
        return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function(resolve2) {
          resolve2(1);
        });
        var FakePromise = function(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === "BROWSER" || ENVIRONMENT === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    module2.exports = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING
    };
  }
});

// node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "node_modules/core-js/internals/new-promise-capability.js"(exports2, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var $TypeError = TypeError;
    var PromiseCapability = function(C2) {
      var resolve2, reject2;
      this.promise = new C2(function($$resolve, $$reject) {
        if (resolve2 !== void 0 || reject2 !== void 0)
          throw new $TypeError("Bad Promise constructor");
        resolve2 = $$resolve;
        reject2 = $$reject;
      });
      this.resolve = aCallable(resolve2);
      this.reject = aCallable(reject2);
    };
    module2.exports.f = function(C2) {
      return new PromiseCapability(C2);
    };
  }
});

// node_modules/core-js/modules/es.promise.constructor.js
var require_es_promise_constructor = __commonJS({
  "node_modules/core-js/modules/es.promise.constructor.js"() {
    "use strict";
    var $2 = require_export();
    var IS_PURE = require_is_pure();
    var IS_NODE = require_environment_is_node();
    var globalThis2 = require_global_this();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var hostReportErrors = require_host_report_errors();
    var perform = require_perform();
    var Queue = require_queue();
    var InternalStateModule = require_internal_state();
    var NativePromiseConstructor = require_promise_native_constructor();
    var PromiseConstructorDetection = require_promise_constructor_detection();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = globalThis2.TypeError;
    var document2 = globalThis2.document;
    var process2 = globalThis2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && globalThis2.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var isThenable = function(it2) {
      var then;
      return isObject(it2) && isCallable(then = it2.then) ? then : false;
    };
    var callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve2 = reaction.resolve;
      var reject2 = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED)
              onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject2(new TypeError2("Promise-chain cycle"));
          } else if (then = isThenable(result)) {
            call(then, result, resolve2, reject2);
          } else
            resolve2(result);
        } else
          reject2(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject2(error);
      }
    };
    var notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        globalThis2.dispatchEvent(event);
      } else
        event = { promise, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis2["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call(task, globalThis2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process2.emit("unhandledRejection", value, promise);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call(task, globalThis2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process2.emit("rejectionHandled", promise);
        } else
          dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw new TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: null
        });
      };
      Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process2.domain : void 0;
        if (state.state === PENDING)
          state.reactions.add(reaction);
        else
          microtask(function() {
            callReaction(reaction, state);
          });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C2) {
        return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
      };
      if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve2, reject2) {
              call(nativeThen, that, resolve2, reject2);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $2({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
  }
});

// node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/internals/iterators.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js/internals/is-array-iterator-method.js"(exports2, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module2.exports = function(it2) {
      return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
    };
  }
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js/internals/get-iterator-method.js"(exports2, module2) {
    "use strict";
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module2.exports = function(it2) {
      if (!isNullOrUndefined(it2))
        return getMethod(it2, ITERATOR) || getMethod(it2, "@@iterator") || Iterators[classof(it2)];
    };
  }
});

// node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/internals/get-iterator.js"(exports2, module2) {
    "use strict";
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module2.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw new $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js/internals/iterator-close.js"(exports2, module2) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module2.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js/internals/iterate.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module2.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index2, length, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw new $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index2 = 0, length = lengthOfArrayLike(iterable); length > index2; index2++) {
            result = callFn(iterable[index2]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports2, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module2.exports = function(exec, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING)
          return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// node_modules/core-js/internals/promise-statics-incorrect-iteration.js
var require_promise_statics_incorrect_iteration = __commonJS({
  "node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports2, module2) {
    "use strict";
    var NativePromiseConstructor = require_promise_native_constructor();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    module2.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
      NativePromiseConstructor.all(iterable).then(void 0, function() {
      });
    });
  }
});

// node_modules/core-js/modules/es.promise.all.js
var require_es_promise_all = __commonJS({
  "node_modules/core-js/modules/es.promise.all.js"() {
    "use strict";
    var $2 = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      all: function all(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule.f(C2);
        var resolve2 = capability.resolve;
        var reject2 = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C2.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index2 = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C2, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index2] = value;
              --remaining || resolve2(values);
            }, reject2);
          });
          --remaining || resolve2(values);
        });
        if (result.error)
          reject2(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.catch.js
var require_es_promise_catch = __commonJS({
  "node_modules/core-js/modules/es.promise.catch.js"() {
    "use strict";
    var $2 = require_export();
    var IS_PURE = require_is_pure();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var NativePromiseConstructor = require_promise_native_constructor();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $2({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    var method;
  }
});

// node_modules/core-js/modules/es.promise.race.js
var require_es_promise_race = __commonJS({
  "node_modules/core-js/modules/es.promise.race.js"() {
    "use strict";
    var $2 = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule.f(C2);
        var reject2 = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C2.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C2, promise).then(capability.resolve, reject2);
          });
        });
        if (result.error)
          reject2(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.reject.js
var require_es_promise_reject = __commonJS({
  "node_modules/core-js/modules/es.promise.reject.js"() {
    "use strict";
    var $2 = require_export();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    $2({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      reject: function reject2(r2) {
        var capability = newPromiseCapabilityModule.f(this);
        var capabilityReject = capability.reject;
        capabilityReject(r2);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "node_modules/core-js/internals/promise-resolve.js"(exports2, module2) {
    "use strict";
    var anObject = require_an_object();
    var isObject = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module2.exports = function(C2, x2) {
      anObject(C2);
      if (isObject(x2) && x2.constructor === C2)
        return x2;
      var promiseCapability = newPromiseCapability.f(C2);
      var resolve2 = promiseCapability.resolve;
      resolve2(x2);
      return promiseCapability.promise;
    };
  }
});

// node_modules/core-js/modules/es.promise.resolve.js
var require_es_promise_resolve = __commonJS({
  "node_modules/core-js/modules/es.promise.resolve.js"() {
    "use strict";
    var $2 = require_export();
    var getBuiltIn = require_get_built_in();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var promiseResolve = require_promise_resolve();
    var PromiseConstructorWrapper = getBuiltIn("Promise");
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $2({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve2(x2) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.js
var require_es_promise = __commonJS({
  "node_modules/core-js/modules/es.promise.js"() {
    "use strict";
    require_es_promise_constructor();
    require_es_promise_all();
    require_es_promise_catch();
    require_es_promise_race();
    require_es_promise_reject();
    require_es_promise_resolve();
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject2(error);
    return;
  }
  if (info.done) {
    resolve2(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve2, reject2) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "next", value);
      }
      function _throw(err3) {
        asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "throw", err3);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js/internals/to-string.js"(exports2, module2) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module2.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "node_modules/core-js/internals/regexp-flags.js"(exports2, module2) {
    "use strict";
    var anObject = require_an_object();
    module2.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
  }
});

// node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
  "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    var UNSUPPORTED_Y = fails(function() {
      var re2 = $RegExp("a", "y");
      re2.lastIndex = 2;
      return re2.exec("abcd") !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
      var re2 = $RegExp("^r", "gy");
      re2.lastIndex = 2;
      return re2.exec("str") !== null;
    });
    module2.exports = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
  }
});

// node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/internals/object-keys.js"(exports2, module2) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module2.exports = Object.keys || function keys(O3) {
      return internalObjectKeys(O3, enumBugKeys);
    };
  }
});

// node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js/internals/object-define-properties.js"(exports2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O3, Properties) {
      anObject(O3);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index2 = 0;
      var key;
      while (length > index2)
        definePropertyModule.f(O3, key = keys[index2++], props[key]);
      return O3;
    };
  }
});

// node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/internals/object-create.js"(exports2, module2) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module2.exports = Object.create || function create(O3, Properties) {
      var result;
      if (O3 !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O3);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O3;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    module2.exports = fails(function() {
      var re2 = $RegExp(".", "s");
      return !(re2.dotAll && re2.test("\n") && re2.flags === "s");
    });
  }
});

// node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    module2.exports = fails(function() {
      var re2 = $RegExp("(?<a>b)", "g");
      return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
    });
  }
});

// node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
  "node_modules/core-js/internals/regexp-exec.js"(exports2, module2) {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var toString2 = require_to_string();
    var regexpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var shared = require_shared();
    var create = require_object_create();
    var getInternalState = require_internal_state().get;
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, "a");
      call(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re2 = this;
        var state = getInternalState(re2);
        var str = toString2(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i3, object, group;
        if (raw) {
          raw.lastIndex = re2.lastIndex;
          result = call(patchedExec, raw, str);
          re2.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re2.sticky;
        var flags = call(regexpFlags, re2);
        var source = re2.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re2.lastIndex);
          if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt(str, re2.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG)
          lastIndex = re2.lastIndex;
        match = call(nativeExec, sticky ? reCopy : re2, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re2.lastIndex;
            re2.lastIndex += match[0].length;
          } else
            re2.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re2.lastIndex = re2.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call(nativeReplace, match[0], reCopy, function() {
            for (i3 = 1; i3 < arguments.length - 2; i3++) {
              if (arguments[i3] === void 0)
                match[i3] = void 0;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create(null);
          for (i3 = 0; i3 < groups.length; i3++) {
            group = groups[i3];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    module2.exports = patchedExec;
  }
});

// node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "node_modules/core-js/modules/es.regexp.exec.js"() {
    "use strict";
    var $2 = require_export();
    var exec = require_regexp_exec();
    $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
  }
});

// node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
  "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports2, module2) {
    "use strict";
    require_es_regexp_exec();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var SPECIES = wellKnownSymbol("species");
    var RegExpPrototype = RegExp.prototype;
    module2.exports = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O3 = {};
        O3[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O3) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re2 = /a/;
        if (KEY === "split") {
          re2 = {};
          re2.constructor = {};
          re2.constructor[SPECIES] = function() {
            return re2;
          };
          re2.flags = "";
          re2[SYMBOL] = /./[SYMBOL];
        }
        re2.exec = function() {
          execCalled = true;
          return null;
        };
        re2[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods3 = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
            }
            return { done: true, value: call(nativeMethod, str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn(String.prototype, KEY, methods3[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods3[1]);
      }
      if (SHAM)
        createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
    };
  }
});

// node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js/internals/string-multibyte.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S2 = toString2(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S2.length;
        var first, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S2, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S2, position) : first : CONVERT_TO_STRING ? stringSlice(S2, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module2.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
  "node_modules/core-js/internals/advance-string-index.js"(exports2, module2) {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    module2.exports = function(S2, index2, unicode) {
      return index2 + (unicode ? charAt(S2, index2).length : 1);
    };
  }
});

// node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "node_modules/core-js/internals/regexp-exec-abstract.js"(exports2, module2) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var regexpExec = require_regexp_exec();
    var $TypeError = TypeError;
    module2.exports = function(R2, S2) {
      var exec = R2.exec;
      if (isCallable(exec)) {
        var result = call(exec, R2, S2);
        if (result !== null)
          anObject(result);
        return result;
      }
      if (classof(R2) === "RegExp")
        return call(regexpExec, R2, S2);
      throw new $TypeError("RegExp#exec called on incompatible receiver");
    };
  }
});

// node_modules/core-js/modules/es.string.match.js
var require_es_string_match = __commonJS({
  "node_modules/core-js/modules/es.string.match.js"() {
    "use strict";
    var call = require_function_call();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var getMethod = require_get_method();
    var advanceStringIndex = require_advance_string_index();
    var regExpExec = require_regexp_exec_abstract();
    fixRegExpWellKnownSymbolLogic("match", function(MATCH2, nativeMatch, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match(regexp) {
          var O3 = requireObjectCoercible(this);
          var matcher = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, MATCH2);
          return matcher ? call(matcher, regexp, O3) : new RegExp(regexp)[MATCH2](toString2(O3));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string) {
          var rx = anObject(this);
          var S2 = toString2(string);
          var res = maybeCallNative(nativeMatch, rx, S2);
          if (res.done)
            return res.value;
          if (!rx.global)
            return regExpExec(rx, S2);
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
          var A2 = [];
          var n3 = 0;
          var result;
          while ((result = regExpExec(rx, S2)) !== null) {
            var matchStr = toString2(result[0]);
            A2[n3] = matchStr;
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
            n3++;
          }
          return n3 === 0 ? null : A2;
        }
      ];
    });
  }
});

// node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
  "node_modules/core-js/internals/get-substitution.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var floor = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m4 = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols, function(match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n3 = +ch;
            if (n3 === 0)
              return match;
            if (n3 > m4) {
              var f3 = floor(n3 / 10);
              if (f3 === 0)
                return match;
              if (f3 <= m4)
                return captures[f3 - 1] === void 0 ? charAt(ch, 1) : captures[f3 - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n3 - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "node_modules/core-js/modules/es.string.replace.js"() {
    "use strict";
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var fails = require_fails();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var advanceStringIndex = require_advance_string_index();
    var getMethod = require_get_method();
    var getSubstitution = require_get_substitution();
    var regExpExec = require_regexp_exec_abstract();
    var wellKnownSymbol = require_well_known_symbol();
    var REPLACE = wellKnownSymbol("replace");
    var max4 = Math.max;
    var min3 = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = function(it2) {
      return it2 === void 0 ? it2 : String(it2);
    };
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re2 = /./;
      re2.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re2, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_3, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O3 = requireObjectCoercible(this);
          var replacer = isNullOrUndefined(searchValue) ? void 0 : getMethod(searchValue, REPLACE);
          return replacer ? call(replacer, searchValue, O3, replaceValue) : call(nativeReplace, toString2(O3), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
          var rx = anObject(this);
          var S2 = toString2(string);
          if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx, S2, replaceValue);
            if (res.done)
              return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace)
            replaceValue = toString2(replaceValue);
          var global2 = rx.global;
          var fullUnicode;
          if (global2) {
            fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          var result;
          while (true) {
            result = regExpExec(rx, S2);
            if (result === null)
              break;
            push(results, result);
            if (!global2)
              break;
            var matchStr = toString2(result[0]);
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i3 = 0; i3 < results.length; i3++) {
            result = results[i3];
            var matched = toString2(result[0]);
            var position = max4(min3(toIntegerOrInfinity(result.index), S2.length), 0);
            var captures = [];
            var replacement;
            for (var j2 = 1; j2 < result.length; j2++)
              push(captures, maybeToString(result[j2]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position, S2);
              if (namedCaptures !== void 0)
                push(replacerArgs, namedCaptures);
              replacement = toString2(apply(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S2, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += stringSlice(S2, nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S2, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  }
});

// node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js/internals/is-regexp.js"(exports2, module2) {
    "use strict";
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH2 = wellKnownSymbol("match");
    module2.exports = function(it2) {
      var isRegExp;
      return isObject(it2) && ((isRegExp = it2[MATCH2]) !== void 0 ? !!isRegExp : classof(it2) === "RegExp");
    };
  }
});

// node_modules/core-js/internals/not-a-regexp.js
var require_not_a_regexp = __commonJS({
  "node_modules/core-js/internals/not-a-regexp.js"(exports2, module2) {
    "use strict";
    var isRegExp = require_is_regexp();
    var $TypeError = TypeError;
    module2.exports = function(it2) {
      if (isRegExp(it2)) {
        throw new $TypeError("The method doesn't accept regular expressions");
      }
      return it2;
    };
  }
});

// node_modules/core-js/internals/correct-is-regexp-logic.js
var require_correct_is_regexp_logic = __commonJS({
  "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports2, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH2 = wellKnownSymbol("match");
    module2.exports = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH2] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
  }
});

// node_modules/core-js/modules/es.string.starts-with.js
var require_es_string_starts_with = __commonJS({
  "node_modules/core-js/modules/es.string.starts-with.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var stringSlice = uncurryThis("".slice);
    var min3 = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    }();
    $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString2(requireObjectCoercible(this));
        notARegExp(searchString);
        var index2 = toLength(min3(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString2(searchString);
        return stringSlice(that, index2, index2 + search.length) === search;
      }
    });
  }
});

// node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/internals/add-to-unscopables.js"(exports2, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var create = require_object_create();
    var defineProperty = require_object_define_property().f;
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create(null)
      });
    }
    module2.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/core-js/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js/internals/correct-prototype-getter.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      function F2() {
      }
      F2.prototype.constructor = null;
      return Object.getPrototypeOf(new F2()) !== F2.prototype;
    });
  }
});

// node_modules/core-js/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-get-prototype-of.js"(exports2, module2) {
    "use strict";
    var hasOwn3 = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O3) {
      var object = toObject(O3);
      if (hasOwn3(object, IE_PROTO))
        return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js/internals/iterators-core.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var create = require_object_create();
    var getPrototypeOf = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype = {};
    else if (IS_PURE)
      IteratorPrototype = create(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module2.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS({
  "node_modules/core-js/internals/iterator-create-constructor.js"(exports2, module2) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module2.exports = function(IteratorConstructor, NAME2, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME2 + " Iterator";
      IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js/internals/iterator-define.js
var require_iterator_define = __commonJS({
  "node_modules/core-js/internals/iterator-define.js"(exports2, module2) {
    "use strict";
    var $2 = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module2.exports = function(Iterable, NAME2, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME2, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME2 + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME2 === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods3, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE)
            Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods3 = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
          for (KEY in methods3) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods3[KEY]);
            }
          }
        else
          $2({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods3);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME2] = defaultIterator;
      return methods3;
    };
  }
});

// node_modules/core-js/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS({
  "node_modules/core-js/internals/create-iter-result-object.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value, done) {
      return { value, done };
    };
  }
});

// node_modules/core-js/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js/modules/es.array.iterator.js"(exports2, module2) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var index2 = state.index++;
      if (!target || index2 >= target.length) {
        state.target = null;
        return createIterResultObject(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject(index2, false);
        case "values":
          return createIterResultObject(target[index2], false);
      }
      return createIterResultObject([index2, target[index2]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values")
      try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
  }
});

// node_modules/core-js/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js/internals/dom-iterables.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js/internals/dom-token-list-prototype.js
var require_dom_token_list_prototype = __commonJS({
  "node_modules/core-js/internals/dom-token-list-prototype.js"(exports2, module2) {
    "use strict";
    var documentCreateElement = require_document_create_element();
    var classList = documentCreateElement("span").classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    module2.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
  }
});

// node_modules/core-js/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var ArrayIteratorMethods = require_es_array_iterator();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var setToStringTag = require_set_to_string_tag();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues)
          try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
        setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
        if (DOMIterables[COLLECTION_NAME2])
          for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
              try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
          }
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t3, r2) {
  if ("object" != _typeof(t3) || !t3)
    return t3;
  var e2 = t3[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i3 = e2.call(t3, r2 || "default");
    if ("object" != _typeof(i3))
      return i3;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t3);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t3) {
  var i3 = toPrimitive(t3, "string");
  return "symbol" == _typeof(i3) ? i3 : i3 + "";
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/core-js/internals/array-reduce.js
var require_array_reduce = __commonJS({
  "node_modules/core-js/internals/array-reduce.js"(exports2, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var $TypeError = TypeError;
    var REDUCE_EMPTY = "Reduce of empty array with no initial value";
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        var O3 = toObject(that);
        var self2 = IndexedObject(O3);
        var length = lengthOfArrayLike(O3);
        aCallable(callbackfn);
        if (length === 0 && argumentsLength < 2)
          throw new $TypeError(REDUCE_EMPTY);
        var index2 = IS_RIGHT ? length - 1 : 0;
        var i3 = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2)
          while (true) {
            if (index2 in self2) {
              memo = self2[index2];
              index2 += i3;
              break;
            }
            index2 += i3;
            if (IS_RIGHT ? index2 < 0 : length <= index2) {
              throw new $TypeError(REDUCE_EMPTY);
            }
          }
        for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i3)
          if (index2 in self2) {
            memo = callbackfn(memo, self2[index2], index2, O3);
          }
        return memo;
      };
    };
    module2.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS({
  "node_modules/core-js/internals/array-method-is-strict.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
  }
});

// node_modules/core-js/modules/es.array.reduce.js
var require_es_array_reduce = __commonJS({
  "node_modules/core-js/modules/es.array.reduce.js"() {
    "use strict";
    var $2 = require_export();
    var $reduce = require_array_reduce().left;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var CHROME_VERSION = require_environment_v8_version();
    var IS_NODE = require_environment_is_node();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
    $2({ target: "Array", proto: true, forced: FORCED }, {
      reduce: function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.ends-with.js
var require_es_string_ends_with = __commonJS({
  "node_modules/core-js/modules/es.string.ends-with.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var slice = uncurryThis("".slice);
    var min3 = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
      return descriptor && !descriptor.writable;
    }();
    $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      endsWith: function endsWith(searchString) {
        var that = toString2(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : void 0;
        var len = that.length;
        var end = endPosition === void 0 ? len : min3(toLength(endPosition), len);
        var search = toString2(searchString);
        return slice(that, end - search.length, end) === search;
      }
    });
  }
});

// node_modules/core-js/modules/es.string.split.js
var require_es_string_split = __commonJS({
  "node_modules/core-js/modules/es.string.split.js"() {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var requireObjectCoercible = require_require_object_coercible();
    var speciesConstructor = require_species_constructor();
    var advanceStringIndex = require_advance_string_index();
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var getMethod = require_get_method();
    var regExpExec = require_regexp_exec_abstract();
    var stickyHelpers = require_regexp_sticky_helpers();
    var fails = require_fails();
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var MAX_UINT32 = 4294967295;
    var min3 = Math.min;
    var push = uncurryThis([].push);
    var stringSlice = uncurryThis("".slice);
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re2 = /(?:)/;
      var originalExec = re2.exec;
      re2.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re2);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
    "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    ".".split(/()()/).length > 1 || "".split(/.?/).length;
    fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
        return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
      } : nativeSplit;
      return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split2(separator, limit) {
          var O3 = requireObjectCoercible(this);
          var splitter = isNullOrUndefined(separator) ? void 0 : getMethod(separator, SPLIT);
          return splitter ? call(splitter, separator, O3, limit) : call(internalSplit, toString2(O3), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string, limit) {
          var rx = anObject(this);
          var S2 = toString2(string);
          if (!BUGGY) {
            var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
            if (res.done)
              return res.value;
          }
          var C2 = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (S2.length === 0)
            return regExpExec(splitter, S2) === null ? [S2] : [];
          var p3 = 0;
          var q2 = 0;
          var A2 = [];
          while (q2 < S2.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
            var z2 = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);
            var e2;
            if (z2 === null || (e2 = min3(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p3) {
              q2 = advanceStringIndex(S2, q2, unicodeMatching);
            } else {
              push(A2, stringSlice(S2, p3, q2));
              if (A2.length === lim)
                return A2;
              for (var i3 = 1; i3 <= z2.length - 1; i3++) {
                push(A2, z2[i3]);
                if (A2.length === lim)
                  return A2;
              }
              q2 = p3 = e2;
            }
          }
          push(A2, stringSlice(S2, p3));
          return A2;
        }
      ];
    }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
  }
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports2, module2) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module2.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module2.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module2.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module2.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }).call(exports2);
  }
});

// node_modules/raf/index.js
var require_raf = __commonJS({
  "node_modules/raf/index.js"(exports2, module2) {
    var now = require_performance_now();
    var root = typeof window === "undefined" ? global : window;
    var vendors = ["moz", "webkit"];
    var suffix = "AnimationFrame";
    var raf = root["request" + suffix];
    var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
    for (i3 = 0; !raf && i3 < vendors.length; i3++) {
      raf = root[vendors[i3] + "Request" + suffix];
      caf = root[vendors[i3] + "Cancel" + suffix] || root[vendors[i3] + "CancelRequest" + suffix];
    }
    var i3;
    if (!raf || !caf) {
      last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
      raf = function(callback) {
        if (queue.length === 0) {
          var _now = now(), next = Math.max(0, frameDuration - (_now - last));
          last = next + _now;
          setTimeout(function() {
            var cp = queue.slice(0);
            queue.length = 0;
            for (var i4 = 0; i4 < cp.length; i4++) {
              if (!cp[i4].cancelled) {
                try {
                  cp[i4].callback(last);
                } catch (e2) {
                  setTimeout(function() {
                    throw e2;
                  }, 0);
                }
              }
            }
          }, Math.round(next));
        }
        queue.push({
          handle: ++id,
          callback,
          cancelled: false
        });
        return id;
      };
      caf = function(handle) {
        for (var i4 = 0; i4 < queue.length; i4++) {
          if (queue[i4].handle === handle) {
            queue[i4].cancelled = true;
          }
        }
      };
    }
    var last;
    var id;
    var queue;
    var frameDuration;
    module2.exports = function(fn) {
      return raf.call(root, fn);
    };
    module2.exports.cancel = function() {
      caf.apply(root, arguments);
    };
    module2.exports.polyfill = function(object) {
      if (!object) {
        object = root;
      }
      object.requestAnimationFrame = raf;
      object.cancelAnimationFrame = caf;
    };
  }
});

// node_modules/core-js/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "node_modules/core-js/internals/whitespaces.js"(exports2, module2) {
    "use strict";
    module2.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js/internals/string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js/internals/string-trim.js"(exports2, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString2 = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var ltrim = RegExp("^[" + whitespaces + "]+");
    var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
    var createMethod = function(TYPE2) {
      return function($this) {
        var string = toString2(requireObjectCoercible($this));
        if (TYPE2 & 1)
          string = replace(string, ltrim, "");
        if (TYPE2 & 2)
          string = replace(string, rtrim, "$1");
        return string;
      };
    };
    module2.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// node_modules/core-js/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "node_modules/core-js/internals/string-trim-forced.js"(exports2, module2) {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails = require_fails();
    var whitespaces = require_whitespaces();
    var non = "\u200B\x85\u180E";
    module2.exports = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.trim.js
var require_es_string_trim = __commonJS({
  "node_modules/core-js/modules/es.string.trim.js"() {
    "use strict";
    var $2 = require_export();
    var $trim = require_string_trim().trim;
    var forcedStringTrimMethod = require_string_trim_forced();
    $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
  }
});

// node_modules/rgbcolor/index.js
var require_rgbcolor = __commonJS({
  "node_modules/rgbcolor/index.js"(exports2, module2) {
    module2.exports = function(color_string) {
      this.ok = false;
      this.alpha = 1;
      if (color_string.charAt(0) == "#") {
        color_string = color_string.substr(1, 6);
      }
      color_string = color_string.replace(/ /g, "");
      color_string = color_string.toLowerCase();
      var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
      };
      color_string = simple_colors[color_string] || color_string;
      var color_defs = [
        {
          re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
          example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
          process: function(bits3) {
            return [
              parseInt(bits3[1]),
              parseInt(bits3[2]),
              parseInt(bits3[3]),
              parseFloat(bits3[4])
            ];
          }
        },
        {
          re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
          example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
          process: function(bits3) {
            return [
              parseInt(bits3[1]),
              parseInt(bits3[2]),
              parseInt(bits3[3])
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          example: ["#00ff00", "336699"],
          process: function(bits3) {
            return [
              parseInt(bits3[1], 16),
              parseInt(bits3[2], 16),
              parseInt(bits3[3], 16)
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          example: ["#fb0", "f0f"],
          process: function(bits3) {
            return [
              parseInt(bits3[1] + bits3[1], 16),
              parseInt(bits3[2] + bits3[2], 16),
              parseInt(bits3[3] + bits3[3], 16)
            ];
          }
        }
      ];
      for (var i3 = 0; i3 < color_defs.length; i3++) {
        var re2 = color_defs[i3].re;
        var processor = color_defs[i3].process;
        var bits2 = re2.exec(color_string);
        if (bits2) {
          var channels = processor(bits2);
          this.r = channels[0];
          this.g = channels[1];
          this.b = channels[2];
          if (channels.length > 3) {
            this.alpha = channels[3];
          }
          this.ok = true;
        }
      }
      this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
      this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
      this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
      this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
      this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
      };
      this.toRGBA = function() {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
      };
      this.toHex = function() {
        var r2 = this.r.toString(16);
        var g2 = this.g.toString(16);
        var b2 = this.b.toString(16);
        if (r2.length == 1)
          r2 = "0" + r2;
        if (g2.length == 1)
          g2 = "0" + g2;
        if (b2.length == 1)
          b2 = "0" + b2;
        return "#" + r2 + g2 + b2;
      };
      this.getHelpXML = function() {
        var examples = new Array();
        for (var i4 = 0; i4 < color_defs.length; i4++) {
          var example = color_defs[i4].example;
          for (var j2 = 0; j2 < example.length; j2++) {
            examples[examples.length] = example[j2];
          }
        }
        for (var sc in simple_colors) {
          examples[examples.length] = sc;
        }
        var xml = document.createElement("ul");
        xml.setAttribute("id", "rgbcolor-examples");
        for (var i4 = 0; i4 < examples.length; i4++) {
          try {
            var list_item = document.createElement("li");
            var list_color = new RGBColor(examples[i4]);
            var example_div = document.createElement("div");
            example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
            example_div.appendChild(document.createTextNode("test"));
            var list_item_value = document.createTextNode(
              " " + examples[i4] + " -> " + list_color.toRGB() + " -> " + list_color.toHex()
            );
            list_item.appendChild(example_div);
            list_item.appendChild(list_item_value);
            xml.appendChild(list_item);
          } catch (e2) {
          }
        }
        return xml;
      };
    };
  }
});

// node_modules/core-js/modules/es.array.index-of.js
var require_es_array_index_of = __commonJS({
  "node_modules/core-js/modules/es.array.index-of.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var $indexOf = require_array_includes().indexOf;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var nativeIndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
    var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
    $2({ target: "Array", proto: true, forced: FORCED }, {
      indexOf: function indexOf(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
        return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.includes.js
var require_es_string_includes = __commonJS({
  "node_modules/core-js/modules/es.string.includes.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var toString2 = require_to_string();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var stringIndexOf = uncurryThis("".indexOf);
    $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(
          toString2(requireObjectCoercible(this)),
          toString2(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
  }
});

// node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/internals/is-array.js"(exports2, module2) {
    "use strict";
    var classof = require_classof_raw();
    module2.exports = Array.isArray || function isArray2(argument) {
      return classof(argument) === "Array";
    };
  }
});

// node_modules/core-js/modules/es.array.reverse.js
var require_es_array_reverse = __commonJS({
  "node_modules/core-js/modules/es.array.reverse.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this();
    var isArray2 = require_is_array();
    var nativeReverse = uncurryThis([].reverse);
    var test = [1, 2];
    $2({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
      reverse: function reverse() {
        if (isArray2(this))
          this.length = this.length;
        return nativeReverse(this);
      }
    });
  }
});

// node_modules/svg-pathdata/lib/SVGPathData.module.js
function r(r2, e2) {
  if ("function" != typeof e2 && null !== e2)
    throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
  function i3() {
    this.constructor = r2;
  }
  t(r2, e2), r2.prototype = null === e2 ? Object.create(e2) : (i3.prototype = e2.prototype, new i3());
}
function e(t3) {
  var r2 = "";
  Array.isArray(t3) || (t3 = [t3]);
  for (var e2 = 0; e2 < t3.length; e2++) {
    var i3 = t3[e2];
    if (i3.type === _.CLOSE_PATH)
      r2 += "z";
    else if (i3.type === _.HORIZ_LINE_TO)
      r2 += (i3.relative ? "h" : "H") + i3.x;
    else if (i3.type === _.VERT_LINE_TO)
      r2 += (i3.relative ? "v" : "V") + i3.y;
    else if (i3.type === _.MOVE_TO)
      r2 += (i3.relative ? "m" : "M") + i3.x + " " + i3.y;
    else if (i3.type === _.LINE_TO)
      r2 += (i3.relative ? "l" : "L") + i3.x + " " + i3.y;
    else if (i3.type === _.CURVE_TO)
      r2 += (i3.relative ? "c" : "C") + i3.x1 + " " + i3.y1 + " " + i3.x2 + " " + i3.y2 + " " + i3.x + " " + i3.y;
    else if (i3.type === _.SMOOTH_CURVE_TO)
      r2 += (i3.relative ? "s" : "S") + i3.x2 + " " + i3.y2 + " " + i3.x + " " + i3.y;
    else if (i3.type === _.QUAD_TO)
      r2 += (i3.relative ? "q" : "Q") + i3.x1 + " " + i3.y1 + " " + i3.x + " " + i3.y;
    else if (i3.type === _.SMOOTH_QUAD_TO)
      r2 += (i3.relative ? "t" : "T") + i3.x + " " + i3.y;
    else {
      if (i3.type !== _.ARC)
        throw new Error('Unexpected command type "' + i3.type + '" at index ' + e2 + ".");
      r2 += (i3.relative ? "a" : "A") + i3.rX + " " + i3.rY + " " + i3.xRot + " " + +i3.lArcFlag + " " + +i3.sweepFlag + " " + i3.x + " " + i3.y;
    }
  }
  return r2;
}
function i(t3, r2) {
  var e2 = t3[0], i3 = t3[1];
  return [e2 * Math.cos(r2) - i3 * Math.sin(r2), e2 * Math.sin(r2) + i3 * Math.cos(r2)];
}
function a() {
  for (var t3 = [], r2 = 0; r2 < arguments.length; r2++)
    t3[r2] = arguments[r2];
  for (var e2 = 0; e2 < t3.length; e2++)
    if ("number" != typeof t3[e2])
      throw new Error("assertNumbers arguments[" + e2 + "] is not a number. " + typeof t3[e2] + " == typeof " + t3[e2]);
  return true;
}
function o(t3, r2, e2) {
  t3.lArcFlag = 0 === t3.lArcFlag ? 0 : 1, t3.sweepFlag = 0 === t3.sweepFlag ? 0 : 1;
  var a3 = t3.rX, o3 = t3.rY, s3 = t3.x, u3 = t3.y;
  a3 = Math.abs(t3.rX), o3 = Math.abs(t3.rY);
  var h3 = i([(r2 - s3) / 2, (e2 - u3) / 2], -t3.xRot / 180 * n), c4 = h3[0], y3 = h3[1], p3 = Math.pow(c4, 2) / Math.pow(a3, 2) + Math.pow(y3, 2) / Math.pow(o3, 2);
  1 < p3 && (a3 *= Math.sqrt(p3), o3 *= Math.sqrt(p3)), t3.rX = a3, t3.rY = o3;
  var m4 = Math.pow(a3, 2) * Math.pow(y3, 2) + Math.pow(o3, 2) * Math.pow(c4, 2), O3 = (t3.lArcFlag !== t3.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a3, 2) * Math.pow(o3, 2) - m4) / m4)), l3 = a3 * y3 / o3 * O3, T3 = -o3 * c4 / a3 * O3, v3 = i([l3, T3], t3.xRot / 180 * n);
  t3.cX = v3[0] + (r2 + s3) / 2, t3.cY = v3[1] + (e2 + u3) / 2, t3.phi1 = Math.atan2((y3 - T3) / o3, (c4 - l3) / a3), t3.phi2 = Math.atan2((-y3 - T3) / o3, (-c4 - l3) / a3), 0 === t3.sweepFlag && t3.phi2 > t3.phi1 && (t3.phi2 -= 2 * n), 1 === t3.sweepFlag && t3.phi2 < t3.phi1 && (t3.phi2 += 2 * n), t3.phi1 *= 180 / n, t3.phi2 *= 180 / n;
}
function s(t3, r2, e2) {
  a(t3, r2, e2);
  var i3 = t3 * t3 + r2 * r2 - e2 * e2;
  if (0 > i3)
    return [];
  if (0 === i3)
    return [[t3 * e2 / (t3 * t3 + r2 * r2), r2 * e2 / (t3 * t3 + r2 * r2)]];
  var n3 = Math.sqrt(i3);
  return [[(t3 * e2 + r2 * n3) / (t3 * t3 + r2 * r2), (r2 * e2 - t3 * n3) / (t3 * t3 + r2 * r2)], [(t3 * e2 - r2 * n3) / (t3 * t3 + r2 * r2), (r2 * e2 + t3 * n3) / (t3 * t3 + r2 * r2)]];
}
function c(t3, r2, e2) {
  return (1 - e2) * t3 + e2 * r2;
}
function y(t3, r2, e2, i3) {
  return t3 + Math.cos(i3 / 180 * n) * r2 + Math.sin(i3 / 180 * n) * e2;
}
function p(t3, r2, e2, i3) {
  var a3 = 1e-6, n3 = r2 - t3, o3 = e2 - r2, s3 = 3 * n3 + 3 * (i3 - e2) - 6 * o3, u3 = 6 * (o3 - n3), h3 = 3 * n3;
  return Math.abs(s3) < a3 ? [-h3 / u3] : function(t4, r3, e3) {
    void 0 === e3 && (e3 = 1e-6);
    var i4 = t4 * t4 / 4 - r3;
    if (i4 < -e3)
      return [];
    if (i4 <= e3)
      return [-t4 / 2];
    var a4 = Math.sqrt(i4);
    return [-t4 / 2 - a4, -t4 / 2 + a4];
  }(u3 / s3, h3 / s3, a3);
}
function m(t3, r2, e2, i3, a3) {
  var n3 = 1 - a3;
  return t3 * (n3 * n3 * n3) + r2 * (3 * n3 * n3 * a3) + e2 * (3 * n3 * a3 * a3) + i3 * (a3 * a3 * a3);
}
var t, n, u, h, O, l, T, v, f, _, N;
var init_SVGPathData_module = __esm({
  "node_modules/svg-pathdata/lib/SVGPathData.module.js"() {
    t = function(r2, e2) {
      return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, r3) {
        t3.__proto__ = r3;
      } || function(t3, r3) {
        for (var e3 in r3)
          Object.prototype.hasOwnProperty.call(r3, e3) && (t3[e3] = r3[e3]);
      })(r2, e2);
    };
    n = Math.PI;
    h = Math.PI / 180;
    !function(t3) {
      function r2() {
        return u3(function(t4, r3, e3) {
          return t4.relative && (void 0 !== t4.x1 && (t4.x1 += r3), void 0 !== t4.y1 && (t4.y1 += e3), void 0 !== t4.x2 && (t4.x2 += r3), void 0 !== t4.y2 && (t4.y2 += e3), void 0 !== t4.x && (t4.x += r3), void 0 !== t4.y && (t4.y += e3), t4.relative = false), t4;
        });
      }
      function e2() {
        var t4 = NaN, r3 = NaN, e3 = NaN, i3 = NaN;
        return u3(function(a3, n4, o3) {
          return a3.type & _.SMOOTH_CURVE_TO && (a3.type = _.CURVE_TO, t4 = isNaN(t4) ? n4 : t4, r3 = isNaN(r3) ? o3 : r3, a3.x1 = a3.relative ? n4 - t4 : 2 * n4 - t4, a3.y1 = a3.relative ? o3 - r3 : 2 * o3 - r3), a3.type & _.CURVE_TO ? (t4 = a3.relative ? n4 + a3.x2 : a3.x2, r3 = a3.relative ? o3 + a3.y2 : a3.y2) : (t4 = NaN, r3 = NaN), a3.type & _.SMOOTH_QUAD_TO && (a3.type = _.QUAD_TO, e3 = isNaN(e3) ? n4 : e3, i3 = isNaN(i3) ? o3 : i3, a3.x1 = a3.relative ? n4 - e3 : 2 * n4 - e3, a3.y1 = a3.relative ? o3 - i3 : 2 * o3 - i3), a3.type & _.QUAD_TO ? (e3 = a3.relative ? n4 + a3.x1 : a3.x1, i3 = a3.relative ? o3 + a3.y1 : a3.y1) : (e3 = NaN, i3 = NaN), a3;
        });
      }
      function n3() {
        var t4 = NaN, r3 = NaN;
        return u3(function(e3, i3, a3) {
          if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t4 = isNaN(t4) ? i3 : t4, r3 = isNaN(r3) ? a3 : r3, e3.x1 = e3.relative ? i3 - t4 : 2 * i3 - t4, e3.y1 = e3.relative ? a3 - r3 : 2 * a3 - r3), e3.type & _.QUAD_TO) {
            t4 = e3.relative ? i3 + e3.x1 : e3.x1, r3 = e3.relative ? a3 + e3.y1 : e3.y1;
            var n4 = e3.x1, o3 = e3.y1;
            e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i3) + 2 * n4) / 3, e3.y1 = ((e3.relative ? 0 : a3) + 2 * o3) / 3, e3.x2 = (e3.x + 2 * n4) / 3, e3.y2 = (e3.y + 2 * o3) / 3;
          } else
            t4 = NaN, r3 = NaN;
          return e3;
        });
      }
      function u3(t4) {
        var r3 = 0, e3 = 0, i3 = NaN, a3 = NaN;
        return function(n4) {
          if (isNaN(i3) && !(n4.type & _.MOVE_TO))
            throw new Error("path must start with moveto");
          var o3 = t4(n4, r3, e3, i3, a3);
          return n4.type & _.CLOSE_PATH && (r3 = i3, e3 = a3), void 0 !== n4.x && (r3 = n4.relative ? r3 + n4.x : n4.x), void 0 !== n4.y && (e3 = n4.relative ? e3 + n4.y : n4.y), n4.type & _.MOVE_TO && (i3 = r3, a3 = e3), o3;
        };
      }
      function O3(t4, r3, e3, i3, n4, o3) {
        return a(t4, r3, e3, i3, n4, o3), u3(function(a3, s3, u4, h3) {
          var c4 = a3.x1, y3 = a3.x2, p3 = a3.relative && !isNaN(h3), m4 = void 0 !== a3.x ? a3.x : p3 ? 0 : s3, O4 = void 0 !== a3.y ? a3.y : p3 ? 0 : u4;
          function l4(t5) {
            return t5 * t5;
          }
          a3.type & _.HORIZ_LINE_TO && 0 !== r3 && (a3.type = _.LINE_TO, a3.y = a3.relative ? 0 : u4), a3.type & _.VERT_LINE_TO && 0 !== e3 && (a3.type = _.LINE_TO, a3.x = a3.relative ? 0 : s3), void 0 !== a3.x && (a3.x = a3.x * t4 + O4 * e3 + (p3 ? 0 : n4)), void 0 !== a3.y && (a3.y = m4 * r3 + a3.y * i3 + (p3 ? 0 : o3)), void 0 !== a3.x1 && (a3.x1 = a3.x1 * t4 + a3.y1 * e3 + (p3 ? 0 : n4)), void 0 !== a3.y1 && (a3.y1 = c4 * r3 + a3.y1 * i3 + (p3 ? 0 : o3)), void 0 !== a3.x2 && (a3.x2 = a3.x2 * t4 + a3.y2 * e3 + (p3 ? 0 : n4)), void 0 !== a3.y2 && (a3.y2 = y3 * r3 + a3.y2 * i3 + (p3 ? 0 : o3));
          var T3 = t4 * i3 - r3 * e3;
          if (void 0 !== a3.xRot && (1 !== t4 || 0 !== r3 || 0 !== e3 || 1 !== i3))
            if (0 === T3)
              delete a3.rX, delete a3.rY, delete a3.xRot, delete a3.lArcFlag, delete a3.sweepFlag, a3.type = _.LINE_TO;
            else {
              var v3 = a3.xRot * Math.PI / 180, f3 = Math.sin(v3), N3 = Math.cos(v3), x2 = 1 / l4(a3.rX), d2 = 1 / l4(a3.rY), E2 = l4(N3) * x2 + l4(f3) * d2, A2 = 2 * f3 * N3 * (x2 - d2), C2 = l4(f3) * x2 + l4(N3) * d2, M2 = E2 * i3 * i3 - A2 * r3 * i3 + C2 * r3 * r3, R2 = A2 * (t4 * i3 + r3 * e3) - 2 * (E2 * e3 * i3 + C2 * t4 * r3), g2 = E2 * e3 * e3 - A2 * t4 * e3 + C2 * t4 * t4, I2 = (Math.atan2(R2, M2 - g2) + Math.PI) % Math.PI / 2, S2 = Math.sin(I2), L2 = Math.cos(I2);
              a3.rX = Math.abs(T3) / Math.sqrt(M2 * l4(L2) + R2 * S2 * L2 + g2 * l4(S2)), a3.rY = Math.abs(T3) / Math.sqrt(M2 * l4(S2) - R2 * S2 * L2 + g2 * l4(L2)), a3.xRot = 180 * I2 / Math.PI;
            }
          return void 0 !== a3.sweepFlag && 0 > T3 && (a3.sweepFlag = +!a3.sweepFlag), a3;
        });
      }
      function l3() {
        return function(t4) {
          var r3 = {};
          for (var e3 in t4)
            r3[e3] = t4[e3];
          return r3;
        };
      }
      t3.ROUND = function(t4) {
        function r3(r4) {
          return Math.round(r4 * t4) / t4;
        }
        return void 0 === t4 && (t4 = 1e13), a(t4), function(t5) {
          return void 0 !== t5.x1 && (t5.x1 = r3(t5.x1)), void 0 !== t5.y1 && (t5.y1 = r3(t5.y1)), void 0 !== t5.x2 && (t5.x2 = r3(t5.x2)), void 0 !== t5.y2 && (t5.y2 = r3(t5.y2)), void 0 !== t5.x && (t5.x = r3(t5.x)), void 0 !== t5.y && (t5.y = r3(t5.y)), void 0 !== t5.rX && (t5.rX = r3(t5.rX)), void 0 !== t5.rY && (t5.rY = r3(t5.rY)), t5;
        };
      }, t3.TO_ABS = r2, t3.TO_REL = function() {
        return u3(function(t4, r3, e3) {
          return t4.relative || (void 0 !== t4.x1 && (t4.x1 -= r3), void 0 !== t4.y1 && (t4.y1 -= e3), void 0 !== t4.x2 && (t4.x2 -= r3), void 0 !== t4.y2 && (t4.y2 -= e3), void 0 !== t4.x && (t4.x -= r3), void 0 !== t4.y && (t4.y -= e3), t4.relative = true), t4;
        });
      }, t3.NORMALIZE_HVZ = function(t4, r3, e3) {
        return void 0 === t4 && (t4 = true), void 0 === r3 && (r3 = true), void 0 === e3 && (e3 = true), u3(function(i3, a3, n4, o3, s3) {
          if (isNaN(o3) && !(i3.type & _.MOVE_TO))
            throw new Error("path must start with moveto");
          return r3 && i3.type & _.HORIZ_LINE_TO && (i3.type = _.LINE_TO, i3.y = i3.relative ? 0 : n4), e3 && i3.type & _.VERT_LINE_TO && (i3.type = _.LINE_TO, i3.x = i3.relative ? 0 : a3), t4 && i3.type & _.CLOSE_PATH && (i3.type = _.LINE_TO, i3.x = i3.relative ? o3 - a3 : o3, i3.y = i3.relative ? s3 - n4 : s3), i3.type & _.ARC && (0 === i3.rX || 0 === i3.rY) && (i3.type = _.LINE_TO, delete i3.rX, delete i3.rY, delete i3.xRot, delete i3.lArcFlag, delete i3.sweepFlag), i3;
        });
      }, t3.NORMALIZE_ST = e2, t3.QT_TO_C = n3, t3.INFO = u3, t3.SANITIZE = function(t4) {
        void 0 === t4 && (t4 = 0), a(t4);
        var r3 = NaN, e3 = NaN, i3 = NaN, n4 = NaN;
        return u3(function(a3, o3, s3, u4, h3) {
          var c4 = Math.abs, y3 = false, p3 = 0, m4 = 0;
          if (a3.type & _.SMOOTH_CURVE_TO && (p3 = isNaN(r3) ? 0 : o3 - r3, m4 = isNaN(e3) ? 0 : s3 - e3), a3.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a3.relative ? o3 + a3.x2 : a3.x2, e3 = a3.relative ? s3 + a3.y2 : a3.y2) : (r3 = NaN, e3 = NaN), a3.type & _.SMOOTH_QUAD_TO ? (i3 = isNaN(i3) ? o3 : 2 * o3 - i3, n4 = isNaN(n4) ? s3 : 2 * s3 - n4) : a3.type & _.QUAD_TO ? (i3 = a3.relative ? o3 + a3.x1 : a3.x1, n4 = a3.relative ? s3 + a3.y1 : a3.y2) : (i3 = NaN, n4 = NaN), a3.type & _.LINE_COMMANDS || a3.type & _.ARC && (0 === a3.rX || 0 === a3.rY || !a3.lArcFlag) || a3.type & _.CURVE_TO || a3.type & _.SMOOTH_CURVE_TO || a3.type & _.QUAD_TO || a3.type & _.SMOOTH_QUAD_TO) {
            var O4 = void 0 === a3.x ? 0 : a3.relative ? a3.x : a3.x - o3, l4 = void 0 === a3.y ? 0 : a3.relative ? a3.y : a3.y - s3;
            p3 = isNaN(i3) ? void 0 === a3.x1 ? p3 : a3.relative ? a3.x : a3.x1 - o3 : i3 - o3, m4 = isNaN(n4) ? void 0 === a3.y1 ? m4 : a3.relative ? a3.y : a3.y1 - s3 : n4 - s3;
            var T3 = void 0 === a3.x2 ? 0 : a3.relative ? a3.x : a3.x2 - o3, v3 = void 0 === a3.y2 ? 0 : a3.relative ? a3.y : a3.y2 - s3;
            c4(O4) <= t4 && c4(l4) <= t4 && c4(p3) <= t4 && c4(m4) <= t4 && c4(T3) <= t4 && c4(v3) <= t4 && (y3 = true);
          }
          return a3.type & _.CLOSE_PATH && c4(o3 - u4) <= t4 && c4(s3 - h3) <= t4 && (y3 = true), y3 ? [] : a3;
        });
      }, t3.MATRIX = O3, t3.ROTATE = function(t4, r3, e3) {
        void 0 === r3 && (r3 = 0), void 0 === e3 && (e3 = 0), a(t4, r3, e3);
        var i3 = Math.sin(t4), n4 = Math.cos(t4);
        return O3(n4, i3, -i3, n4, r3 - r3 * n4 + e3 * i3, e3 - r3 * i3 - e3 * n4);
      }, t3.TRANSLATE = function(t4, r3) {
        return void 0 === r3 && (r3 = 0), a(t4, r3), O3(1, 0, 0, 1, t4, r3);
      }, t3.SCALE = function(t4, r3) {
        return void 0 === r3 && (r3 = t4), a(t4, r3), O3(t4, 0, 0, r3, 0, 0);
      }, t3.SKEW_X = function(t4) {
        return a(t4), O3(1, 0, Math.atan(t4), 1, 0, 0);
      }, t3.SKEW_Y = function(t4) {
        return a(t4), O3(1, Math.atan(t4), 0, 1, 0, 0);
      }, t3.X_AXIS_SYMMETRY = function(t4) {
        return void 0 === t4 && (t4 = 0), a(t4), O3(-1, 0, 0, 1, t4, 0);
      }, t3.Y_AXIS_SYMMETRY = function(t4) {
        return void 0 === t4 && (t4 = 0), a(t4), O3(1, 0, 0, -1, 0, t4);
      }, t3.A_TO_C = function() {
        return u3(function(t4, r3, e3) {
          return _.ARC === t4.type ? function(t5, r4, e4) {
            var a3, n4, s3, u4;
            t5.cX || o(t5, r4, e4);
            for (var y3 = Math.min(t5.phi1, t5.phi2), p3 = Math.max(t5.phi1, t5.phi2) - y3, m4 = Math.ceil(p3 / 90), O4 = new Array(m4), l4 = r4, T3 = e4, v3 = 0; v3 < m4; v3++) {
              var f3 = c(t5.phi1, t5.phi2, v3 / m4), N3 = c(t5.phi1, t5.phi2, (v3 + 1) / m4), x2 = N3 - f3, d2 = 4 / 3 * Math.tan(x2 * h / 4), E2 = [Math.cos(f3 * h) - d2 * Math.sin(f3 * h), Math.sin(f3 * h) + d2 * Math.cos(f3 * h)], A2 = E2[0], C2 = E2[1], M2 = [Math.cos(N3 * h), Math.sin(N3 * h)], R2 = M2[0], g2 = M2[1], I2 = [R2 + d2 * Math.sin(N3 * h), g2 - d2 * Math.cos(N3 * h)], S2 = I2[0], L2 = I2[1];
              O4[v3] = { relative: t5.relative, type: _.CURVE_TO };
              var H2 = function(r5, e5) {
                var a4 = i([r5 * t5.rX, e5 * t5.rY], t5.xRot), n5 = a4[0], o3 = a4[1];
                return [t5.cX + n5, t5.cY + o3];
              };
              a3 = H2(A2, C2), O4[v3].x1 = a3[0], O4[v3].y1 = a3[1], n4 = H2(S2, L2), O4[v3].x2 = n4[0], O4[v3].y2 = n4[1], s3 = H2(R2, g2), O4[v3].x = s3[0], O4[v3].y = s3[1], t5.relative && (O4[v3].x1 -= l4, O4[v3].y1 -= T3, O4[v3].x2 -= l4, O4[v3].y2 -= T3, O4[v3].x -= l4, O4[v3].y -= T3), l4 = (u4 = [O4[v3].x, O4[v3].y])[0], T3 = u4[1];
            }
            return O4;
          }(t4, t4.relative ? 0 : r3, t4.relative ? 0 : e3) : t4;
        });
      }, t3.ANNOTATE_ARCS = function() {
        return u3(function(t4, r3, e3) {
          return t4.relative && (r3 = 0, e3 = 0), _.ARC === t4.type && o(t4, r3, e3), t4;
        });
      }, t3.CLONE = l3, t3.CALCULATE_BOUNDS = function() {
        var t4 = function(t5) {
          var r3 = {};
          for (var e3 in t5)
            r3[e3] = t5[e3];
          return r3;
        }, i3 = r2(), a3 = n3(), h3 = e2(), c4 = u3(function(r3, e3, n4) {
          var u4 = h3(a3(i3(t4(r3))));
          function O4(t5) {
            t5 > c4.maxX && (c4.maxX = t5), t5 < c4.minX && (c4.minX = t5);
          }
          function l4(t5) {
            t5 > c4.maxY && (c4.maxY = t5), t5 < c4.minY && (c4.minY = t5);
          }
          if (u4.type & _.DRAWING_COMMANDS && (O4(e3), l4(n4)), u4.type & _.HORIZ_LINE_TO && O4(u4.x), u4.type & _.VERT_LINE_TO && l4(u4.y), u4.type & _.LINE_TO && (O4(u4.x), l4(u4.y)), u4.type & _.CURVE_TO) {
            O4(u4.x), l4(u4.y);
            for (var T3 = 0, v3 = p(e3, u4.x1, u4.x2, u4.x); T3 < v3.length; T3++) {
              0 < (w2 = v3[T3]) && 1 > w2 && O4(m(e3, u4.x1, u4.x2, u4.x, w2));
            }
            for (var f3 = 0, N3 = p(n4, u4.y1, u4.y2, u4.y); f3 < N3.length; f3++) {
              0 < (w2 = N3[f3]) && 1 > w2 && l4(m(n4, u4.y1, u4.y2, u4.y, w2));
            }
          }
          if (u4.type & _.ARC) {
            O4(u4.x), l4(u4.y), o(u4, e3, n4);
            for (var x2 = u4.xRot / 180 * Math.PI, d2 = Math.cos(x2) * u4.rX, E2 = Math.sin(x2) * u4.rX, A2 = -Math.sin(x2) * u4.rY, C2 = Math.cos(x2) * u4.rY, M2 = u4.phi1 < u4.phi2 ? [u4.phi1, u4.phi2] : -180 > u4.phi2 ? [u4.phi2 + 360, u4.phi1 + 360] : [u4.phi2, u4.phi1], R2 = M2[0], g2 = M2[1], I2 = function(t5) {
              var r4 = t5[0], e4 = t5[1], i4 = 180 * Math.atan2(e4, r4) / Math.PI;
              return i4 < R2 ? i4 + 360 : i4;
            }, S2 = 0, L2 = s(A2, -d2, 0).map(I2); S2 < L2.length; S2++) {
              (w2 = L2[S2]) > R2 && w2 < g2 && O4(y(u4.cX, d2, A2, w2));
            }
            for (var H2 = 0, U2 = s(C2, -E2, 0).map(I2); H2 < U2.length; H2++) {
              var w2;
              (w2 = U2[H2]) > R2 && w2 < g2 && l4(y(u4.cY, E2, C2, w2));
            }
          }
          return r3;
        });
        return c4.minX = 1 / 0, c4.maxX = -1 / 0, c4.minY = 1 / 0, c4.maxY = -1 / 0, c4;
      };
    }(u || (u = {}));
    l = function() {
      function t3() {
      }
      return t3.prototype.round = function(t4) {
        return this.transform(u.ROUND(t4));
      }, t3.prototype.toAbs = function() {
        return this.transform(u.TO_ABS());
      }, t3.prototype.toRel = function() {
        return this.transform(u.TO_REL());
      }, t3.prototype.normalizeHVZ = function(t4, r2, e2) {
        return this.transform(u.NORMALIZE_HVZ(t4, r2, e2));
      }, t3.prototype.normalizeST = function() {
        return this.transform(u.NORMALIZE_ST());
      }, t3.prototype.qtToC = function() {
        return this.transform(u.QT_TO_C());
      }, t3.prototype.aToC = function() {
        return this.transform(u.A_TO_C());
      }, t3.prototype.sanitize = function(t4) {
        return this.transform(u.SANITIZE(t4));
      }, t3.prototype.translate = function(t4, r2) {
        return this.transform(u.TRANSLATE(t4, r2));
      }, t3.prototype.scale = function(t4, r2) {
        return this.transform(u.SCALE(t4, r2));
      }, t3.prototype.rotate = function(t4, r2, e2) {
        return this.transform(u.ROTATE(t4, r2, e2));
      }, t3.prototype.matrix = function(t4, r2, e2, i3, a3, n3) {
        return this.transform(u.MATRIX(t4, r2, e2, i3, a3, n3));
      }, t3.prototype.skewX = function(t4) {
        return this.transform(u.SKEW_X(t4));
      }, t3.prototype.skewY = function(t4) {
        return this.transform(u.SKEW_Y(t4));
      }, t3.prototype.xSymmetry = function(t4) {
        return this.transform(u.X_AXIS_SYMMETRY(t4));
      }, t3.prototype.ySymmetry = function(t4) {
        return this.transform(u.Y_AXIS_SYMMETRY(t4));
      }, t3.prototype.annotateArcs = function() {
        return this.transform(u.ANNOTATE_ARCS());
      }, t3;
    }();
    T = function(t3) {
      return " " === t3 || "	" === t3 || "\r" === t3 || "\n" === t3;
    };
    v = function(t3) {
      return "0".charCodeAt(0) <= t3.charCodeAt(0) && t3.charCodeAt(0) <= "9".charCodeAt(0);
    };
    f = function(t3) {
      function e2() {
        var r2 = t3.call(this) || this;
        return r2.curNumber = "", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;
      }
      return r(e2, t3), e2.prototype.finish = function(t4) {
        if (void 0 === t4 && (t4 = []), this.parse(" ", t4), 0 !== this.curArgs.length || !this.canParseCommandOrComma)
          throw new SyntaxError("Unterminated command at the path end.");
        return t4;
      }, e2.prototype.parse = function(t4, r2) {
        var e3 = this;
        void 0 === r2 && (r2 = []);
        for (var i3 = function(t5) {
          r2.push(t5), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
        }, a3 = 0; a3 < t4.length; a3++) {
          var n3 = t4[a3], o3 = !(this.curCommandType !== _.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || "0" !== this.curNumber && "1" !== this.curNumber), s3 = v(n3) && ("0" === this.curNumber && "0" === n3 || o3);
          if (!v(n3) || s3)
            if ("e" !== n3 && "E" !== n3)
              if ("-" !== n3 && "+" !== n3 || !this.curNumberHasExp || this.curNumberHasExpDigits)
                if ("." !== n3 || this.curNumberHasExp || this.curNumberHasDecimal || o3) {
                  if (this.curNumber && -1 !== this.curCommandType) {
                    var u3 = Number(this.curNumber);
                    if (isNaN(u3))
                      throw new SyntaxError("Invalid number ending at " + a3);
                    if (this.curCommandType === _.ARC) {
                      if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                        if (0 > u3)
                          throw new SyntaxError('Expected positive number, got "' + u3 + '" at index "' + a3 + '"');
                      } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber)
                        throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a3 + '"');
                    }
                    this.curArgs.push(u3), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i3({ type: _.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u3 }) : _.VERT_LINE_TO === this.curCommandType ? i3({ type: _.VERT_LINE_TO, relative: this.curCommandRelative, y: u3 }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i3({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i3({ type: _.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i3({ type: _.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.QUAD_TO ? i3({ type: _.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.ARC && i3({ type: _.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
                  }
                  if (!T(n3))
                    if ("," === n3 && this.canParseCommandOrComma)
                      this.canParseCommandOrComma = false;
                    else if ("+" !== n3 && "-" !== n3 && "." !== n3)
                      if (s3)
                        this.curNumber = n3, this.curNumberHasDecimal = false;
                      else {
                        if (0 !== this.curArgs.length)
                          throw new SyntaxError("Unterminated command at index " + a3 + ".");
                        if (!this.canParseCommandOrComma)
                          throw new SyntaxError('Unexpected character "' + n3 + '" at index ' + a3 + ". Command cannot follow comma");
                        if (this.canParseCommandOrComma = false, "z" !== n3 && "Z" !== n3)
                          if ("h" === n3 || "H" === n3)
                            this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = "h" === n3;
                          else if ("v" === n3 || "V" === n3)
                            this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = "v" === n3;
                          else if ("m" === n3 || "M" === n3)
                            this.curCommandType = _.MOVE_TO, this.curCommandRelative = "m" === n3;
                          else if ("l" === n3 || "L" === n3)
                            this.curCommandType = _.LINE_TO, this.curCommandRelative = "l" === n3;
                          else if ("c" === n3 || "C" === n3)
                            this.curCommandType = _.CURVE_TO, this.curCommandRelative = "c" === n3;
                          else if ("s" === n3 || "S" === n3)
                            this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === n3;
                          else if ("q" === n3 || "Q" === n3)
                            this.curCommandType = _.QUAD_TO, this.curCommandRelative = "q" === n3;
                          else if ("t" === n3 || "T" === n3)
                            this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === n3;
                          else {
                            if ("a" !== n3 && "A" !== n3)
                              throw new SyntaxError('Unexpected character "' + n3 + '" at index ' + a3 + ".");
                            this.curCommandType = _.ARC, this.curCommandRelative = "a" === n3;
                          }
                        else
                          r2.push({ type: _.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
                      }
                    else
                      this.curNumber = n3, this.curNumberHasDecimal = "." === n3;
                } else
                  this.curNumber += n3, this.curNumberHasDecimal = true;
              else
                this.curNumber += n3;
            else
              this.curNumber += n3, this.curNumberHasExp = true;
          else
            this.curNumber += n3, this.curNumberHasExpDigits = this.curNumberHasExp;
        }
        return r2;
      }, e2.prototype.transform = function(t4) {
        return Object.create(this, { parse: { value: function(r2, e3) {
          void 0 === e3 && (e3 = []);
          for (var i3 = 0, a3 = Object.getPrototypeOf(this).parse.call(this, r2); i3 < a3.length; i3++) {
            var n3 = a3[i3], o3 = t4(n3);
            Array.isArray(o3) ? e3.push.apply(e3, o3) : e3.push(o3);
          }
          return e3;
        } } });
      }, e2;
    }(l);
    _ = function(t3) {
      function i3(r2) {
        var e2 = t3.call(this) || this;
        return e2.commands = "string" == typeof r2 ? i3.parse(r2) : r2, e2;
      }
      return r(i3, t3), i3.prototype.encode = function() {
        return i3.encode(this.commands);
      }, i3.prototype.getBounds = function() {
        var t4 = u.CALCULATE_BOUNDS();
        return this.transform(t4), t4;
      }, i3.prototype.transform = function(t4) {
        for (var r2 = [], e2 = 0, i4 = this.commands; e2 < i4.length; e2++) {
          var a3 = t4(i4[e2]);
          Array.isArray(a3) ? r2.push.apply(r2, a3) : r2.push(a3);
        }
        return this.commands = r2, this;
      }, i3.encode = function(t4) {
        return e(t4);
      }, i3.parse = function(t4) {
        var r2 = new f(), e2 = [];
        return r2.parse(t4, e2), r2.finish(e2), e2;
      }, i3.CLOSE_PATH = 1, i3.MOVE_TO = 2, i3.HORIZ_LINE_TO = 4, i3.VERT_LINE_TO = 8, i3.LINE_TO = 16, i3.CURVE_TO = 32, i3.SMOOTH_CURVE_TO = 64, i3.QUAD_TO = 128, i3.SMOOTH_QUAD_TO = 256, i3.ARC = 512, i3.LINE_COMMANDS = i3.LINE_TO | i3.HORIZ_LINE_TO | i3.VERT_LINE_TO, i3.DRAWING_COMMANDS = i3.HORIZ_LINE_TO | i3.VERT_LINE_TO | i3.LINE_TO | i3.CURVE_TO | i3.SMOOTH_CURVE_TO | i3.QUAD_TO | i3.SMOOTH_QUAD_TO | i3.ARC, i3;
    }(l);
    N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);
  }
});

// node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "node_modules/core-js/internals/regexp-get-flags.js"(exports2, module2) {
    "use strict";
    var call = require_function_call();
    var hasOwn3 = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlags = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module2.exports = function(R2) {
      var flags = R2.flags;
      return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn3(R2, "flags") && isPrototypeOf(RegExpPrototype, R2) ? call(regExpFlags, R2) : flags;
    };
  }
});

// node_modules/core-js/modules/es.regexp.to-string.js
var require_es_regexp_to_string = __commonJS({
  "node_modules/core-js/modules/es.regexp.to-string.js"() {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var defineBuiltIn = require_define_built_in();
    var anObject = require_an_object();
    var $toString = require_to_string();
    var fails = require_fails();
    var getRegExpFlags = require_regexp_get_flags();
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function() {
      return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
    });
    var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      defineBuiltIn(RegExpPrototype, TO_STRING, function toString2() {
        var R2 = anObject(this);
        var pattern = $toString(R2.source);
        var flags = $toString(getRegExpFlags(R2));
        return "/" + pattern + "/" + flags;
      }, { unsafe: true });
    }
  }
});

// node_modules/stackblur-canvas/dist/stackblur-es.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || _typeof2(canvas) !== "object" || !("getContext" in canvas)) {
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  }
  var context = canvas.getContext("2d");
  try {
    return context.getImageData(topX, topY, width, height);
  } catch (e2) {
    throw new Error("unable to access image data: " + e2);
  }
}
function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;
  for (var i3 = 1; i3 < div; i3++) {
    stack = stack.next = new BlurStack();
    if (i3 === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null, stackOut = null, yw = 0, yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  for (var y3 = 0; y3 < height; y3++) {
    stack = stackStart;
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p3 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r2 = pixels[p3], g2 = pixels[p3 + 1], b2 = pixels[p3 + 2], a3 = pixels[p3 + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r2) * rbs;
      gSum += (stack.g = g2) * rbs;
      bSum += (stack.b = b2) * rbs;
      aSum += (stack.a = a3) * rbs;
      rInSum += r2;
      gInSum += g2;
      bInSum += b2;
      aInSum += a3;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x2 = 0; x2 < width; x2++) {
      var paInitial = aSum * mulSum >>> shgSum;
      pixels[yi + 3] = paInitial;
      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;
        pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;
      var _p = x2 + radius + 1;
      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b2;
      aOutSum += _a3;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b2;
      aInSum -= _a3;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (var _x = 0; _x < width; _x++) {
    yi = _x << 2;
    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
    stack = stackStart;
    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }
    var yp = width;
    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;
      var _rbs = radiusPlus1 - _i4;
      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;
      if (_i4 < heightMinus1) {
        yp += width;
      }
    }
    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y = 0; _y < height; _y++) {
      var _p2 = yi << 2;
      pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;
      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }
      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
  return imageData;
}
var mulTable, shgTable, BlurStack;
var init_stackblur_es = __esm({
  "node_modules/stackblur-canvas/dist/stackblur-es.js"() {
    mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
    shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
    BlurStack = /**
     * Set properties.
     */
    function BlurStack2() {
      _classCallCheck(this, BlurStack2);
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    };
  }
});

// node_modules/canvg/lib/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  AElement: () => AElement,
  AnimateColorElement: () => AnimateColorElement,
  AnimateElement: () => AnimateElement,
  AnimateTransformElement: () => AnimateTransformElement,
  BoundingBox: () => BoundingBox,
  CB1: () => CB1,
  CB2: () => CB2,
  CB3: () => CB3,
  CB4: () => CB4,
  Canvg: () => Canvg,
  CircleElement: () => CircleElement,
  ClipPathElement: () => ClipPathElement,
  DefsElement: () => DefsElement,
  DescElement: () => DescElement,
  Document: () => Document,
  Element: () => Element,
  EllipseElement: () => EllipseElement,
  FeColorMatrixElement: () => FeColorMatrixElement,
  FeCompositeElement: () => FeCompositeElement,
  FeDropShadowElement: () => FeDropShadowElement,
  FeGaussianBlurElement: () => FeGaussianBlurElement,
  FeMorphologyElement: () => FeMorphologyElement,
  FilterElement: () => FilterElement,
  Font: () => Font,
  FontElement: () => FontElement,
  FontFaceElement: () => FontFaceElement,
  GElement: () => GElement,
  GlyphElement: () => GlyphElement,
  GradientElement: () => GradientElement,
  ImageElement: () => ImageElement,
  LineElement: () => LineElement,
  LinearGradientElement: () => LinearGradientElement,
  MarkerElement: () => MarkerElement,
  MaskElement: () => MaskElement,
  Matrix: () => Matrix4,
  MissingGlyphElement: () => MissingGlyphElement,
  Mouse: () => Mouse,
  PSEUDO_ZERO: () => PSEUDO_ZERO,
  Parser: () => Parser,
  PathElement: () => PathElement,
  PathParser: () => PathParser,
  PatternElement: () => PatternElement,
  Point: () => Point,
  PolygonElement: () => PolygonElement,
  PolylineElement: () => PolylineElement,
  Property: () => Property,
  QB1: () => QB1,
  QB2: () => QB2,
  QB3: () => QB3,
  RadialGradientElement: () => RadialGradientElement,
  RectElement: () => RectElement,
  RenderedElement: () => RenderedElement,
  Rotate: () => Rotate,
  SVGElement: () => SVGElement,
  SVGFontLoader: () => SVGFontLoader,
  Scale: () => Scale,
  Screen: () => Screen,
  Skew: () => Skew,
  SkewX: () => SkewX,
  SkewY: () => SkewY,
  StopElement: () => StopElement,
  StyleElement: () => StyleElement,
  SymbolElement: () => SymbolElement,
  TRefElement: () => TRefElement,
  TSpanElement: () => TSpanElement,
  TextElement: () => TextElement,
  TextPathElement: () => TextPathElement,
  TitleElement: () => TitleElement,
  Transform: () => Transform,
  Translate: () => Translate,
  UnknownElement: () => UnknownElement,
  UseElement: () => UseElement,
  ViewPort: () => ViewPort,
  compressSpaces: () => compressSpaces,
  default: () => Canvg,
  getSelectorSpecificity: () => getSelectorSpecificity,
  normalizeAttributeName: () => normalizeAttributeName,
  normalizeColor: () => normalizeColor,
  parseExternalUrl: () => parseExternalUrl,
  presets: () => index,
  toNumbers: () => toNumbers,
  trimLeft: () => trimLeft,
  trimRight: () => trimRight,
  vectorMagnitude: () => vectorMagnitude,
  vectorsAngle: () => vectorsAngle,
  vectorsRatio: () => vectorsRatio
});
function offscreen() {
  var {
    DOMParser: DOMParserFallback
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var preset = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParserFallback,
    createCanvas(width, height) {
      return new OffscreenCanvas(width, height);
    },
    createImage(url) {
      return _asyncToGenerator(function* () {
        var response = yield fetch(url);
        var blob = yield response.blob();
        var img = yield createImageBitmap(blob);
        return img;
      })();
    }
  };
  if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
    Reflect.deleteProperty(preset, "DOMParser");
  }
  return preset;
}
function node(_ref) {
  var {
    DOMParser: DOMParser2,
    canvas,
    fetch: fetch2
  } = _ref;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParser2,
    fetch: fetch2,
    createCanvas: canvas.createCanvas,
    createImage: canvas.loadImage
  };
}
function compressSpaces(str) {
  return str.replace(/(?!\u3000)\s+/gm, " ");
}
function trimLeft(str) {
  return str.replace(/^[\n \t]+/, "");
}
function trimRight(str) {
  return str.replace(/[\n \t]+$/, "");
}
function toNumbers(str) {
  var matches = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return matches.map(parseFloat);
}
function normalizeAttributeName(name) {
  if (allUppercase.test(name)) {
    return name.toLowerCase();
  }
  return name;
}
function parseExternalUrl(url) {
  var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
  return urlMatch[2] || urlMatch[3] || urlMatch[4];
}
function normalizeColor(color) {
  if (!color.startsWith("rgb")) {
    return color;
  }
  var rgbParts = 3;
  var normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
  return normalizedColor;
}
function findSelectorMatch(selector, regex) {
  var matches = regex.exec(selector);
  if (!matches) {
    return [selector, 0];
  }
  return [selector.replace(regex, " "), matches.length];
}
function getSelectorSpecificity(selector) {
  var specificity = [0, 0, 0];
  var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
  var delta = 0;
  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
  specificity[0] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
  specificity[2] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
  specificity[1] += delta;
  currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
  specificity[2] += delta;
  return specificity.join("");
}
function vectorMagnitude(v3) {
  return Math.sqrt(Math.pow(v3[0], 2) + Math.pow(v3[1], 2));
}
function vectorsRatio(u3, v3) {
  return (u3[0] * v3[0] + u3[1] * v3[1]) / (vectorMagnitude(u3) * vectorMagnitude(v3));
}
function vectorsAngle(u3, v3) {
  return (u3[0] * v3[1] < u3[1] * v3[0] ? -1 : 1) * Math.acos(vectorsRatio(u3, v3));
}
function CB1(t3) {
  return t3 * t3 * t3;
}
function CB2(t3) {
  return 3 * t3 * t3 * (1 - t3);
}
function CB3(t3) {
  return 3 * t3 * (1 - t3) * (1 - t3);
}
function CB4(t3) {
  return (1 - t3) * (1 - t3) * (1 - t3);
}
function QB1(t3) {
  return t3 * t3;
}
function QB2(t3) {
  return 2 * t3 * (1 - t3);
}
function QB3(t3) {
  return (1 - t3) * (1 - t3);
}
function parseTransforms(transform) {
  return compressSpaces(transform).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function parseTransform(transform) {
  var [type, value] = transform.split("(");
  return [type.trim(), value.trim().replace(")", "")];
}
function wrapFontFamily(fontFamily) {
  var trimmed = fontFamily.trim();
  return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
}
function prepareFontFamily(fontFamily) {
  return typeof process === "undefined" ? fontFamily : fontFamily.trim().split(",").map(wrapFontFamily).join(",");
}
function prepareFontStyle(fontStyle) {
  if (!fontStyle) {
    return "";
  }
  var targetFontStyle = fontStyle.trim().toLowerCase();
  switch (targetFontStyle) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontStyle;
    default:
      if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
        return targetFontStyle;
      }
      return "";
  }
}
function prepareFontWeight(fontWeight) {
  if (!fontWeight) {
    return "";
  }
  var targetFontWeight = fontWeight.trim().toLowerCase();
  switch (targetFontWeight) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontWeight;
    default:
      if (/^[\d.]+$/.test(targetFontWeight)) {
        return targetFontWeight;
      }
      return "";
  }
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function imGet(img, x2, y3, width, _height, rgba) {
  return img[y3 * width * 4 + x2 * 4 + rgba];
}
function imSet(img, x2, y3, width, _height, rgba, val) {
  img[y3 * width * 4 + x2 * 4 + rgba] = val;
}
function m2(matrix2, i3, v3) {
  var mi = matrix2[i3];
  return mi * v3;
}
function c2(a3, m1, m22, m32) {
  return m1 + Math.cos(a3) * m22 + Math.sin(a3) * m32;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function createCanvas2(width, height) {
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function createImage(_x) {
  return _createImage.apply(this, arguments);
}
function _createImage() {
  _createImage = _asyncToGenerator(function* (src) {
    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var image = document.createElement("img");
    if (anonymousCrossOrigin) {
      image.crossOrigin = "Anonymous";
    }
    return new Promise((resolve2, reject2) => {
      image.onload = () => {
        resolve2(image);
      };
      image.onerror = (_event, _source, _lineno, _colno, error) => {
        reject2(error);
      };
      image.src = src;
    });
  });
  return _createImage.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_es_promise, import_es_string_match, import_es_string_replace, import_es_string_starts_with, import_es_array_iterator, import_web_dom_collections_iterator, import_es_array_reduce, import_es_string_ends_with, import_es_string_split, import_raf, import_es_string_trim, import_rgbcolor, import_es_array_index_of, import_es_string_includes, import_es_array_reverse, import_es_regexp_to_string, index, allUppercase, attributeRegex, idRegex, classRegex, pseudoElementRegex, pseudoClassWithBracketsRegex, pseudoClassRegex, elementRegex, PSEUDO_ZERO, Property, ViewPort, Point, Mouse, defaultWindow, defaultFetch$1, Screen, defaultFetch, DefaultDOMParser, Parser, Translate, Rotate, Scale, Matrix4, Skew, SkewX, SkewY, Transform, Element, UnknownElement, Font, BoundingBox, PathParser, RenderedElement, PathElement, GlyphElement, TextElement, TSpanElement, TextNode, SVGElement, RectElement, CircleElement, EllipseElement, LineElement, PolylineElement, PolygonElement, PatternElement, MarkerElement, DefsElement, GElement, GradientElement, LinearGradientElement, RadialGradientElement, StopElement, AnimateElement, AnimateColorElement, AnimateTransformElement, FontElement, FontFaceElement, MissingGlyphElement, TRefElement, AElement, TextPathElement, dataUriRegex, ImageElement, SymbolElement, SVGFontLoader, StyleElement, UseElement, FeColorMatrixElement, MaskElement, noop, ClipPathElement, FilterElement, FeDropShadowElement, FeMorphologyElement, FeCompositeElement, FeGaussianBlurElement, TitleElement, DescElement, elements, Document, Canvg;
var init_index_es = __esm({
  "node_modules/canvg/lib/index.es.js"() {
    import_es_promise = __toESM(require_es_promise(), 1);
    init_asyncToGenerator();
    import_es_string_match = __toESM(require_es_string_match(), 1);
    import_es_string_replace = __toESM(require_es_string_replace(), 1);
    import_es_string_starts_with = __toESM(require_es_string_starts_with(), 1);
    import_es_array_iterator = __toESM(require_es_array_iterator(), 1);
    import_web_dom_collections_iterator = __toESM(require_web_dom_collections_iterator(), 1);
    init_defineProperty();
    import_es_array_reduce = __toESM(require_es_array_reduce(), 1);
    import_es_string_ends_with = __toESM(require_es_string_ends_with(), 1);
    import_es_string_split = __toESM(require_es_string_split(), 1);
    import_raf = __toESM(require_raf(), 1);
    import_es_string_trim = __toESM(require_es_string_trim(), 1);
    import_rgbcolor = __toESM(require_rgbcolor(), 1);
    import_es_array_index_of = __toESM(require_es_array_index_of(), 1);
    import_es_string_includes = __toESM(require_es_string_includes(), 1);
    import_es_array_reverse = __toESM(require_es_array_reverse(), 1);
    init_SVGPathData_module();
    import_es_regexp_to_string = __toESM(require_es_regexp_to_string(), 1);
    init_stackblur_es();
    index = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      offscreen,
      node
    });
    allUppercase = /^[A-Z-]+$/;
    attributeRegex = /(\[[^\]]+\])/g;
    idRegex = /(#[^\s+>~.[:]+)/g;
    classRegex = /(\.[^\s+>~.[:]+)/g;
    pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
    pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
    pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
    elementRegex = /([^\s+>~.[:]+)/g;
    PSEUDO_ZERO = 1e-8;
    Property = class {
      constructor(document2, name, value) {
        this.document = document2;
        this.name = name;
        this.value = value;
        this.isNormalizedColor = false;
      }
      static empty(document2) {
        return new Property(document2, "EMPTY", "");
      }
      split() {
        var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
        var {
          document: document2,
          name
        } = this;
        return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document2, name, value));
      }
      hasValue(zeroIsValue) {
        var {
          value
        } = this;
        return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
      }
      isString(regexp) {
        var {
          value
        } = this;
        var result = typeof value === "string";
        if (!result || !regexp) {
          return result;
        }
        return regexp.test(value);
      }
      isUrlDefinition() {
        return this.isString(/^url\(/);
      }
      isPixels() {
        if (!this.hasValue()) {
          return false;
        }
        var asString = this.getString();
        switch (true) {
          case asString.endsWith("px"):
          case /^[0-9]+$/.test(asString):
            return true;
          default:
            return false;
        }
      }
      setValue(value) {
        this.value = value;
        return this;
      }
      getValue(def) {
        if (typeof def === "undefined" || this.hasValue()) {
          return this.value;
        }
        return def;
      }
      getNumber(def) {
        if (!this.hasValue()) {
          if (typeof def === "undefined") {
            return 0;
          }
          return parseFloat(def);
        }
        var {
          value
        } = this;
        var n3 = parseFloat(value);
        if (this.isString(/%$/)) {
          n3 /= 100;
        }
        return n3;
      }
      getString(def) {
        if (typeof def === "undefined" || this.hasValue()) {
          return typeof this.value === "undefined" ? "" : String(this.value);
        }
        return String(def);
      }
      getColor(def) {
        var color = this.getString(def);
        if (this.isNormalizedColor) {
          return color;
        }
        this.isNormalizedColor = true;
        color = normalizeColor(color);
        this.value = color;
        return color;
      }
      getDpi() {
        return 96;
      }
      getRem() {
        return this.document.rootEmSize;
      }
      getEm() {
        return this.document.emSize;
      }
      getUnits() {
        return this.getString().replace(/[0-9.-]/g, "");
      }
      getPixels(axisOrIsFontSize) {
        var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this.hasValue()) {
          return 0;
        }
        var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];
        var {
          viewPort
        } = this.document.screen;
        switch (true) {
          case this.isString(/vmin$/):
            return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
          case this.isString(/vmax$/):
            return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
          case this.isString(/vw$/):
            return this.getNumber() / 100 * viewPort.computeSize("x");
          case this.isString(/vh$/):
            return this.getNumber() / 100 * viewPort.computeSize("y");
          case this.isString(/rem$/):
            return this.getNumber() * this.getRem();
          case this.isString(/em$/):
            return this.getNumber() * this.getEm();
          case this.isString(/ex$/):
            return this.getNumber() * this.getEm() / 2;
          case this.isString(/px$/):
            return this.getNumber();
          case this.isString(/pt$/):
            return this.getNumber() * this.getDpi() * (1 / 72);
          case this.isString(/pc$/):
            return this.getNumber() * 15;
          case this.isString(/cm$/):
            return this.getNumber() * this.getDpi() / 2.54;
          case this.isString(/mm$/):
            return this.getNumber() * this.getDpi() / 25.4;
          case this.isString(/in$/):
            return this.getNumber() * this.getDpi();
          case (this.isString(/%$/) && isFontSize):
            return this.getNumber() * this.getEm();
          case this.isString(/%$/):
            return this.getNumber() * viewPort.computeSize(axis);
          default: {
            var n3 = this.getNumber();
            if (processPercent && n3 < 1) {
              return n3 * viewPort.computeSize(axis);
            }
            return n3;
          }
        }
      }
      getMilliseconds() {
        if (!this.hasValue()) {
          return 0;
        }
        if (this.isString(/ms$/)) {
          return this.getNumber();
        }
        return this.getNumber() * 1e3;
      }
      getRadians() {
        if (!this.hasValue()) {
          return 0;
        }
        switch (true) {
          case this.isString(/deg$/):
            return this.getNumber() * (Math.PI / 180);
          case this.isString(/grad$/):
            return this.getNumber() * (Math.PI / 200);
          case this.isString(/rad$/):
            return this.getNumber();
          default:
            return this.getNumber() * (Math.PI / 180);
        }
      }
      getDefinition() {
        var asString = this.getString();
        var name = /#([^)'"]+)/.exec(asString);
        if (name) {
          name = name[1];
        }
        if (!name) {
          name = asString;
        }
        return this.document.definitions[name];
      }
      getFillStyleDefinition(element, opacity) {
        var def = this.getDefinition();
        if (!def) {
          return null;
        }
        if (typeof def.createGradient === "function") {
          return def.createGradient(this.document.ctx, element, opacity);
        }
        if (typeof def.createPattern === "function") {
          if (def.getHrefAttribute().hasValue()) {
            var patternTransform = def.getAttribute("patternTransform");
            def = def.getHrefAttribute().getDefinition();
            if (patternTransform.hasValue()) {
              def.getAttribute("patternTransform", true).setValue(patternTransform.value);
            }
          }
          return def.createPattern(this.document.ctx, element, opacity);
        }
        return null;
      }
      getTextBaseline() {
        if (!this.hasValue()) {
          return null;
        }
        return Property.textBaselineMapping[this.getString()];
      }
      addOpacity(opacity) {
        var value = this.getColor();
        var len = value.length;
        var commas = 0;
        for (var i3 = 0; i3 < len; i3++) {
          if (value[i3] === ",") {
            commas++;
          }
          if (commas === 3) {
            break;
          }
        }
        if (opacity.hasValue() && this.isString() && commas !== 3) {
          var color = new import_rgbcolor.default(value);
          if (color.ok) {
            color.alpha = opacity.getNumber();
            value = color.toRGBA();
          }
        }
        return new Property(this.document, this.name, value);
      }
    };
    Property.textBaselineMapping = {
      "baseline": "alphabetic",
      "before-edge": "top",
      "text-before-edge": "top",
      "middle": "middle",
      "central": "middle",
      "after-edge": "bottom",
      "text-after-edge": "bottom",
      "ideographic": "ideographic",
      "alphabetic": "alphabetic",
      "hanging": "hanging",
      "mathematical": "alphabetic"
    };
    ViewPort = class {
      constructor() {
        this.viewPorts = [];
      }
      clear() {
        this.viewPorts = [];
      }
      setCurrent(width, height) {
        this.viewPorts.push({
          width,
          height
        });
      }
      removeCurrent() {
        this.viewPorts.pop();
      }
      getCurrent() {
        var {
          viewPorts
        } = this;
        return viewPorts[viewPorts.length - 1];
      }
      get width() {
        return this.getCurrent().width;
      }
      get height() {
        return this.getCurrent().height;
      }
      computeSize(d2) {
        if (typeof d2 === "number") {
          return d2;
        }
        if (d2 === "x") {
          return this.width;
        }
        if (d2 === "y") {
          return this.height;
        }
        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
      }
    };
    Point = class {
      constructor(x2, y3) {
        this.x = x2;
        this.y = y3;
      }
      static parse(point) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var [x2 = defaultValue, y3 = defaultValue] = toNumbers(point);
        return new Point(x2, y3);
      }
      static parseScale(scale) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var [x2 = defaultValue, y3 = x2] = toNumbers(scale);
        return new Point(x2, y3);
      }
      static parsePath(path) {
        var points2 = toNumbers(path);
        var len = points2.length;
        var pathPoints = [];
        for (var i3 = 0; i3 < len; i3 += 2) {
          pathPoints.push(new Point(points2[i3], points2[i3 + 1]));
        }
        return pathPoints;
      }
      angleTo(point) {
        return Math.atan2(point.y - this.y, point.x - this.x);
      }
      applyTransform(transform) {
        var {
          x: x2,
          y: y3
        } = this;
        var xp = x2 * transform[0] + y3 * transform[2] + transform[4];
        var yp = x2 * transform[1] + y3 * transform[3] + transform[5];
        this.x = xp;
        this.y = yp;
      }
    };
    Mouse = class {
      constructor(screen) {
        this.screen = screen;
        this.working = false;
        this.events = [];
        this.eventElements = [];
        this.onClick = this.onClick.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
      }
      isWorking() {
        return this.working;
      }
      start() {
        if (this.working) {
          return;
        }
        var {
          screen,
          onClick,
          onMouseMove
        } = this;
        var canvas = screen.ctx.canvas;
        canvas.onclick = onClick;
        canvas.onmousemove = onMouseMove;
        this.working = true;
      }
      stop() {
        if (!this.working) {
          return;
        }
        var canvas = this.screen.ctx.canvas;
        this.working = false;
        canvas.onclick = null;
        canvas.onmousemove = null;
      }
      hasEvents() {
        return this.working && this.events.length > 0;
      }
      runEvents() {
        if (!this.working) {
          return;
        }
        var {
          screen: document2,
          events,
          eventElements
        } = this;
        var {
          style
        } = document2.ctx.canvas;
        if (style) {
          style.cursor = "";
        }
        events.forEach((_ref, i3) => {
          var {
            run: run2
          } = _ref;
          var element = eventElements[i3];
          while (element) {
            run2(element);
            element = element.parent;
          }
        });
        this.events = [];
        this.eventElements = [];
      }
      checkPath(element, ctx) {
        if (!this.working || !ctx) {
          return;
        }
        var {
          events,
          eventElements
        } = this;
        events.forEach((_ref2, i3) => {
          var {
            x: x2,
            y: y3
          } = _ref2;
          if (!eventElements[i3] && ctx.isPointInPath && ctx.isPointInPath(x2, y3)) {
            eventElements[i3] = element;
          }
        });
      }
      checkBoundingBox(element, boundingBox) {
        if (!this.working || !boundingBox) {
          return;
        }
        var {
          events,
          eventElements
        } = this;
        events.forEach((_ref3, i3) => {
          var {
            x: x2,
            y: y3
          } = _ref3;
          if (!eventElements[i3] && boundingBox.isPointInBox(x2, y3)) {
            eventElements[i3] = element;
          }
        });
      }
      mapXY(x2, y3) {
        var {
          window: window2,
          ctx
        } = this.screen;
        var point = new Point(x2, y3);
        var element = ctx.canvas;
        while (element) {
          point.x -= element.offsetLeft;
          point.y -= element.offsetTop;
          element = element.offsetParent;
        }
        if (window2.scrollX) {
          point.x += window2.scrollX;
        }
        if (window2.scrollY) {
          point.y += window2.scrollY;
        }
        return point;
      }
      onClick(event) {
        var {
          x: x2,
          y: y3
        } = this.mapXY(event.clientX, event.clientY);
        this.events.push({
          type: "onclick",
          x: x2,
          y: y3,
          run(eventTarget) {
            if (eventTarget.onClick) {
              eventTarget.onClick();
            }
          }
        });
      }
      onMouseMove(event) {
        var {
          x: x2,
          y: y3
        } = this.mapXY(event.clientX, event.clientY);
        this.events.push({
          type: "onmousemove",
          x: x2,
          y: y3,
          run(eventTarget) {
            if (eventTarget.onMouseMove) {
              eventTarget.onMouseMove();
            }
          }
        });
      }
    };
    defaultWindow = typeof window !== "undefined" ? window : null;
    defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
    Screen = class {
      constructor(ctx) {
        var {
          fetch: fetch2 = defaultFetch$1,
          window: window2 = defaultWindow
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.ctx = ctx;
        this.FRAMERATE = 30;
        this.MAX_VIRTUAL_PIXELS = 3e4;
        this.CLIENT_WIDTH = 800;
        this.CLIENT_HEIGHT = 600;
        this.viewPort = new ViewPort();
        this.mouse = new Mouse(this);
        this.animations = [];
        this.waits = [];
        this.frameDuration = 0;
        this.isReadyLock = false;
        this.isFirstRender = true;
        this.intervalId = null;
        this.window = window2;
        this.fetch = fetch2;
      }
      wait(checker) {
        this.waits.push(checker);
      }
      ready() {
        if (!this.readyPromise) {
          return Promise.resolve();
        }
        return this.readyPromise;
      }
      isReady() {
        if (this.isReadyLock) {
          return true;
        }
        var isReadyLock = this.waits.every((_3) => _3());
        if (isReadyLock) {
          this.waits = [];
          if (this.resolveReady) {
            this.resolveReady();
          }
        }
        this.isReadyLock = isReadyLock;
        return isReadyLock;
      }
      setDefaults(ctx) {
        ctx.strokeStyle = "rgba(0,0,0,0)";
        ctx.lineCap = "butt";
        ctx.lineJoin = "miter";
        ctx.miterLimit = 4;
      }
      setViewBox(_ref) {
        var {
          document: document2,
          ctx,
          aspectRatio,
          width,
          desiredWidth,
          height,
          desiredHeight,
          minX = 0,
          minY = 0,
          refX,
          refY,
          clip = false,
          clipX = 0,
          clipY = 0
        } = _ref;
        var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
        var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
        var align = aspectRatioAlign || "xMidYMid";
        var meetOrSlice = aspectRatioMeetOrSlice || "meet";
        var scaleX = width / desiredWidth;
        var scaleY = height / desiredHeight;
        var scaleMin = Math.min(scaleX, scaleY);
        var scaleMax = Math.max(scaleX, scaleY);
        var finalDesiredWidth = desiredWidth;
        var finalDesiredHeight = desiredHeight;
        if (meetOrSlice === "meet") {
          finalDesiredWidth *= scaleMin;
          finalDesiredHeight *= scaleMin;
        }
        if (meetOrSlice === "slice") {
          finalDesiredWidth *= scaleMax;
          finalDesiredHeight *= scaleMax;
        }
        var refXProp = new Property(document2, "refX", refX);
        var refYProp = new Property(document2, "refY", refY);
        var hasRefs = refXProp.hasValue() && refYProp.hasValue();
        if (hasRefs) {
          ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
        }
        if (clip) {
          var scaledClipX = scaleMin * clipX;
          var scaledClipY = scaleMin * clipY;
          ctx.beginPath();
          ctx.moveTo(scaledClipX, scaledClipY);
          ctx.lineTo(width, scaledClipY);
          ctx.lineTo(width, height);
          ctx.lineTo(scaledClipX, height);
          ctx.closePath();
          ctx.clip();
        }
        if (!hasRefs) {
          var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
          var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
          var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
          var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
          if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
            ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
          }
          if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
            ctx.translate(0, height / 2 - finalDesiredHeight / 2);
          }
          if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
            ctx.translate(width - finalDesiredWidth, 0);
          }
          if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
            ctx.translate(0, height - finalDesiredHeight);
          }
        }
        switch (true) {
          case align === "none":
            ctx.scale(scaleX, scaleY);
            break;
          case meetOrSlice === "meet":
            ctx.scale(scaleMin, scaleMin);
            break;
          case meetOrSlice === "slice":
            ctx.scale(scaleMax, scaleMax);
            break;
        }
        ctx.translate(-minX, -minY);
      }
      start(element) {
        var {
          enableRedraw = false,
          ignoreMouse = false,
          ignoreAnimation = false,
          ignoreDimensions = false,
          ignoreClear = false,
          forceRedraw,
          scaleWidth,
          scaleHeight,
          offsetX,
          offsetY
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var {
          FRAMERATE,
          mouse
        } = this;
        var frameDuration = 1e3 / FRAMERATE;
        this.frameDuration = frameDuration;
        this.readyPromise = new Promise((resolve2) => {
          this.resolveReady = resolve2;
        });
        if (this.isReady()) {
          this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
        }
        if (!enableRedraw) {
          return;
        }
        var now = Date.now();
        var then = now;
        var delta = 0;
        var tick = () => {
          now = Date.now();
          delta = now - then;
          if (delta >= frameDuration) {
            then = now - delta % frameDuration;
            if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
              this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
              mouse.runEvents();
            }
          }
          this.intervalId = (0, import_raf.default)(tick);
        };
        if (!ignoreMouse) {
          mouse.start();
        }
        this.intervalId = (0, import_raf.default)(tick);
      }
      stop() {
        if (this.intervalId) {
          import_raf.default.cancel(this.intervalId);
          this.intervalId = null;
        }
        this.mouse.stop();
      }
      shouldUpdate(ignoreAnimation, forceRedraw) {
        if (!ignoreAnimation) {
          var {
            frameDuration
          } = this;
          var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
          if (shouldUpdate) {
            return true;
          }
        }
        if (typeof forceRedraw === "function" && forceRedraw()) {
          return true;
        }
        if (!this.isReadyLock && this.isReady()) {
          return true;
        }
        if (this.mouse.hasEvents()) {
          return true;
        }
        return false;
      }
      render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
        var {
          CLIENT_WIDTH,
          CLIENT_HEIGHT,
          viewPort,
          ctx,
          isFirstRender
        } = this;
        var canvas = ctx.canvas;
        viewPort.clear();
        if (canvas.width && canvas.height) {
          viewPort.setCurrent(canvas.width, canvas.height);
        } else {
          viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
        }
        var widthStyle = element.getStyle("width");
        var heightStyle = element.getStyle("height");
        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
          if (widthStyle.hasValue()) {
            canvas.width = widthStyle.getPixels("x");
            if (canvas.style) {
              canvas.style.width = "".concat(canvas.width, "px");
            }
          }
          if (heightStyle.hasValue()) {
            canvas.height = heightStyle.getPixels("y");
            if (canvas.style) {
              canvas.style.height = "".concat(canvas.height, "px");
            }
          }
        }
        var cWidth = canvas.clientWidth || canvas.width;
        var cHeight = canvas.clientHeight || canvas.height;
        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
          cWidth = widthStyle.getPixels("x");
          cHeight = heightStyle.getPixels("y");
        }
        viewPort.setCurrent(cWidth, cHeight);
        if (typeof offsetX === "number") {
          element.getAttribute("x", true).setValue(offsetX);
        }
        if (typeof offsetY === "number") {
          element.getAttribute("y", true).setValue(offsetY);
        }
        if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
          var viewBox = toNumbers(element.getAttribute("viewBox").getString());
          var xRatio = 0;
          var yRatio = 0;
          if (typeof scaleWidth === "number") {
            var _widthStyle = element.getStyle("width");
            if (_widthStyle.hasValue()) {
              xRatio = _widthStyle.getPixels("x") / scaleWidth;
            } else if (!isNaN(viewBox[2])) {
              xRatio = viewBox[2] / scaleWidth;
            }
          }
          if (typeof scaleHeight === "number") {
            var _heightStyle = element.getStyle("height");
            if (_heightStyle.hasValue()) {
              yRatio = _heightStyle.getPixels("y") / scaleHeight;
            } else if (!isNaN(viewBox[3])) {
              yRatio = viewBox[3] / scaleHeight;
            }
          }
          if (!xRatio) {
            xRatio = yRatio;
          }
          if (!yRatio) {
            yRatio = xRatio;
          }
          element.getAttribute("width", true).setValue(scaleWidth);
          element.getAttribute("height", true).setValue(scaleHeight);
          var transformStyle = element.getStyle("transform", true, true);
          transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
        }
        if (!ignoreClear) {
          ctx.clearRect(0, 0, cWidth, cHeight);
        }
        element.render(ctx);
        if (isFirstRender) {
          this.isFirstRender = false;
        }
      }
    };
    Screen.defaultWindow = defaultWindow;
    Screen.defaultFetch = defaultFetch$1;
    ({
      defaultFetch
    } = Screen);
    DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
    Parser = class {
      constructor() {
        var {
          fetch: fetch2 = defaultFetch,
          DOMParser: DOMParser2 = DefaultDOMParser
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.fetch = fetch2;
        this.DOMParser = DOMParser2;
      }
      parse(resource) {
        var _this = this;
        return _asyncToGenerator(function* () {
          if (resource.startsWith("<")) {
            return _this.parseFromString(resource);
          }
          return _this.load(resource);
        })();
      }
      parseFromString(xml) {
        var parser = new this.DOMParser();
        try {
          return this.checkDocument(parser.parseFromString(xml, "image/svg+xml"));
        } catch (err3) {
          return this.checkDocument(parser.parseFromString(xml, "text/xml"));
        }
      }
      checkDocument(document2) {
        var parserError = document2.getElementsByTagName("parsererror")[0];
        if (parserError) {
          throw new Error(parserError.textContent);
        }
        return document2;
      }
      load(url) {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          var response = yield _this2.fetch(url);
          var xml = yield response.text();
          return _this2.parseFromString(xml);
        })();
      }
    };
    Translate = class {
      constructor(_3, point) {
        this.type = "translate";
        this.point = null;
        this.point = Point.parse(point);
      }
      apply(ctx) {
        var {
          x: x2,
          y: y3
        } = this.point;
        ctx.translate(x2 || 0, y3 || 0);
      }
      unapply(ctx) {
        var {
          x: x2,
          y: y3
        } = this.point;
        ctx.translate(-1 * x2 || 0, -1 * y3 || 0);
      }
      applyToPoint(point) {
        var {
          x: x2,
          y: y3
        } = this.point;
        point.applyTransform([1, 0, 0, 1, x2 || 0, y3 || 0]);
      }
    };
    Rotate = class {
      constructor(document2, rotate3, transformOrigin) {
        this.type = "rotate";
        this.angle = null;
        this.originX = null;
        this.originY = null;
        this.cx = 0;
        this.cy = 0;
        var numbers = toNumbers(rotate3);
        this.angle = new Property(document2, "angle", numbers[0]);
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
        this.cx = numbers[1] || 0;
        this.cy = numbers[2] || 0;
      }
      apply(ctx) {
        var {
          cx,
          cy,
          originX,
          originY,
          angle
        } = this;
        var tx = cx + originX.getPixels("x");
        var ty = cy + originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.rotate(angle.getRadians());
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          cx,
          cy,
          originX,
          originY,
          angle
        } = this;
        var tx = cx + originX.getPixels("x");
        var ty = cy + originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.rotate(-1 * angle.getRadians());
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point) {
        var {
          cx,
          cy,
          angle
        } = this;
        var rad = angle.getRadians();
        point.applyTransform([
          1,
          0,
          0,
          1,
          cx || 0,
          cy || 0
          // this.p.y
        ]);
        point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
        point.applyTransform([
          1,
          0,
          0,
          1,
          -cx || 0,
          -cy || 0
          // -this.p.y
        ]);
      }
    };
    Scale = class {
      constructor(_3, scale, transformOrigin) {
        this.type = "scale";
        this.scale = null;
        this.originX = null;
        this.originY = null;
        var scaleSize = Point.parseScale(scale);
        if (scaleSize.x === 0 || scaleSize.y === 0) {
          scaleSize.x = PSEUDO_ZERO;
          scaleSize.y = PSEUDO_ZERO;
        }
        this.scale = scaleSize;
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
      }
      apply(ctx) {
        var {
          scale: {
            x: x2,
            y: y3
          },
          originX,
          originY
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.scale(x2, y3 || x2);
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          scale: {
            x: x2,
            y: y3
          },
          originX,
          originY
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.scale(1 / x2, 1 / y3 || x2);
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point) {
        var {
          x: x2,
          y: y3
        } = this.scale;
        point.applyTransform([x2 || 0, 0, 0, y3 || 0, 0, 0]);
      }
    };
    Matrix4 = class {
      constructor(_3, matrix2, transformOrigin) {
        this.type = "matrix";
        this.matrix = [];
        this.originX = null;
        this.originY = null;
        this.matrix = toNumbers(matrix2);
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
      }
      apply(ctx) {
        var {
          originX,
          originY,
          matrix: matrix2
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.transform(matrix2[0], matrix2[1], matrix2[2], matrix2[3], matrix2[4], matrix2[5]);
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          originX,
          originY,
          matrix: matrix2
        } = this;
        var a3 = matrix2[0];
        var b2 = matrix2[2];
        var c4 = matrix2[4];
        var d2 = matrix2[1];
        var e2 = matrix2[3];
        var f3 = matrix2[5];
        var g2 = 0;
        var h3 = 0;
        var i3 = 1;
        var det = 1 / (a3 * (e2 * i3 - f3 * h3) - b2 * (d2 * i3 - f3 * g2) + c4 * (d2 * h3 - e2 * g2));
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.transform(det * (e2 * i3 - f3 * h3), det * (f3 * g2 - d2 * i3), det * (c4 * h3 - b2 * i3), det * (a3 * i3 - c4 * g2), det * (b2 * f3 - c4 * e2), det * (c4 * d2 - a3 * f3));
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point) {
        point.applyTransform(this.matrix);
      }
    };
    Skew = class extends Matrix4 {
      constructor(document2, skew, transformOrigin) {
        super(document2, skew, transformOrigin);
        this.type = "skew";
        this.angle = null;
        this.angle = new Property(document2, "angle", skew);
      }
    };
    SkewX = class extends Skew {
      constructor(document2, skew, transformOrigin) {
        super(document2, skew, transformOrigin);
        this.type = "skewX";
        this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
      }
    };
    SkewY = class extends Skew {
      constructor(document2, skew, transformOrigin) {
        super(document2, skew, transformOrigin);
        this.type = "skewY";
        this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
      }
    };
    Transform = class {
      constructor(document2, transform, transformOrigin) {
        this.document = document2;
        this.transforms = [];
        var data = parseTransforms(transform);
        data.forEach((transform2) => {
          if (transform2 === "none") {
            return;
          }
          var [type, value] = parseTransform(transform2);
          var TransformType = Transform.transformTypes[type];
          if (typeof TransformType !== "undefined") {
            this.transforms.push(new TransformType(this.document, value, transformOrigin));
          }
        });
      }
      static fromElement(document2, element) {
        var transformStyle = element.getStyle("transform", false, true);
        var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle("transform-origin", false, true).split();
        var transformOrigin = [transformOriginXProperty, transformOriginYProperty];
        if (transformStyle.hasValue()) {
          return new Transform(document2, transformStyle.getString(), transformOrigin);
        }
        return null;
      }
      apply(ctx) {
        var {
          transforms
        } = this;
        var len = transforms.length;
        for (var i3 = 0; i3 < len; i3++) {
          transforms[i3].apply(ctx);
        }
      }
      unapply(ctx) {
        var {
          transforms
        } = this;
        var len = transforms.length;
        for (var i3 = len - 1; i3 >= 0; i3--) {
          transforms[i3].unapply(ctx);
        }
      }
      // TODO: applyToPoint unused ... remove?
      applyToPoint(point) {
        var {
          transforms
        } = this;
        var len = transforms.length;
        for (var i3 = 0; i3 < len; i3++) {
          transforms[i3].applyToPoint(point);
        }
      }
    };
    Transform.transformTypes = {
      translate: Translate,
      rotate: Rotate,
      scale: Scale,
      matrix: Matrix4,
      skewX: SkewX,
      skewY: SkewY
    };
    Element = class {
      constructor(document2, node2) {
        var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.document = document2;
        this.node = node2;
        this.captureTextNodes = captureTextNodes;
        this.attributes = {};
        this.styles = {};
        this.stylesSpecificity = {};
        this.animationFrozen = false;
        this.animationFrozenValue = "";
        this.parent = null;
        this.children = [];
        if (!node2 || node2.nodeType !== 1) {
          return;
        }
        Array.from(node2.attributes).forEach((attribute) => {
          var nodeName = normalizeAttributeName(attribute.nodeName);
          this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
        });
        this.addStylesFromStyleDefinition();
        if (this.getAttribute("style").hasValue()) {
          var styles = this.getAttribute("style").getString().split(";").map((_3) => _3.trim());
          styles.forEach((style) => {
            if (!style) {
              return;
            }
            var [name, value] = style.split(":").map((_3) => _3.trim());
            this.styles[name] = new Property(document2, name, value);
          });
        }
        var {
          definitions
        } = document2;
        var id = this.getAttribute("id");
        if (id.hasValue()) {
          if (!definitions[id.getString()]) {
            definitions[id.getString()] = this;
          }
        }
        Array.from(node2.childNodes).forEach((childNode) => {
          if (childNode.nodeType === 1) {
            this.addChild(childNode);
          } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
            var textNode = document2.createTextNode(childNode);
            if (textNode.getText().length > 0) {
              this.addChild(textNode);
            }
          }
        });
      }
      getAttribute(name) {
        var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var attr = this.attributes[name];
        if (!attr && createIfNotExists) {
          var _attr = new Property(this.document, name, "");
          this.attributes[name] = _attr;
          return _attr;
        }
        return attr || Property.empty(this.document);
      }
      getHrefAttribute() {
        for (var key in this.attributes) {
          if (key === "href" || key.endsWith(":href")) {
            return this.attributes[key];
          }
        }
        return Property.empty(this.document);
      }
      getStyle(name) {
        var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var style = this.styles[name];
        if (style) {
          return style;
        }
        var attr = this.getAttribute(name);
        if (attr !== null && attr !== void 0 && attr.hasValue()) {
          this.styles[name] = attr;
          return attr;
        }
        if (!skipAncestors) {
          var {
            parent
          } = this;
          if (parent) {
            var parentStyle = parent.getStyle(name);
            if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
              return parentStyle;
            }
          }
        }
        if (createIfNotExists) {
          var _style = new Property(this.document, name, "");
          this.styles[name] = _style;
          return _style;
        }
        return style || Property.empty(this.document);
      }
      render(ctx) {
        if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
          return;
        }
        ctx.save();
        if (this.getStyle("mask").hasValue()) {
          var mask2 = this.getStyle("mask").getDefinition();
          if (mask2) {
            this.applyEffects(ctx);
            mask2.apply(ctx, this);
          }
        } else if (this.getStyle("filter").getValue("none") !== "none") {
          var filter = this.getStyle("filter").getDefinition();
          if (filter) {
            this.applyEffects(ctx);
            filter.apply(ctx, this);
          }
        } else {
          this.setContext(ctx);
          this.renderChildren(ctx);
          this.clearContext(ctx);
        }
        ctx.restore();
      }
      setContext(_3) {
      }
      applyEffects(ctx) {
        var transform = Transform.fromElement(this.document, this);
        if (transform) {
          transform.apply(ctx);
        }
        var clipPathStyleProp = this.getStyle("clip-path", false, true);
        if (clipPathStyleProp.hasValue()) {
          var clip = clipPathStyleProp.getDefinition();
          if (clip) {
            clip.apply(ctx);
          }
        }
      }
      clearContext(_3) {
      }
      renderChildren(ctx) {
        this.children.forEach((child) => {
          child.render(ctx);
        });
      }
      addChild(childNode) {
        var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);
        child.parent = this;
        if (!Element.ignoreChildTypes.includes(child.type)) {
          this.children.push(child);
        }
      }
      matchesSelector(selector) {
        var _node$getAttribute;
        var {
          node: node2
        } = this;
        if (typeof node2.matches === "function") {
          return node2.matches(selector);
        }
        var styleClasses = (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "class");
        if (!styleClasses || styleClasses === "") {
          return false;
        }
        return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
      }
      addStylesFromStyleDefinition() {
        var {
          styles,
          stylesSpecificity
        } = this.document;
        for (var selector in styles) {
          if (!selector.startsWith("@") && this.matchesSelector(selector)) {
            var style = styles[selector];
            var specificity = stylesSpecificity[selector];
            if (style) {
              for (var name in style) {
                var existingSpecificity = this.stylesSpecificity[name];
                if (typeof existingSpecificity === "undefined") {
                  existingSpecificity = "000";
                }
                if (specificity >= existingSpecificity) {
                  this.styles[name] = style[name];
                  this.stylesSpecificity[name] = specificity;
                }
              }
            }
          }
        }
      }
      removeStyles(element, ignoreStyles) {
        var toRestore = ignoreStyles.reduce((toRestore2, name) => {
          var styleProp = element.getStyle(name);
          if (!styleProp.hasValue()) {
            return toRestore2;
          }
          var value = styleProp.getString();
          styleProp.setValue("");
          return [...toRestore2, [name, value]];
        }, []);
        return toRestore;
      }
      restoreStyles(element, styles) {
        styles.forEach((_ref) => {
          var [name, value] = _ref;
          element.getStyle(name, true).setValue(value);
        });
      }
      isFirstChild() {
        var _this$parent;
        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
      }
    };
    Element.ignoreChildTypes = ["title"];
    UnknownElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
      }
    };
    Font = class {
      constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
        var inheritFont = inherit ? typeof inherit === "string" ? Font.parse(inherit) : inherit : {};
        this.fontFamily = fontFamily || inheritFont.fontFamily;
        this.fontSize = fontSize || inheritFont.fontSize;
        this.fontStyle = fontStyle || inheritFont.fontStyle;
        this.fontWeight = fontWeight || inheritFont.fontWeight;
        this.fontVariant = fontVariant || inheritFont.fontVariant;
      }
      static parse() {
        var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var inherit = arguments.length > 1 ? arguments[1] : void 0;
        var fontStyle = "";
        var fontVariant = "";
        var fontWeight = "";
        var fontSize = "";
        var fontFamily = "";
        var parts = compressSpaces(font).trim().split(" ");
        var set = {
          fontSize: false,
          fontStyle: false,
          fontWeight: false,
          fontVariant: false
        };
        parts.forEach((part) => {
          switch (true) {
            case (!set.fontStyle && Font.styles.includes(part)):
              if (part !== "inherit") {
                fontStyle = part;
              }
              set.fontStyle = true;
              break;
            case (!set.fontVariant && Font.variants.includes(part)):
              if (part !== "inherit") {
                fontVariant = part;
              }
              set.fontStyle = true;
              set.fontVariant = true;
              break;
            case (!set.fontWeight && Font.weights.includes(part)):
              if (part !== "inherit") {
                fontWeight = part;
              }
              set.fontStyle = true;
              set.fontVariant = true;
              set.fontWeight = true;
              break;
            case !set.fontSize:
              if (part !== "inherit") {
                [fontSize] = part.split("/");
              }
              set.fontStyle = true;
              set.fontVariant = true;
              set.fontWeight = true;
              set.fontSize = true;
              break;
            default:
              if (part !== "inherit") {
                fontFamily += part;
              }
          }
        });
        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);
      }
      toString() {
        return [
          prepareFontStyle(this.fontStyle),
          this.fontVariant,
          prepareFontWeight(this.fontWeight),
          this.fontSize,
          // Wrap fontFamily only on nodejs and only for canvas.ctx
          prepareFontFamily(this.fontFamily)
        ].join(" ").trim();
      }
    };
    Font.styles = "normal|italic|oblique|inherit";
    Font.variants = "normal|small-caps|inherit";
    Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
    BoundingBox = class {
      constructor() {
        var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
        var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
        var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
        var y22 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y22;
        this.addPoint(x1, y1);
        this.addPoint(x2, y22);
      }
      get x() {
        return this.x1;
      }
      get y() {
        return this.y1;
      }
      get width() {
        return this.x2 - this.x1;
      }
      get height() {
        return this.y2 - this.y1;
      }
      addPoint(x2, y3) {
        if (typeof x2 !== "undefined") {
          if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x2;
            this.x2 = x2;
          }
          if (x2 < this.x1) {
            this.x1 = x2;
          }
          if (x2 > this.x2) {
            this.x2 = x2;
          }
        }
        if (typeof y3 !== "undefined") {
          if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y3;
            this.y2 = y3;
          }
          if (y3 < this.y1) {
            this.y1 = y3;
          }
          if (y3 > this.y2) {
            this.y2 = y3;
          }
        }
      }
      addX(x2) {
        this.addPoint(x2, null);
      }
      addY(y3) {
        this.addPoint(null, y3);
      }
      addBoundingBox(boundingBox) {
        if (!boundingBox) {
          return;
        }
        var {
          x1,
          y1,
          x2,
          y2: y22
        } = boundingBox;
        this.addPoint(x1, y1);
        this.addPoint(x2, y22);
      }
      sumCubic(t3, p0, p1, p22, p3) {
        return Math.pow(1 - t3, 3) * p0 + 3 * Math.pow(1 - t3, 2) * t3 * p1 + 3 * (1 - t3) * Math.pow(t3, 2) * p22 + Math.pow(t3, 3) * p3;
      }
      bezierCurveAdd(forX, p0, p1, p22, p3) {
        var b2 = 6 * p0 - 12 * p1 + 6 * p22;
        var a3 = -3 * p0 + 9 * p1 - 9 * p22 + 3 * p3;
        var c4 = 3 * p1 - 3 * p0;
        if (a3 === 0) {
          if (b2 === 0) {
            return;
          }
          var t3 = -c4 / b2;
          if (0 < t3 && t3 < 1) {
            if (forX) {
              this.addX(this.sumCubic(t3, p0, p1, p22, p3));
            } else {
              this.addY(this.sumCubic(t3, p0, p1, p22, p3));
            }
          }
          return;
        }
        var b2ac = Math.pow(b2, 2) - 4 * c4 * a3;
        if (b2ac < 0) {
          return;
        }
        var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a3);
        if (0 < t1 && t1 < 1) {
          if (forX) {
            this.addX(this.sumCubic(t1, p0, p1, p22, p3));
          } else {
            this.addY(this.sumCubic(t1, p0, p1, p22, p3));
          }
        }
        var t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a3);
        if (0 < t22 && t22 < 1) {
          if (forX) {
            this.addX(this.sumCubic(t22, p0, p1, p22, p3));
          } else {
            this.addY(this.sumCubic(t22, p0, p1, p22, p3));
          }
        }
      }
      // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
      addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
        this.addPoint(p0x, p0y);
        this.addPoint(p3x, p3y);
        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
      }
      addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
        var cp1x = p0x + 2 / 3 * (p1x - p0x);
        var cp1y = p0y + 2 / 3 * (p1y - p0y);
        var cp2x = cp1x + 1 / 3 * (p2x - p0x);
        var cp2y = cp1y + 1 / 3 * (p2y - p0y);
        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
      }
      isPointInBox(x2, y3) {
        var {
          x1,
          y1,
          x2: x22,
          y2: y22
        } = this;
        return x1 <= x2 && x2 <= x22 && y1 <= y3 && y3 <= y22;
      }
    };
    PathParser = class extends _ {
      constructor(path) {
        super(path.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
        this.control = null;
        this.start = null;
        this.current = null;
        this.command = null;
        this.commands = this.commands;
        this.i = -1;
        this.previousCommand = null;
        this.points = [];
        this.angles = [];
      }
      reset() {
        this.i = -1;
        this.command = null;
        this.previousCommand = null;
        this.start = new Point(0, 0);
        this.control = new Point(0, 0);
        this.current = new Point(0, 0);
        this.points = [];
        this.angles = [];
      }
      isEnd() {
        var {
          i: i3,
          commands
        } = this;
        return i3 >= commands.length - 1;
      }
      next() {
        var command = this.commands[++this.i];
        this.previousCommand = this.command;
        this.command = command;
        return command;
      }
      getPoint() {
        var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
        var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
        var point = new Point(this.command[xProp], this.command[yProp]);
        return this.makeAbsolute(point);
      }
      getAsControlPoint(xProp, yProp) {
        var point = this.getPoint(xProp, yProp);
        this.control = point;
        return point;
      }
      getAsCurrentPoint(xProp, yProp) {
        var point = this.getPoint(xProp, yProp);
        this.current = point;
        return point;
      }
      getReflectedControlPoint() {
        var previousCommand = this.previousCommand.type;
        if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
          return this.current;
        }
        var {
          current: {
            x: cx,
            y: cy
          },
          control: {
            x: ox,
            y: oy
          }
        } = this;
        var point = new Point(2 * cx - ox, 2 * cy - oy);
        return point;
      }
      makeAbsolute(point) {
        if (this.command.relative) {
          var {
            x: x2,
            y: y3
          } = this.current;
          point.x += x2;
          point.y += y3;
        }
        return point;
      }
      addMarker(point, from, priorTo) {
        var {
          points: points2,
          angles
        } = this;
        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
          angles[angles.length - 1] = points2[points2.length - 1].angleTo(priorTo);
        }
        this.addMarkerAngle(point, from ? from.angleTo(point) : null);
      }
      addMarkerAngle(point, angle) {
        this.points.push(point);
        this.angles.push(angle);
      }
      getMarkerPoints() {
        return this.points;
      }
      getMarkerAngles() {
        var {
          angles
        } = this;
        var len = angles.length;
        for (var i3 = 0; i3 < len; i3++) {
          if (!angles[i3]) {
            for (var j2 = i3 + 1; j2 < len; j2++) {
              if (angles[j2]) {
                angles[i3] = angles[j2];
                break;
              }
            }
          }
        }
        return angles;
      }
    };
    RenderedElement = class extends Element {
      constructor() {
        super(...arguments);
        this.modifiedEmSizeStack = false;
      }
      calculateOpacity() {
        var opacity = 1;
        var element = this;
        while (element) {
          var opacityStyle = element.getStyle("opacity", false, true);
          if (opacityStyle.hasValue(true)) {
            opacity *= opacityStyle.getNumber();
          }
          element = element.parent;
        }
        return opacity;
      }
      setContext(ctx) {
        var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!fromMeasure) {
          var fillStyleProp = this.getStyle("fill");
          var fillOpacityStyleProp = this.getStyle("fill-opacity");
          var strokeStyleProp = this.getStyle("stroke");
          var strokeOpacityProp = this.getStyle("stroke-opacity");
          if (fillStyleProp.isUrlDefinition()) {
            var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
            if (fillStyle) {
              ctx.fillStyle = fillStyle;
            }
          } else if (fillStyleProp.hasValue()) {
            if (fillStyleProp.getString() === "currentColor") {
              fillStyleProp.setValue(this.getStyle("color").getColor());
            }
            var _fillStyle = fillStyleProp.getColor();
            if (_fillStyle !== "inherit") {
              ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
            }
          }
          if (fillOpacityStyleProp.hasValue()) {
            var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
            ctx.fillStyle = _fillStyle2;
          }
          if (strokeStyleProp.isUrlDefinition()) {
            var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
            if (strokeStyle) {
              ctx.strokeStyle = strokeStyle;
            }
          } else if (strokeStyleProp.hasValue()) {
            if (strokeStyleProp.getString() === "currentColor") {
              strokeStyleProp.setValue(this.getStyle("color").getColor());
            }
            var _strokeStyle = strokeStyleProp.getString();
            if (_strokeStyle !== "inherit") {
              ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
            }
          }
          if (strokeOpacityProp.hasValue()) {
            var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
            ctx.strokeStyle = _strokeStyle2;
          }
          var strokeWidthStyleProp = this.getStyle("stroke-width");
          if (strokeWidthStyleProp.hasValue()) {
            var newLineWidth = strokeWidthStyleProp.getPixels();
            ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
          }
          var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
          var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
          var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
          var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
          var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
          if (strokeLinecapStyleProp.hasValue()) {
            ctx.lineCap = strokeLinecapStyleProp.getString();
          }
          if (strokeLinejoinStyleProp.hasValue()) {
            ctx.lineJoin = strokeLinejoinStyleProp.getString();
          }
          if (strokeMiterlimitProp.hasValue()) {
            ctx.miterLimit = strokeMiterlimitProp.getNumber();
          }
          if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
            var gaps = toNumbers(strokeDasharrayStyleProp.getString());
            if (typeof ctx.setLineDash !== "undefined") {
              ctx.setLineDash(gaps);
            } else if (typeof ctx.webkitLineDash !== "undefined") {
              ctx.webkitLineDash = gaps;
            } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
              ctx.mozDash = gaps;
            }
            var offset = strokeDashoffsetProp.getPixels();
            if (typeof ctx.lineDashOffset !== "undefined") {
              ctx.lineDashOffset = offset;
            } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
              ctx.webkitLineDashOffset = offset;
            } else if (typeof ctx.mozDashOffset !== "undefined") {
              ctx.mozDashOffset = offset;
            }
          }
        }
        this.modifiedEmSizeStack = false;
        if (typeof ctx.font !== "undefined") {
          var fontStyleProp = this.getStyle("font");
          var fontStyleStyleProp = this.getStyle("font-style");
          var fontVariantStyleProp = this.getStyle("font-variant");
          var fontWeightStyleProp = this.getStyle("font-weight");
          var fontSizeStyleProp = this.getStyle("font-size");
          var fontFamilyStyleProp = this.getStyle("font-family");
          var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
          fontStyleStyleProp.setValue(font.fontStyle);
          fontVariantStyleProp.setValue(font.fontVariant);
          fontWeightStyleProp.setValue(font.fontWeight);
          fontSizeStyleProp.setValue(font.fontSize);
          fontFamilyStyleProp.setValue(font.fontFamily);
          ctx.font = font.toString();
          if (fontSizeStyleProp.isPixels()) {
            this.document.emSize = fontSizeStyleProp.getPixels();
            this.modifiedEmSizeStack = true;
          }
        }
        if (!fromMeasure) {
          this.applyEffects(ctx);
          ctx.globalAlpha = this.calculateOpacity();
        }
      }
      clearContext(ctx) {
        super.clearContext(ctx);
        if (this.modifiedEmSizeStack) {
          this.document.popEmSize();
        }
      }
    };
    PathElement = class extends RenderedElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "path";
        this.pathParser = null;
        this.pathParser = new PathParser(this.getAttribute("d").getString());
      }
      path(ctx) {
        var {
          pathParser
        } = this;
        var boundingBox = new BoundingBox();
        pathParser.reset();
        if (ctx) {
          ctx.beginPath();
        }
        while (!pathParser.isEnd()) {
          switch (pathParser.next().type) {
            case PathParser.MOVE_TO:
              this.pathM(ctx, boundingBox);
              break;
            case PathParser.LINE_TO:
              this.pathL(ctx, boundingBox);
              break;
            case PathParser.HORIZ_LINE_TO:
              this.pathH(ctx, boundingBox);
              break;
            case PathParser.VERT_LINE_TO:
              this.pathV(ctx, boundingBox);
              break;
            case PathParser.CURVE_TO:
              this.pathC(ctx, boundingBox);
              break;
            case PathParser.SMOOTH_CURVE_TO:
              this.pathS(ctx, boundingBox);
              break;
            case PathParser.QUAD_TO:
              this.pathQ(ctx, boundingBox);
              break;
            case PathParser.SMOOTH_QUAD_TO:
              this.pathT(ctx, boundingBox);
              break;
            case PathParser.ARC:
              this.pathA(ctx, boundingBox);
              break;
            case PathParser.CLOSE_PATH:
              this.pathZ(ctx, boundingBox);
              break;
          }
        }
        return boundingBox;
      }
      getBoundingBox(_3) {
        return this.path();
      }
      getMarkers() {
        var {
          pathParser
        } = this;
        var points2 = pathParser.getMarkerPoints();
        var angles = pathParser.getMarkerAngles();
        var markers = points2.map((point, i3) => [point, angles[i3]]);
        return markers;
      }
      renderChildren(ctx) {
        this.path(ctx);
        this.document.screen.mouse.checkPath(this, ctx);
        var fillRuleStyleProp = this.getStyle("fill-rule");
        if (ctx.fillStyle !== "") {
          if (fillRuleStyleProp.getString("inherit") !== "inherit") {
            ctx.fill(fillRuleStyleProp.getString());
          } else {
            ctx.fill();
          }
        }
        if (ctx.strokeStyle !== "") {
          if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.stroke();
            ctx.restore();
          } else {
            ctx.stroke();
          }
        }
        var markers = this.getMarkers();
        if (markers) {
          var markersLastIndex = markers.length - 1;
          var markerStartStyleProp = this.getStyle("marker-start");
          var markerMidStyleProp = this.getStyle("marker-mid");
          var markerEndStyleProp = this.getStyle("marker-end");
          if (markerStartStyleProp.isUrlDefinition()) {
            var marker = markerStartStyleProp.getDefinition();
            var [point, angle] = markers[0];
            marker.render(ctx, point, angle);
          }
          if (markerMidStyleProp.isUrlDefinition()) {
            var _marker = markerMidStyleProp.getDefinition();
            for (var i3 = 1; i3 < markersLastIndex; i3++) {
              var [_point, _angle] = markers[i3];
              _marker.render(ctx, _point, _angle);
            }
          }
          if (markerEndStyleProp.isUrlDefinition()) {
            var _marker2 = markerEndStyleProp.getDefinition();
            var [_point2, _angle2] = markers[markersLastIndex];
            _marker2.render(ctx, _point2, _angle2);
          }
        }
      }
      static pathM(pathParser) {
        var point = pathParser.getAsCurrentPoint();
        pathParser.start = pathParser.current;
        return {
          point
        };
      }
      pathM(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          point
        } = PathElement.pathM(pathParser);
        var {
          x: x2,
          y: y3
        } = point;
        pathParser.addMarker(point);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.moveTo(x2, y3);
        }
      }
      static pathL(pathParser) {
        var {
          current
        } = pathParser;
        var point = pathParser.getAsCurrentPoint();
        return {
          current,
          point
        };
      }
      pathL(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point
        } = PathElement.pathL(pathParser);
        var {
          x: x2,
          y: y3
        } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathH(pathParser) {
        var {
          current,
          command
        } = pathParser;
        var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
        pathParser.current = point;
        return {
          current,
          point
        };
      }
      pathH(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point
        } = PathElement.pathH(pathParser);
        var {
          x: x2,
          y: y3
        } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathV(pathParser) {
        var {
          current,
          command
        } = pathParser;
        var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
        pathParser.current = point;
        return {
          current,
          point
        };
      }
      pathV(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point
        } = PathElement.pathV(pathParser);
        var {
          x: x2,
          y: y3
        } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathC(pathParser) {
        var {
          current
        } = pathParser;
        var point = pathParser.getPoint("x1", "y1");
        var controlPoint = pathParser.getAsControlPoint("x2", "y2");
        var currentPoint = pathParser.getAsCurrentPoint();
        return {
          current,
          point,
          controlPoint,
          currentPoint
        };
      }
      pathC(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point,
          controlPoint,
          currentPoint
        } = PathElement.pathC(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, point);
        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathS(pathParser) {
        var {
          current
        } = pathParser;
        var point = pathParser.getReflectedControlPoint();
        var controlPoint = pathParser.getAsControlPoint("x2", "y2");
        var currentPoint = pathParser.getAsCurrentPoint();
        return {
          current,
          point,
          controlPoint,
          currentPoint
        };
      }
      pathS(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point,
          controlPoint,
          currentPoint
        } = PathElement.pathS(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, point);
        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathQ(pathParser) {
        var {
          current
        } = pathParser;
        var controlPoint = pathParser.getAsControlPoint("x1", "y1");
        var currentPoint = pathParser.getAsCurrentPoint();
        return {
          current,
          controlPoint,
          currentPoint
        };
      }
      pathQ(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          controlPoint,
          currentPoint
        } = PathElement.pathQ(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, controlPoint);
        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathT(pathParser) {
        var {
          current
        } = pathParser;
        var controlPoint = pathParser.getReflectedControlPoint();
        pathParser.control = controlPoint;
        var currentPoint = pathParser.getAsCurrentPoint();
        return {
          current,
          controlPoint,
          currentPoint
        };
      }
      pathT(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          controlPoint,
          currentPoint
        } = PathElement.pathT(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, controlPoint);
        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathA(pathParser) {
        var {
          current,
          command
        } = pathParser;
        var {
          rX,
          rY,
          xRot,
          lArcFlag,
          sweepFlag
        } = command;
        var xAxisRotation = xRot * (Math.PI / 180);
        var currentPoint = pathParser.getAsCurrentPoint();
        var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
        var l3 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
        if (l3 > 1) {
          rX *= Math.sqrt(l3);
          rY *= Math.sqrt(l3);
        }
        var s3 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
        if (isNaN(s3)) {
          s3 = 0;
        }
        var cpp = new Point(s3 * rX * currp.y / rY, s3 * -rY * currp.x / rX);
        var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
        var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
        var u3 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
        var v3 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
        var ad = vectorsAngle(u3, v3);
        if (vectorsRatio(u3, v3) <= -1) {
          ad = Math.PI;
        }
        if (vectorsRatio(u3, v3) >= 1) {
          ad = 0;
        }
        return {
          currentPoint,
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        };
      }
      pathA(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          currentPoint,
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        } = PathElement.pathA(pathParser);
        var dir = 1 - sweepFlag ? 1 : -1;
        var ah = a1 + dir * (ad / 2);
        var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
        boundingBox.addPoint(currentPoint.x, currentPoint.y);
        if (ctx && !isNaN(a1) && !isNaN(ad)) {
          var r2 = rX > rY ? rX : rY;
          var sx = rX > rY ? 1 : rX / rY;
          var sy = rX > rY ? rY / rX : 1;
          ctx.translate(centp.x, centp.y);
          ctx.rotate(xAxisRotation);
          ctx.scale(sx, sy);
          ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));
          ctx.scale(1 / sx, 1 / sy);
          ctx.rotate(-xAxisRotation);
          ctx.translate(-centp.x, -centp.y);
        }
      }
      static pathZ(pathParser) {
        pathParser.current = pathParser.start;
      }
      pathZ(ctx, boundingBox) {
        PathElement.pathZ(this.pathParser);
        if (ctx) {
          if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
            ctx.closePath();
          }
        }
      }
    };
    GlyphElement = class extends PathElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "glyph";
        this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
        this.unicode = this.getAttribute("unicode").getString();
        this.arabicForm = this.getAttribute("arabic-form").getString();
      }
    };
    TextElement = class extends RenderedElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, new.target === TextElement ? true : captureTextNodes);
        this.type = "text";
        this.x = 0;
        this.y = 0;
        this.measureCache = -1;
      }
      setContext(ctx) {
        var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        super.setContext(ctx, fromMeasure);
        var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
        if (textBaseline) {
          ctx.textBaseline = textBaseline;
        }
      }
      initializeCoordinates() {
        this.x = 0;
        this.y = 0;
        this.leafTexts = [];
        this.textChunkStart = 0;
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
      }
      getBoundingBox(ctx) {
        if (this.type !== "text") {
          return this.getTElementBoundingBox(ctx);
        }
        this.initializeCoordinates();
        this.adjustChildCoordinatesRecursive(ctx);
        var boundingBox = null;
        this.children.forEach((_3, i3) => {
          var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i3);
          if (!boundingBox) {
            boundingBox = childBoundingBox;
          } else {
            boundingBox.addBoundingBox(childBoundingBox);
          }
        });
        return boundingBox;
      }
      getFontSize() {
        var {
          document: document2,
          parent
        } = this;
        var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
        var fontSize = parent.getStyle("font-size").getNumber(inheritFontSize);
        return fontSize;
      }
      getTElementBoundingBox(ctx) {
        var fontSize = this.getFontSize();
        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
      }
      getGlyph(font, text, i3) {
        var char = text[i3];
        var glyph = null;
        if (font.isArabic) {
          var len = text.length;
          var prevChar = text[i3 - 1];
          var nextChar = text[i3 + 1];
          var arabicForm = "isolated";
          if ((i3 === 0 || prevChar === " ") && i3 < len - 1 && nextChar !== " ") {
            arabicForm = "terminal";
          }
          if (i3 > 0 && prevChar !== " " && i3 < len - 1 && nextChar !== " ") {
            arabicForm = "medial";
          }
          if (i3 > 0 && prevChar !== " " && (i3 === len - 1 || nextChar === " ")) {
            arabicForm = "initial";
          }
          if (typeof font.glyphs[char] !== "undefined") {
            var maybeGlyph = font.glyphs[char];
            glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
          }
        } else {
          glyph = font.glyphs[char];
        }
        if (!glyph) {
          glyph = font.missingGlyph;
        }
        return glyph;
      }
      getText() {
        return "";
      }
      getTextFromNode(node2) {
        var textNode = node2 || this.node;
        var childNodes = Array.from(textNode.parentNode.childNodes);
        var index2 = childNodes.indexOf(textNode);
        var lastIndex = childNodes.length - 1;
        var text = compressSpaces(
          // textNode.value
          // || textNode.text
          textNode.textContent || ""
        );
        if (index2 === 0) {
          text = trimLeft(text);
        }
        if (index2 === lastIndex) {
          text = trimRight(text);
        }
        return text;
      }
      renderChildren(ctx) {
        if (this.type !== "text") {
          this.renderTElementChildren(ctx);
          return;
        }
        this.initializeCoordinates();
        this.adjustChildCoordinatesRecursive(ctx);
        this.children.forEach((_3, i3) => {
          this.renderChild(ctx, this, this, i3);
        });
        var {
          mouse
        } = this.document.screen;
        if (mouse.isWorking()) {
          mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
        }
      }
      renderTElementChildren(ctx) {
        var {
          document: document2,
          parent
        } = this;
        var renderText = this.getText();
        var customFont = parent.getStyle("font-family").getDefinition();
        if (customFont) {
          var {
            unitsPerEm
          } = customFont.fontFace;
          var ctxFont = Font.parse(document2.ctx.font);
          var fontSize = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
          var fontStyle = parent.getStyle("font-style").getString(ctxFont.fontStyle);
          var scale = fontSize / unitsPerEm;
          var text = customFont.isRTL ? renderText.split("").reverse().join("") : renderText;
          var dx = toNumbers(parent.getAttribute("dx").getString());
          var len = text.length;
          for (var i3 = 0; i3 < len; i3++) {
            var glyph = this.getGlyph(customFont, text, i3);
            ctx.translate(this.x, this.y);
            ctx.scale(scale, -scale);
            var lw = ctx.lineWidth;
            ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;
            if (fontStyle === "italic") {
              ctx.transform(1, 0, 0.4, 1, 0, 0);
            }
            glyph.render(ctx);
            if (fontStyle === "italic") {
              ctx.transform(1, 0, -0.4, 1, 0, 0);
            }
            ctx.lineWidth = lw;
            ctx.scale(1 / scale, -1 / scale);
            ctx.translate(-this.x, -this.y);
            this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
            if (typeof dx[i3] !== "undefined" && !isNaN(dx[i3])) {
              this.x += dx[i3];
            }
          }
          return;
        }
        var {
          x: x2,
          y: y3
        } = this;
        if (ctx.fillStyle) {
          ctx.fillText(renderText, x2, y3);
        }
        if (ctx.strokeStyle) {
          ctx.strokeText(renderText, x2, y3);
        }
      }
      applyAnchoring() {
        if (this.textChunkStart >= this.leafTexts.length) {
          return;
        }
        var firstElement = this.leafTexts[this.textChunkStart];
        var textAnchor = firstElement.getStyle("text-anchor").getString("start");
        var isRTL = false;
        var shift = 0;
        if (textAnchor === "start" && !isRTL || textAnchor === "end" && isRTL) {
          shift = firstElement.x - this.minX;
        } else if (textAnchor === "end" && !isRTL || textAnchor === "start" && isRTL) {
          shift = firstElement.x - this.maxX;
        } else {
          shift = firstElement.x - (this.minX + this.maxX) / 2;
        }
        for (var i3 = this.textChunkStart; i3 < this.leafTexts.length; i3++) {
          this.leafTexts[i3].x += shift;
        }
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.textChunkStart = this.leafTexts.length;
      }
      adjustChildCoordinatesRecursive(ctx) {
        this.children.forEach((_3, i3) => {
          this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i3);
        });
        this.applyAnchoring();
      }
      adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i3) {
        var child = parent.children[i3];
        if (child.children.length > 0) {
          child.children.forEach((_3, i4) => {
            textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i4);
          });
        } else {
          this.adjustChildCoordinates(ctx, textParent, parent, i3);
        }
      }
      adjustChildCoordinates(ctx, textParent, parent, i3) {
        var child = parent.children[i3];
        if (typeof child.measureText !== "function") {
          return child;
        }
        ctx.save();
        child.setContext(ctx, true);
        var xAttr = child.getAttribute("x");
        var yAttr = child.getAttribute("y");
        var dxAttr = child.getAttribute("dx");
        var dyAttr = child.getAttribute("dy");
        var customFont = child.getStyle("font-family").getDefinition();
        var isRTL = Boolean(customFont) && customFont.isRTL;
        if (i3 === 0) {
          if (!xAttr.hasValue()) {
            xAttr.setValue(child.getInheritedAttribute("x"));
          }
          if (!yAttr.hasValue()) {
            yAttr.setValue(child.getInheritedAttribute("y"));
          }
          if (!dxAttr.hasValue()) {
            dxAttr.setValue(child.getInheritedAttribute("dx"));
          }
          if (!dyAttr.hasValue()) {
            dyAttr.setValue(child.getInheritedAttribute("dy"));
          }
        }
        var width = child.measureText(ctx);
        if (isRTL) {
          textParent.x -= width;
        }
        if (xAttr.hasValue()) {
          textParent.applyAnchoring();
          child.x = xAttr.getPixels("x");
          if (dxAttr.hasValue()) {
            child.x += dxAttr.getPixels("x");
          }
        } else {
          if (dxAttr.hasValue()) {
            textParent.x += dxAttr.getPixels("x");
          }
          child.x = textParent.x;
        }
        textParent.x = child.x;
        if (!isRTL) {
          textParent.x += width;
        }
        if (yAttr.hasValue()) {
          child.y = yAttr.getPixels("y");
          if (dyAttr.hasValue()) {
            child.y += dyAttr.getPixels("y");
          }
        } else {
          if (dyAttr.hasValue()) {
            textParent.y += dyAttr.getPixels("y");
          }
          child.y = textParent.y;
        }
        textParent.y = child.y;
        textParent.leafTexts.push(child);
        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
        child.clearContext(ctx);
        ctx.restore();
        return child;
      }
      getChildBoundingBox(ctx, textParent, parent, i3) {
        var child = parent.children[i3];
        if (typeof child.getBoundingBox !== "function") {
          return null;
        }
        var boundingBox = child.getBoundingBox(ctx);
        if (!boundingBox) {
          return null;
        }
        child.children.forEach((_3, i4) => {
          var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i4);
          boundingBox.addBoundingBox(childBoundingBox);
        });
        return boundingBox;
      }
      renderChild(ctx, textParent, parent, i3) {
        var child = parent.children[i3];
        child.render(ctx);
        child.children.forEach((_3, i4) => {
          textParent.renderChild(ctx, textParent, child, i4);
        });
      }
      measureText(ctx) {
        var {
          measureCache
        } = this;
        if (~measureCache) {
          return measureCache;
        }
        var renderText = this.getText();
        var measure = this.measureTargetText(ctx, renderText);
        this.measureCache = measure;
        return measure;
      }
      measureTargetText(ctx, targetText) {
        if (!targetText.length) {
          return 0;
        }
        var {
          parent
        } = this;
        var customFont = parent.getStyle("font-family").getDefinition();
        if (customFont) {
          var fontSize = this.getFontSize();
          var text = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
          var dx = toNumbers(parent.getAttribute("dx").getString());
          var len = text.length;
          var _measure = 0;
          for (var i3 = 0; i3 < len; i3++) {
            var glyph = this.getGlyph(customFont, text, i3);
            _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
            if (typeof dx[i3] !== "undefined" && !isNaN(dx[i3])) {
              _measure += dx[i3];
            }
          }
          return _measure;
        }
        if (!ctx.measureText) {
          return targetText.length * 10;
        }
        ctx.save();
        this.setContext(ctx, true);
        var {
          width: measure
        } = ctx.measureText(targetText);
        this.clearContext(ctx);
        ctx.restore();
        return measure;
      }
      /**
       * Inherits positional attributes from {@link TextElement} parent(s). Attributes
       * are only inherited from a parent to its first child.
       * @param name - The attribute name.
       * @returns The attribute value or null.
       */
      getInheritedAttribute(name) {
        var current = this;
        while (current instanceof TextElement && current.isFirstChild()) {
          var parentAttr = current.parent.getAttribute(name);
          if (parentAttr.hasValue(true)) {
            return parentAttr.getValue("0");
          }
          current = current.parent;
        }
        return null;
      }
    };
    TSpanElement = class extends TextElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, new.target === TSpanElement ? true : captureTextNodes);
        this.type = "tspan";
        this.text = this.children.length > 0 ? "" : this.getTextFromNode();
      }
      getText() {
        return this.text;
      }
    };
    TextNode = class extends TSpanElement {
      constructor() {
        super(...arguments);
        this.type = "textNode";
      }
    };
    SVGElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "svg";
        this.root = false;
      }
      setContext(ctx) {
        var _this$node$parentNode;
        var {
          document: document2
        } = this;
        var {
          screen,
          window: window2
        } = document2;
        var canvas = ctx.canvas;
        screen.setDefaults(ctx);
        if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
          ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
          var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
          if (fontSizeProp.hasValue()) {
            document2.rootEmSize = fontSizeProp.getPixels("y");
            document2.emSize = document2.rootEmSize;
          }
        }
        if (!this.getAttribute("x").hasValue()) {
          this.getAttribute("x", true).setValue(0);
        }
        if (!this.getAttribute("y").hasValue()) {
          this.getAttribute("y", true).setValue(0);
        }
        var {
          width,
          height
        } = screen.viewPort;
        if (!this.getStyle("width").hasValue()) {
          this.getStyle("width", true).setValue("100%");
        }
        if (!this.getStyle("height").hasValue()) {
          this.getStyle("height", true).setValue("100%");
        }
        if (!this.getStyle("color").hasValue()) {
          this.getStyle("color", true).setValue("black");
        }
        var refXAttr = this.getAttribute("refX");
        var refYAttr = this.getAttribute("refY");
        var viewBoxAttr = this.getAttribute("viewBox");
        var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
        var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
        var minX = 0;
        var minY = 0;
        var clipX = 0;
        var clipY = 0;
        if (viewBox) {
          minX = viewBox[0];
          minY = viewBox[1];
        }
        if (!this.root) {
          width = this.getStyle("width").getPixels("x");
          height = this.getStyle("height").getPixels("y");
          if (this.type === "marker") {
            clipX = minX;
            clipY = minY;
            minX = 0;
            minY = 0;
          }
        }
        screen.viewPort.setCurrent(width, height);
        if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
          this.getStyle("transform-origin", true, true).setValue("50% 50%");
        }
        super.setContext(ctx);
        ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
        if (viewBox) {
          width = viewBox[2];
          height = viewBox[3];
        }
        document2.setViewBox({
          ctx,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: screen.viewPort.width,
          desiredWidth: width,
          height: screen.viewPort.height,
          desiredHeight: height,
          minX,
          minY,
          refX: refXAttr.getValue(),
          refY: refYAttr.getValue(),
          clip,
          clipX,
          clipY
        });
        if (viewBox) {
          screen.viewPort.removeCurrent();
          screen.viewPort.setCurrent(width, height);
        }
      }
      clearContext(ctx) {
        super.clearContext(ctx);
        this.document.screen.viewPort.removeCurrent();
      }
      /**
       * Resize SVG to fit in given size.
       * @param width
       * @param height
       * @param preserveAspectRatio
       */
      resize(width) {
        var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var widthAttr = this.getAttribute("width", true);
        var heightAttr = this.getAttribute("height", true);
        var viewBoxAttr = this.getAttribute("viewBox");
        var styleAttr = this.getAttribute("style");
        var originWidth = widthAttr.getNumber(0);
        var originHeight = heightAttr.getNumber(0);
        if (preserveAspectRatio) {
          if (typeof preserveAspectRatio === "string") {
            this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
          } else {
            var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
            if (preserveAspectRatioAttr.hasValue()) {
              preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
            }
          }
        }
        widthAttr.setValue(width);
        heightAttr.setValue(height);
        if (!viewBoxAttr.hasValue()) {
          viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
        }
        if (styleAttr.hasValue()) {
          var widthStyle = this.getStyle("width");
          var heightStyle = this.getStyle("height");
          if (widthStyle.hasValue()) {
            widthStyle.setValue("".concat(width, "px"));
          }
          if (heightStyle.hasValue()) {
            heightStyle.setValue("".concat(height, "px"));
          }
        }
      }
    };
    RectElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "rect";
      }
      path(ctx) {
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width = this.getStyle("width", false, true).getPixels("x");
        var height = this.getStyle("height", false, true).getPixels("y");
        var rxAttr = this.getAttribute("rx");
        var ryAttr = this.getAttribute("ry");
        var rx = rxAttr.getPixels("x");
        var ry = ryAttr.getPixels("y");
        if (rxAttr.hasValue() && !ryAttr.hasValue()) {
          ry = rx;
        }
        if (ryAttr.hasValue() && !rxAttr.hasValue()) {
          rx = ry;
        }
        rx = Math.min(rx, width / 2);
        ry = Math.min(ry, height / 2);
        if (ctx) {
          var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
          ctx.beginPath();
          if (height > 0 && width > 0) {
            ctx.moveTo(x2 + rx, y3);
            ctx.lineTo(x2 + width - rx, y3);
            ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y3, x2 + width, y3 + ry - KAPPA * ry, x2 + width, y3 + ry);
            ctx.lineTo(x2 + width, y3 + height - ry);
            ctx.bezierCurveTo(x2 + width, y3 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y3 + height, x2 + width - rx, y3 + height);
            ctx.lineTo(x2 + rx, y3 + height);
            ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y3 + height, x2, y3 + height - ry + KAPPA * ry, x2, y3 + height - ry);
            ctx.lineTo(x2, y3 + ry);
            ctx.bezierCurveTo(x2, y3 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y3, x2 + rx, y3);
            ctx.closePath();
          }
        }
        return new BoundingBox(x2, y3, x2 + width, y3 + height);
      }
      getMarkers() {
        return null;
      }
    };
    CircleElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "circle";
      }
      path(ctx) {
        var cx = this.getAttribute("cx").getPixels("x");
        var cy = this.getAttribute("cy").getPixels("y");
        var r2 = this.getAttribute("r").getPixels();
        if (ctx && r2 > 0) {
          ctx.beginPath();
          ctx.arc(cx, cy, r2, 0, Math.PI * 2, false);
          ctx.closePath();
        }
        return new BoundingBox(cx - r2, cy - r2, cx + r2, cy + r2);
      }
      getMarkers() {
        return null;
      }
    };
    EllipseElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "ellipse";
      }
      path(ctx) {
        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        var rx = this.getAttribute("rx").getPixels("x");
        var ry = this.getAttribute("ry").getPixels("y");
        var cx = this.getAttribute("cx").getPixels("x");
        var cy = this.getAttribute("cy").getPixels("y");
        if (ctx && rx > 0 && ry > 0) {
          ctx.beginPath();
          ctx.moveTo(cx + rx, cy);
          ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
          ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
          ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
          ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
          ctx.closePath();
        }
        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
      }
      getMarkers() {
        return null;
      }
    };
    LineElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "line";
      }
      getPoints() {
        return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
      }
      path(ctx) {
        var [{
          x: x0,
          y: y0
        }, {
          x: x1,
          y: y1
        }] = this.getPoints();
        if (ctx) {
          ctx.beginPath();
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
        }
        return new BoundingBox(x0, y0, x1, y1);
      }
      getMarkers() {
        var [p0, p1] = this.getPoints();
        var a3 = p0.angleTo(p1);
        return [[p0, a3], [p1, a3]];
      }
    };
    PolylineElement = class extends PathElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "polyline";
        this.points = [];
        this.points = Point.parsePath(this.getAttribute("points").getString());
      }
      path(ctx) {
        var {
          points: points2
        } = this;
        var [{
          x: x0,
          y: y0
        }] = points2;
        var boundingBox = new BoundingBox(x0, y0);
        if (ctx) {
          ctx.beginPath();
          ctx.moveTo(x0, y0);
        }
        points2.forEach((_ref) => {
          var {
            x: x2,
            y: y3
          } = _ref;
          boundingBox.addPoint(x2, y3);
          if (ctx) {
            ctx.lineTo(x2, y3);
          }
        });
        return boundingBox;
      }
      getMarkers() {
        var {
          points: points2
        } = this;
        var lastIndex = points2.length - 1;
        var markers = [];
        points2.forEach((point, i3) => {
          if (i3 === lastIndex) {
            return;
          }
          markers.push([point, point.angleTo(points2[i3 + 1])]);
        });
        if (markers.length > 0) {
          markers.push([points2[points2.length - 1], markers[markers.length - 1][1]]);
        }
        return markers;
      }
    };
    PolygonElement = class extends PolylineElement {
      constructor() {
        super(...arguments);
        this.type = "polygon";
      }
      path(ctx) {
        var boundingBox = super.path(ctx);
        var [{
          x: x2,
          y: y3
        }] = this.points;
        if (ctx) {
          ctx.lineTo(x2, y3);
          ctx.closePath();
        }
        return boundingBox;
      }
    };
    PatternElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "pattern";
      }
      createPattern(ctx, _3, parentOpacityProp) {
        var width = this.getStyle("width").getPixels("x", true);
        var height = this.getStyle("height").getPixels("y", true);
        var patternSvg = new SVGElement(this.document, null);
        patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
        patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
        patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
        patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
        patternSvg.children = this.children;
        var patternCanvas = this.document.createCanvas(width, height);
        var patternCtx = patternCanvas.getContext("2d");
        var xAttr = this.getAttribute("x");
        var yAttr = this.getAttribute("y");
        if (xAttr.hasValue() && yAttr.hasValue()) {
          patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
        }
        if (parentOpacityProp.hasValue()) {
          this.styles["fill-opacity"] = parentOpacityProp;
        } else {
          Reflect.deleteProperty(this.styles, "fill-opacity");
        }
        for (var x2 = -1; x2 <= 1; x2++) {
          for (var y3 = -1; y3 <= 1; y3++) {
            patternCtx.save();
            patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
            patternSvg.attributes.y = new Property(this.document, "y", y3 * patternCanvas.height);
            patternSvg.render(patternCtx);
            patternCtx.restore();
          }
        }
        var pattern = ctx.createPattern(patternCanvas, "repeat");
        return pattern;
      }
    };
    MarkerElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "marker";
      }
      render(ctx, point, angle) {
        if (!point) {
          return;
        }
        var {
          x: x2,
          y: y3
        } = point;
        var orient = this.getAttribute("orient").getString("auto");
        var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
        ctx.translate(x2, y3);
        if (orient === "auto") {
          ctx.rotate(angle);
        }
        if (markerUnits === "strokeWidth") {
          ctx.scale(ctx.lineWidth, ctx.lineWidth);
        }
        ctx.save();
        var markerSvg = new SVGElement(this.document, null);
        markerSvg.type = this.type;
        markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
        markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
        markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
        markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
        markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
        markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
        markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
        markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
        markerSvg.children = this.children;
        markerSvg.render(ctx);
        ctx.restore();
        if (markerUnits === "strokeWidth") {
          ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
        }
        if (orient === "auto") {
          ctx.rotate(-angle);
        }
        ctx.translate(-x2, -y3);
      }
    };
    DefsElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "defs";
      }
      render() {
      }
    };
    GElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "g";
      }
      getBoundingBox(ctx) {
        var boundingBox = new BoundingBox();
        this.children.forEach((child) => {
          boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        return boundingBox;
      }
    };
    GradientElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.attributesToInherit = ["gradientUnits"];
        this.stops = [];
        var {
          stops,
          children
        } = this;
        children.forEach((child) => {
          if (child.type === "stop") {
            stops.push(child);
          }
        });
      }
      getGradientUnits() {
        return this.getAttribute("gradientUnits").getString("objectBoundingBox");
      }
      createGradient(ctx, element, parentOpacityProp) {
        var stopsContainer = this;
        if (this.getHrefAttribute().hasValue()) {
          stopsContainer = this.getHrefAttribute().getDefinition();
          this.inheritStopContainer(stopsContainer);
        }
        var {
          stops
        } = stopsContainer;
        var gradient = this.getGradient(ctx, element);
        if (!gradient) {
          return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
        }
        stops.forEach((stop) => {
          gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
        });
        if (this.getAttribute("gradientTransform").hasValue()) {
          var {
            document: document2
          } = this;
          var {
            MAX_VIRTUAL_PIXELS,
            viewPort
          } = document2.screen;
          var [rootView] = viewPort.viewPorts;
          var rect = new RectElement(document2, null);
          rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
          rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
          rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
          rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
          var group = new GElement(document2, null);
          group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
          group.children = [rect];
          var patternSvg = new SVGElement(document2, null);
          patternSvg.attributes.x = new Property(document2, "x", 0);
          patternSvg.attributes.y = new Property(document2, "y", 0);
          patternSvg.attributes.width = new Property(document2, "width", rootView.width);
          patternSvg.attributes.height = new Property(document2, "height", rootView.height);
          patternSvg.children = [group];
          var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
          var patternCtx = patternCanvas.getContext("2d");
          patternCtx.fillStyle = gradient;
          patternSvg.render(patternCtx);
          return patternCtx.createPattern(patternCanvas, "no-repeat");
        }
        return gradient;
      }
      inheritStopContainer(stopsContainer) {
        this.attributesToInherit.forEach((attributeToInherit) => {
          if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
            this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
          }
        });
      }
      addParentOpacity(parentOpacityProp, color) {
        if (parentOpacityProp.hasValue()) {
          var colorProp = new Property(this.document, "color", color);
          return colorProp.addOpacity(parentOpacityProp).getColor();
        }
        return color;
      }
    };
    LinearGradientElement = class extends GradientElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "linearGradient";
        this.attributesToInherit.push("x1", "y1", "x2", "y2");
      }
      getGradient(ctx, element) {
        var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
        var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
        if (isBoundingBoxUnits && !boundingBox) {
          return null;
        }
        if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
          this.getAttribute("x1", true).setValue(0);
          this.getAttribute("y1", true).setValue(0);
          this.getAttribute("x2", true).setValue(1);
          this.getAttribute("y2", true).setValue(0);
        }
        var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
        var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
        var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
        var y22 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
        if (x1 === x2 && y1 === y22) {
          return null;
        }
        return ctx.createLinearGradient(x1, y1, x2, y22);
      }
    };
    RadialGradientElement = class extends GradientElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "radialGradient";
        this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
      }
      getGradient(ctx, element) {
        var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
        var boundingBox = element.getBoundingBox(ctx);
        if (isBoundingBoxUnits && !boundingBox) {
          return null;
        }
        if (!this.getAttribute("cx").hasValue()) {
          this.getAttribute("cx", true).setValue("50%");
        }
        if (!this.getAttribute("cy").hasValue()) {
          this.getAttribute("cy", true).setValue("50%");
        }
        if (!this.getAttribute("r").hasValue()) {
          this.getAttribute("r", true).setValue("50%");
        }
        var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
        var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
        var fx = cx;
        var fy = cy;
        if (this.getAttribute("fx").hasValue()) {
          fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
        }
        if (this.getAttribute("fy").hasValue()) {
          fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
        }
        var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
        var fr = this.getAttribute("fr").getPixels();
        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r2);
      }
    };
    StopElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "stop";
        var offset = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
        var stopOpacity = this.getStyle("stop-opacity");
        var stopColor = this.getStyle("stop-color", true);
        if (stopColor.getString() === "") {
          stopColor.setValue("#000");
        }
        if (stopOpacity.hasValue()) {
          stopColor = stopColor.addOpacity(stopOpacity);
        }
        this.offset = offset;
        this.color = stopColor.getColor();
      }
    };
    AnimateElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "animate";
        this.duration = 0;
        this.initialValue = null;
        this.initialUnits = "";
        this.removed = false;
        this.frozen = false;
        document2.screen.animations.push(this);
        this.begin = this.getAttribute("begin").getMilliseconds();
        this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
        this.from = this.getAttribute("from");
        this.to = this.getAttribute("to");
        this.values = new Property(document2, "values", null);
        var valuesAttr = this.getAttribute("values");
        if (valuesAttr.hasValue()) {
          this.values.setValue(valuesAttr.getString().split(";"));
        }
      }
      getProperty() {
        var attributeType = this.getAttribute("attributeType").getString();
        var attributeName = this.getAttribute("attributeName").getString();
        if (attributeType === "CSS") {
          return this.parent.getStyle(attributeName, true);
        }
        return this.parent.getAttribute(attributeName, true);
      }
      calcValue() {
        var {
          initialUnits
        } = this;
        var {
          progress,
          from,
          to
        } = this.getProgress();
        var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
        if (initialUnits === "%") {
          newValue *= 100;
        }
        return "".concat(newValue).concat(initialUnits);
      }
      update(delta) {
        var {
          parent
        } = this;
        var prop = this.getProperty();
        if (!this.initialValue) {
          this.initialValue = prop.getString();
          this.initialUnits = prop.getUnits();
        }
        if (this.duration > this.maxDuration) {
          var fill2 = this.getAttribute("fill").getString("remove");
          if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
            this.duration = 0;
          } else if (fill2 === "freeze" && !this.frozen) {
            this.frozen = true;
            parent.animationFrozen = true;
            parent.animationFrozenValue = prop.getString();
          } else if (fill2 === "remove" && !this.removed) {
            this.removed = true;
            prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
            return true;
          }
          return false;
        }
        this.duration += delta;
        var updated = false;
        if (this.begin < this.duration) {
          var newValue = this.calcValue();
          var typeAttr = this.getAttribute("type");
          if (typeAttr.hasValue()) {
            var type = typeAttr.getString();
            newValue = "".concat(type, "(").concat(newValue, ")");
          }
          prop.setValue(newValue);
          updated = true;
        }
        return updated;
      }
      getProgress() {
        var {
          document: document2,
          values
        } = this;
        var result = {
          progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
        };
        if (values.hasValue()) {
          var p3 = result.progress * (values.getValue().length - 1);
          var lb = Math.floor(p3);
          var ub = Math.ceil(p3);
          result.from = new Property(document2, "from", parseFloat(values.getValue()[lb]));
          result.to = new Property(document2, "to", parseFloat(values.getValue()[ub]));
          result.progress = (p3 - lb) / (ub - lb);
        } else {
          result.from = this.from;
          result.to = this.to;
        }
        return result;
      }
    };
    AnimateColorElement = class extends AnimateElement {
      constructor() {
        super(...arguments);
        this.type = "animateColor";
      }
      calcValue() {
        var {
          progress,
          from,
          to
        } = this.getProgress();
        var colorFrom = new import_rgbcolor.default(from.getColor());
        var colorTo = new import_rgbcolor.default(to.getColor());
        if (colorFrom.ok && colorTo.ok) {
          var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
          var g2 = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
          var b2 = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
          return "rgb(".concat(Math.floor(r2), ", ").concat(Math.floor(g2), ", ").concat(Math.floor(b2), ")");
        }
        return this.getAttribute("from").getColor();
      }
    };
    AnimateTransformElement = class extends AnimateElement {
      constructor() {
        super(...arguments);
        this.type = "animateTransform";
      }
      calcValue() {
        var {
          progress,
          from,
          to
        } = this.getProgress();
        var transformFrom = toNumbers(from.getString());
        var transformTo = toNumbers(to.getString());
        var newValue = transformFrom.map((from2, i3) => {
          var to2 = transformTo[i3];
          return from2 + (to2 - from2) * progress;
        }).join(" ");
        return newValue;
      }
    };
    FontElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "font";
        this.glyphs = {};
        this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
        var {
          definitions
        } = document2;
        var {
          children
        } = this;
        for (var child of children) {
          switch (child.type) {
            case "font-face": {
              this.fontFace = child;
              var fontFamilyStyle = child.getStyle("font-family");
              if (fontFamilyStyle.hasValue()) {
                definitions[fontFamilyStyle.getString()] = this;
              }
              break;
            }
            case "missing-glyph":
              this.missingGlyph = child;
              break;
            case "glyph": {
              var glyph = child;
              if (glyph.arabicForm) {
                this.isRTL = true;
                this.isArabic = true;
                if (typeof this.glyphs[glyph.unicode] === "undefined") {
                  this.glyphs[glyph.unicode] = {};
                }
                this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
              } else {
                this.glyphs[glyph.unicode] = glyph;
              }
              break;
            }
          }
        }
      }
      render() {
      }
    };
    FontFaceElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "font-face";
        this.ascent = this.getAttribute("ascent").getNumber();
        this.descent = this.getAttribute("descent").getNumber();
        this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
      }
    };
    MissingGlyphElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "missing-glyph";
        this.horizAdvX = 0;
      }
    };
    TRefElement = class extends TextElement {
      constructor() {
        super(...arguments);
        this.type = "tref";
      }
      getText() {
        var element = this.getHrefAttribute().getDefinition();
        if (element) {
          var firstChild = element.children[0];
          if (firstChild) {
            return firstChild.getText();
          }
        }
        return "";
      }
    };
    AElement = class extends TextElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "a";
        var {
          childNodes
        } = node2;
        var firstChild = childNodes[0];
        var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);
        this.hasText = hasText;
        this.text = hasText ? this.getTextFromNode(firstChild) : "";
      }
      getText() {
        return this.text;
      }
      renderChildren(ctx) {
        if (this.hasText) {
          super.renderChildren(ctx);
          var {
            document: document2,
            x: x2,
            y: y3
          } = this;
          var {
            mouse
          } = document2.screen;
          var fontSize = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
          if (mouse.isWorking()) {
            mouse.checkBoundingBox(this, new BoundingBox(x2, y3 - fontSize.getPixels("y"), x2 + this.measureText(ctx), y3));
          }
        } else if (this.children.length > 0) {
          var g2 = new GElement(this.document, null);
          g2.children = this.children;
          g2.parent = this;
          g2.render(ctx);
        }
      }
      onClick() {
        var {
          window: window2
        } = this.document;
        if (window2) {
          window2.open(this.getHrefAttribute().getString());
        }
      }
      onMouseMove() {
        var ctx = this.document.ctx;
        ctx.canvas.style.cursor = "pointer";
      }
    };
    TextPathElement = class extends TextElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "textPath";
        this.textWidth = 0;
        this.textHeight = 0;
        this.pathLength = -1;
        this.glyphInfo = null;
        this.letterSpacingCache = [];
        this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
        var pathElement = this.getHrefAttribute().getDefinition();
        this.text = this.getTextFromNode();
        this.dataArray = this.parsePathData(pathElement);
      }
      getText() {
        return this.text;
      }
      path(ctx) {
        var {
          dataArray
        } = this;
        if (ctx) {
          ctx.beginPath();
        }
        dataArray.forEach((_ref) => {
          var {
            type,
            points: points2
          } = _ref;
          switch (type) {
            case PathParser.LINE_TO:
              if (ctx) {
                ctx.lineTo(points2[0], points2[1]);
              }
              break;
            case PathParser.MOVE_TO:
              if (ctx) {
                ctx.moveTo(points2[0], points2[1]);
              }
              break;
            case PathParser.CURVE_TO:
              if (ctx) {
                ctx.bezierCurveTo(points2[0], points2[1], points2[2], points2[3], points2[4], points2[5]);
              }
              break;
            case PathParser.QUAD_TO:
              if (ctx) {
                ctx.quadraticCurveTo(points2[0], points2[1], points2[2], points2[3]);
              }
              break;
            case PathParser.ARC: {
              var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points2;
              var r2 = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;
              if (ctx) {
                ctx.translate(cx, cy);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs));
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx, -cy);
              }
              break;
            }
            case PathParser.CLOSE_PATH:
              if (ctx) {
                ctx.closePath();
              }
              break;
          }
        });
      }
      renderChildren(ctx) {
        this.setTextData(ctx);
        ctx.save();
        var textDecoration = this.parent.getStyle("text-decoration").getString();
        var fontSize = this.getFontSize();
        var {
          glyphInfo
        } = this;
        var fill2 = ctx.fillStyle;
        if (textDecoration === "underline") {
          ctx.beginPath();
        }
        glyphInfo.forEach((glyph, i3) => {
          var {
            p0,
            p1,
            rotation,
            text: partialText
          } = glyph;
          ctx.save();
          ctx.translate(p0.x, p0.y);
          ctx.rotate(rotation);
          if (ctx.fillStyle) {
            ctx.fillText(partialText, 0, 0);
          }
          if (ctx.strokeStyle) {
            ctx.strokeText(partialText, 0, 0);
          }
          ctx.restore();
          if (textDecoration === "underline") {
            if (i3 === 0) {
              ctx.moveTo(p0.x, p0.y + fontSize / 8);
            }
            ctx.lineTo(p1.x, p1.y + fontSize / 5);
          }
        });
        if (textDecoration === "underline") {
          ctx.lineWidth = fontSize / 20;
          ctx.strokeStyle = fill2;
          ctx.stroke();
          ctx.closePath();
        }
        ctx.restore();
      }
      getLetterSpacingAt() {
        var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        return this.letterSpacingCache[idx] || 0;
      }
      findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c4, charI) {
        var offset = inputOffset;
        var glyphWidth = this.measureText(ctx, c4);
        if (c4 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
        }
        if (charI > -1) {
          offset += this.getLetterSpacingAt(charI);
        }
        var splineStep = this.textHeight / 20;
        var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
        var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
        var segment = {
          p0,
          p1
        };
        var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
        if (dy) {
          var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
          var dyY = Math.cos(-rotation) * dy;
          segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
            x: p0.x + dyX,
            y: p0.y + dyY
          });
          segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
            x: p1.x + dyX,
            y: p1.y + dyY
          });
        }
        offset += glyphWidth;
        return {
          offset,
          segment,
          rotation
        };
      }
      measureText(ctx, text) {
        var {
          measuresCache
        } = this;
        var targetText = text || this.getText();
        if (measuresCache.has(targetText)) {
          return measuresCache.get(targetText);
        }
        var measure = this.measureTargetText(ctx, targetText);
        measuresCache.set(targetText, measure);
        return measure;
      }
      // This method supposes what all custom fonts already loaded.
      // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
      // You need to call this method manually to update glyphs cache.
      setTextData(ctx) {
        if (this.glyphInfo) {
          return;
        }
        var renderText = this.getText();
        var chars2 = renderText.split("");
        var spacesNumber = renderText.split(" ").length - 1;
        var dx = this.parent.getAttribute("dx").split().map((_3) => _3.getPixels("x"));
        var dy = this.parent.getAttribute("dy").getPixels("y");
        var anchor = this.parent.getStyle("text-anchor").getString("start");
        var thisSpacing = this.getStyle("letter-spacing");
        var parentSpacing = this.parent.getStyle("letter-spacing");
        var letterSpacing = 0;
        if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
          letterSpacing = parentSpacing.getPixels();
        } else if (thisSpacing.hasValue()) {
          if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
            letterSpacing = thisSpacing.getPixels();
          }
        }
        var letterSpacingCache = [];
        var textLen = renderText.length;
        this.letterSpacingCache = letterSpacingCache;
        for (var i3 = 0; i3 < textLen; i3++) {
          letterSpacingCache.push(typeof dx[i3] !== "undefined" ? dx[i3] : letterSpacing);
        }
        var dxSum = letterSpacingCache.reduce((acc, cur, i4) => i4 === 0 ? 0 : acc + cur || 0, 0);
        var textWidth = this.measureText(ctx);
        var textFullWidth = Math.max(textWidth + dxSum, 0);
        this.textWidth = textWidth;
        this.textHeight = this.getFontSize();
        this.glyphInfo = [];
        var fullPathWidth = this.getPathLength();
        var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
        var offset = 0;
        if (anchor === "middle" || anchor === "center") {
          offset = -textFullWidth / 2;
        }
        if (anchor === "end" || anchor === "right") {
          offset = -textFullWidth;
        }
        offset += startOffset;
        chars2.forEach((char, i4) => {
          var {
            offset: nextOffset,
            segment,
            rotation
          } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i4);
          offset = nextOffset;
          if (!segment.p0 || !segment.p1) {
            return;
          }
          this.glyphInfo.push({
            // transposeX: midpoint.x,
            // transposeY: midpoint.y,
            text: chars2[i4],
            p0: segment.p0,
            p1: segment.p1,
            rotation
          });
        });
      }
      parsePathData(path) {
        this.pathLength = -1;
        if (!path) {
          return [];
        }
        var pathCommands = [];
        var {
          pathParser
        } = path;
        pathParser.reset();
        while (!pathParser.isEnd()) {
          var {
            current
          } = pathParser;
          var startX = current ? current.x : 0;
          var startY = current ? current.y : 0;
          var command = pathParser.next();
          var nextCommandType = command.type;
          var points2 = [];
          switch (command.type) {
            case PathParser.MOVE_TO:
              this.pathM(pathParser, points2);
              break;
            case PathParser.LINE_TO:
              nextCommandType = this.pathL(pathParser, points2);
              break;
            case PathParser.HORIZ_LINE_TO:
              nextCommandType = this.pathH(pathParser, points2);
              break;
            case PathParser.VERT_LINE_TO:
              nextCommandType = this.pathV(pathParser, points2);
              break;
            case PathParser.CURVE_TO:
              this.pathC(pathParser, points2);
              break;
            case PathParser.SMOOTH_CURVE_TO:
              nextCommandType = this.pathS(pathParser, points2);
              break;
            case PathParser.QUAD_TO:
              this.pathQ(pathParser, points2);
              break;
            case PathParser.SMOOTH_QUAD_TO:
              nextCommandType = this.pathT(pathParser, points2);
              break;
            case PathParser.ARC:
              points2 = this.pathA(pathParser);
              break;
            case PathParser.CLOSE_PATH:
              PathElement.pathZ(pathParser);
              break;
          }
          if (command.type !== PathParser.CLOSE_PATH) {
            pathCommands.push({
              type: nextCommandType,
              points: points2,
              start: {
                x: startX,
                y: startY
              },
              pathLength: this.calcLength(startX, startY, nextCommandType, points2)
            });
          } else {
            pathCommands.push({
              type: PathParser.CLOSE_PATH,
              points: [],
              pathLength: 0
            });
          }
        }
        return pathCommands;
      }
      pathM(pathParser, points2) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathM(pathParser).point;
        points2.push(x2, y3);
      }
      pathL(pathParser, points2) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathL(pathParser).point;
        points2.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathH(pathParser, points2) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathH(pathParser).point;
        points2.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathV(pathParser, points2) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathV(pathParser).point;
        points2.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathC(pathParser, points2) {
        var {
          point,
          controlPoint,
          currentPoint
        } = PathElement.pathC(pathParser);
        points2.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
      pathS(pathParser, points2) {
        var {
          point,
          controlPoint,
          currentPoint
        } = PathElement.pathS(pathParser);
        points2.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        return PathParser.CURVE_TO;
      }
      pathQ(pathParser, points2) {
        var {
          controlPoint,
          currentPoint
        } = PathElement.pathQ(pathParser);
        points2.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
      pathT(pathParser, points2) {
        var {
          controlPoint,
          currentPoint
        } = PathElement.pathT(pathParser);
        points2.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        return PathParser.QUAD_TO;
      }
      pathA(pathParser) {
        var {
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        } = PathElement.pathA(pathParser);
        if (sweepFlag === 0 && ad > 0) {
          ad -= 2 * Math.PI;
        }
        if (sweepFlag === 1 && ad < 0) {
          ad += 2 * Math.PI;
        }
        return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
      }
      calcLength(x2, y3, commandType, points2) {
        var len = 0;
        var p1 = null;
        var p22 = null;
        var t3 = 0;
        switch (commandType) {
          case PathParser.LINE_TO:
            return this.getLineLength(x2, y3, points2[0], points2[1]);
          case PathParser.CURVE_TO:
            len = 0;
            p1 = this.getPointOnCubicBezier(0, x2, y3, points2[0], points2[1], points2[2], points2[3], points2[4], points2[5]);
            for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
              p22 = this.getPointOnCubicBezier(t3, x2, y3, points2[0], points2[1], points2[2], points2[3], points2[4], points2[5]);
              len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
              p1 = p22;
            }
            return len;
          case PathParser.QUAD_TO:
            len = 0;
            p1 = this.getPointOnQuadraticBezier(0, x2, y3, points2[0], points2[1], points2[2], points2[3]);
            for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
              p22 = this.getPointOnQuadraticBezier(t3, x2, y3, points2[0], points2[1], points2[2], points2[3]);
              len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
              p1 = p22;
            }
            return len;
          case PathParser.ARC: {
            len = 0;
            var start = points2[4];
            var dTheta = points2[5];
            var end = points2[4] + dTheta;
            var inc = Math.PI / 180;
            if (Math.abs(start - end) < inc) {
              inc = Math.abs(start - end);
            }
            p1 = this.getPointOnEllipticalArc(points2[0], points2[1], points2[2], points2[3], start, 0);
            if (dTheta < 0) {
              for (t3 = start - inc; t3 > end; t3 -= inc) {
                p22 = this.getPointOnEllipticalArc(points2[0], points2[1], points2[2], points2[3], t3, 0);
                len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
                p1 = p22;
              }
            } else {
              for (t3 = start + inc; t3 < end; t3 += inc) {
                p22 = this.getPointOnEllipticalArc(points2[0], points2[1], points2[2], points2[3], t3, 0);
                len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
                p1 = p22;
              }
            }
            p22 = this.getPointOnEllipticalArc(points2[0], points2[1], points2[2], points2[3], end, 0);
            len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
            return len;
          }
        }
        return 0;
      }
      getPointOnLine(dist, p1x, p1y, p2x, p2y) {
        var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
        var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
        var m4 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
        var run2 = Math.sqrt(dist * dist / (1 + m4 * m4));
        if (p2x < p1x) {
          run2 *= -1;
        }
        var rise = m4 * run2;
        var pt2 = null;
        if (p2x === p1x) {
          pt2 = {
            x: fromX,
            y: fromY + rise
          };
        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m4) {
          pt2 = {
            x: fromX + run2,
            y: fromY + rise
          };
        } else {
          var ix = 0;
          var iy = 0;
          var len = this.getLineLength(p1x, p1y, p2x, p2y);
          if (len < PSEUDO_ZERO) {
            return null;
          }
          var u3 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
          u3 /= len * len;
          ix = p1x + u3 * (p2x - p1x);
          iy = p1y + u3 * (p2y - p1y);
          var pRise = this.getLineLength(fromX, fromY, ix, iy);
          var pRun = Math.sqrt(dist * dist - pRise * pRise);
          run2 = Math.sqrt(pRun * pRun / (1 + m4 * m4));
          if (p2x < p1x) {
            run2 *= -1;
          }
          rise = m4 * run2;
          pt2 = {
            x: ix + run2,
            y: iy + rise
          };
        }
        return pt2;
      }
      getPointOnPath(distance) {
        var fullLen = this.getPathLength();
        var cumulativePathLength = 0;
        var p3 = null;
        if (distance < -5e-5 || distance - 5e-5 > fullLen) {
          return null;
        }
        var {
          dataArray
        } = this;
        for (var command of dataArray) {
          if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance)) {
            cumulativePathLength += command.pathLength;
            continue;
          }
          var delta = distance - cumulativePathLength;
          var currentT = 0;
          switch (command.type) {
            case PathParser.LINE_TO:
              p3 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
              break;
            case PathParser.ARC: {
              var start = command.points[4];
              var dTheta = command.points[5];
              var end = command.points[4] + dTheta;
              currentT = start + delta / command.pathLength * dTheta;
              if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                break;
              }
              p3 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
              break;
            }
            case PathParser.CURVE_TO:
              currentT = delta / command.pathLength;
              if (currentT > 1) {
                currentT = 1;
              }
              p3 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
              break;
            case PathParser.QUAD_TO:
              currentT = delta / command.pathLength;
              if (currentT > 1) {
                currentT = 1;
              }
              p3 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
              break;
          }
          if (p3) {
            return p3;
          }
          break;
        }
        return null;
      }
      getLineLength(x1, y1, x2, y22) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y22 - y1) * (y22 - y1));
      }
      getPathLength() {
        if (this.pathLength === -1) {
          this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
        }
        return this.pathLength;
      }
      getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
        var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
        var y3 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
        return {
          x: x2,
          y: y3
        };
      }
      getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
        var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
        var y3 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
        return {
          x: x2,
          y: y3
        };
      }
      getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi);
        var sinPsi = Math.sin(psi);
        var pt2 = {
          x: rx * Math.cos(theta),
          y: ry * Math.sin(theta)
        };
        return {
          x: cx + (pt2.x * cosPsi - pt2.y * sinPsi),
          y: cy + (pt2.x * sinPsi + pt2.y * cosPsi)
        };
      }
      // TODO need some optimisations. possibly build cache only for curved segments?
      buildEquidistantCache(inputStep, inputPrecision) {
        var fullLen = this.getPathLength();
        var precision = inputPrecision || 0.25;
        var step = inputStep || fullLen / 100;
        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
          this.equidistantCache = {
            step,
            precision,
            points: []
          };
          var s3 = 0;
          for (var l3 = 0; l3 <= fullLen; l3 += precision) {
            var p0 = this.getPointOnPath(l3);
            var p1 = this.getPointOnPath(l3 + precision);
            if (!p0 || !p1) {
              continue;
            }
            s3 += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
            if (s3 >= step) {
              this.equidistantCache.points.push({
                x: p0.x,
                y: p0.y,
                distance: l3
              });
              s3 -= step;
            }
          }
        }
      }
      getEquidistantPointOnPath(targetDistance, step, precision) {
        this.buildEquidistantCache(step, precision);
        if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
          return null;
        }
        var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
        return this.equidistantCache.points[idx] || null;
      }
    };
    dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
    ImageElement = class extends RenderedElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "image";
        this.loaded = false;
        var href = this.getHrefAttribute().getString();
        if (!href) {
          return;
        }
        var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
        document2.images.push(this);
        if (!isSvg) {
          void this.loadImage(href);
        } else {
          void this.loadSvg(href);
        }
        this.isSvg = isSvg;
      }
      loadImage(href) {
        var _this = this;
        return _asyncToGenerator(function* () {
          try {
            var image = yield _this.document.createImage(href);
            _this.image = image;
          } catch (err3) {
            console.error('Error while loading image "'.concat(href, '":'), err3);
          }
          _this.loaded = true;
        })();
      }
      loadSvg(href) {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          var match = dataUriRegex.exec(href);
          if (match) {
            var data = match[5];
            if (match[4] === "base64") {
              _this2.image = atob(data);
            } else {
              _this2.image = decodeURIComponent(data);
            }
          } else {
            try {
              var response = yield _this2.document.fetch(href);
              var svg = yield response.text();
              _this2.image = svg;
            } catch (err3) {
              console.error('Error while loading image "'.concat(href, '":'), err3);
            }
          }
          _this2.loaded = true;
        })();
      }
      renderChildren(ctx) {
        var {
          document: document2,
          image,
          loaded
        } = this;
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width = this.getStyle("width").getPixels("x");
        var height = this.getStyle("height").getPixels("y");
        if (!loaded || !image || !width || !height) {
          return;
        }
        ctx.save();
        ctx.translate(x2, y3);
        if (this.isSvg) {
          var subDocument = document2.canvg.forkString(ctx, this.image, {
            ignoreMouse: true,
            ignoreAnimation: true,
            ignoreDimensions: true,
            ignoreClear: true,
            offsetX: 0,
            offsetY: 0,
            scaleWidth: width,
            scaleHeight: height
          });
          subDocument.document.documentElement.parent = this;
          void subDocument.render();
        } else {
          var _image = this.image;
          document2.setViewBox({
            ctx,
            aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
            width,
            desiredWidth: _image.width,
            height,
            desiredHeight: _image.height
          });
          if (this.loaded) {
            if (typeof _image.complete === "undefined" || _image.complete) {
              ctx.drawImage(_image, 0, 0);
            }
          }
        }
        ctx.restore();
      }
      getBoundingBox() {
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width = this.getStyle("width").getPixels("x");
        var height = this.getStyle("height").getPixels("y");
        return new BoundingBox(x2, y3, x2 + width, y3 + height);
      }
    };
    SymbolElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "symbol";
      }
      render(_3) {
      }
    };
    SVGFontLoader = class {
      constructor(document2) {
        this.document = document2;
        this.loaded = false;
        document2.fonts.push(this);
      }
      load(fontFamily, url) {
        var _this = this;
        return _asyncToGenerator(function* () {
          try {
            var {
              document: document2
            } = _this;
            var svgDocument = yield document2.canvg.parser.load(url);
            var fonts = svgDocument.getElementsByTagName("font");
            Array.from(fonts).forEach((fontNode) => {
              var font = document2.createElement(fontNode);
              document2.definitions[fontFamily] = font;
            });
          } catch (err3) {
            console.error('Error while loading font "'.concat(url, '":'), err3);
          }
          _this.loaded = true;
        })();
      }
    };
    StyleElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "style";
        var css = compressSpaces(
          Array.from(node2.childNodes).map((_3) => _3.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
          // remove imports
        );
        var cssDefs = css.split("}");
        cssDefs.forEach((_3) => {
          var def = _3.trim();
          if (!def) {
            return;
          }
          var cssParts = def.split("{");
          var cssClasses = cssParts[0].split(",");
          var cssProps = cssParts[1].split(";");
          cssClasses.forEach((_4) => {
            var cssClass = _4.trim();
            if (!cssClass) {
              return;
            }
            var props = document2.styles[cssClass] || {};
            cssProps.forEach((cssProp) => {
              var prop = cssProp.indexOf(":");
              var name = cssProp.substr(0, prop).trim();
              var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
              if (name && value) {
                props[name] = new Property(document2, name, value);
              }
            });
            document2.styles[cssClass] = props;
            document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
            if (cssClass === "@font-face") {
              var fontFamily = props["font-family"].getString().replace(/"|'/g, "");
              var srcs = props.src.getString().split(",");
              srcs.forEach((src) => {
                if (src.indexOf('format("svg")') > 0) {
                  var url = parseExternalUrl(src);
                  if (url) {
                    void new SVGFontLoader(document2).load(fontFamily, url);
                  }
                }
              });
            }
          });
        });
      }
    };
    StyleElement.parseExternalUrl = parseExternalUrl;
    UseElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "use";
      }
      setContext(ctx) {
        super.setContext(ctx);
        var xAttr = this.getAttribute("x");
        var yAttr = this.getAttribute("y");
        if (xAttr.hasValue()) {
          ctx.translate(xAttr.getPixels("x"), 0);
        }
        if (yAttr.hasValue()) {
          ctx.translate(0, yAttr.getPixels("y"));
        }
      }
      path(ctx) {
        var {
          element
        } = this;
        if (element) {
          element.path(ctx);
        }
      }
      renderChildren(ctx) {
        var {
          document: document2,
          element
        } = this;
        if (element) {
          var tempSvg = element;
          if (element.type === "symbol") {
            tempSvg = new SVGElement(document2, null);
            tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
            tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
            tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
            tempSvg.children = element.children;
            element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
          }
          if (tempSvg.type === "svg") {
            var widthStyle = this.getStyle("width", false, true);
            var heightStyle = this.getStyle("height", false, true);
            if (widthStyle.hasValue()) {
              tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
            }
            if (heightStyle.hasValue()) {
              tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
            }
          }
          var oldParent = tempSvg.parent;
          tempSvg.parent = this;
          tempSvg.render(ctx);
          tempSvg.parent = oldParent;
        }
      }
      getBoundingBox(ctx) {
        var {
          element
        } = this;
        if (element) {
          return element.getBoundingBox(ctx);
        }
        return null;
      }
      elementTransform() {
        var {
          document: document2,
          element
        } = this;
        return Transform.fromElement(document2, element);
      }
      get element() {
        if (!this.cachedElement) {
          this.cachedElement = this.getHrefAttribute().getDefinition();
        }
        return this.cachedElement;
      }
    };
    FeColorMatrixElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "feColorMatrix";
        var matrix2 = toNumbers(this.getAttribute("values").getString());
        switch (this.getAttribute("type").getString("matrix")) {
          case "saturate": {
            var s3 = matrix2[0];
            matrix2 = [0.213 + 0.787 * s3, 0.715 - 0.715 * s3, 0.072 - 0.072 * s3, 0, 0, 0.213 - 0.213 * s3, 0.715 + 0.285 * s3, 0.072 - 0.072 * s3, 0, 0, 0.213 - 0.213 * s3, 0.715 - 0.715 * s3, 0.072 + 0.928 * s3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            break;
          }
          case "hueRotate": {
            var a3 = matrix2[0] * Math.PI / 180;
            matrix2 = [c2(a3, 0.213, 0.787, -0.213), c2(a3, 0.715, -0.715, -0.715), c2(a3, 0.072, -0.072, 0.928), 0, 0, c2(a3, 0.213, -0.213, 0.143), c2(a3, 0.715, 0.285, 0.14), c2(a3, 0.072, -0.072, -0.283), 0, 0, c2(a3, 0.213, -0.213, -0.787), c2(a3, 0.715, -0.715, 0.715), c2(a3, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            break;
          }
          case "luminanceToAlpha":
            matrix2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
            break;
        }
        this.matrix = matrix2;
        this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
      }
      apply(ctx, _x, _y, width, height) {
        var {
          includeOpacity,
          matrix: matrix2
        } = this;
        var srcData = ctx.getImageData(0, 0, width, height);
        for (var y3 = 0; y3 < height; y3++) {
          for (var x2 = 0; x2 < width; x2++) {
            var r2 = imGet(srcData.data, x2, y3, width, height, 0);
            var g2 = imGet(srcData.data, x2, y3, width, height, 1);
            var b2 = imGet(srcData.data, x2, y3, width, height, 2);
            var a3 = imGet(srcData.data, x2, y3, width, height, 3);
            var nr = m2(matrix2, 0, r2) + m2(matrix2, 1, g2) + m2(matrix2, 2, b2) + m2(matrix2, 3, a3) + m2(matrix2, 4, 1);
            var ng = m2(matrix2, 5, r2) + m2(matrix2, 6, g2) + m2(matrix2, 7, b2) + m2(matrix2, 8, a3) + m2(matrix2, 9, 1);
            var nb = m2(matrix2, 10, r2) + m2(matrix2, 11, g2) + m2(matrix2, 12, b2) + m2(matrix2, 13, a3) + m2(matrix2, 14, 1);
            var na = m2(matrix2, 15, r2) + m2(matrix2, 16, g2) + m2(matrix2, 17, b2) + m2(matrix2, 18, a3) + m2(matrix2, 19, 1);
            if (includeOpacity) {
              nr = 0;
              ng = 0;
              nb = 0;
              na *= a3 / 255;
            }
            imSet(srcData.data, x2, y3, width, height, 0, nr);
            imSet(srcData.data, x2, y3, width, height, 1, ng);
            imSet(srcData.data, x2, y3, width, height, 2, nb);
            imSet(srcData.data, x2, y3, width, height, 3, na);
          }
        }
        ctx.clearRect(0, 0, width, height);
        ctx.putImageData(srcData, 0, 0);
      }
    };
    MaskElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "mask";
      }
      apply(ctx, element) {
        var {
          document: document2
        } = this;
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width = this.getStyle("width").getPixels("x");
        var height = this.getStyle("height").getPixels("y");
        if (!width && !height) {
          var boundingBox = new BoundingBox();
          this.children.forEach((child) => {
            boundingBox.addBoundingBox(child.getBoundingBox(ctx));
          });
          x2 = Math.floor(boundingBox.x1);
          y3 = Math.floor(boundingBox.y1);
          width = Math.floor(boundingBox.width);
          height = Math.floor(boundingBox.height);
        }
        var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
        var maskCanvas = document2.createCanvas(x2 + width, y3 + height);
        var maskCtx = maskCanvas.getContext("2d");
        document2.screen.setDefaults(maskCtx);
        this.renderChildren(maskCtx);
        new FeColorMatrixElement(document2, {
          nodeType: 1,
          childNodes: [],
          attributes: [{
            nodeName: "type",
            value: "luminanceToAlpha"
          }, {
            nodeName: "includeOpacity",
            value: "true"
          }]
        }).apply(maskCtx, 0, 0, x2 + width, y3 + height);
        var tmpCanvas = document2.createCanvas(x2 + width, y3 + height);
        var tmpCtx = tmpCanvas.getContext("2d");
        document2.screen.setDefaults(tmpCtx);
        element.render(tmpCtx);
        tmpCtx.globalCompositeOperation = "destination-in";
        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
        tmpCtx.fillRect(0, 0, x2 + width, y3 + height);
        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
        ctx.fillRect(0, 0, x2 + width, y3 + height);
        this.restoreStyles(element, ignoredStyles);
      }
      render(_3) {
      }
    };
    MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
    noop = () => {
    };
    ClipPathElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "clipPath";
      }
      apply(ctx) {
        var {
          document: document2
        } = this;
        var contextProto = Reflect.getPrototypeOf(ctx);
        var {
          beginPath,
          closePath
        } = ctx;
        if (contextProto) {
          contextProto.beginPath = noop;
          contextProto.closePath = noop;
        }
        Reflect.apply(beginPath, ctx, []);
        this.children.forEach((child) => {
          if (typeof child.path === "undefined") {
            return;
          }
          var transform = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
          if (!transform) {
            transform = Transform.fromElement(document2, child);
          }
          if (transform) {
            transform.apply(ctx);
          }
          child.path(ctx);
          if (contextProto) {
            contextProto.closePath = closePath;
          }
          if (transform) {
            transform.unapply(ctx);
          }
        });
        Reflect.apply(closePath, ctx, []);
        ctx.clip();
        if (contextProto) {
          contextProto.beginPath = beginPath;
          contextProto.closePath = closePath;
        }
      }
      render(_3) {
      }
    };
    FilterElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "filter";
      }
      apply(ctx, element) {
        var {
          document: document2,
          children
        } = this;
        var boundingBox = element.getBoundingBox(ctx);
        if (!boundingBox) {
          return;
        }
        var px = 0;
        var py = 0;
        children.forEach((child) => {
          var efd = child.extraFilterDistance || 0;
          px = Math.max(px, efd);
          py = Math.max(py, efd);
        });
        var width = Math.floor(boundingBox.width);
        var height = Math.floor(boundingBox.height);
        var tmpCanvasWidth = width + 2 * px;
        var tmpCanvasHeight = height + 2 * py;
        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
          return;
        }
        var x2 = Math.floor(boundingBox.x);
        var y3 = Math.floor(boundingBox.y);
        var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
        var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
        var tmpCtx = tmpCanvas.getContext("2d");
        document2.screen.setDefaults(tmpCtx);
        tmpCtx.translate(-x2 + px, -y3 + py);
        element.render(tmpCtx);
        children.forEach((child) => {
          if (typeof child.apply === "function") {
            child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
          }
        });
        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y3 - py, tmpCanvasWidth, tmpCanvasHeight);
        this.restoreStyles(element, ignoredStyles);
      }
      render(_3) {
      }
    };
    FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
    FeDropShadowElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "feDropShadow";
        this.addStylesFromStyleDefinition();
      }
      apply(_3, _x, _y, _width, _height) {
      }
    };
    FeMorphologyElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "feMorphology";
      }
      apply(_3, _x, _y, _width, _height) {
      }
    };
    FeCompositeElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "feComposite";
      }
      apply(_3, _x, _y, _width, _height) {
      }
    };
    FeGaussianBlurElement = class extends Element {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "feGaussianBlur";
        this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
        this.extraFilterDistance = this.blurRadius;
      }
      apply(ctx, x2, y3, width, height) {
        var {
          document: document2,
          blurRadius
        } = this;
        var body = document2.window ? document2.window.document.body : null;
        var canvas = ctx.canvas;
        canvas.id = document2.getUniqueId();
        if (body) {
          canvas.style.display = "none";
          body.appendChild(canvas);
        }
        processCanvasRGBA(canvas, x2, y3, width, height, blurRadius);
        if (body) {
          body.removeChild(canvas);
        }
      }
    };
    TitleElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "title";
      }
    };
    DescElement = class extends Element {
      constructor() {
        super(...arguments);
        this.type = "desc";
      }
    };
    elements = {
      "svg": SVGElement,
      "rect": RectElement,
      "circle": CircleElement,
      "ellipse": EllipseElement,
      "line": LineElement,
      "polyline": PolylineElement,
      "polygon": PolygonElement,
      "path": PathElement,
      "pattern": PatternElement,
      "marker": MarkerElement,
      "defs": DefsElement,
      "linearGradient": LinearGradientElement,
      "radialGradient": RadialGradientElement,
      "stop": StopElement,
      "animate": AnimateElement,
      "animateColor": AnimateColorElement,
      "animateTransform": AnimateTransformElement,
      "font": FontElement,
      "font-face": FontFaceElement,
      "missing-glyph": MissingGlyphElement,
      "glyph": GlyphElement,
      "text": TextElement,
      "tspan": TSpanElement,
      "tref": TRefElement,
      "a": AElement,
      "textPath": TextPathElement,
      "image": ImageElement,
      "g": GElement,
      "symbol": SymbolElement,
      "style": StyleElement,
      "use": UseElement,
      "mask": MaskElement,
      "clipPath": ClipPathElement,
      "filter": FilterElement,
      "feDropShadow": FeDropShadowElement,
      "feMorphology": FeMorphologyElement,
      "feComposite": FeCompositeElement,
      "feColorMatrix": FeColorMatrixElement,
      "feGaussianBlur": FeGaussianBlurElement,
      "title": TitleElement,
      "desc": DescElement
    };
    Document = class {
      constructor(canvg) {
        var {
          rootEmSize = 12,
          emSize = 12,
          createCanvas: createCanvas3 = Document.createCanvas,
          createImage: createImage2 = Document.createImage,
          anonymousCrossOrigin
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.canvg = canvg;
        this.definitions = {};
        this.styles = {};
        this.stylesSpecificity = {};
        this.images = [];
        this.fonts = [];
        this.emSizeStack = [];
        this.uniqueId = 0;
        this.screen = canvg.screen;
        this.rootEmSize = rootEmSize;
        this.emSize = emSize;
        this.createCanvas = createCanvas3;
        this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
        this.screen.wait(this.isImagesLoaded.bind(this));
        this.screen.wait(this.isFontsLoaded.bind(this));
      }
      bindCreateImage(createImage2, anonymousCrossOrigin) {
        if (typeof anonymousCrossOrigin === "boolean") {
          return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
        }
        return createImage2;
      }
      get window() {
        return this.screen.window;
      }
      get fetch() {
        return this.screen.fetch;
      }
      get ctx() {
        return this.screen.ctx;
      }
      get emSize() {
        var {
          emSizeStack
        } = this;
        return emSizeStack[emSizeStack.length - 1];
      }
      set emSize(value) {
        var {
          emSizeStack
        } = this;
        emSizeStack.push(value);
      }
      popEmSize() {
        var {
          emSizeStack
        } = this;
        emSizeStack.pop();
      }
      getUniqueId() {
        return "canvg".concat(++this.uniqueId);
      }
      isImagesLoaded() {
        return this.images.every((_3) => _3.loaded);
      }
      isFontsLoaded() {
        return this.fonts.every((_3) => _3.loaded);
      }
      createDocumentElement(document2) {
        var documentElement = this.createElement(document2.documentElement);
        documentElement.root = true;
        documentElement.addStylesFromStyleDefinition();
        this.documentElement = documentElement;
        return documentElement;
      }
      createElement(node2) {
        var elementType = node2.nodeName.replace(/^[^:]+:/, "");
        var ElementType = Document.elementTypes[elementType];
        if (typeof ElementType !== "undefined") {
          return new ElementType(this, node2);
        }
        return new UnknownElement(this, node2);
      }
      createTextNode(node2) {
        return new TextNode(this, node2);
      }
      setViewBox(config) {
        this.screen.setViewBox(_objectSpread$1({
          document: this
        }, config));
      }
    };
    Document.createCanvas = createCanvas2;
    Document.createImage = createImage;
    Document.elementTypes = elements;
    Canvg = class {
      /**
       * Main constructor.
       * @param ctx - Rendering context.
       * @param svg - SVG Document.
       * @param options - Rendering options.
       */
      constructor(ctx, svg) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        this.parser = new Parser(options);
        this.screen = new Screen(ctx, options);
        this.options = options;
        var document2 = new Document(this, options);
        var documentElement = document2.createDocumentElement(svg);
        this.document = document2;
        this.documentElement = documentElement;
      }
      /**
       * Create Canvg instance from SVG source string or URL.
       * @param ctx - Rendering context.
       * @param svg - SVG source string or URL.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      static from(ctx, svg) {
        var _arguments = arguments;
        return _asyncToGenerator(function* () {
          var options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
          var parser = new Parser(options);
          var svgDocument = yield parser.parse(svg);
          return new Canvg(ctx, svgDocument, options);
        })();
      }
      /**
       * Create Canvg instance from SVG source string.
       * @param ctx - Rendering context.
       * @param svg - SVG source string.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      static fromString(ctx, svg) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var parser = new Parser(options);
        var svgDocument = parser.parseFromString(svg);
        return new Canvg(ctx, svgDocument, options);
      }
      /**
       * Create new Canvg instance with inherited options.
       * @param ctx - Rendering context.
       * @param svg - SVG source string or URL.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      fork(ctx, svg) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
      }
      /**
       * Create new Canvg instance with inherited options.
       * @param ctx - Rendering context.
       * @param svg - SVG source string.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      forkString(ctx, svg) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
      }
      /**
       * Document is ready promise.
       * @returns Ready promise.
       */
      ready() {
        return this.screen.ready();
      }
      /**
       * Document is ready value.
       * @returns Is ready or not.
       */
      isReady() {
        return this.screen.isReady();
      }
      /**
       * Render only first frame, ignoring animations and mouse.
       * @param options - Rendering options.
       */
      render() {
        var _arguments2 = arguments, _this = this;
        return _asyncToGenerator(function* () {
          var options = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};
          _this.start(_objectSpread({
            enableRedraw: true,
            ignoreAnimation: true,
            ignoreMouse: true
          }, options));
          yield _this.ready();
          _this.stop();
        })();
      }
      /**
       * Start rendering.
       * @param options - Render options.
       */
      start() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var {
          documentElement,
          screen,
          options: baseOptions
        } = this;
        screen.start(documentElement, _objectSpread(_objectSpread({
          enableRedraw: true
        }, baseOptions), options));
      }
      /**
       * Stop rendering.
       */
      stop() {
        this.screen.stop();
      }
      /**
       * Resize SVG to fit in given size.
       * @param width
       * @param height
       * @param preserveAspectRatio
       */
      resize(width) {
        var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.documentElement.resize(width, height, preserveAspectRatio);
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ImageConverter: () => ImageConverter,
  SupernoteView: () => SupernoteView,
  VIEW_TYPE_SUPERNOTE: () => VIEW_TYPE_SUPERNOTE,
  WorkerPool: () => WorkerPool,
  default: () => SupernotePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// supernote-typescript/src/parsing.ts
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function readUintLE(data, offset, byteLength) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  checkOffset(offset, byteLength, data.length);
  let val = data[offset];
  let mul = 1;
  let i3 = 0;
  while (++i3 < byteLength && (mul *= 256)) {
    val += data[offset + i3] * mul;
  }
  return val;
}
function getContentAtAddress(buffer, address, byteLength) {
  if (address === 0)
    return null;
  const blockLength = readUintLE(buffer, address, byteLength);
  const content = buffer.subarray(
    address + byteLength,
    address + byteLength + blockLength
  );
  return content;
}
function parseKeyValue(buffer, address, byteLength) {
  const content = getContentAtAddress(buffer, address, byteLength);
  if (content === null)
    return {};
  const str = uint8ArrayToString(content);
  return extractKeyValue(str);
}
function extractKeyValue(content) {
  const pattern = /<([^:<>]+):([^:<>]+)>/gm;
  const pairs = [...content.matchAll(pattern)];
  const data = pairs.reduce(
    (acc, [_3, key, value]) => {
      if (key in acc) {
        let newValue = typeof acc[key] === "string" ? [acc[key], value] : [...acc[key], value];
        acc[key] = newValue;
      } else {
        acc[key] = value;
      }
      return acc;
    },
    {}
  );
  return data;
}
function extractNestedKeyValue(record, delimiter = "_", prefixes = []) {
  const data = {};
  Object.entries(record).forEach(([key, value]) => {
    let main;
    let sub;
    if (typeof value !== "string")
      return;
    const idx = key.indexOf(delimiter);
    if (idx > -1) {
      main = key.substring(0, idx);
      sub = key.substring(idx + 1);
    } else {
      for (const prefix of prefixes) {
        if (!key.startsWith(prefix))
          continue;
        main = prefix;
        sub = key.substring(main.length);
        break;
      }
    }
    if (!(main && sub))
      return;
    if (main in data)
      data[main][sub] = value;
    else
      data[main] = { [sub]: value };
  });
  return data;
}
function extractLayerInfo(content) {
  const layerPattern = /{(?<content>[^{}]+)}/gm;
  const dictPattern = /"(?<key>[^"\[{}\]]+)"#"?(?<value>[^"\[{}\],]+)/gm;
  const layerContents = Array.from(content.matchAll(layerPattern));
  const layerInfos = layerContents.map((match) => {
    var _a2, _b2;
    if (match.groups === void 0)
      throw new Error("Undefined layer content.");
    const layerDictContents = Array.from(
      match.groups.content.matchAll(dictPattern)
    );
    const data = layerDictContents.reduce(
      (acc, match2) => {
        if (match2.groups === void 0)
          throw new Error("Undefined key/value pair.");
        const { key, value } = match2.groups;
        acc[key] = value;
        return acc;
      },
      {}
    );
    const layerInfo = {
      layerId: parseInt((_a2 = data.layerId) != null ? _a2 : "0"),
      name: (_b2 = data.name) != null ? _b2 : "Main layer",
      isBackgroundLayer: data.isBackgroundLayer === "true",
      isAllowAdd: data.isAllowAdd === "true",
      isCurrentLayer: data.isCurrentLayer === "true",
      isVisible: data.isVisible === "true",
      isDeleted: data.isDeleted === "true",
      isAllowUp: data.isAllowUp === "true",
      isAllowDown: data.isAllowDown === "true"
    };
    return layerInfo;
  });
  return layerInfos;
}
function uint8ArrayToString(uint8Array, encoding = "utf8", start = 0, end) {
  end = end || uint8Array.length;
  const slicedArray = uint8Array.slice(start, end);
  const decoder = new TextDecoder(encoding);
  return decoder.decode(slicedArray);
}
var SupernoteX = class {
  constructor(buffer) {
    this.pageWidth = 1404;
    this.pageHeight = 1872;
    this.addressSize = 4;
    this.lengthFieldSize = 4;
    this.defaultLayers = ["MAINLAYER", "LAYER1", "LAYER2", "LAYER3", "BGLAYER"];
    this._parseBuffer(buffer);
  }
  /** Parse note contents from buffer. */
  _parseBuffer(buffer) {
    this._parseSignature(buffer);
    this._parseFooter(buffer);
    this._parseHeader(buffer);
    if (this.header.APPLY_EQUIPMENT == "N5") {
      this.pageWidth = 1920;
      this.pageHeight = 2560;
    }
    this._parsePages(buffer);
    this._parseCover(buffer);
    this._parseKeywords(buffer);
    this._parseTitles(buffer);
    return this;
  }
  /** Parse Supernote file signature from buffer. */
  _parseSignature(buffer) {
    const pattern = /^noteSN_FILE_VER_(\d{8})/;
    const content = uint8ArrayToString(buffer, "utf8", 0, 24);
    const match = content.match(pattern);
    if (!match)
      throw new Error("Cannot parse this file. Signature doesn't match.");
    this.signature = content;
    this.version = parseFloat(match[1]);
    return this.signature;
  }
  /** Parse the footer of a Supernote file's buffer contents. */
  _parseFooter(buffer) {
    const chunk = buffer.subarray(buffer.length - this.addressSize);
    const address = readUintLE(chunk, 0, this.addressSize);
    const data = parseKeyValue(buffer, address, this.lengthFieldSize);
    const nested = extractNestedKeyValue(data, "_", ["PAGE"]);
    this.footer = {
      FILE: { FEATURE: "24" },
      COVER: { "0": "0" },
      KEYWORD: {},
      TITLE: {},
      STYLE: {},
      PAGE: {},
      ...nested
    };
    return this.footer;
  }
  /** Parse the header of a Supernote file's buffer contents.
   * Relies on the address as given in the file's footer. */
  _parseHeader(buffer) {
    var _a2;
    const address = ((_a2 = this.footer.FILE) == null ? void 0 : _a2.FEATURE) ? parseInt(this.footer.FILE.FEATURE) : 24;
    const data = parseKeyValue(buffer, address, this.lengthFieldSize);
    this.header = {
      MODULE_LABEL: "0",
      FILE_TYPE: "0",
      APPLY_EQUIPMENT: "0",
      FINAL_OPERATION_PAGE: "0",
      FINAL_OPERATION_LAYER: "0",
      ORIGINAL_STYLE: "0",
      ORIGINAL_STYLEMD5: "0",
      DEVICE_DPI: "0",
      SOFT_DPI: "0",
      FILE_PARSE_TYPE: "0",
      RATTA_ETMD: "0",
      APP_VERSION: "0",
      FILE_RECOGN_TYPE: "0",
      ...data
    };
    return this.header;
  }
  /** Parse pages of a Supernote file's buffer contents.
   * Relies on the address as given in the file's footer. */
  _parsePages(buffer) {
    const collator = new Intl.Collator([], { numeric: true });
    const pages = Array.from(Object.keys(this.footer.PAGE)).sort((a3, b2) => collator.compare(a3, b2)).map((idx) => {
      var _a2, _b2, _c, _d, _e, _f;
      const address = parseInt(this.footer.PAGE[idx]);
      const data = parseKeyValue(buffer, address, this.lengthFieldSize);
      return {
        PAGESTYLE: "0",
        PAGESTYLEMD5: "0",
        LAYERSWITCH: "0",
        TOTALPATH: "0",
        THUMBNAILTYPE: "0",
        RECOGNSTATUS: "0" /* NONE */,
        RECOGNTEXT: "0",
        RECOGNFILE: "0",
        RECOGNFILESTATUS: "0" /* NONE */,
        ...data,
        MAINLAYER: this._parseLayer(
          buffer,
          parseInt((_a2 = data.MAINLAYER) != null ? _a2 : "0")
        ),
        LAYER1: this._parseLayer(
          buffer,
          parseInt((_b2 = data.LAYER1) != null ? _b2 : "0")
        ),
        LAYER2: this._parseLayer(
          buffer,
          parseInt((_c = data.LAYER2) != null ? _c : "0")
        ),
        LAYER3: this._parseLayer(
          buffer,
          parseInt((_d = data.LAYER3) != null ? _d : "0")
        ),
        BGLAYER: this._parseLayer(
          buffer,
          parseInt((_e = data.BGLAYER) != null ? _e : "0")
        ),
        LAYERINFO: extractLayerInfo(data["LAYERINFO"]),
        LAYERSEQ: data["LAYERSEQ"].split(","),
        text: this._parseText(buffer, data["RECOGNTEXT"]),
        totalPathBuffer: getContentAtAddress(
          buffer,
          parseInt((_f = data.TOTALPATH) != null ? _f : "0"),
          this.lengthFieldSize
        )
      };
    });
    this.pages = pages;
    return pages;
  }
  /** Parse text of a Supernote file's buffer contents.
   * Relies on the address as given in the file's footer. */
  _parseText(buffer, text) {
    if (text === "0" || text === void 0) {
      return;
    }
    const address = parseInt(text);
    const data = getContentAtAddress(buffer, address, this.lengthFieldSize);
    if (data === null) {
      return;
    }
    const recognJson = new TextDecoder("utf8").decode(data);
    const recogn = JSON.parse(atob(recognJson));
    const elements2 = recogn.elements || [];
    const labels = elements2.filter((e2) => e2.type === "Text").map((e2) => decodeURIComponent(escape(e2.label)));
    return labels.join("\n");
  }
  /** Parse layer at a specific address in a Supernote file's buffer contents. */
  _parseLayer(buffer, address) {
    var _a2;
    const data = parseKeyValue(buffer, address, this.lengthFieldSize);
    const bitmapBuffer = getContentAtAddress(
      buffer,
      parseInt((_a2 = data.LAYERBITMAP) != null ? _a2 : "0"),
      this.lengthFieldSize
    );
    return {
      LAYERTYPE: "NOTE",
      LAYERPROTOCOL: "RATTA_RLE",
      LAYERNAME: "MAINLAYER",
      LAYERPATH: "0",
      LAYERBITMAP: "0",
      LAYERVECTORGRAPH: "0",
      LAYERRECOGN: "0",
      ...data,
      bitmapBuffer
    };
  }
  /** Parse cover from Supernote file's buffer contents. */
  _parseCover(buffer) {
    var _a2;
    const address = parseInt((_a2 = this.footer.COVER["0"]) != null ? _a2 : this.footer.COVER["1"]);
    if (address && address > 0) {
      const bitmapBuffer = getContentAtAddress(
        buffer,
        address,
        this.lengthFieldSize
      );
      this.cover = { bitmapBuffer };
    }
    return this.cover;
  }
  /** Parse keywords from Supernote file's buffer contents. */
  _parseKeywords(buffer) {
    this.keywords = {};
    Object.entries(this.footer.KEYWORD).forEach(([key, value]) => {
      if (!(key in this.keywords))
        this.keywords[key] = [];
      if (typeof value === "string")
        this.keywords[key].push(this._parseKeyword(buffer, parseInt(value)));
      else
        value.forEach(
          (address) => this.keywords[key].push(
            this._parseKeyword(buffer, parseInt(address))
          )
        );
    });
    return this.keywords;
  }
  /** Parse a single keyword entry at a certain buffer address. */
  _parseKeyword(buffer, address) {
    var _a2;
    const data = parseKeyValue(buffer, address, this.lengthFieldSize);
    const bitmapBuffer = getContentAtAddress(
      buffer,
      parseInt((_a2 = data.KEYWORDSITE) != null ? _a2 : "0"),
      this.lengthFieldSize
    );
    const keyword = {
      KEYWORDSEQNO: "0",
      KEYWORDPAGE: "1",
      KEYWORDRECT: ["0", "0", "0", "0"],
      KEYWORDRECTORI: ["0", "0", "0", "0"],
      KEYWORDSITE: "0",
      KEYWORDLEN: "0",
      KEYWORD: "",
      bitmapBuffer
    };
    return keyword;
  }
  /** Parse titles from Supernote file's buffer contents. */
  _parseTitles(buffer) {
    this.titles = {};
    Object.entries(this.footer.TITLE).forEach(([key, value]) => {
      if (!(key in this.titles))
        this.titles[key] = [];
      if (typeof value === "string")
        this.titles[key].push(this._parseTitle(buffer, parseInt(value)));
      else
        value.forEach(
          (address) => this.titles[key].push(this._parseTitle(buffer, parseInt(address)))
        );
    });
    return this.titles;
  }
  /** Parse a single title entry at a certain buffer address. */
  _parseTitle(buffer, address) {
    var _a2;
    const data = parseKeyValue(buffer, address, this.lengthFieldSize);
    const bitmapBuffer = getContentAtAddress(
      buffer,
      parseInt((_a2 = data.TITLEBITMAP) != null ? _a2 : "0"),
      this.lengthFieldSize
    );
    const title = {
      TITLESEQNO: "0",
      TITLELEVEL: "1",
      TITLERECT: ["0", "0", "0", "0"],
      TITLERECTORI: ["0", "0", "0", "0"],
      TITLEBITMAP: "0",
      TITLEPROTOCOL: "RATTA_RLE",
      TITLESTYLE: "1000254",
      ...data,
      bitmapBuffer
    };
    return title;
  }
};

// node_modules/image-js/src/image/core/bitMethods.js
var bitMethods = {
  /**
   * Get the bit of a pixel using a pixel index.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
   * @return {number} 0: bit is unset, 1: bit is set
   */
  getBit(pixel) {
    return this.data[getSlot(pixel)] & 1 << getShift(pixel) ? 1 : 0;
  },
  /**
   * Set the bit of a pixel using a pixel index.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
   */
  setBit(pixel) {
    this.data[getSlot(pixel)] |= 1 << getShift(pixel);
  },
  /**
   * Clear the bit of a pixel using a pixel index.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
   */
  clearBit(pixel) {
    this.data[getSlot(pixel)] &= ~(1 << getShift(pixel));
  },
  /**
   * Toggle (invert) the bit of a pixel using a pixel index.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
   */
  toggleBit(pixel) {
    this.data[getSlot(pixel)] ^= 1 << getShift(pixel);
  },
  /**
   * Get the bit of a pixel using coordinates.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @return {number} 0: bit is unset, 1: bit is set
   */
  getBitXY(x2, y3) {
    if (x2 >= this.width || y3 >= this.height)
      return 0;
    return this.getBit(y3 * this.width + x2);
  },
  /**
   * Set the bit of a pixel using coordinates.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   */
  setBitXY(x2, y3) {
    this.setBit(y3 * this.width + x2);
  },
  /**
   * Clear the bit of a pixel using coordinates.
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   */
  clearBitXY(x2, y3) {
    this.clearBit(y3 * this.width + x2);
  },
  /**
   * Toggle (invert) the bit of a pixel using coordinates.
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   */
  toggleBitXY(x2, y3) {
    this.toggleBit(y3 * this.width + x2);
  }
};
function getSlot(pixel) {
  return pixel >> 3;
}
function getShift(pixel) {
  return 7 - (pixel & 7);
}
function setBitMethods(Image3) {
  for (const i3 in bitMethods) {
    Image3.prototype[i3] = bitMethods[i3];
  }
}

// node_modules/image-js/src/image/core/checkProcessable.js
function checkProcessable(processName, options = {}) {
  let { bitDepth, alpha, colorModel, components, channels } = options;
  if (typeof processName !== "string" || processName.length === 0) {
    throw new TypeError("processName must be a string");
  }
  if (bitDepth) {
    if (!Array.isArray(bitDepth)) {
      bitDepth = [bitDepth];
    }
    if (!bitDepth.includes(this.bitDepth)) {
      throw new TypeError(
        `The process: ${processName} can only be applied if bit depth is in: ${bitDepth}`
      );
    }
  }
  if (alpha) {
    if (!Array.isArray(alpha)) {
      alpha = [alpha];
    }
    if (!alpha.includes(this.alpha)) {
      throw new TypeError(
        `The process: ${processName} can only be applied if alpha is in: ${alpha}`
      );
    }
  }
  if (colorModel) {
    if (!Array.isArray(colorModel)) {
      colorModel = [colorModel];
    }
    if (!colorModel.includes(this.colorModel)) {
      throw new TypeError(
        `The process: ${processName} can only be applied if color model is in: ${colorModel}`
      );
    }
  }
  if (components) {
    if (!Array.isArray(components)) {
      components = [components];
    }
    if (!components.includes(this.components)) {
      let errorMessage = `The process: ${processName} can only be applied if the number of components is in: ${components}`;
      if (components.length === 1 && components[0] === 1) {
        throw new TypeError(
          `${errorMessage}.\rYou should transform your image using "image.grey()" before applying the algorithm.`
        );
      } else {
        throw new TypeError(errorMessage);
      }
    }
  }
  if (channels) {
    if (!Array.isArray(channels)) {
      channels = [channels];
    }
    if (!channels.includes(this.channels)) {
      throw new TypeError(
        `The process: ${processName} can only be applied if the number of channels is in: ${channels}`
      );
    }
  }
}

// node_modules/blob-util/dist/blob-util.es.js
function createBlob(parts, properties) {
  parts = parts || [];
  properties = properties || {};
  if (typeof properties === "string") {
    properties = { type: properties };
  }
  try {
    return new Blob(parts, properties);
  } catch (e2) {
    if (e2.name !== "TypeError") {
      throw e2;
    }
    var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
    var builder = new Builder();
    for (var i3 = 0; i3 < parts.length; i3 += 1) {
      builder.append(parts[i3]);
    }
    return builder.getBlob(properties.type);
  }
}
function dataURLToBlob(dataURL) {
  var type = dataURL.match(/data:([^;]+)/)[1];
  var base64 = dataURL.replace(/^[^,]+,/, "");
  var buff = binaryStringToArrayBuffer(atob(base64));
  return createBlob([buff], { type });
}
function canvasToBlob(canvas, type, quality) {
  if (typeof canvas.toBlob === "function") {
    return new Promise(function(resolve2) {
      canvas.toBlob(resolve2, type, quality);
    });
  }
  return Promise.resolve(dataURLToBlob(canvas.toDataURL(type, quality)));
}
function binaryStringToArrayBuffer(binary) {
  var length = binary.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);
  var i3 = -1;
  while (++i3 < length) {
    arr[i3] = binary.charCodeAt(i3);
  }
  return buf;
}

// node_modules/image-js/src/image/core/export.js
var import_fast_bmp = __toESM(require_src());

// node_modules/fast-png/lib-esm/PngDecoder.js
var import_iobuffer = __toESM(require_IOBuffer());

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s3, w2) => {
  s3.pending_buf[s3.pending++] = w2 & 255;
  s3.pending_buf[s3.pending++] = w2 >>> 8 & 255;
};
var send_bits = (s3, value, length) => {
  if (s3.bi_valid > Buf_size - length) {
    s3.bi_buf |= value << s3.bi_valid & 65535;
    put_short(s3, s3.bi_buf);
    s3.bi_buf = value >> Buf_size - s3.bi_valid;
    s3.bi_valid += length - Buf_size;
  } else {
    s3.bi_buf |= value << s3.bi_valid & 65535;
    s3.bi_valid += length;
  }
};
var send_code = (s3, c4, tree) => {
  send_bits(
    s3,
    tree[c4 * 2],
    tree[c4 * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s3) => {
  if (s3.bi_valid === 16) {
    put_short(s3, s3.bi_buf);
    s3.bi_buf = 0;
    s3.bi_valid = 0;
  } else if (s3.bi_valid >= 8) {
    s3.pending_buf[s3.pending++] = s3.bi_buf & 255;
    s3.bi_buf >>= 8;
    s3.bi_valid -= 8;
  }
};
var gen_bitlen = (s3, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h3;
  let n3, m4;
  let bits2;
  let xbits;
  let f3;
  let overflow = 0;
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    s3.bl_count[bits2] = 0;
  }
  tree[s3.heap[s3.heap_max] * 2 + 1] = 0;
  for (h3 = s3.heap_max + 1; h3 < HEAP_SIZE$1; h3++) {
    n3 = s3.heap[h3];
    bits2 = tree[tree[n3 * 2 + 1] * 2 + 1] + 1;
    if (bits2 > max_length) {
      bits2 = max_length;
      overflow++;
    }
    tree[n3 * 2 + 1] = bits2;
    if (n3 > max_code) {
      continue;
    }
    s3.bl_count[bits2]++;
    xbits = 0;
    if (n3 >= base) {
      xbits = extra[n3 - base];
    }
    f3 = tree[n3 * 2];
    s3.opt_len += f3 * (bits2 + xbits);
    if (has_stree) {
      s3.static_len += f3 * (stree[n3 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits2 = max_length - 1;
    while (s3.bl_count[bits2] === 0) {
      bits2--;
    }
    s3.bl_count[bits2]--;
    s3.bl_count[bits2 + 1] += 2;
    s3.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits2 = max_length; bits2 !== 0; bits2--) {
    n3 = s3.bl_count[bits2];
    while (n3 !== 0) {
      m4 = s3.heap[--h3];
      if (m4 > max_code) {
        continue;
      }
      if (tree[m4 * 2 + 1] !== bits2) {
        s3.opt_len += (bits2 - tree[m4 * 2 + 1]) * tree[m4 * 2];
        tree[m4 * 2 + 1] = bits2;
      }
      n3--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits2;
  let n3;
  for (bits2 = 1; bits2 <= MAX_BITS$1; bits2++) {
    code = code + bl_count[bits2 - 1] << 1;
    next_code[bits2] = code;
  }
  for (n3 = 0; n3 <= max_code; n3++) {
    let len = tree[n3 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n3 * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n3;
  let bits2;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n3 = 0; n3 < 1 << extra_lbits[code]; n3++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n3 = 0; n3 < 1 << extra_dbits[code]; n3++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n3 = 0; n3 < 1 << extra_dbits[code] - 7; n3++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits2 = 0; bits2 <= MAX_BITS$1; bits2++) {
    bl_count[bits2] = 0;
  }
  n3 = 0;
  while (n3 <= 143) {
    static_ltree[n3 * 2 + 1] = 8;
    n3++;
    bl_count[8]++;
  }
  while (n3 <= 255) {
    static_ltree[n3 * 2 + 1] = 9;
    n3++;
    bl_count[9]++;
  }
  while (n3 <= 279) {
    static_ltree[n3 * 2 + 1] = 7;
    n3++;
    bl_count[7]++;
  }
  while (n3 <= 287) {
    static_ltree[n3 * 2 + 1] = 8;
    n3++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n3 = 0; n3 < D_CODES$1; n3++) {
    static_dtree[n3 * 2 + 1] = 5;
    static_dtree[n3 * 2] = bi_reverse(n3, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s3) => {
  let n3;
  for (n3 = 0; n3 < L_CODES$1; n3++) {
    s3.dyn_ltree[n3 * 2] = 0;
  }
  for (n3 = 0; n3 < D_CODES$1; n3++) {
    s3.dyn_dtree[n3 * 2] = 0;
  }
  for (n3 = 0; n3 < BL_CODES$1; n3++) {
    s3.bl_tree[n3 * 2] = 0;
  }
  s3.dyn_ltree[END_BLOCK * 2] = 1;
  s3.opt_len = s3.static_len = 0;
  s3.sym_next = s3.matches = 0;
};
var bi_windup = (s3) => {
  if (s3.bi_valid > 8) {
    put_short(s3, s3.bi_buf);
  } else if (s3.bi_valid > 0) {
    s3.pending_buf[s3.pending++] = s3.bi_buf;
  }
  s3.bi_buf = 0;
  s3.bi_valid = 0;
};
var smaller = (tree, n3, m4, depth) => {
  const _n2 = n3 * 2;
  const _m2 = m4 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n3] <= depth[m4];
};
var pqdownheap = (s3, tree, k2) => {
  const v3 = s3.heap[k2];
  let j2 = k2 << 1;
  while (j2 <= s3.heap_len) {
    if (j2 < s3.heap_len && smaller(tree, s3.heap[j2 + 1], s3.heap[j2], s3.depth)) {
      j2++;
    }
    if (smaller(tree, v3, s3.heap[j2], s3.depth)) {
      break;
    }
    s3.heap[k2] = s3.heap[j2];
    k2 = j2;
    j2 <<= 1;
  }
  s3.heap[k2] = v3;
};
var compress_block = (s3, ltree, dtree) => {
  let dist;
  let lc2;
  let sx = 0;
  let code;
  let extra;
  if (s3.sym_next !== 0) {
    do {
      dist = s3.pending_buf[s3.sym_buf + sx++] & 255;
      dist += (s3.pending_buf[s3.sym_buf + sx++] & 255) << 8;
      lc2 = s3.pending_buf[s3.sym_buf + sx++];
      if (dist === 0) {
        send_code(s3, lc2, ltree);
      } else {
        code = _length_code[lc2];
        send_code(s3, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc2 -= base_length[code];
          send_bits(s3, lc2, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s3, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s3, dist, extra);
        }
      }
    } while (sx < s3.sym_next);
  }
  send_code(s3, END_BLOCK, ltree);
};
var build_tree = (s3, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n3, m4;
  let max_code = -1;
  let node2;
  s3.heap_len = 0;
  s3.heap_max = HEAP_SIZE$1;
  for (n3 = 0; n3 < elems; n3++) {
    if (tree[n3 * 2] !== 0) {
      s3.heap[++s3.heap_len] = max_code = n3;
      s3.depth[n3] = 0;
    } else {
      tree[n3 * 2 + 1] = 0;
    }
  }
  while (s3.heap_len < 2) {
    node2 = s3.heap[++s3.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node2 * 2] = 1;
    s3.depth[node2] = 0;
    s3.opt_len--;
    if (has_stree) {
      s3.static_len -= stree[node2 * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n3 = s3.heap_len >> 1; n3 >= 1; n3--) {
    pqdownheap(s3, tree, n3);
  }
  node2 = elems;
  do {
    n3 = s3.heap[
      1
      /*SMALLEST*/
    ];
    s3.heap[
      1
      /*SMALLEST*/
    ] = s3.heap[s3.heap_len--];
    pqdownheap(
      s3,
      tree,
      1
      /*SMALLEST*/
    );
    m4 = s3.heap[
      1
      /*SMALLEST*/
    ];
    s3.heap[--s3.heap_max] = n3;
    s3.heap[--s3.heap_max] = m4;
    tree[node2 * 2] = tree[n3 * 2] + tree[m4 * 2];
    s3.depth[node2] = (s3.depth[n3] >= s3.depth[m4] ? s3.depth[n3] : s3.depth[m4]) + 1;
    tree[n3 * 2 + 1] = tree[m4 * 2 + 1] = node2;
    s3.heap[
      1
      /*SMALLEST*/
    ] = node2++;
    pqdownheap(
      s3,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s3.heap_len >= 2);
  s3.heap[--s3.heap_max] = s3.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s3, desc);
  gen_codes(tree, max_code, s3.bl_count);
};
var scan_tree = (s3, tree, max_code) => {
  let n3;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n3 = 0; n3 <= max_code; n3++) {
    curlen = nextlen;
    nextlen = tree[(n3 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s3.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s3.bl_tree[curlen * 2]++;
      }
      s3.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s3.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s3.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s3, tree, max_code) => {
  let n3;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n3 = 0; n3 <= max_code; n3++) {
    curlen = nextlen;
    nextlen = tree[(n3 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s3, curlen, s3.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s3, curlen, s3.bl_tree);
        count--;
      }
      send_code(s3, REP_3_6, s3.bl_tree);
      send_bits(s3, count - 3, 2);
    } else if (count <= 10) {
      send_code(s3, REPZ_3_10, s3.bl_tree);
      send_bits(s3, count - 3, 3);
    } else {
      send_code(s3, REPZ_11_138, s3.bl_tree);
      send_bits(s3, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s3) => {
  let max_blindex;
  scan_tree(s3, s3.dyn_ltree, s3.l_desc.max_code);
  scan_tree(s3, s3.dyn_dtree, s3.d_desc.max_code);
  build_tree(s3, s3.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s3.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s3.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s3, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s3, lcodes - 257, 5);
  send_bits(s3, dcodes - 1, 5);
  send_bits(s3, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s3, s3.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s3, s3.dyn_ltree, lcodes - 1);
  send_tree(s3, s3.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s3) => {
  let block_mask = 4093624447;
  let n3;
  for (n3 = 0; n3 <= 31; n3++, block_mask >>>= 1) {
    if (block_mask & 1 && s3.dyn_ltree[n3 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s3.dyn_ltree[9 * 2] !== 0 || s3.dyn_ltree[10 * 2] !== 0 || s3.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n3 = 32; n3 < LITERALS$1; n3++) {
    if (s3.dyn_ltree[n3 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s3) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s3.l_desc = new TreeDesc(s3.dyn_ltree, static_l_desc);
  s3.d_desc = new TreeDesc(s3.dyn_dtree, static_d_desc);
  s3.bl_desc = new TreeDesc(s3.bl_tree, static_bl_desc);
  s3.bi_buf = 0;
  s3.bi_valid = 0;
  init_block(s3);
};
var _tr_stored_block$1 = (s3, buf, stored_len, last) => {
  send_bits(s3, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s3);
  put_short(s3, stored_len);
  put_short(s3, ~stored_len);
  if (stored_len) {
    s3.pending_buf.set(s3.window.subarray(buf, buf + stored_len), s3.pending);
  }
  s3.pending += stored_len;
};
var _tr_align$1 = (s3) => {
  send_bits(s3, STATIC_TREES << 1, 3);
  send_code(s3, END_BLOCK, static_ltree);
  bi_flush(s3);
};
var _tr_flush_block$1 = (s3, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s3.level > 0) {
    if (s3.strm.data_type === Z_UNKNOWN$1) {
      s3.strm.data_type = detect_data_type(s3);
    }
    build_tree(s3, s3.l_desc);
    build_tree(s3, s3.d_desc);
    max_blindex = build_bl_tree(s3);
    opt_lenb = s3.opt_len + 3 + 7 >>> 3;
    static_lenb = s3.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s3, buf, stored_len, last);
  } else if (s3.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s3, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s3, static_ltree, static_dtree);
  } else {
    send_bits(s3, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s3, s3.l_desc.max_code + 1, s3.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s3, s3.dyn_ltree, s3.dyn_dtree);
  }
  init_block(s3);
  if (last) {
    bi_windup(s3);
  }
};
var _tr_tally$1 = (s3, dist, lc2) => {
  s3.pending_buf[s3.sym_buf + s3.sym_next++] = dist;
  s3.pending_buf[s3.sym_buf + s3.sym_next++] = dist >> 8;
  s3.pending_buf[s3.sym_buf + s3.sym_next++] = lc2;
  if (dist === 0) {
    s3.dyn_ltree[lc2 * 2]++;
  } else {
    s3.matches++;
    dist--;
    s3.dyn_ltree[(_length_code[lc2] + LITERALS$1 + 1) * 2]++;
    s3.dyn_dtree[d_code(dist) * 2]++;
  }
  return s3.sym_next === s3.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler2, buf, len, pos) => {
  let s1 = adler2 & 65535 | 0, s22 = adler2 >>> 16 & 65535 | 0, n3 = 0;
  while (len !== 0) {
    n3 = len > 2e3 ? 2e3 : len;
    len -= n3;
    do {
      s1 = s1 + buf[pos++] | 0;
      s22 = s22 + s1 | 0;
    } while (--n3);
    s1 %= 65521;
    s22 %= 65521;
  }
  return s1 | s22 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c4, table = [];
  for (var n3 = 0; n3 < 256; n3++) {
    c4 = n3;
    for (var k2 = 0; k2 < 8; k2++) {
      c4 = c4 & 1 ? 3988292384 ^ c4 >>> 1 : c4 >>> 1;
    }
    table[n3] = c4;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc2, buf, len, pos) => {
  const t3 = crcTable;
  const end = pos + len;
  crc2 ^= -1;
  for (let i3 = pos; i3 < end; i3++) {
    crc2 = crc2 >>> 8 ^ t3[(crc2 ^ buf[i3]) & 255];
  }
  return crc2 ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f3) => {
  return f3 * 2 - (f3 > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s3) => {
  let n3, m4;
  let p3;
  let wsize = s3.w_size;
  n3 = s3.hash_size;
  p3 = n3;
  do {
    m4 = s3.head[--p3];
    s3.head[p3] = m4 >= wsize ? m4 - wsize : 0;
  } while (--n3);
  n3 = wsize;
  p3 = n3;
  do {
    m4 = s3.prev[--p3];
    s3.prev[p3] = m4 >= wsize ? m4 - wsize : 0;
  } while (--n3);
};
var HASH_ZLIB = (s3, prev, data) => (prev << s3.hash_shift ^ data) & s3.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s3 = strm.state;
  let len = s3.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s3.pending_buf.subarray(s3.pending_out, s3.pending_out + len), strm.next_out);
  strm.next_out += len;
  s3.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s3.pending -= len;
  if (s3.pending === 0) {
    s3.pending_out = 0;
  }
};
var flush_block_only = (s3, last) => {
  _tr_flush_block(s3, s3.block_start >= 0 ? s3.block_start : -1, s3.strstart - s3.block_start, last);
  s3.block_start = s3.strstart;
  flush_pending(s3.strm);
};
var put_byte = (s3, b2) => {
  s3.pending_buf[s3.pending++] = b2;
};
var putShortMSB = (s3, b2) => {
  s3.pending_buf[s3.pending++] = b2 >>> 8 & 255;
  s3.pending_buf[s3.pending++] = b2 & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s3, cur_match) => {
  let chain_length = s3.max_chain_length;
  let scan = s3.strstart;
  let match;
  let len;
  let best_len = s3.prev_length;
  let nice_match = s3.nice_match;
  const limit = s3.strstart > s3.w_size - MIN_LOOKAHEAD ? s3.strstart - (s3.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s3.window;
  const wmask = s3.w_mask;
  const prev = s3.prev;
  const strend = s3.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s3.prev_length >= s3.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s3.lookahead) {
    nice_match = s3.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s3.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s3.lookahead) {
    return best_len;
  }
  return s3.lookahead;
};
var fill_window = (s3) => {
  const _w_size = s3.w_size;
  let n3, more, str;
  do {
    more = s3.window_size - s3.lookahead - s3.strstart;
    if (s3.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s3.window.set(s3.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s3.match_start -= _w_size;
      s3.strstart -= _w_size;
      s3.block_start -= _w_size;
      if (s3.insert > s3.strstart) {
        s3.insert = s3.strstart;
      }
      slide_hash(s3);
      more += _w_size;
    }
    if (s3.strm.avail_in === 0) {
      break;
    }
    n3 = read_buf(s3.strm, s3.window, s3.strstart + s3.lookahead, more);
    s3.lookahead += n3;
    if (s3.lookahead + s3.insert >= MIN_MATCH) {
      str = s3.strstart - s3.insert;
      s3.ins_h = s3.window[str];
      s3.ins_h = HASH(s3, s3.ins_h, s3.window[str + 1]);
      while (s3.insert) {
        s3.ins_h = HASH(s3, s3.ins_h, s3.window[str + MIN_MATCH - 1]);
        s3.prev[str & s3.w_mask] = s3.head[s3.ins_h];
        s3.head[s3.ins_h] = str;
        str++;
        s3.insert--;
        if (s3.lookahead + s3.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s3.lookahead < MIN_LOOKAHEAD && s3.strm.avail_in !== 0);
};
var deflate_stored = (s3, flush) => {
  let min_block = s3.pending_buf_size - 5 > s3.w_size ? s3.w_size : s3.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s3.strm.avail_in;
  do {
    len = 65535;
    have = s3.bi_valid + 42 >> 3;
    if (s3.strm.avail_out < have) {
      break;
    }
    have = s3.strm.avail_out - have;
    left = s3.strstart - s3.block_start;
    if (len > left + s3.strm.avail_in) {
      len = left + s3.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s3.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s3.strm.avail_in ? 1 : 0;
    _tr_stored_block(s3, 0, 0, last);
    s3.pending_buf[s3.pending - 4] = len;
    s3.pending_buf[s3.pending - 3] = len >> 8;
    s3.pending_buf[s3.pending - 2] = ~len;
    s3.pending_buf[s3.pending - 1] = ~len >> 8;
    flush_pending(s3.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s3.strm.output.set(s3.window.subarray(s3.block_start, s3.block_start + left), s3.strm.next_out);
      s3.strm.next_out += left;
      s3.strm.avail_out -= left;
      s3.strm.total_out += left;
      s3.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s3.strm, s3.strm.output, s3.strm.next_out, len);
      s3.strm.next_out += len;
      s3.strm.avail_out -= len;
      s3.strm.total_out += len;
    }
  } while (last === 0);
  used -= s3.strm.avail_in;
  if (used) {
    if (used >= s3.w_size) {
      s3.matches = 2;
      s3.window.set(s3.strm.input.subarray(s3.strm.next_in - s3.w_size, s3.strm.next_in), 0);
      s3.strstart = s3.w_size;
      s3.insert = s3.strstart;
    } else {
      if (s3.window_size - s3.strstart <= used) {
        s3.strstart -= s3.w_size;
        s3.window.set(s3.window.subarray(s3.w_size, s3.w_size + s3.strstart), 0);
        if (s3.matches < 2) {
          s3.matches++;
        }
        if (s3.insert > s3.strstart) {
          s3.insert = s3.strstart;
        }
      }
      s3.window.set(s3.strm.input.subarray(s3.strm.next_in - used, s3.strm.next_in), s3.strstart);
      s3.strstart += used;
      s3.insert += used > s3.w_size - s3.insert ? s3.w_size - s3.insert : used;
    }
    s3.block_start = s3.strstart;
  }
  if (s3.high_water < s3.strstart) {
    s3.high_water = s3.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s3.strm.avail_in === 0 && s3.strstart === s3.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s3.window_size - s3.strstart;
  if (s3.strm.avail_in > have && s3.block_start >= s3.w_size) {
    s3.block_start -= s3.w_size;
    s3.strstart -= s3.w_size;
    s3.window.set(s3.window.subarray(s3.w_size, s3.w_size + s3.strstart), 0);
    if (s3.matches < 2) {
      s3.matches++;
    }
    have += s3.w_size;
    if (s3.insert > s3.strstart) {
      s3.insert = s3.strstart;
    }
  }
  if (have > s3.strm.avail_in) {
    have = s3.strm.avail_in;
  }
  if (have) {
    read_buf(s3.strm, s3.window, s3.strstart, have);
    s3.strstart += have;
    s3.insert += have > s3.w_size - s3.insert ? s3.w_size - s3.insert : have;
  }
  if (s3.high_water < s3.strstart) {
    s3.high_water = s3.strstart;
  }
  have = s3.bi_valid + 42 >> 3;
  have = s3.pending_buf_size - have > 65535 ? 65535 : s3.pending_buf_size - have;
  min_block = have > s3.w_size ? s3.w_size : have;
  left = s3.strstart - s3.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s3.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s3.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s3, s3.block_start, len, last);
    s3.block_start += len;
    flush_pending(s3.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s3, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s3.lookahead < MIN_LOOKAHEAD) {
      fill_window(s3);
      if (s3.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s3.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s3.lookahead >= MIN_MATCH) {
      s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + MIN_MATCH - 1]);
      hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
      s3.head[s3.ins_h] = s3.strstart;
    }
    if (hash_head !== 0 && s3.strstart - hash_head <= s3.w_size - MIN_LOOKAHEAD) {
      s3.match_length = longest_match(s3, hash_head);
    }
    if (s3.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s3, s3.strstart - s3.match_start, s3.match_length - MIN_MATCH);
      s3.lookahead -= s3.match_length;
      if (s3.match_length <= s3.max_lazy_match && s3.lookahead >= MIN_MATCH) {
        s3.match_length--;
        do {
          s3.strstart++;
          s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + MIN_MATCH - 1]);
          hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
          s3.head[s3.ins_h] = s3.strstart;
        } while (--s3.match_length !== 0);
        s3.strstart++;
      } else {
        s3.strstart += s3.match_length;
        s3.match_length = 0;
        s3.ins_h = s3.window[s3.strstart];
        s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s3, 0, s3.window[s3.strstart]);
      s3.lookahead--;
      s3.strstart++;
    }
    if (bflush) {
      flush_block_only(s3, false);
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s3.insert = s3.strstart < MIN_MATCH - 1 ? s3.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.sym_next) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s3, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s3.lookahead < MIN_LOOKAHEAD) {
      fill_window(s3);
      if (s3.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s3.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s3.lookahead >= MIN_MATCH) {
      s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + MIN_MATCH - 1]);
      hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
      s3.head[s3.ins_h] = s3.strstart;
    }
    s3.prev_length = s3.match_length;
    s3.prev_match = s3.match_start;
    s3.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s3.prev_length < s3.max_lazy_match && s3.strstart - hash_head <= s3.w_size - MIN_LOOKAHEAD) {
      s3.match_length = longest_match(s3, hash_head);
      if (s3.match_length <= 5 && (s3.strategy === Z_FILTERED || s3.match_length === MIN_MATCH && s3.strstart - s3.match_start > 4096)) {
        s3.match_length = MIN_MATCH - 1;
      }
    }
    if (s3.prev_length >= MIN_MATCH && s3.match_length <= s3.prev_length) {
      max_insert = s3.strstart + s3.lookahead - MIN_MATCH;
      bflush = _tr_tally(s3, s3.strstart - 1 - s3.prev_match, s3.prev_length - MIN_MATCH);
      s3.lookahead -= s3.prev_length - 1;
      s3.prev_length -= 2;
      do {
        if (++s3.strstart <= max_insert) {
          s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + MIN_MATCH - 1]);
          hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
          s3.head[s3.ins_h] = s3.strstart;
        }
      } while (--s3.prev_length !== 0);
      s3.match_available = 0;
      s3.match_length = MIN_MATCH - 1;
      s3.strstart++;
      if (bflush) {
        flush_block_only(s3, false);
        if (s3.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s3.match_available) {
      bflush = _tr_tally(s3, 0, s3.window[s3.strstart - 1]);
      if (bflush) {
        flush_block_only(s3, false);
      }
      s3.strstart++;
      s3.lookahead--;
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s3.match_available = 1;
      s3.strstart++;
      s3.lookahead--;
    }
  }
  if (s3.match_available) {
    bflush = _tr_tally(s3, 0, s3.window[s3.strstart - 1]);
    s3.match_available = 0;
  }
  s3.insert = s3.strstart < MIN_MATCH - 1 ? s3.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.sym_next) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s3, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s3.window;
  for (; ; ) {
    if (s3.lookahead <= MAX_MATCH) {
      fill_window(s3);
      if (s3.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s3.lookahead === 0) {
        break;
      }
    }
    s3.match_length = 0;
    if (s3.lookahead >= MIN_MATCH && s3.strstart > 0) {
      scan = s3.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s3.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s3.match_length = MAX_MATCH - (strend - scan);
        if (s3.match_length > s3.lookahead) {
          s3.match_length = s3.lookahead;
        }
      }
    }
    if (s3.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s3, 1, s3.match_length - MIN_MATCH);
      s3.lookahead -= s3.match_length;
      s3.strstart += s3.match_length;
      s3.match_length = 0;
    } else {
      bflush = _tr_tally(s3, 0, s3.window[s3.strstart]);
      s3.lookahead--;
      s3.strstart++;
    }
    if (bflush) {
      flush_block_only(s3, false);
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s3.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.sym_next) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s3, flush) => {
  let bflush;
  for (; ; ) {
    if (s3.lookahead === 0) {
      fill_window(s3);
      if (s3.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s3.match_length = 0;
    bflush = _tr_tally(s3, 0, s3.window[s3.strstart]);
    s3.lookahead--;
    s3.strstart++;
    if (bflush) {
      flush_block_only(s3, false);
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s3.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.sym_next) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s3) => {
  s3.window_size = 2 * s3.w_size;
  zero(s3.head);
  s3.max_lazy_match = configuration_table[s3.level].max_lazy;
  s3.good_match = configuration_table[s3.level].good_length;
  s3.nice_match = configuration_table[s3.level].nice_length;
  s3.max_chain_length = configuration_table[s3.level].max_chain;
  s3.strstart = 0;
  s3.block_start = 0;
  s3.lookahead = 0;
  s3.insert = 0;
  s3.match_length = s3.prev_length = MIN_MATCH - 1;
  s3.match_available = 0;
  s3.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s3 = strm.state;
  if (!s3 || s3.strm !== strm || s3.status !== INIT_STATE && //#ifdef GZIP
  s3.status !== GZIP_STATE && //#endif
  s3.status !== EXTRA_STATE && s3.status !== NAME_STATE && s3.status !== COMMENT_STATE && s3.status !== HCRC_STATE && s3.status !== BUSY_STATE && s3.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s3 = strm.state;
  s3.pending = 0;
  s3.pending_out = 0;
  if (s3.wrap < 0) {
    s3.wrap = -s3.wrap;
  }
  s3.status = //#ifdef GZIP
  s3.wrap === 2 ? GZIP_STATE : (
    //#endif
    s3.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s3.wrap === 2 ? 0 : 1;
  s3.last_flush = -2;
  _tr_init(s3);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level2, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level2 === Z_DEFAULT_COMPRESSION$1) {
    level2 = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level2 < 0 || level2 > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap2 !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s3 = new DeflateState();
  strm.state = s3;
  s3.strm = strm;
  s3.status = INIT_STATE;
  s3.wrap = wrap2;
  s3.gzhead = null;
  s3.w_bits = windowBits;
  s3.w_size = 1 << s3.w_bits;
  s3.w_mask = s3.w_size - 1;
  s3.hash_bits = memLevel + 7;
  s3.hash_size = 1 << s3.hash_bits;
  s3.hash_mask = s3.hash_size - 1;
  s3.hash_shift = ~~((s3.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s3.window = new Uint8Array(s3.w_size * 2);
  s3.head = new Uint16Array(s3.hash_size);
  s3.prev = new Uint16Array(s3.w_size);
  s3.lit_bufsize = 1 << memLevel + 6;
  s3.pending_buf_size = s3.lit_bufsize * 4;
  s3.pending_buf = new Uint8Array(s3.pending_buf_size);
  s3.sym_buf = s3.lit_bufsize;
  s3.sym_end = (s3.lit_bufsize - 1) * 3;
  s3.level = level2;
  s3.strategy = strategy;
  s3.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level2) => {
  return deflateInit2(strm, level2, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s3 = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s3.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s3.last_flush;
  s3.last_flush = flush;
  if (s3.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s3.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s3.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s3.status === INIT_STATE && s3.wrap === 0) {
    s3.status = BUSY_STATE;
  }
  if (s3.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s3.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2) {
      level_flags = 0;
    } else if (s3.level < 6) {
      level_flags = 1;
    } else if (s3.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s3.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s3, header);
    if (s3.strstart !== 0) {
      putShortMSB(s3, strm.adler >>> 16);
      putShortMSB(s3, strm.adler & 65535);
    }
    strm.adler = 1;
    s3.status = BUSY_STATE;
    flush_pending(strm);
    if (s3.pending !== 0) {
      s3.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s3.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s3, 31);
    put_byte(s3, 139);
    put_byte(s3, 8);
    if (!s3.gzhead) {
      put_byte(s3, 0);
      put_byte(s3, 0);
      put_byte(s3, 0);
      put_byte(s3, 0);
      put_byte(s3, 0);
      put_byte(s3, s3.level === 9 ? 2 : s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2 ? 4 : 0);
      put_byte(s3, OS_CODE);
      s3.status = BUSY_STATE;
      flush_pending(strm);
      if (s3.pending !== 0) {
        s3.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s3,
        (s3.gzhead.text ? 1 : 0) + (s3.gzhead.hcrc ? 2 : 0) + (!s3.gzhead.extra ? 0 : 4) + (!s3.gzhead.name ? 0 : 8) + (!s3.gzhead.comment ? 0 : 16)
      );
      put_byte(s3, s3.gzhead.time & 255);
      put_byte(s3, s3.gzhead.time >> 8 & 255);
      put_byte(s3, s3.gzhead.time >> 16 & 255);
      put_byte(s3, s3.gzhead.time >> 24 & 255);
      put_byte(s3, s3.level === 9 ? 2 : s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2 ? 4 : 0);
      put_byte(s3, s3.gzhead.os & 255);
      if (s3.gzhead.extra && s3.gzhead.extra.length) {
        put_byte(s3, s3.gzhead.extra.length & 255);
        put_byte(s3, s3.gzhead.extra.length >> 8 & 255);
      }
      if (s3.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending, 0);
      }
      s3.gzindex = 0;
      s3.status = EXTRA_STATE;
    }
  }
  if (s3.status === EXTRA_STATE) {
    if (s3.gzhead.extra) {
      let beg = s3.pending;
      let left = (s3.gzhead.extra.length & 65535) - s3.gzindex;
      while (s3.pending + left > s3.pending_buf_size) {
        let copy = s3.pending_buf_size - s3.pending;
        s3.pending_buf.set(s3.gzhead.extra.subarray(s3.gzindex, s3.gzindex + copy), s3.pending);
        s3.pending = s3.pending_buf_size;
        if (s3.gzhead.hcrc && s3.pending > beg) {
          strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
        }
        s3.gzindex += copy;
        flush_pending(strm);
        if (s3.pending !== 0) {
          s3.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s3.gzhead.extra);
      s3.pending_buf.set(gzhead_extra.subarray(s3.gzindex, s3.gzindex + left), s3.pending);
      s3.pending += left;
      if (s3.gzhead.hcrc && s3.pending > beg) {
        strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
      }
      s3.gzindex = 0;
    }
    s3.status = NAME_STATE;
  }
  if (s3.status === NAME_STATE) {
    if (s3.gzhead.name) {
      let beg = s3.pending;
      let val;
      do {
        if (s3.pending === s3.pending_buf_size) {
          if (s3.gzhead.hcrc && s3.pending > beg) {
            strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
          }
          flush_pending(strm);
          if (s3.pending !== 0) {
            s3.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s3.gzindex < s3.gzhead.name.length) {
          val = s3.gzhead.name.charCodeAt(s3.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s3, val);
      } while (val !== 0);
      if (s3.gzhead.hcrc && s3.pending > beg) {
        strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
      }
      s3.gzindex = 0;
    }
    s3.status = COMMENT_STATE;
  }
  if (s3.status === COMMENT_STATE) {
    if (s3.gzhead.comment) {
      let beg = s3.pending;
      let val;
      do {
        if (s3.pending === s3.pending_buf_size) {
          if (s3.gzhead.hcrc && s3.pending > beg) {
            strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
          }
          flush_pending(strm);
          if (s3.pending !== 0) {
            s3.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s3.gzindex < s3.gzhead.comment.length) {
          val = s3.gzhead.comment.charCodeAt(s3.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s3, val);
      } while (val !== 0);
      if (s3.gzhead.hcrc && s3.pending > beg) {
        strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
      }
    }
    s3.status = HCRC_STATE;
  }
  if (s3.status === HCRC_STATE) {
    if (s3.gzhead.hcrc) {
      if (s3.pending + 2 > s3.pending_buf_size) {
        flush_pending(strm);
        if (s3.pending !== 0) {
          s3.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s3, strm.adler & 255);
      put_byte(s3, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s3.status = BUSY_STATE;
    flush_pending(strm);
    if (s3.pending !== 0) {
      s3.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s3.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s3.status !== FINISH_STATE) {
    let bstate = s3.level === 0 ? deflate_stored(s3, flush) : s3.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s3, flush) : s3.strategy === Z_RLE ? deflate_rle(s3, flush) : configuration_table[s3.level].func(s3, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s3.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s3.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s3);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s3, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s3.head);
          if (s3.lookahead === 0) {
            s3.strstart = 0;
            s3.block_start = 0;
            s3.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s3.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s3.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s3.wrap === 2) {
    put_byte(s3, strm.adler & 255);
    put_byte(s3, strm.adler >> 8 & 255);
    put_byte(s3, strm.adler >> 16 & 255);
    put_byte(s3, strm.adler >> 24 & 255);
    put_byte(s3, strm.total_in & 255);
    put_byte(s3, strm.total_in >> 8 & 255);
    put_byte(s3, strm.total_in >> 16 & 255);
    put_byte(s3, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s3, strm.adler >>> 16);
    putShortMSB(s3, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s3.wrap > 0) {
    s3.wrap = -s3.wrap;
  }
  return s3.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s3 = strm.state;
  const wrap2 = s3.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s3.status !== INIT_STATE || s3.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s3.wrap = 0;
  if (dictLength >= s3.w_size) {
    if (wrap2 === 0) {
      zero(s3.head);
      s3.strstart = 0;
      s3.block_start = 0;
      s3.insert = 0;
    }
    let tmpDict = new Uint8Array(s3.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s3.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s3.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s3);
  while (s3.lookahead >= MIN_MATCH) {
    let str = s3.strstart;
    let n3 = s3.lookahead - (MIN_MATCH - 1);
    do {
      s3.ins_h = HASH(s3, s3.ins_h, s3.window[str + MIN_MATCH - 1]);
      s3.prev[str & s3.w_mask] = s3.head[s3.ins_h];
      s3.head[s3.ins_h] = str;
      str++;
    } while (--n3);
    s3.strstart = str;
    s3.lookahead = MIN_MATCH - 1;
    fill_window(s3);
  }
  s3.strstart += s3.lookahead;
  s3.block_start = s3.strstart;
  s3.insert = s3.lookahead;
  s3.lookahead = 0;
  s3.match_length = s3.prev_length = MIN_MATCH - 1;
  s3.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s3.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p3 in source) {
      if (_has(source, p3)) {
        obj[p3] = source[p3];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i3 = 0, l3 = chunks.length; i3 < l3; i3++) {
    len += chunks[i3].length;
  }
  const result = new Uint8Array(len);
  for (let i3 = 0, pos = 0, l3 = chunks.length; i3 < l3; i3++) {
    let chunk = chunks[i3];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q2 = 0; q2 < 256; q2++) {
  _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c4, c22, m_pos, i3, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c4 = str.charCodeAt(m_pos);
    if ((c4 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c4 = 65536 + (c4 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c4 < 128 ? 1 : c4 < 2048 ? 2 : c4 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i3 = 0, m_pos = 0; i3 < buf_len; m_pos++) {
    c4 = str.charCodeAt(m_pos);
    if ((c4 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c4 = 65536 + (c4 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c4 < 128) {
      buf[i3++] = c4;
    } else if (c4 < 2048) {
      buf[i3++] = 192 | c4 >>> 6;
      buf[i3++] = 128 | c4 & 63;
    } else if (c4 < 65536) {
      buf[i3++] = 224 | c4 >>> 12;
      buf[i3++] = 128 | c4 >>> 6 & 63;
      buf[i3++] = 128 | c4 & 63;
    } else {
      buf[i3++] = 240 | c4 >>> 18;
      buf[i3++] = 128 | c4 >>> 12 & 63;
      buf[i3++] = 128 | c4 >>> 6 & 63;
      buf[i3++] = 128 | c4 & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i3 = 0; i3 < len; i3++) {
    result += String.fromCharCode(buf[i3]);
  }
  return result;
};
var buf2string = (buf, max4) => {
  const len = max4 || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max4));
  }
  let i3, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i3 = 0; i3 < len; ) {
    let c4 = buf[i3++];
    if (c4 < 128) {
      utf16buf[out++] = c4;
      continue;
    }
    let c_len = _utf8len[c4];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i3 += c_len - 1;
      continue;
    }
    c4 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i3 < len) {
      c4 = c4 << 6 | buf[i3++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c4 < 65536) {
      utf16buf[out++] = c4;
    } else {
      c4 -= 65536;
      utf16buf[out++] = 55296 | c4 >> 10 & 1023;
      utf16buf[out++] = 56320 | c4 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max4) => {
  max4 = max4 || buf.length;
  if (max4 > buf.length) {
    max4 = buf.length;
  }
  let pos = max4 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max4;
  }
  if (pos === 0) {
    return max4;
  }
  return pos + _utf8len[buf[pos]] > max4 ? pos : max4;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits2;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits2 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits2 < 15) {
        hold += input[_in++] << bits2;
        bits2 += 8;
        hold += input[_in++] << bits2;
        bits2 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits2 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits2 < op) {
                hold += input[_in++] << bits2;
                bits2 += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits2 -= op;
            }
            if (bits2 < 15) {
              hold += input[_in++] << bits2;
              bits2 += 8;
              hold += input[_in++] << bits2;
              bits2 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits2 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits2 < op) {
                    hold += input[_in++] << bits2;
                    bits2 += 8;
                    if (bits2 < op) {
                      hold += input[_in++] << bits2;
                      bits2 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits2 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits2 >> 3;
  _in -= len;
  bits2 -= len << 3;
  hold &= (1 << bits2) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits2;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work2, opts) => {
  const bits2 = opts.bits;
  let len = 0;
  let sym = 0;
  let min3 = 0, max4 = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill2;
  let low;
  let mask2;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits2;
  for (max4 = MAXBITS; max4 >= 1; max4--) {
    if (count[max4] !== 0) {
      break;
    }
  }
  if (root > max4) {
    root = max4;
  }
  if (max4 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min3 = 1; min3 < max4; min3++) {
    if (count[min3] !== 0) {
      break;
    }
  }
  if (root < min3) {
    root = min3;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max4 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work2[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work2;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min3;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask2 = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work2[sym] + 1 < match) {
      here_op = 0;
      here_val = work2[sym];
    } else if (work2[sym] >= match) {
      here_op = extra[work2[sym] - match];
      here_val = base[work2[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill2 = 1 << curr;
    min3 = fill2;
    do {
      fill2 -= incr;
      table[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill2 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max4) {
        break;
      }
      len = lens[lens_index + work2[sym]];
    }
    if (len > root && (huff & mask2) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min3;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max4) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask2;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q2) => {
  return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits2;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n3;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits2 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits2 = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits2 -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits2 = 0;
          break;
        case FLAGS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = TIME;
        case TIME:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = OS;
        case OS:
          while (bits2 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits2 = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits2 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits2 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits2 = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits2 & 7;
            bits2 -= bits2 & 7;
            state.mode = CHECK;
            break;
          }
          while (bits2 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits2 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits2 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits2 -= 2;
          break;
        case STORED:
          hold >>>= bits2 & 7;
          bits2 -= bits2 & 7;
          while (bits2 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits2 = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits2 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits2 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits2 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits2 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits2 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits2 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits2 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n3 = here_bits + 2;
                while (bits2 < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits2 -= 2;
              } else if (here_val === 17) {
                n3 = here_bits + 3;
                while (bits2 < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits2 -= 3;
              } else {
                n3 = here_bits + 7;
                while (bits2 < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits2;
                  bits2 += 8;
                }
                hold >>>= here_bits;
                bits2 -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits2 -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits2;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits2 = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n3 = state.extra;
            while (bits2 < n3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits2) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits2;
            bits2 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits2) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            hold >>>= last_bits;
            bits2 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits2 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n3 = state.extra;
            while (bits2 < n3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits2 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits2;
              bits2 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits2 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits2;
              bits2 += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits2 = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits2;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var deflate_1 = deflate;
var Inflate_1 = Inflate;
var inflate_1 = inflate;

// node_modules/fast-png/lib-esm/common.js
var pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];
var crcTable2 = [];
for (let n3 = 0; n3 < 256; n3++) {
  let c4 = n3;
  for (let k2 = 0; k2 < 8; k2++) {
    if (c4 & 1) {
      c4 = 3988292384 ^ c4 >>> 1;
    } else {
      c4 = c4 >>> 1;
    }
  }
  crcTable2[n3] = c4;
}
var initialCrc = 4294967295;
function updateCrc(currentCrc, data, length) {
  let c4 = currentCrc;
  for (let n3 = 0; n3 < length; n3++) {
    c4 = crcTable2[(c4 ^ data[n3]) & 255] ^ c4 >>> 8;
  }
  return c4;
}
function crc(data, length) {
  return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
}

// node_modules/fast-png/lib-esm/internalTypes.js
var ColorType;
(function(ColorType2) {
  ColorType2[ColorType2["UNKNOWN"] = -1] = "UNKNOWN";
  ColorType2[ColorType2["GREYSCALE"] = 0] = "GREYSCALE";
  ColorType2[ColorType2["TRUECOLOUR"] = 2] = "TRUECOLOUR";
  ColorType2[ColorType2["INDEXED_COLOUR"] = 3] = "INDEXED_COLOUR";
  ColorType2[ColorType2["GREYSCALE_ALPHA"] = 4] = "GREYSCALE_ALPHA";
  ColorType2[ColorType2["TRUECOLOUR_ALPHA"] = 6] = "TRUECOLOUR_ALPHA";
})(ColorType || (ColorType = {}));
var CompressionMethod;
(function(CompressionMethod2) {
  CompressionMethod2[CompressionMethod2["UNKNOWN"] = -1] = "UNKNOWN";
  CompressionMethod2[CompressionMethod2["DEFLATE"] = 0] = "DEFLATE";
})(CompressionMethod || (CompressionMethod = {}));
var FilterMethod;
(function(FilterMethod2) {
  FilterMethod2[FilterMethod2["UNKNOWN"] = -1] = "UNKNOWN";
  FilterMethod2[FilterMethod2["ADAPTIVE"] = 0] = "ADAPTIVE";
})(FilterMethod || (FilterMethod = {}));
var InterlaceMethod;
(function(InterlaceMethod2) {
  InterlaceMethod2[InterlaceMethod2["UNKNOWN"] = -1] = "UNKNOWN";
  InterlaceMethod2[InterlaceMethod2["NO_INTERLACE"] = 0] = "NO_INTERLACE";
  InterlaceMethod2[InterlaceMethod2["ADAM7"] = 1] = "ADAM7";
})(InterlaceMethod || (InterlaceMethod = {}));

// node_modules/fast-png/lib-esm/PngDecoder.js
var empty = new Uint8Array(0);
var NULL = "\0";
var uint16 = new Uint16Array([255]);
var uint8 = new Uint8Array(uint16.buffer);
var osIsLittleEndian = uint8[0] === 255;
var PngDecoder = class extends import_iobuffer.IOBuffer {
  constructor(data, options = {}) {
    super(data);
    const { checkCrc = false } = options;
    this._checkCrc = checkCrc;
    this._inflator = new Inflate_1();
    this._png = {
      width: -1,
      height: -1,
      channels: -1,
      data: new Uint8Array(0),
      depth: 1,
      text: {}
    };
    this._end = false;
    this._hasPalette = false;
    this._palette = [];
    this._hasTransparency = false;
    this._transparency = new Uint16Array(0);
    this._compressionMethod = CompressionMethod.UNKNOWN;
    this._filterMethod = FilterMethod.UNKNOWN;
    this._interlaceMethod = InterlaceMethod.UNKNOWN;
    this._colorType = ColorType.UNKNOWN;
    this.setBigEndian();
  }
  decode() {
    this.decodeSignature();
    while (!this._end) {
      this.decodeChunk();
    }
    this.decodeImage();
    return this._png;
  }
  // https://www.w3.org/TR/PNG/#5PNG-file-signature
  decodeSignature() {
    for (let i3 = 0; i3 < pngSignature.length; i3++) {
      if (this.readUint8() !== pngSignature[i3]) {
        throw new Error(`wrong PNG signature. Byte at ${i3} should be ${pngSignature[i3]}.`);
      }
    }
  }
  // https://www.w3.org/TR/PNG/#5Chunk-layout
  decodeChunk() {
    const length = this.readUint32();
    const type = this.readChars(4);
    const offset = this.offset;
    switch (type) {
      case "IHDR":
        this.decodeIHDR();
        break;
      case "PLTE":
        this.decodePLTE(length);
        break;
      case "IDAT":
        this.decodeIDAT(length);
        break;
      case "IEND":
        this._end = true;
        break;
      case "tRNS":
        this.decodetRNS(length);
        break;
      case "iCCP":
        this.decodeiCCP(length);
        break;
      case "tEXt":
        this.decodetEXt(length);
        break;
      case "pHYs":
        this.decodepHYs();
        break;
      default:
        this.skip(length);
        break;
    }
    if (this.offset - offset !== length) {
      throw new Error(`Length mismatch while decoding chunk ${type}`);
    }
    if (this._checkCrc) {
      const expectedCrc = this.readUint32();
      const crcLength = length + 4;
      const actualCrc = crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - crcLength - 4, crcLength), crcLength);
      if (actualCrc !== expectedCrc) {
        throw new Error(`CRC mismatch for chunk ${type}. Expected ${expectedCrc}, found ${actualCrc}`);
      }
    } else {
      this.skip(4);
    }
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  decodeIHDR() {
    const image = this._png;
    image.width = this.readUint32();
    image.height = this.readUint32();
    image.depth = checkBitDepth(this.readUint8());
    const colorType = this.readUint8();
    this._colorType = colorType;
    let channels;
    switch (colorType) {
      case ColorType.GREYSCALE:
        channels = 1;
        break;
      case ColorType.TRUECOLOUR:
        channels = 3;
        break;
      case ColorType.INDEXED_COLOUR:
        channels = 1;
        break;
      case ColorType.GREYSCALE_ALPHA:
        channels = 2;
        break;
      case ColorType.TRUECOLOUR_ALPHA:
        channels = 4;
        break;
      default:
        throw new Error(`Unknown color type: ${colorType}`);
    }
    this._png.channels = channels;
    this._compressionMethod = this.readUint8();
    if (this._compressionMethod !== CompressionMethod.DEFLATE) {
      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
    }
    this._filterMethod = this.readUint8();
    this._interlaceMethod = this.readUint8();
  }
  // https://www.w3.org/TR/PNG/#11PLTE
  decodePLTE(length) {
    if (length % 3 !== 0) {
      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
    }
    const l3 = length / 3;
    this._hasPalette = true;
    const palette = [];
    this._palette = palette;
    for (let i3 = 0; i3 < l3; i3++) {
      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
    }
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  decodeIDAT(length) {
    this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, length));
    this.skip(length);
  }
  // https://www.w3.org/TR/PNG/#11tRNS
  decodetRNS(length) {
    switch (this._colorType) {
      case ColorType.GREYSCALE:
      case ColorType.TRUECOLOUR: {
        if (length % 2 !== 0) {
          throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
        }
        if (length / 2 > this._png.width * this._png.height) {
          throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
        }
        this._hasTransparency = true;
        this._transparency = new Uint16Array(length / 2);
        for (let i3 = 0; i3 < length / 2; i3++) {
          this._transparency[i3] = this.readUint16();
        }
        break;
      }
      case ColorType.INDEXED_COLOUR: {
        if (length > this._palette.length) {
          throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
        }
        let i3 = 0;
        for (; i3 < length; i3++) {
          const alpha = this.readByte();
          this._palette[i3].push(alpha);
        }
        for (; i3 < this._palette.length; i3++) {
          this._palette[i3].push(255);
        }
        break;
      }
      default: {
        throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
      }
    }
  }
  // https://www.w3.org/TR/PNG/#11iCCP
  decodeiCCP(length) {
    let name = "";
    let char;
    while ((char = this.readChar()) !== NULL) {
      name += char;
    }
    const compressionMethod = this.readUint8();
    if (compressionMethod !== CompressionMethod.DEFLATE) {
      throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
    }
    const compressedProfile = this.readBytes(length - name.length - 2);
    this._png.iccEmbeddedProfile = {
      name,
      profile: inflate_1(compressedProfile)
    };
  }
  // https://www.w3.org/TR/PNG/#11tEXt
  decodetEXt(length) {
    let keyword = "";
    let char;
    while ((char = this.readChar()) !== NULL) {
      keyword += char;
    }
    this._png.text[keyword] = this.readChars(length - keyword.length - 1);
  }
  // https://www.w3.org/TR/PNG/#11pHYs
  decodepHYs() {
    const ppuX = this.readUint32();
    const ppuY = this.readUint32();
    const unitSpecifier = this.readByte();
    this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };
  }
  decodeImage() {
    if (this._inflator.err) {
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    }
    const data = this._inflator.result;
    if (this._filterMethod !== FilterMethod.ADAPTIVE) {
      throw new Error(`Filter method ${this._filterMethod} not supported`);
    }
    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
      this.decodeInterlaceNull(data);
    } else {
      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
    }
  }
  decodeInterlaceNull(data) {
    const height = this._png.height;
    const bytesPerPixel = this._png.channels * this._png.depth / 8;
    const bytesPerLine = this._png.width * bytesPerPixel;
    const newData = new Uint8Array(this._png.height * bytesPerLine);
    let prevLine = empty;
    let offset = 0;
    let currentLine;
    let newLine;
    for (let i3 = 0; i3 < height; i3++) {
      currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
      newLine = newData.subarray(i3 * bytesPerLine, (i3 + 1) * bytesPerLine);
      switch (data[offset]) {
        case 0:
          unfilterNone(currentLine, newLine, bytesPerLine);
          break;
        case 1:
          unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
          break;
        case 2:
          unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
          break;
        case 3:
          unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
          break;
        case 4:
          unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
          break;
        default:
          throw new Error(`Unsupported filter: ${data[offset]}`);
      }
      prevLine = newLine;
      offset += bytesPerLine + 1;
    }
    if (this._hasPalette) {
      this._png.palette = this._palette;
    }
    if (this._hasTransparency) {
      this._png.transparency = this._transparency;
    }
    if (this._png.depth === 16) {
      const uint16Data = new Uint16Array(newData.buffer);
      if (osIsLittleEndian) {
        for (let k2 = 0; k2 < uint16Data.length; k2++) {
          uint16Data[k2] = swap16(uint16Data[k2]);
        }
      }
      this._png.data = uint16Data;
    } else {
      this._png.data = newData;
    }
  }
};
function unfilterNone(currentLine, newLine, bytesPerLine) {
  for (let i3 = 0; i3 < bytesPerLine; i3++) {
    newLine[i3] = currentLine[i3];
  }
}
function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
  let i3 = 0;
  for (; i3 < bytesPerPixel; i3++) {
    newLine[i3] = currentLine[i3];
  }
  for (; i3 < bytesPerLine; i3++) {
    newLine[i3] = currentLine[i3] + newLine[i3 - bytesPerPixel] & 255;
  }
}
function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
  let i3 = 0;
  if (prevLine.length === 0) {
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3];
    }
  } else {
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + prevLine[i3] & 255;
    }
  }
}
function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i3 = 0;
  if (prevLine.length === 0) {
    for (; i3 < bytesPerPixel; i3++) {
      newLine[i3] = currentLine[i3];
    }
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + (newLine[i3 - bytesPerPixel] >> 1) & 255;
    }
  } else {
    for (; i3 < bytesPerPixel; i3++) {
      newLine[i3] = currentLine[i3] + (prevLine[i3] >> 1) & 255;
    }
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + (newLine[i3 - bytesPerPixel] + prevLine[i3] >> 1) & 255;
    }
  }
}
function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i3 = 0;
  if (prevLine.length === 0) {
    for (; i3 < bytesPerPixel; i3++) {
      newLine[i3] = currentLine[i3];
    }
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + newLine[i3 - bytesPerPixel] & 255;
    }
  } else {
    for (; i3 < bytesPerPixel; i3++) {
      newLine[i3] = currentLine[i3] + prevLine[i3] & 255;
    }
    for (; i3 < bytesPerLine; i3++) {
      newLine[i3] = currentLine[i3] + paethPredictor(newLine[i3 - bytesPerPixel], prevLine[i3], prevLine[i3 - bytesPerPixel]) & 255;
    }
  }
}
function paethPredictor(a3, b2, c4) {
  const p3 = a3 + b2 - c4;
  const pa = Math.abs(p3 - a3);
  const pb = Math.abs(p3 - b2);
  const pc = Math.abs(p3 - c4);
  if (pa <= pb && pa <= pc)
    return a3;
  else if (pb <= pc)
    return b2;
  else
    return c4;
}
function swap16(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}
function checkBitDepth(value) {
  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {
    throw new Error(`invalid bit depth: ${value}`);
  }
  return value;
}

// node_modules/fast-png/lib-esm/PngEncoder.js
var import_iobuffer2 = __toESM(require_IOBuffer());
var defaultZlibOptions = {
  level: 3
};
var PngEncoder = class extends import_iobuffer2.IOBuffer {
  constructor(data, options = {}) {
    super();
    this._colorType = ColorType.UNKNOWN;
    this._zlibOptions = { ...defaultZlibOptions, ...options.zlib };
    this._png = this._checkData(data);
    this.setBigEndian();
  }
  encode() {
    this.encodeSignature();
    this.encodeIHDR();
    this.encodeData();
    this.encodeIEND();
    return this.toArray();
  }
  // https://www.w3.org/TR/PNG/#5PNG-file-signature
  encodeSignature() {
    this.writeBytes(pngSignature);
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  encodeIHDR() {
    this.writeUint32(13);
    this.writeChars("IHDR");
    this.writeUint32(this._png.width);
    this.writeUint32(this._png.height);
    this.writeByte(this._png.depth);
    this.writeByte(this._colorType);
    this.writeByte(CompressionMethod.DEFLATE);
    this.writeByte(FilterMethod.ADAPTIVE);
    this.writeByte(InterlaceMethod.NO_INTERLACE);
    this.writeCrc(17);
  }
  // https://www.w3.org/TR/PNG/#11IEND
  encodeIEND() {
    this.writeUint32(0);
    this.writeChars("IEND");
    this.writeCrc(4);
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  encodeIDAT(data) {
    this.writeUint32(data.length);
    this.writeChars("IDAT");
    this.writeBytes(data);
    this.writeCrc(data.length + 4);
  }
  encodeData() {
    const { width, height, channels, depth, data } = this._png;
    const slotsPerLine = channels * width;
    const newData = new import_iobuffer2.IOBuffer().setBigEndian();
    let offset = 0;
    for (let i3 = 0; i3 < height; i3++) {
      newData.writeByte(0);
      if (depth === 8) {
        offset = writeDataBytes(data, newData, slotsPerLine, offset);
      } else if (depth === 16) {
        offset = writeDataUint16(data, newData, slotsPerLine, offset);
      } else {
        throw new Error("unreachable");
      }
    }
    const buffer = newData.toArray();
    const compressed = deflate_1(buffer, this._zlibOptions);
    this.encodeIDAT(compressed);
  }
  _checkData(data) {
    const { colorType, channels, depth } = getColorType(data);
    const png = {
      width: checkInteger(data.width, "width"),
      height: checkInteger(data.height, "height"),
      channels,
      data: data.data,
      depth,
      text: {}
    };
    this._colorType = colorType;
    const expectedSize = png.width * png.height * channels;
    if (png.data.length !== expectedSize) {
      throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);
    }
    return png;
  }
  writeCrc(length) {
    this.writeUint32(crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - length, length), length));
  }
};
function checkInteger(value, name) {
  if (Number.isInteger(value) && value > 0) {
    return value;
  }
  throw new TypeError(`${name} must be a positive integer`);
}
function getColorType(data) {
  const { channels = 4, depth = 8 } = data;
  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {
    throw new RangeError(`unsupported number of channels: ${channels}`);
  }
  if (depth !== 8 && depth !== 16) {
    throw new RangeError(`unsupported bit depth: ${depth}`);
  }
  const returnValue = { channels, depth, colorType: ColorType.UNKNOWN };
  switch (channels) {
    case 4:
      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;
      break;
    case 3:
      returnValue.colorType = ColorType.TRUECOLOUR;
      break;
    case 1:
      returnValue.colorType = ColorType.GREYSCALE;
      break;
    case 2:
      returnValue.colorType = ColorType.GREYSCALE_ALPHA;
      break;
    default:
      throw new Error("unsupported number of channels");
  }
  return returnValue;
}
function writeDataBytes(data, newData, slotsPerLine, offset) {
  for (let j2 = 0; j2 < slotsPerLine; j2++) {
    newData.writeByte(data[offset++]);
  }
  return offset;
}
function writeDataUint16(data, newData, slotsPerLine, offset) {
  for (let j2 = 0; j2 < slotsPerLine; j2++) {
    newData.writeUint16(data[offset++]);
  }
  return offset;
}

// node_modules/fast-png/lib-esm/types.js
var ResolutionUnitSpecifier;
(function(ResolutionUnitSpecifier2) {
  ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["UNKNOWN"] = 0] = "UNKNOWN";
  ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["METRE"] = 1] = "METRE";
})(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));

// node_modules/fast-png/lib-esm/index.js
function decodePng(data, options) {
  const decoder = new PngDecoder(data, options);
  return decoder.decode();
}
function encodePng(png, options) {
  const encoder = new PngEncoder(png, options);
  return encoder.encode();
}

// node_modules/image-js/src/image/core/export.js
var import_jpeg_js = __toESM(require_jpeg_js());

// node_modules/image-js/src/util/base64.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = new Uint8Array(256);
for (let i3 = 0; i3 < chars.length; i3++) {
  lookup[chars.charCodeAt(i3)] = i3;
}
function encode(bytes) {
  let i3;
  let len = bytes.length;
  let base64 = "";
  for (i3 = 0; i3 < len; i3 += 3) {
    base64 += chars[bytes[i3] >> 2];
    base64 += chars[(bytes[i3] & 3) << 4 | bytes[i3 + 1] >> 4];
    base64 += chars[(bytes[i3 + 1] & 15) << 2 | bytes[i3 + 2] >> 6];
    base64 += chars[bytes[i3 + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = `${base64.substring(0, base64.length - 1)}=`;
  } else if (len % 3 === 1) {
    base64 = `${base64.substring(0, base64.length - 2)}==`;
  }
  return base64;
}
function decode(base64) {
  let bufferLength = base64.length * 0.75;
  let len = base64.length;
  let p3 = 0;
  let encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const bytes = new Uint8Array(bufferLength);
  for (let i3 = 0; i3 < len; i3 += 4) {
    encoded1 = lookup[base64.charCodeAt(i3)];
    encoded2 = lookup[base64.charCodeAt(i3 + 1)];
    encoded3 = lookup[base64.charCodeAt(i3 + 2)];
    encoded4 = lookup[base64.charCodeAt(i3 + 3)];
    bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
}
function toBase64URL(u82, type) {
  const base64 = encode(u82);
  return `data:${type};base64,${base64}`;
}

// node_modules/image-js/src/browser/environment.js
var ImageData = self.ImageData;
var DOMImage = self.Image;
function createCanvas(width, height) {
  let canvas = self.document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function fetchBinary(url, { withCredentials = false } = {}) {
  return new Promise(function(resolve2, reject2) {
    let xhr = new self.XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.responseType = "arraybuffer";
    xhr.withCredentials = withCredentials;
    xhr.onload = function(e2) {
      if (this.status !== 200)
        reject2(e2);
      else
        resolve2(this.response);
    };
    xhr.onerror = reject2;
    xhr.send();
  });
}
function createWriteStream() {
  throw new Error("createWriteStream does not exist in the browser");
}
function writeFile() {
  throw new Error("writeFile does not exist in the browser");
}

// node_modules/image-js/src/image/core/mediaTypes.js
function getType(type) {
  if (!type.includes("/")) {
    type = `image/${type}`;
  }
  return type;
}

// node_modules/image-js/src/image/core/export.js
function encodeJpeg(image, options = {}) {
  const data = {
    width: image.width,
    height: image.height,
    data: image.getRGBAData()
  };
  return (0, import_jpeg_js.encode)(data, options.quality).data;
}
function encodePng2(image, options) {
  const data = {
    width: image.width,
    height: image.height,
    channels: image.channels,
    depth: image.bitDepth,
    data: image.data
  };
  if (data.depth === 1 || data.depth === 32) {
    data.depth = 8;
    data.channels = 4;
    data.data = image.getRGBAData();
  }
  return encodePng(data, options);
}
var exportMethods = {
  /**
   * Save the image to disk (Node.js only)
   * @memberof Image
   * @instance
   * @param {string} path
   * @param {object} [options]
   * @param {string} [options.format] - One of: png, jpg, bmp (limited support for bmp). If not specified will try to infer from filename
   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of a JavaScript implementation
   * @param {object} [options.encoder] - Specify options for the encoder if applicable.
   * @return {Promise} - Resolves when the file is fully written
   */
  save(path, options = {}) {
    const { useCanvas = false, encoder: encoderOptions = void 0 } = options;
    let { format } = options;
    if (!format) {
      const m4 = /\.(?<format>[a-zA-Z]+)$/.exec(path);
      if (m4) {
        format = m4.groups.format.toLowerCase();
      }
    }
    if (!format) {
      throw new Error("file format not provided");
    }
    return new Promise((resolve2, reject2) => {
      let stream2, buffer;
      switch (format.toLowerCase()) {
        case "png": {
          if (useCanvas) {
            stream2 = this.getCanvas().pngStream();
          } else {
            buffer = encodePng2(this, encoderOptions);
          }
          break;
        }
        case "jpg":
        case "jpeg":
          if (useCanvas) {
            stream2 = this.getCanvas().jpegStream();
          } else {
            buffer = encodeJpeg(this, encoderOptions);
          }
          break;
        case "bmp":
          buffer = (0, import_fast_bmp.encode)(this, encoderOptions);
          break;
        default:
          throw new RangeError(`invalid output format: ${format}`);
      }
      if (stream2) {
        let out = createWriteStream(path);
        out.on("finish", resolve2);
        out.on("error", reject2);
        stream2.pipe(out);
      } else if (buffer) {
        writeFile(path, buffer, (err3) => {
          if (err3) {
            reject2(err3);
            return;
          }
          resolve2();
        });
      }
    });
  },
  /**
   * Creates a dataURL string from the image.
   * @memberof Image
   * @instance
   * @param {string} [type='image/png']
   * @param {object} [options]
   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of JavaScript implementation.
   * @param {object} [options.encoder] - Specify options for the encoder if applicable.
   * @return {string|Promise<string>}
   */
  toDataURL(type = "image/png", options = {}) {
    if (typeof type === "object") {
      options = type;
      type = "image/png";
    }
    const { useCanvas = false, encoder: encoderOptions = void 0 } = options;
    type = getType(type);
    function dataUrl(encoder, ctx) {
      const u82 = encoder(ctx, encoderOptions);
      return toBase64URL(u82, type);
    }
    if (type === "image/bmp") {
      return dataUrl(import_fast_bmp.encode, this);
    } else if (type === "image/png" && !useCanvas) {
      return dataUrl(encodePng2, this);
    } else if (type === "image/jpeg" && !useCanvas) {
      return dataUrl(encodeJpeg, this);
    } else {
      return this.getCanvas().toDataURL(type);
    }
  },
  /**
   * Encodes the image and returns a buffer
   * @memberof Image
   * @instance
   * @param {object} [options]
   * @param {string} [options.format='png']
   * @param {object} [options.encoder] - Specify options for the encoder if applicable.
   * @return {Uint8Array}
   */
  toBuffer(options = {}) {
    const { format = "png", encoder: encoderOptions = void 0 } = options;
    switch (format.toLowerCase()) {
      case "png":
        return encodePng2(this, encoderOptions);
      case "jpeg":
      case "jpg":
        return encodeJpeg(this, encoderOptions);
      case "bmp":
        return (0, import_fast_bmp.encode)(this, encoderOptions);
      default:
        throw new RangeError(`invalid output format: ${format}`);
    }
  },
  /**
   * Creates a base64 string from the image.
   * @memberof Image
   * @instance
   * @param {string} [type='image/png']
   * @param {object} [options] - Same options as toDataURL
   * @return {string|Promise<string>}
   */
  toBase64(type = "image/png", options = {}) {
    if (options.async) {
      return this.toDataURL(type, options).then(function(dataURL) {
        return dataURL.substring(dataURL.indexOf(",") + 1);
      });
    } else {
      const dataURL = this.toDataURL(type, options);
      return dataURL.substring(dataURL.indexOf(",") + 1);
    }
  },
  /**
   * Creates a blob from the image and return a Promise.
   * This function is only available in the browser.
   * @memberof Image
   * @instance
   * @param {string} [type='image/png'] A String indicating the image format. The default type is image/png.
   * @param {string} [quality=0.8] A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.
   * @return {Promise}
   */
  toBlob(type = "image/png", quality = 0.8) {
    return canvasToBlob(this.getCanvas(), type, quality);
  },
  /**
   * Creates a new canvas element and draw the image inside it
   * @memberof Image
   * @instance
   * @return {Canvas}
   */
  getCanvas() {
    const data = new ImageData(
      this.getRGBAData({ clamped: true }),
      this.width,
      this.height
    );
    let canvas = createCanvas(this.width, this.height);
    let ctx = canvas.getContext("2d");
    ctx.putImageData(data, 0, 0);
    return canvas;
  }
};
function setExportMethods(Image3) {
  for (const i3 in exportMethods) {
    Image3.prototype[i3] = exportMethods[i3];
  }
}

// node_modules/image-js/src/image/core/extend.js
var import_has_own = __toESM(require_has_own());
var computedPropertyDescriptor = {
  configurable: true,
  enumerable: false,
  get: void 0
};
function extendMethod(name, method, options = {}) {
  let { inPlace = false, returnThis = true, partialArgs = [] } = options;
  if (inPlace) {
    Image2.prototype[name] = function(...args) {
      this.computed = null;
      let result = method.apply(this, [...partialArgs, ...args]);
      if (returnThis) {
        return this;
      }
      return result;
    };
  } else {
    Image2.prototype[name] = function(...args) {
      return method.apply(this, [...partialArgs, ...args]);
    };
  }
  return Image2;
}
function extendProperty(name, method, options = {}) {
  let { partialArgs = [] } = options;
  computedPropertyDescriptor.get = function() {
    if (this.computed === null) {
      this.computed = {};
    } else if ((0, import_has_own.default)(name, this.computed)) {
      return this.computed[name];
    }
    let result = method.apply(this, partialArgs);
    this.computed[name] = result;
    return result;
  };
  Object.defineProperty(Image2.prototype, name, computedPropertyDescriptor);
  return Image2;
}

// node_modules/image-js/src/image/model/model.js
var model_exports = {};
__export(model_exports, {
  CMYK: () => CMYK,
  GREY: () => GREY,
  HSL: () => HSL,
  HSV: () => HSV,
  RGB: () => RGB
});
var GREY = "GREY";
var RGB = "RGB";
var HSL = "HSL";
var HSV = "HSV";
var CMYK = "CMYK";

// node_modules/image-js/src/image/core/getRGBAData.js
function getRGBAData(options = {}) {
  const { clamped } = options;
  this.checkProcessable("getRGBAData", {
    components: [1, 3],
    bitDepth: [1, 8, 16, 32]
  });
  const arrayLength = this.width * this.height * 4;
  let newData = clamped ? new Uint8ClampedArray(arrayLength) : new Uint8Array(arrayLength);
  if (this.bitDepth === 1) {
    fillDataFromBinary(this, newData);
  } else if (this.bitDepth === 32) {
    this.checkProcessable("getRGBAData", { alpha: 0 });
    if (this.components === 1) {
      fillDataFromGrey32(this, newData);
    } else if (this.components === 3) {
      this.checkProcessable("getRGBAData", { colorModel: [RGB] });
      fillDataFromRGB32(this, newData);
    }
  } else {
    if (this.components === 1) {
      fillDataFromGrey(this, newData);
    } else if (this.components === 3) {
      this.checkProcessable("getRGBAData", { colorModel: [RGB] });
      fillDataFromRGB(this, newData);
    }
  }
  if (this.alpha === 1) {
    this.checkProcessable("getRGBAData", { bitDepth: [8, 16] });
    copyAlpha(this, newData);
  } else {
    fillAlpha(this, newData);
  }
  return newData;
}
function fillDataFromBinary(image, newData) {
  for (let i3 = 0; i3 < image.size; i3++) {
    const value = image.getBit(i3);
    newData[i3 * 4] = value * 255;
    newData[i3 * 4 + 1] = value * 255;
    newData[i3 * 4 + 2] = value * 255;
  }
}
function fillDataFromGrey32(image, newData) {
  const min3 = image.min[0];
  const max4 = image.max[0];
  const range = max4 - min3;
  for (let i3 = 0; i3 < image.size; i3++) {
    const val = Math.floor(255 * (image.data[i3] - min3) / range);
    newData[i3 * 4] = val;
    newData[i3 * 4 + 1] = val;
    newData[i3 * 4 + 2] = val;
  }
}
function fillDataFromRGB32(image, newData) {
  const min3 = Math.min(...image.min);
  const max4 = Math.max(...image.max);
  const range = max4 - min3;
  for (let i3 = 0; i3 < image.size; i3++) {
    const val1 = Math.floor(255 * (image.data[i3 * 3] - min3) / range);
    const val2 = Math.floor(255 * (image.data[i3 * 3 + 1] - min3) / range);
    const val3 = Math.floor(255 * (image.data[i3 * 3 + 2] - min3) / range);
    newData[i3 * 4] = val1;
    newData[i3 * 4 + 1] = val2;
    newData[i3 * 4 + 2] = val3;
  }
}
function fillDataFromGrey(image, newData) {
  for (let i3 = 0; i3 < image.size; i3++) {
    newData[i3 * 4] = image.data[i3 * image.channels] >>> image.bitDepth - 8;
    newData[i3 * 4 + 1] = image.data[i3 * image.channels] >>> image.bitDepth - 8;
    newData[i3 * 4 + 2] = image.data[i3 * image.channels] >>> image.bitDepth - 8;
  }
}
function fillDataFromRGB(image, newData) {
  for (let i3 = 0; i3 < image.size; i3++) {
    newData[i3 * 4] = image.data[i3 * image.channels] >>> image.bitDepth - 8;
    newData[i3 * 4 + 1] = image.data[i3 * image.channels + 1] >>> image.bitDepth - 8;
    newData[i3 * 4 + 2] = image.data[i3 * image.channels + 2] >>> image.bitDepth - 8;
  }
}
function copyAlpha(image, newData) {
  for (let i3 = 0; i3 < image.size; i3++) {
    newData[i3 * 4 + 3] = image.data[i3 * image.channels + image.components] >> image.bitDepth - 8;
  }
}
function fillAlpha(image, newData) {
  for (let i3 = 0; i3 < image.size; i3++) {
    newData[i3 * 4 + 3] = 255;
  }
}

// node_modules/image-js/src/image/core/kindNames.js
var BINARY = "BINARY";
var GREY2 = "GREY";
var GREYA = "GREYA";
var RGB2 = "RGB";
var RGBA = "RGBA";
var CMYK2 = "CMYK";
var CMYKA = "CMYKA";

// node_modules/image-js/src/image/core/kind.js
var kinds = {};
kinds[BINARY] = {
  components: 1,
  alpha: 0,
  bitDepth: 1,
  colorModel: GREY
};
kinds[GREYA] = {
  components: 1,
  alpha: 1,
  bitDepth: 8,
  colorModel: GREY
};
kinds[GREY2] = {
  components: 1,
  alpha: 0,
  bitDepth: 8,
  colorModel: GREY
};
kinds[RGBA] = {
  components: 3,
  alpha: 1,
  bitDepth: 8,
  colorModel: RGB
};
kinds[RGB2] = {
  components: 3,
  alpha: 0,
  bitDepth: 8,
  colorModel: RGB
};
kinds[CMYK2] = {
  components: 4,
  alpha: 0,
  bitDepth: 8,
  colorModel: CMYK
};
kinds[CMYKA] = {
  components: 4,
  alpha: 1,
  bitDepth: 8,
  colorModel: CMYK
};
function getKind(kind) {
  const result = kinds[kind];
  if (!result) {
    throw new RangeError(`invalid image kind: ${kind}`);
  }
  return result;
}
var validBitDepth = [1, 8, 16, 32];
function verifyKindDefinition(definition) {
  const { components, alpha, bitDepth, colorModel } = definition;
  if (!Number.isInteger(components) || components <= 0) {
    throw new RangeError(
      `invalid components: ${components}. Must be a positive integer`
    );
  }
  if (alpha !== 0 && alpha !== 1 && typeof alpha !== "boolean") {
    throw new TypeError(`invalid alpha: ${alpha}: must be a boolean, 0 or 1`);
  }
  if (!validBitDepth.includes(bitDepth)) {
    throw new RangeError(
      `invalid bitDepth: ${bitDepth}. Must be one of ${validBitDepth.join(
        ", "
      )}`
    );
  }
  if (!model_exports[colorModel]) {
    throw new RangeError(
      `invalid colorModel: ${colorModel}. Must be one of ${Object.keys(
        model_exports
      ).join(", ")}`
    );
  }
}
function getTheoreticalPixelArraySize(size, channels, bitDepth) {
  let length = channels * size;
  if (bitDepth === 1) {
    length = Math.ceil(length / 8);
  }
  return length;
}
function createPixelArray(size, components, alpha, channels, bitDepth, maxValue) {
  const length = channels * size;
  let arr;
  switch (bitDepth) {
    case 1:
      arr = new Uint8Array(Math.ceil(length / 8));
      break;
    case 8:
      arr = new Uint8Array(length);
      break;
    case 16:
      arr = new Uint16Array(length);
      break;
    case 32:
      arr = new Float32Array(length);
      break;
    default:
      throw new Error(`Cannot create pixel array for bit depth ${bitDepth}`);
  }
  if (alpha) {
    for (let i3 = components; i3 < arr.length; i3 += channels) {
      arr[i3] = maxValue;
    }
  }
  return arr;
}

// node_modules/image-js/src/image/core/load.js
var import_fast_jpeg = __toESM(require_src3());
var import_image_type = __toESM(require_image_type());
var import_jpeg_js2 = __toESM(require_jpeg_js());

// node_modules/tiff/lib-esm/tiffDecoder.js
var import_iobuffer4 = __toESM(require_IOBuffer());

// node_modules/tiff/lib-esm/hacks.js
function guessStripByteCounts(ifd) {
  if (ifd.compression !== 1) {
    throw new Error("missing mandatory StripByteCounts field in compressed image");
  }
  const bytesPerStrip = ifd.rowsPerStrip * ifd.width * ifd.samplesPerPixel * (ifd.bitsPerSample / 8);
  return new Array(ifd.stripOffsets.length).fill(bytesPerStrip);
}

// node_modules/tiff/lib-esm/horizontalDifferencing.js
function applyHorizontalDifferencing8Bit(data, width, components) {
  let i3 = 0;
  while (i3 < data.length) {
    for (let j2 = components; j2 < width * components; j2 += components) {
      for (let k2 = 0; k2 < components; k2++) {
        data[i3 + j2 + k2] = data[i3 + j2 + k2] + data[i3 + j2 - (components - k2)] & 255;
      }
    }
    i3 += width * components;
  }
}
function applyHorizontalDifferencing16Bit(data, width, components) {
  let i3 = 0;
  while (i3 < data.length) {
    for (let j2 = components; j2 < width * components; j2 += components) {
      for (let k2 = 0; k2 < components; k2++) {
        data[i3 + j2 + k2] = data[i3 + j2 + k2] + data[i3 + j2 - (components - k2)] & 65535;
      }
    }
    i3 += width * components;
  }
}

// node_modules/tiff/lib-esm/tags/exif.js
var exif_exports = {};
__export(exif_exports, {
  tagsById: () => tagsById,
  tagsByName: () => tagsByName
});
var tagsById = {
  33434: "ExposureTime",
  33437: "FNumber",
  34850: "ExposureProgram",
  34852: "SpectralSensitivity",
  34855: "ISOSpeedRatings",
  34856: "OECF",
  34864: "SensitivityType",
  34865: "StandardOutputSensitivity",
  34866: "RecommendedExposureIndex",
  34867: "ISOSpeed",
  34868: "ISOSpeedLatitudeyyy",
  34869: "ISOSpeedLatitudezzz",
  36864: "ExifVersion",
  36867: "DateTimeOriginal",
  36868: "DateTimeDigitized",
  37121: "ComponentsConfiguration",
  37122: "CompressedBitsPerPixel",
  37377: "ShutterSpeedValue",
  37378: "ApertureValue",
  37379: "BrightnessValue",
  37380: "ExposureBiasValue",
  37381: "MaxApertureValue",
  37382: "SubjectDistance",
  37383: "MeteringMode",
  37384: "LightSource",
  37385: "Flash",
  37386: "FocalLength",
  37396: "SubjectArea",
  37500: "MakerNote",
  37510: "UserComment",
  37520: "SubsecTime",
  37521: "SubsecTimeOriginal",
  37522: "SubsecTimeDigitized",
  40960: "FlashpixVersion",
  40961: "ColorSpace",
  40962: "PixelXDimension",
  40963: "PixelYDimension",
  40964: "RelatedSoundFile",
  41483: "FlashEnergy",
  41484: "SpatialFrequencyResponse",
  41486: "FocalPlaneXResolution",
  41487: "FocalPlaneYResolution",
  41488: "FocalPlaneResolutionUnit",
  41492: "SubjectLocation",
  41493: "ExposureIndex",
  41495: "SensingMethod",
  41728: "FileSource",
  41729: "SceneType",
  41730: "CFAPattern",
  41985: "CustomRendered",
  41986: "ExposureMode",
  41987: "WhiteBalance",
  41988: "DigitalZoomRatio",
  41989: "FocalLengthIn35mmFilm",
  41990: "SceneCaptureType",
  41991: "GainControl",
  41992: "Contrast",
  41993: "Saturation",
  41994: "Sharpness",
  41995: "DeviceSettingDescription",
  41996: "SubjectDistanceRange",
  42016: "ImageUniqueID",
  42032: "CameraOwnerName",
  42033: "BodySerialNumber",
  42034: "LensSpecification",
  42035: "LensMake",
  42036: "LensModel",
  42037: "LensSerialNumber",
  42240: "Gamma"
};
var tagsByName = {};
for (let i3 in tagsById) {
  tagsByName[tagsById[i3]] = Number(i3);
}

// node_modules/tiff/lib-esm/tags/gps.js
var gps_exports = {};
__export(gps_exports, {
  tagsById: () => tagsById2,
  tagsByName: () => tagsByName2
});
var tagsById2 = {
  0: "GPSVersionID",
  1: "GPSLatitudeRef",
  2: "GPSLatitude",
  3: "GPSLongitudeRef",
  4: "GPSLongitude",
  5: "GPSAltitudeRef",
  6: "GPSAltitude",
  7: "GPSTimeStamp",
  8: "GPSSatellites",
  9: "GPSStatus",
  10: "GPSMeasureMode",
  11: "GPSDOP",
  12: "GPSSpeedRef",
  13: "GPSSpeed",
  14: "GPSTrackRef",
  15: "GPSTrack",
  16: "GPSImgDirectionRef",
  17: "GPSImgDirection",
  18: "GPSMapDatum",
  19: "GPSDestLatitudeRef",
  20: "GPSDestLatitude",
  21: "GPSDestLongitudeRef",
  22: "GPSDestLongitude",
  23: "GPSDestBearingRef",
  24: "GPSDestBearing",
  25: "GPSDestDistanceRef",
  26: "GPSDestDistance",
  27: "GPSProcessingMethod",
  28: "GPSAreaInformation",
  29: "GPSDateStamp",
  30: "GPSDifferential",
  31: "GPSHPositioningError"
};
var tagsByName2 = {};
for (let i3 in tagsById2) {
  tagsByName2[tagsById2[i3]] = Number(i3);
}

// node_modules/tiff/lib-esm/tags/standard.js
var standard_exports = {};
__export(standard_exports, {
  tagsById: () => tagsById3,
  tagsByName: () => tagsByName3
});
var tagsById3 = {
  // Baseline tags
  254: "NewSubfileType",
  255: "SubfileType",
  256: "ImageWidth",
  257: "ImageLength",
  258: "BitsPerSample",
  259: "Compression",
  262: "PhotometricInterpretation",
  263: "Threshholding",
  264: "CellWidth",
  265: "CellLength",
  266: "FillOrder",
  270: "ImageDescription",
  271: "Make",
  272: "Model",
  273: "StripOffsets",
  274: "Orientation",
  277: "SamplesPerPixel",
  278: "RowsPerStrip",
  279: "StripByteCounts",
  280: "MinSampleValue",
  281: "MaxSampleValue",
  282: "XResolution",
  283: "YResolution",
  284: "PlanarConfiguration",
  288: "FreeOffsets",
  289: "FreeByteCounts",
  290: "GrayResponseUnit",
  291: "GrayResponseCurve",
  296: "ResolutionUnit",
  305: "Software",
  306: "DateTime",
  315: "Artist",
  316: "HostComputer",
  320: "ColorMap",
  338: "ExtraSamples",
  33432: "Copyright",
  // Extension tags
  269: "DocumentName",
  285: "PageName",
  286: "XPosition",
  287: "YPosition",
  292: "T4Options",
  293: "T6Options",
  297: "PageNumber",
  301: "TransferFunction",
  317: "Predictor",
  318: "WhitePoint",
  319: "PrimaryChromaticities",
  321: "HalftoneHints",
  322: "TileWidth",
  323: "TileLength",
  324: "TileOffsets",
  325: "TileByteCounts",
  326: "BadFaxLines",
  327: "CleanFaxData",
  328: "ConsecutiveBadFaxLines",
  330: "SubIFDs",
  332: "InkSet",
  333: "InkNames",
  334: "NumberOfInks",
  336: "DotRange",
  337: "TargetPrinter",
  339: "SampleFormat",
  340: "SMinSampleValue",
  341: "SMaxSampleValue",
  342: "TransferRange",
  343: "ClipPath",
  344: "XClipPathUnits",
  345: "YClipPathUnits",
  346: "Indexed",
  347: "JPEGTables",
  351: "OPIProxy",
  400: "GlobalParametersIFD",
  401: "ProfileType",
  402: "FaxProfile",
  403: "CodingMethods",
  404: "VersionYear",
  405: "ModeNumber",
  433: "Decode",
  434: "DefaultImageColor",
  512: "JPEGProc",
  513: "JPEGInterchangeFormat",
  514: "JPEGInterchangeFormatLength",
  515: "JPEGRestartInterval",
  517: "JPEGLosslessPredictors",
  518: "JPEGPointTransforms",
  519: "JPEGQTables",
  520: "JPEGDCTables",
  521: "JPEGACTables",
  529: "YCbCrCoefficients",
  530: "YCbCrSubSampling",
  531: "YCbCrPositioning",
  532: "ReferenceBlackWhite",
  559: "StripRowCounts",
  700: "XMP",
  32781: "ImageID",
  34732: "ImageLayer",
  // Private tags
  32932: "WangAnnotatio",
  33445: "MDFileTag",
  33446: "MDScalePixel",
  33447: "MDColorTable",
  33448: "MDLabName",
  33449: "MDSampleInfo",
  33450: "MDPrepDate",
  33451: "MDPrepTime",
  33452: "MDFileUnits",
  33550: "ModelPixelScaleTag",
  33723: "IPTC",
  33918: "INGRPacketDataTag",
  33919: "INGRFlagRegisters",
  33920: "IrasBTransformationMatrix",
  33922: "ModelTiepointTag",
  34264: "ModelTransformationTag",
  34377: "Photoshop",
  34665: "ExifIFD",
  34675: "ICCProfile",
  34735: "GeoKeyDirectoryTag",
  34736: "GeoDoubleParamsTag",
  34737: "GeoAsciiParamsTag",
  34853: "GPSIFD",
  34908: "HylaFAXFaxRecvParams",
  34909: "HylaFAXFaxSubAddress",
  34910: "HylaFAXFaxRecvTime",
  37724: "ImageSourceData",
  40965: "InteroperabilityIFD",
  42112: "GDAL_METADATA",
  42113: "GDAL_NODATA",
  50215: "OceScanjobDescription",
  50216: "OceApplicationSelector",
  50217: "OceIdentificationNumber",
  50218: "OceImageLogicCharacteristics",
  50706: "DNGVersion",
  50707: "DNGBackwardVersion",
  50708: "UniqueCameraModel",
  50709: "LocalizedCameraModel",
  50710: "CFAPlaneColor",
  50711: "CFALayout",
  50712: "LinearizationTable",
  50713: "BlackLevelRepeatDim",
  50714: "BlackLevel",
  50715: "BlackLevelDeltaH",
  50716: "BlackLevelDeltaV",
  50717: "WhiteLevel",
  50718: "DefaultScale",
  50719: "DefaultCropOrigin",
  50720: "DefaultCropSize",
  50721: "ColorMatrix1",
  50722: "ColorMatrix2",
  50723: "CameraCalibration1",
  50724: "CameraCalibration2",
  50725: "ReductionMatrix1",
  50726: "ReductionMatrix2",
  50727: "AnalogBalance",
  50728: "AsShotNeutral",
  50729: "AsShotWhiteXY",
  50730: "BaselineExposure",
  50731: "BaselineNoise",
  50732: "BaselineSharpness",
  50733: "BayerGreenSplit",
  50734: "LinearResponseLimit",
  50735: "CameraSerialNumber",
  50736: "LensInfo",
  50737: "ChromaBlurRadius",
  50738: "AntiAliasStrength",
  50740: "DNGPrivateData",
  50741: "MakerNoteSafety",
  50778: "CalibrationIlluminant1",
  50779: "CalibrationIlluminant2",
  50780: "BestQualityScale",
  50784: "AliasLayerMetadata"
};
var tagsByName3 = {};
for (let i3 in tagsById3) {
  tagsByName3[tagsById3[i3]] = Number(i3);
}

// node_modules/tiff/lib-esm/ifd.js
var tags = {
  standard: standard_exports,
  exif: exif_exports,
  gps: gps_exports
};
var IFD = class {
  constructor(kind) {
    if (!kind) {
      throw new Error("missing kind");
    }
    this.data = new Uint8Array();
    this.fields = /* @__PURE__ */ new Map();
    this.kind = kind;
    this._hasMap = false;
    this._map = {};
  }
  get(tag) {
    if (typeof tag === "number") {
      return this.fields.get(tag);
    } else if (typeof tag === "string") {
      return this.fields.get(tags[this.kind].tagsByName[tag]);
    } else {
      throw new Error("expected a number or string");
    }
  }
  get map() {
    if (!this._hasMap) {
      const taglist = tags[this.kind].tagsById;
      for (let key of this.fields.keys()) {
        if (taglist[key]) {
          this._map[taglist[key]] = this.fields.get(key);
        }
      }
      this._hasMap = true;
    }
    return this._map;
  }
};

// node_modules/tiff/lib-esm/ifdValue.js
var types = /* @__PURE__ */ new Map([
  [1, [1, readByte]],
  [2, [1, readASCII]],
  [3, [2, readShort]],
  [4, [4, readLong]],
  [5, [8, readRational]],
  [6, [1, readSByte]],
  [7, [1, readByte]],
  [8, [2, readSShort]],
  [9, [4, readSLong]],
  [10, [8, readSRational]],
  [11, [4, readFloat]],
  [12, [8, readDouble]]
  // DOUBLE
]);
function getByteLength(type, count) {
  const val = types.get(type);
  if (!val)
    throw new Error(`type not found: ${type}`);
  return val[0] * count;
}
function readData(decoder, type, count) {
  const val = types.get(type);
  if (!val)
    throw new Error(`type not found: ${type}`);
  return val[1](decoder, count);
}
function readByte(decoder, count) {
  if (count === 1)
    return decoder.readUint8();
  let array3 = new Uint8Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    array3[i3] = decoder.readUint8();
  }
  return array3;
}
function readASCII(decoder, count) {
  let strings2 = [];
  let currentString = "";
  for (let i3 = 0; i3 < count; i3++) {
    let char = String.fromCharCode(decoder.readUint8());
    if (char === "\0") {
      strings2.push(currentString);
      currentString = "";
    } else {
      currentString += char;
    }
  }
  if (strings2.length === 1) {
    return strings2[0];
  } else {
    return strings2;
  }
}
function readShort(decoder, count) {
  if (count === 1)
    return decoder.readUint16();
  let array3 = new Uint16Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    array3[i3] = decoder.readUint16();
  }
  return array3;
}
function readLong(decoder, count) {
  if (count === 1)
    return decoder.readUint32();
  let array3 = new Uint32Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    array3[i3] = decoder.readUint32();
  }
  return array3;
}
function readRational(decoder, count) {
  if (count === 1) {
    return decoder.readUint32() / decoder.readUint32();
  }
  let rationals = new Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    rationals[i3] = decoder.readUint32() / decoder.readUint32();
  }
  return rationals;
}
function readSByte(decoder, count) {
  if (count === 1)
    return decoder.readInt8();
  let array3 = new Int8Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    array3[i3] = decoder.readInt8();
  }
  return array3;
}
function readSShort(decoder, count) {
  if (count === 1)
    return decoder.readInt16();
  let array3 = new Int16Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    array3[i3] = decoder.readInt16();
  }
  return array3;
}
function readSLong(decoder, count) {
  if (count === 1)
    return decoder.readInt32();
  let array3 = new Int32Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    array3[i3] = decoder.readInt32();
  }
  return array3;
}
function readSRational(decoder, count) {
  if (count === 1) {
    return decoder.readInt32() / decoder.readInt32();
  }
  let rationals = new Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    rationals[i3] = decoder.readInt32() / decoder.readInt32();
  }
  return rationals;
}
function readFloat(decoder, count) {
  if (count === 1)
    return decoder.readFloat32();
  let array3 = new Float32Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    array3[i3] = decoder.readFloat32();
  }
  return array3;
}
function readDouble(decoder, count) {
  if (count === 1)
    return decoder.readFloat64();
  let array3 = new Float64Array(count);
  for (let i3 = 0; i3 < count; i3++) {
    array3[i3] = decoder.readFloat64();
  }
  return array3;
}

// node_modules/tiff/lib-esm/lzw.js
var import_iobuffer3 = __toESM(require_IOBuffer());
var CLEAR_CODE = 256;
var EOI_CODE = 257;
var TABLE_START = 258;
var MIN_BIT_LENGTH = 9;
var stringTable = [];
function initializeStringTable() {
  if (stringTable.length === 0) {
    for (let i3 = 0; i3 < 256; i3++) {
      stringTable.push([i3]);
    }
    const dummyString = [];
    for (let i3 = 256; i3 < 4096; i3++) {
      stringTable.push(dummyString);
    }
  }
}
var andTable = [511, 1023, 2047, 4095];
var bitJumps = [0, 0, 0, 0, 0, 0, 0, 0, 0, 511, 1023, 2047, 4095];
var LzwDecoder = class {
  constructor(data) {
    this.nextData = 0;
    this.nextBits = 0;
    this.bytePointer = 0;
    this.tableLength = TABLE_START;
    this.currentBitLength = MIN_BIT_LENGTH;
    this.stripArray = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    this.outData = new import_iobuffer3.IOBuffer(data.byteLength);
    this.initializeTable();
  }
  decode() {
    let code = 0;
    let oldCode = 0;
    while ((code = this.getNextCode()) !== EOI_CODE) {
      if (code === CLEAR_CODE) {
        this.initializeTable();
        code = this.getNextCode();
        if (code === EOI_CODE) {
          break;
        }
        this.writeString(this.stringFromCode(code));
        oldCode = code;
      } else if (this.isInTable(code)) {
        this.writeString(this.stringFromCode(code));
        this.addStringToTable(this.stringFromCode(oldCode).concat(this.stringFromCode(code)[0]));
        oldCode = code;
      } else {
        const outString = this.stringFromCode(oldCode).concat(this.stringFromCode(oldCode)[0]);
        this.writeString(outString);
        this.addStringToTable(outString);
        oldCode = code;
      }
    }
    const outArray = this.outData.toArray();
    return new DataView(outArray.buffer, outArray.byteOffset, outArray.byteLength);
  }
  initializeTable() {
    initializeStringTable();
    this.tableLength = TABLE_START;
    this.currentBitLength = MIN_BIT_LENGTH;
  }
  writeString(string) {
    this.outData.writeBytes(string);
  }
  stringFromCode(code) {
    return stringTable[code];
  }
  isInTable(code) {
    return code < this.tableLength;
  }
  addStringToTable(string) {
    stringTable[this.tableLength++] = string;
    if (stringTable.length > 4096) {
      stringTable = [];
      throw new Error("LZW decoding error. Please open an issue at https://github.com/image-js/tiff/issues/new/choose (include a test image).");
    }
    if (this.tableLength === bitJumps[this.currentBitLength]) {
      this.currentBitLength++;
    }
  }
  getNextCode() {
    this.nextData = this.nextData << 8 | this.stripArray[this.bytePointer++] & 255;
    this.nextBits += 8;
    if (this.nextBits < this.currentBitLength) {
      this.nextData = this.nextData << 8 | this.stripArray[this.bytePointer++] & 255;
      this.nextBits += 8;
    }
    const code = this.nextData >> this.nextBits - this.currentBitLength & andTable[this.currentBitLength - 9];
    this.nextBits -= this.currentBitLength;
    if (this.bytePointer > this.stripArray.length) {
      return 257;
    }
    return code;
  }
};
function decompressLzw(stripData) {
  return new LzwDecoder(stripData).decode();
}

// node_modules/tiff/lib-esm/tiffIfd.js
var dateTimeRegex = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;
var TiffIfd = class extends IFD {
  constructor() {
    super("standard");
  }
  // Custom fields
  get size() {
    return this.width * this.height;
  }
  get width() {
    return this.imageWidth;
  }
  get height() {
    return this.imageLength;
  }
  get components() {
    return this.samplesPerPixel;
  }
  get date() {
    let date = new Date();
    let result = dateTimeRegex.exec(this.dateTime);
    if (result === null) {
      throw new Error(`invalid dateTime: ${this.dateTime}`);
    }
    date.setFullYear(Number(result[1]), Number(result[2]) - 1, Number(result[3]));
    date.setHours(Number(result[4]), Number(result[5]), Number(result[6]));
    return date;
  }
  // IFD fields
  get newSubfileType() {
    return this.get("NewSubfileType");
  }
  get imageWidth() {
    return this.get("ImageWidth");
  }
  get imageLength() {
    return this.get("ImageLength");
  }
  get bitsPerSample() {
    const data = this.get("BitsPerSample");
    if (data && typeof data !== "number") {
      return data[0];
    }
    return data;
  }
  get alpha() {
    const extraSamples = this.extraSamples;
    if (!extraSamples)
      return false;
    return extraSamples[0] !== 0;
  }
  get associatedAlpha() {
    const extraSamples = this.extraSamples;
    if (!extraSamples)
      return false;
    return extraSamples[0] === 1;
  }
  get extraSamples() {
    return alwaysArray(this.get("ExtraSamples"));
  }
  get compression() {
    return this.get("Compression") || 1;
  }
  get type() {
    return this.get("PhotometricInterpretation");
  }
  get fillOrder() {
    return this.get("FillOrder") || 1;
  }
  get documentName() {
    return this.get("DocumentName");
  }
  get imageDescription() {
    return this.get("ImageDescription");
  }
  get stripOffsets() {
    return alwaysArray(this.get("StripOffsets"));
  }
  get orientation() {
    return this.get("Orientation");
  }
  get samplesPerPixel() {
    return this.get("SamplesPerPixel") || 1;
  }
  get rowsPerStrip() {
    return this.get("RowsPerStrip");
  }
  get stripByteCounts() {
    return alwaysArray(this.get("StripByteCounts"));
  }
  get minSampleValue() {
    return this.get("MinSampleValue") || 0;
  }
  get maxSampleValue() {
    return this.get("MaxSampleValue") || Math.pow(2, this.bitsPerSample) - 1;
  }
  get xResolution() {
    return this.get("XResolution");
  }
  get yResolution() {
    return this.get("YResolution");
  }
  get planarConfiguration() {
    return this.get("PlanarConfiguration") || 1;
  }
  get resolutionUnit() {
    return this.get("ResolutionUnit") || 2;
  }
  get dateTime() {
    return this.get("DateTime");
  }
  get predictor() {
    return this.get("Predictor") || 1;
  }
  get sampleFormat() {
    return this.get("SampleFormat") || 1;
  }
  get sMinSampleValue() {
    return this.get("SMinSampleValue") || this.minSampleValue;
  }
  get sMaxSampleValue() {
    return this.get("SMaxSampleValue") || this.maxSampleValue;
  }
  get palette() {
    const totalColors = 2 ** this.bitsPerSample;
    const colorMap = this.get("ColorMap");
    if (!colorMap)
      return void 0;
    if (colorMap.length !== 3 * totalColors) {
      throw new Error(`ColorMap size must be ${totalColors}`);
    }
    const palette = [];
    for (let i3 = 0; i3 < totalColors; i3++) {
      palette.push([
        colorMap[i3],
        colorMap[i3 + totalColors],
        colorMap[i3 + 2 * totalColors]
      ]);
    }
    return palette;
  }
};
function alwaysArray(value) {
  if (typeof value === "number")
    return [value];
  return value;
}

// node_modules/tiff/lib-esm/zlib.js
function decompressZlib(stripData) {
  const stripUint8 = new Uint8Array(stripData.buffer, stripData.byteOffset, stripData.byteLength);
  const inflated = inflate_1(stripUint8);
  return new DataView(inflated.buffer, inflated.byteOffset, inflated.byteLength);
}

// node_modules/tiff/lib-esm/tiffDecoder.js
var defaultOptions = {
  ignoreImageData: false,
  onlyFirst: false
};
var TIFFDecoder = class extends import_iobuffer4.IOBuffer {
  constructor(data) {
    super(data);
    this._nextIFD = 0;
  }
  get isMultiPage() {
    let c4 = 0;
    this.decodeHeader();
    while (this._nextIFD) {
      c4++;
      this.decodeIFD({ ignoreImageData: true }, true);
      if (c4 === 2) {
        return true;
      }
    }
    if (c4 === 1) {
      return false;
    }
    throw unsupported("ifdCount", c4);
  }
  get pageCount() {
    let c4 = 0;
    this.decodeHeader();
    while (this._nextIFD) {
      c4++;
      this.decodeIFD({ ignoreImageData: true }, true);
    }
    if (c4 > 0) {
      return c4;
    }
    throw unsupported("ifdCount", c4);
  }
  decode(options = {}) {
    options = Object.assign({}, defaultOptions, options);
    const result = [];
    this.decodeHeader();
    while (this._nextIFD) {
      result.push(this.decodeIFD(options, true));
      if (options.onlyFirst) {
        return [result[0]];
      }
    }
    return result;
  }
  decodeHeader() {
    const value = this.readUint16();
    if (value === 18761) {
      this.setLittleEndian();
    } else if (value === 19789) {
      this.setBigEndian();
    } else {
      throw new Error(`invalid byte order: 0x${value.toString(16)}`);
    }
    if (this.readUint16() !== 42) {
      throw new Error("not a TIFF file");
    }
    this._nextIFD = this.readUint32();
  }
  decodeIFD(options, tiff) {
    this.seek(this._nextIFD);
    let ifd;
    if (tiff) {
      ifd = new TiffIfd();
    } else {
      if (!options.kind) {
        throw new Error(`kind is missing`);
      }
      ifd = new IFD(options.kind);
    }
    const numEntries = this.readUint16();
    for (let i3 = 0; i3 < numEntries; i3++) {
      this.decodeIFDEntry(ifd);
    }
    if (!options.ignoreImageData) {
      if (!(ifd instanceof TiffIfd)) {
        throw new Error("must be a tiff ifd");
      }
      this.decodeImageData(ifd);
    }
    this._nextIFD = this.readUint32();
    return ifd;
  }
  decodeIFDEntry(ifd) {
    const offset = this.offset;
    const tag = this.readUint16();
    const type = this.readUint16();
    const numValues = this.readUint32();
    if (type < 1 || type > 12) {
      this.skip(4);
      return;
    }
    const valueByteLength = getByteLength(type, numValues);
    if (valueByteLength > 4) {
      this.seek(this.readUint32());
    }
    const value = readData(this, type, numValues);
    ifd.fields.set(tag, value);
    if (tag === 34665 || tag === 34853) {
      let currentOffset = this.offset;
      let kind = "exif";
      if (tag === 34665) {
        kind = "exif";
      } else if (tag === 34853) {
        kind = "gps";
      }
      this._nextIFD = value;
      ifd[kind] = this.decodeIFD({
        kind,
        ignoreImageData: true
      }, false);
      this.offset = currentOffset;
    }
    this.seek(offset);
    this.skip(12);
  }
  decodeImageData(ifd) {
    const orientation = ifd.orientation;
    if (orientation && orientation !== 1) {
      throw unsupported("orientation", orientation);
    }
    switch (ifd.type) {
      case 0:
      case 1:
      case 2:
      case 3:
        this.readStripData(ifd);
        break;
      default:
        throw unsupported("image type", ifd.type);
    }
    this.applyPredictor(ifd);
    this.convertAlpha(ifd);
    if (ifd.type === 0) {
      const bitDepth = ifd.bitsPerSample;
      const maxValue = Math.pow(2, bitDepth) - 1;
      for (let i3 = 0; i3 < ifd.data.length; i3++) {
        ifd.data[i3] = maxValue - ifd.data[i3];
      }
    }
  }
  readStripData(ifd) {
    const width = ifd.width;
    const height = ifd.height;
    const bitDepth = ifd.bitsPerSample;
    const sampleFormat = ifd.sampleFormat;
    const size = width * height * ifd.samplesPerPixel;
    const data = getDataArray(size, bitDepth, sampleFormat);
    const rowsPerStrip = ifd.rowsPerStrip;
    const maxPixels = rowsPerStrip * width * ifd.samplesPerPixel;
    const stripOffsets = ifd.stripOffsets;
    const stripByteCounts = ifd.stripByteCounts || guessStripByteCounts(ifd);
    let remainingPixels = size;
    let pixel = 0;
    for (let i3 = 0; i3 < stripOffsets.length; i3++) {
      let stripData = new DataView(this.buffer, this.byteOffset + stripOffsets[i3], stripByteCounts[i3]);
      let length = remainingPixels > maxPixels ? maxPixels : remainingPixels;
      remainingPixels -= length;
      let dataToFill = stripData;
      switch (ifd.compression) {
        case 1: {
          break;
        }
        case 5: {
          dataToFill = decompressLzw(stripData);
          break;
        }
        case 8: {
          dataToFill = decompressZlib(stripData);
          break;
        }
        case 2:
          throw unsupported("Compression", "CCITT Group 3");
        case 32773:
          throw unsupported("Compression", "PackBits");
        default:
          throw unsupported("Compression", ifd.compression);
      }
      pixel = this.fillUncompressed(bitDepth, sampleFormat, data, dataToFill, pixel, length);
    }
    ifd.data = data;
  }
  fillUncompressed(bitDepth, sampleFormat, data, stripData, pixel, length) {
    if (bitDepth === 8) {
      return fill8bit(data, stripData, pixel, length);
    } else if (bitDepth === 16) {
      return fill16bit(data, stripData, pixel, length, this.isLittleEndian());
    } else if (bitDepth === 32 && sampleFormat === 3) {
      return fillFloat32(data, stripData, pixel, length, this.isLittleEndian());
    } else {
      throw unsupported("bitDepth", bitDepth);
    }
  }
  applyPredictor(ifd) {
    const bitDepth = ifd.bitsPerSample;
    switch (ifd.predictor) {
      case 1: {
        break;
      }
      case 2: {
        if (bitDepth === 8) {
          applyHorizontalDifferencing8Bit(ifd.data, ifd.width, ifd.components);
        } else if (bitDepth === 16) {
          applyHorizontalDifferencing16Bit(ifd.data, ifd.width, ifd.components);
        } else {
          throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${bitDepth}`);
        }
        break;
      }
      default:
        throw new Error(`invalid predictor: ${ifd.predictor}`);
    }
  }
  convertAlpha(ifd) {
    if (ifd.alpha && ifd.associatedAlpha) {
      const { data, components, maxSampleValue } = ifd;
      for (let i3 = 0; i3 < data.length; i3 += components) {
        const alphaValue = data[i3 + components - 1];
        for (let j2 = 0; j2 < components - 1; j2++) {
          data[i3 + j2] = Math.round(data[i3 + j2] * maxSampleValue / alphaValue);
        }
      }
    }
  }
};
function getDataArray(size, bitDepth, sampleFormat) {
  if (bitDepth === 8) {
    return new Uint8Array(size);
  } else if (bitDepth === 16) {
    return new Uint16Array(size);
  } else if (bitDepth === 32 && sampleFormat === 3) {
    return new Float32Array(size);
  } else {
    throw unsupported("bit depth / sample format", `${bitDepth} / ${sampleFormat}`);
  }
}
function fill8bit(dataTo, dataFrom, index2, length) {
  for (let i3 = 0; i3 < length; i3++) {
    dataTo[index2++] = dataFrom.getUint8(i3);
  }
  return index2;
}
function fill16bit(dataTo, dataFrom, index2, length, littleEndian) {
  for (let i3 = 0; i3 < length * 2; i3 += 2) {
    dataTo[index2++] = dataFrom.getUint16(i3, littleEndian);
  }
  return index2;
}
function fillFloat32(dataTo, dataFrom, index2, length, littleEndian) {
  for (let i3 = 0; i3 < length * 4; i3 += 4) {
    dataTo[index2++] = dataFrom.getFloat32(i3, littleEndian);
  }
  return index2;
}
function unsupported(type, value) {
  return new Error(`Unsupported ${type}: ${value}`);
}

// node_modules/tiff/lib-esm/index.js
function decodeTIFF(data, options) {
  const decoder = new TIFFDecoder(data);
  return decoder.decode(options);
}

// node_modules/image-js/src/stack/Stack.js
var import_has_own2 = __toESM(require_has_own());

// node_modules/image-js/src/stack/transform/matchAndCrop.js
function matchAndCrop(options = {}) {
  let { algorithm = "matchToPrevious", ignoreBorder = [0, 0] } = options;
  this.checkProcessable("matchAndCrop", {
    bitDepth: [8, 16]
  });
  let matchToPrevious = algorithm === "matchToPrevious";
  let parent = this[0];
  let results = [];
  results[0] = {
    position: [0, 0],
    image: this[0]
  };
  let relativePosition = [0, 0];
  for (let i3 = 1; i3 < this.length; i3++) {
    let position = parent.getBestMatch(this[i3], { border: ignoreBorder });
    results[i3] = {
      position: [
        position[0] + relativePosition[0],
        position[1] + relativePosition[1]
      ],
      image: this[i3]
    };
    if (matchToPrevious) {
      relativePosition[0] += position[0];
      relativePosition[1] += position[1];
      parent = this[i3];
    }
  }
  let leftShift = 0;
  let rightShift = 0;
  let topShift = 0;
  let bottomShift = 0;
  for (let i3 = 0; i3 < results.length; i3++) {
    let result = results[i3];
    if (result.position[0] > leftShift) {
      leftShift = result.position[0];
    }
    if (result.position[0] < rightShift) {
      rightShift = result.position[0];
    }
    if (result.position[1] > topShift) {
      topShift = result.position[1];
    }
    if (result.position[1] < bottomShift) {
      bottomShift = result.position[1];
    }
  }
  rightShift = 0 - rightShift;
  bottomShift = 0 - bottomShift;
  for (let i3 = 0; i3 < results.length; i3++) {
    let result = results[i3];
    result.crop = result.image.crop({
      x: leftShift - result.position[0],
      y: topShift - result.position[1],
      width: parent.width - rightShift - leftShift,
      height: parent.height - bottomShift - topShift
    });
  }
  let newImages = [];
  for (let i3 = 0; i3 < results.length; i3++) {
    newImages[i3] = results[i3].crop;
  }
  return new Stack(newImages);
}

// node_modules/image-js/src/stack/compute/min.js
function min() {
  this.checkProcessable("min", {
    bitDepth: [8, 16]
  });
  let min3 = this[0].min;
  for (let i3 = 1; i3 < this.length; i3++) {
    for (let j2 = 0; j2 < min3.length; j2++) {
      min3[j2] = Math.min(min3[j2], this[i3].min[j2]);
    }
  }
  return min3;
}

// node_modules/image-js/src/stack/compute/max.js
function max() {
  this.checkProcessable("min", {
    bitDepth: [8, 16]
  });
  let max4 = this[0].max;
  for (let i3 = 1; i3 < this.length; i3++) {
    for (let j2 = 0; j2 < max4.length; j2++) {
      max4[j2] = Math.max(max4[j2], this[i3].max[j2]);
    }
  }
  return max4;
}

// node_modules/image-js/src/util/histogram.js
function median(histogram2) {
  let total = histogram2.reduce((sum2, x2) => sum2 + x2);
  if (total === 0) {
    throw new Error("unreachable");
  }
  let position = 0;
  let currentTotal = 0;
  let middle = total / 2;
  let previous;
  while (true) {
    if (histogram2[position] > 0) {
      if (previous !== void 0) {
        return (previous + position) / 2;
      }
      currentTotal += histogram2[position];
      if (currentTotal > middle) {
        return position;
      } else if (currentTotal === middle) {
        previous = position;
      }
    }
    position++;
  }
}
function mean(histogram2) {
  let total = 0;
  let sum2 = 0;
  for (let i3 = 0; i3 < histogram2.length; i3++) {
    total += histogram2[i3];
    sum2 += histogram2[i3] * i3;
  }
  if (total === 0) {
    return 0;
  }
  return sum2 / total;
}

// node_modules/image-js/src/stack/compute/median.js
function median2() {
  this.checkProcessable("median", {
    bitDepth: [8, 16]
  });
  let histograms2 = this.getHistograms({ maxSlots: this[0].maxValue + 1 });
  let result = new Array(histograms2.length);
  for (let c4 = 0; c4 < histograms2.length; c4++) {
    let histogram2 = histograms2[c4];
    result[c4] = median(histogram2);
  }
  return result;
}

// node_modules/image-js/src/stack/compute/histogram.js
function histogram(options) {
  this.checkProcessable("min", {
    bitDepth: [8, 16]
  });
  let histogram2 = this[0].getHistogram(options);
  for (let i3 = 1; i3 < this.length; i3++) {
    let secondHistogram = this[i3].getHistogram(options);
    for (let j2 = 0; j2 < histogram2.length; j2++) {
      histogram2[j2] += secondHistogram[j2];
    }
  }
  return histogram2;
}

// node_modules/image-js/src/stack/compute/histograms.js
function histograms(options) {
  this.checkProcessable("min", {
    bitDepth: [8, 16]
  });
  let histograms2 = this[0].getHistograms(options);
  let histogramLength = histograms2[0].length;
  for (let i3 = 1; i3 < this.length; i3++) {
    let secondHistograms = this[i3].getHistograms(options);
    for (let c4 = 0; c4 < histograms2.length; c4++) {
      for (let j2 = 0; j2 < histogramLength; j2++) {
        histograms2[c4][j2] += secondHistograms[c4][j2];
      }
    }
  }
  return histograms2;
}

// node_modules/image-js/src/stack/utility/averageImage.js
function averageImage() {
  this.checkProcessable("averageImage", {
    bitDepth: [8, 16]
  });
  let data = new Uint32Array(this[0].data.length);
  for (let i3 = 0; i3 < this.length; i3++) {
    let current = this[i3];
    for (let j2 = 0; j2 < this[0].data.length; j2++) {
      data[j2] += current.data[j2];
    }
  }
  let image = Image2.createFrom(this[0]);
  let newData = image.data;
  for (let i3 = 0; i3 < this[0].data.length; i3++) {
    newData[i3] = data[i3] / this.length;
  }
  return image;
}

// node_modules/image-js/src/stack/utility/maxImage.js
function maxImage() {
  this.checkProcessable("max", {
    bitDepth: [8, 16]
  });
  let image = Image2.createFrom(this[0]);
  image.data.fill(0);
  for (const current of this) {
    for (let j2 = 0; j2 < image.data.length; j2++) {
      image.data[j2] = Math.max(current.data[j2], image.data[j2]);
    }
  }
  return image;
}

// node_modules/image-js/src/stack/utility/minImage.js
function minImage() {
  this.checkProcessable("max", {
    bitDepth: [8, 16]
  });
  let image = Image2.createFrom(this[0]);
  image.data.fill(image.maxValue);
  for (const current of this) {
    for (let j2 = 0; j2 < image.data.length; j2++) {
      image.data[j2] = Math.min(current.data[j2], image.data[j2]);
    }
  }
  return image;
}

// node_modules/image-js/src/stack/extend.js
function extend(Stack2) {
  Stack2.extendMethod("matchAndCrop", matchAndCrop);
  Stack2.extendMethod("getMin", min);
  Stack2.extendMethod("getMax", max);
  Stack2.extendMethod("getMedian", median2);
  Stack2.extendMethod("getHistogram", histogram);
  Stack2.extendMethod("getHistograms", histograms);
  Stack2.extendMethod("getAverage", averageImage);
  Stack2.extendMethod("getAverageImage", averageImage);
  Stack2.extendMethod("getMaxImage", maxImage);
  Stack2.extendMethod("getMinImage", minImage);
}

// node_modules/image-js/src/stack/Stack.js
var computedPropertyDescriptor2 = {
  configurable: true,
  enumerable: false,
  get: void 0
};
var Stack = class extends Array {
  constructor(images) {
    if (Array.isArray(images)) {
      super(images.length);
      for (let i3 = 0; i3 < images.length; i3++) {
        this[i3] = images[i3];
      }
    } else if (typeof images === "number") {
      super(images);
    } else {
      super();
    }
    this.computed = null;
  }
  static load(urls) {
    return Promise.all(urls.map(Image2.load)).then(
      (images) => new Stack(images)
    );
  }
  static extendMethod(name, method, options = {}) {
    let { inPlace = false, returnThis = true, partialArgs = [] } = options;
    if (inPlace) {
      Stack.prototype[name] = function(...args) {
        this.computed = null;
        let result = method.apply(this, [...partialArgs, ...args]);
        if (returnThis) {
          return this;
        }
        return result;
      };
    } else {
      Stack.prototype[name] = function(...args) {
        return method.apply(this, [...partialArgs, ...args]);
      };
    }
    return Stack;
  }
  static extendProperty(name, method, options = {}) {
    let { partialArgs = [] } = options;
    computedPropertyDescriptor2.get = function() {
      if (this.computed === null) {
        this.computed = {};
      } else if ((0, import_has_own2.default)(name, this.computed)) {
        return this.computed[name];
      }
      let result = method.apply(this, partialArgs);
      this.computed[name] = result;
      return result;
    };
    Object.defineProperty(Stack.prototype, name, computedPropertyDescriptor2);
    return Stack;
  }
  /**
   * Check if a process can be applied on the stack
   * @param {string} processName
   * @param {object} [options]
   * @private
   */
  checkProcessable(processName, options = {}) {
    if (typeof processName !== "string") {
      throw new TypeError(
        "checkProcessable requires as first parameter the processName (a string)"
      );
    }
    if (this.size === 0) {
      throw new TypeError(
        `The process: ${processName} can not be applied on an empty stack`
      );
    }
    this[0].checkProcessable(processName, options);
    for (let i3 = 1; i3 < this.length; i3++) {
      if ((options.sameSize === void 0 || options.sameSize) && this[0].width !== this[i3].width) {
        throw new TypeError(
          `The process: ${processName} can not be applied if width is not identical in all images`
        );
      }
      if ((options.sameSize === void 0 || options.sameSize) && this[0].height !== this[i3].height) {
        throw new TypeError(
          `The process: ${processName} can not be applied if height is not identical in all images`
        );
      }
      if ((options.sameAlpha === void 0 || options.sameAlpha) && this[0].alpha !== this[i3].alpha) {
        throw new TypeError(
          `The process: ${processName} can not be applied if alpha is not identical in all images`
        );
      }
      if ((options.sameBitDepth === void 0 || options.sameBitDepth) && this[0].bitDepth !== this[i3].bitDepth) {
        throw new TypeError(
          `The process: ${processName} can not be applied if bitDepth is not identical in all images`
        );
      }
      if ((options.sameColorModel === void 0 || options.sameColorModel) && this[0].colorModel !== this[i3].colorModel) {
        throw new TypeError(
          `The process: ${processName} can not be applied if colorModel is not identical in all images`
        );
      }
      if ((options.sameNumberChannels === void 0 || options.sameNumberChannels) && this[0].channels !== this[i3].channels) {
        throw new TypeError(
          `The process: ${processName} can not be applied if channels is not identical in all images`
        );
      }
    }
  }
};
if (!Array[Symbol.species]) {
  Stack.prototype.map = function(cb, thisArg) {
    if (typeof cb !== "function") {
      throw new TypeError(`${cb} is not a function`);
    }
    let newStack = new Stack(this.length);
    for (let i3 = 0; i3 < this.length; i3++) {
      newStack[i3] = cb.call(thisArg, this[i3], i3, this);
    }
    return newStack;
  };
}
extend(Stack);

// node_modules/image-js/src/image/core/load.js
var isDataURL = /^data:[a-z]+\/(?:[a-z]+);base64,/;
function load(image, options) {
  if (typeof image === "string") {
    return loadURL(image, options);
  } else if (image instanceof ArrayBuffer) {
    return Promise.resolve(
      loadBinary(
        new Uint8Array(image),
        void 0,
        options && options.ignorePalette
      )
    );
  } else if (image.buffer) {
    return Promise.resolve(
      loadBinary(image, void 0, options && options.ignorePalette)
    );
  } else {
    throw new Error('argument to "load" must be a string or buffer.');
  }
}
function loadBinary(image, base64Url, ignorePalette) {
  const type = (0, import_image_type.default)(image);
  if (type) {
    switch (type.mime) {
      case "image/png":
        return loadPNG(image);
      case "image/jpeg":
        return loadJPEG(image);
      case "image/tiff":
        return loadTIFF(image, ignorePalette);
      default:
        return loadGeneric(getBase64(type.mime));
    }
  }
  return loadGeneric(getBase64("application/octet-stream"));
  function getBase64(type2) {
    if (base64Url) {
      return base64Url;
    } else {
      return toBase64URL(image, type2);
    }
  }
}
function loadURL(url, options) {
  const dataURL = url.slice(0, 64).match(isDataURL);
  let binaryDataP;
  if (dataURL !== null) {
    binaryDataP = Promise.resolve(decode(url.slice(dataURL[0].length)));
  } else {
    binaryDataP = fetchBinary(url, options);
  }
  return binaryDataP.then((binaryData) => {
    const uint82 = new Uint8Array(binaryData);
    return loadBinary(
      uint82,
      dataURL ? url : void 0,
      options && options.ignorePalette
    );
  });
}
function loadPNG(data) {
  const png = decodePng(data);
  let channels = png.channels;
  let components;
  let alpha = 0;
  if (channels === 2 || channels === 4) {
    components = channels - 1;
    alpha = 1;
  } else {
    components = channels;
  }
  if (png.palette) {
    return loadPNGFromPalette(png);
  }
  return new Image2(png.width, png.height, png.data, {
    components,
    alpha,
    bitDepth: png.depth
  });
}
function loadPNGFromPalette(png) {
  const pixels = png.width * png.height;
  const channels = png.palette[0].length;
  const data = new Uint8Array(pixels * channels);
  const pixelsPerByte = 8 / png.depth;
  const factor = png.depth < 8 ? pixelsPerByte : 1;
  const mask2 = parseInt("1".repeat(png.depth), 2);
  const hasAlpha = channels === 4;
  let dataIndex = 0;
  for (let i3 = 0; i3 < pixels; i3++) {
    const index2 = Math.floor(i3 / factor);
    let value = png.data[index2];
    if (png.depth < 8) {
      value = value >>> png.depth * (pixelsPerByte - 1 - i3 % pixelsPerByte) & mask2;
    }
    const paletteValue = png.palette[value];
    data[dataIndex++] = paletteValue[0];
    data[dataIndex++] = paletteValue[1];
    data[dataIndex++] = paletteValue[2];
    if (hasAlpha) {
      data[dataIndex++] = paletteValue[3];
    }
  }
  return new Image2(png.width, png.height, data, {
    components: 3,
    alpha: hasAlpha,
    bitDepth: 8
  });
}
function loadJPEG(data) {
  const decodedExif = (0, import_fast_jpeg.decode)(data);
  let meta;
  if (decodedExif.exif) {
    meta = getMetadata(decodedExif.exif);
  }
  const jpeg = (0, import_jpeg_js2.decode)(data, { useTArray: true, maxMemoryUsageInMB: 1024 });
  let image = new Image2(jpeg.width, jpeg.height, jpeg.data, { meta });
  if (meta && meta.tiff.tags.Orientation) {
    const orientation = meta.tiff.tags.Orientation;
    if (orientation > 2) {
      image = image.rotate(
        {
          3: 180,
          4: 180,
          5: 90,
          6: 90,
          7: 270,
          8: 270
        }[orientation]
      );
    }
    if ([2, 4, 5, 7].includes(orientation)) {
      image = image.flipX();
    }
  }
  return image;
}
function loadTIFF(data, ignorePalette) {
  let result = decodeTIFF(data);
  if (result.length === 1) {
    return getImageFromIFD(result[0], ignorePalette);
  } else {
    return new Stack(
      result.map(function(image) {
        return getImageFromIFD(image, ignorePalette);
      })
    );
  }
}
function getMetadata(image) {
  const metadata = {
    tiff: {
      fields: image.fields,
      tags: image.map
    }
  };
  if (image.exif) {
    metadata.exif = image.exif;
  }
  if (image.gps) {
    metadata.gps = image.gps;
  }
  return metadata;
}
function getImageFromIFD(image, ignorePalette) {
  if (!ignorePalette && image.type === 3) {
    const data = new Uint16Array(3 * image.width * image.height);
    const palette = image.palette;
    let ptr = 0;
    for (let i3 = 0; i3 < image.data.length; i3++) {
      const index2 = image.data[i3];
      const color = palette[index2];
      data[ptr++] = color[0];
      data[ptr++] = color[1];
      data[ptr++] = color[2];
    }
    return new Image2(image.width, image.height, data, {
      components: 3,
      alpha: image.alpha,
      colorModel: RGB,
      bitDepth: 16,
      meta: getMetadata(image)
    });
  } else {
    return new Image2(image.width, image.height, image.data, {
      components: image.type === 2 ? 3 : 1,
      alpha: image.alpha,
      colorModel: image.type === 2 ? RGB : GREY,
      bitDepth: image.bitsPerSample.length ? image.bitsPerSample[0] : image.bitsPerSample,
      meta: getMetadata(image)
    });
  }
}
function loadGeneric(url, options) {
  options = options || {};
  return new Promise(function(resolve2, reject2) {
    let image = new DOMImage();
    image.onload = function() {
      let w2 = image.width;
      let h3 = image.height;
      let canvas = createCanvas(w2, h3);
      let ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0, w2, h3);
      let data = ctx.getImageData(0, 0, w2, h3).data;
      resolve2(new Image2(w2, h3, data, options));
    };
    image.onerror = function() {
      reject2(new Error(`Could not load ${url}`));
    };
    image.src = url;
  });
}

// node_modules/image-js/src/image/core/valueMethods.js
var valueMethods = {
  /**
   * Get the value of specific pixel channel
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @param {number} channel
   * @return {number} - the value of this pixel channel
   */
  getValueXY(x2, y3, channel) {
    return this.data[(y3 * this.width + x2) * this.channels + channel];
  },
  /**
   * Set the value of specific pixel channel
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @param {number} channel
   * @param {number} value - the new value of this pixel channel
   * @return {this}
   */
  setValueXY(x2, y3, channel, value) {
    this.data[(y3 * this.width + x2) * this.channels + channel] = value;
    this.computed = null;
    return this;
  },
  /**
   * Get the value of specific pixel channel
   * @memberof Image
   * @instance
   * @param {number} index - 1D index of the pixel
   * @param {number} channel
   * @return {number} - the value of this pixel channel
   */
  getValue(index2, channel) {
    return this.data[index2 * this.channels + channel];
  },
  /**
   * Set the value of specific pixel channel
   * @memberof Image
   * @instance
   * @param {number} index - 1D index of the pixel
   * @param {number} channel
   * @param {number} value - the new value of this pixel channel
   * @return {this}
   */
  setValue(index2, channel, value) {
    this.data[index2 * this.channels + channel] = value;
    this.computed = null;
    return this;
  },
  /**
   * Get the value of an entire pixel
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @return {number[]} the value of this pixel
   */
  getPixelXY(x2, y3) {
    return this.getPixel(y3 * this.width + x2);
  },
  /**
   * Set the value of an entire pixel
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @param {number[]} value - the new value of this pixel
   * @return {this}
   */
  setPixelXY(x2, y3, value) {
    return this.setPixel(y3 * this.width + x2, value);
  },
  /**
   * Get the value of an entire pixel
   * @memberof Image
   * @instance
   * @param {number} index - 1D index of the pixel
   * @return {number[]} the value of this pixel
   */
  getPixel(index2) {
    const value = new Array(this.channels);
    const target = index2 * this.channels;
    for (let i3 = 0; i3 < this.channels; i3++) {
      value[i3] = this.data[target + i3];
    }
    return value;
  },
  /**
   * Set the value of an entire pixel
   * @memberof Image
   * @instance
   * @param {number} index - 1D index of the pixel
   * @param {number[]} value - the new value of this pixel
   * @return {this}
   */
  setPixel(index2, value) {
    const target = index2 * this.channels;
    for (let i3 = 0; i3 < value.length; i3++) {
      this.data[target + i3] = value[i3];
    }
    this.computed = null;
    return this;
  }
};
function setValueMethods(Image3) {
  for (const i3 in valueMethods) {
    Image3.prototype[i3] = valueMethods[i3];
  }
}

// node_modules/image-js/src/image/internal/getImageParameters.js
function getImageParameters(image) {
  return {
    width: image.width,
    height: image.height,
    components: image.components,
    alpha: image.alpha,
    colorModel: image.colorModel,
    bitDepth: image.bitDepth
  };
}

// node_modules/image-js/src/image/internal/getOutputImage.js
function getOutputImage(thisImage, options, newParameters, internalOptions = {}) {
  const { out } = options;
  if (out === void 0) {
    if (internalOptions.copy) {
      return thisImage.clone();
    } else {
      return Image2.createFrom(thisImage, newParameters);
    }
  } else {
    if (!Image2.isImage(out)) {
      throw new TypeError("out must be an Image object");
    }
    const requirements = Object.assign(
      getImageParameters(thisImage),
      newParameters
    );
    for (const property in requirements) {
      if (out[property] !== requirements[property]) {
        throw new RangeError(
          `cannot use out. Its ${property} must be "${requirements[property]}" (found "${out[property]}")`
        );
      }
    }
    return out;
  }
}
function getOutputImageOrInPlace(thisImage, options, internalOptions) {
  if (options.inPlace !== void 0 && typeof options.inPlace !== "boolean") {
    throw new TypeError("inPlace option must be a boolean");
  }
  if (options.inPlace) {
    if (options.out !== void 0) {
      throw new TypeError(
        "out option must not be set if inPlace option is true"
      );
    }
    return thisImage;
  }
  return getOutputImage(thisImage, options, null, internalOptions);
}

// node_modules/image-js/src/image/filter/abs.js
function abs(options = {}) {
  this.checkProcessable("abs", {
    bitDepth: [32]
  });
  const out = getOutputImageOrInPlace(this, options);
  absolute(this, out);
  return out;
}
function absolute(image, out) {
  for (let i3 = 0; i3 < image.data.length; i3++) {
    out.data[i3] = Math.abs(image.data[i3]);
  }
}

// node_modules/image-js/src/image/internal/copyAlphaChannel.js
function copyAlphaChannel(from, to) {
  if (from.alpha === 1 && to.alpha === 1) {
    for (let i3 = 0; i3 < from.size; i3++) {
      to.data[i3 * to.channels + to.components] = from.data[i3 * from.channels + from.components];
    }
  }
}

// node_modules/image-js/src/image/filter/invert.js
function invert(options = {}) {
  this.checkProcessable("invert", {
    bitDepth: [1, 8, 16]
  });
  const out = getOutputImageOrInPlace(this, options);
  if (this.bitDepth === 1) {
    invertBinary(this, out);
  } else {
    invertColor(this, out);
    if (this !== out) {
      copyAlphaChannel(this, out);
    }
  }
  return out;
}
function invertBinary(image, out) {
  for (let i3 = 0; i3 < image.data.length; i3++) {
    out.data[i3] = ~image.data[i3];
  }
}
function invertColor(image, out) {
  for (let pixel = 0; pixel < image.data.length; pixel += image.channels) {
    for (let c4 = 0; c4 < image.components; c4++) {
      out.data[pixel + c4] = image.maxValue - image.data[pixel + c4];
    }
  }
}

// node_modules/image-js/src/image/filter/flipX.js
function flipX() {
  this.checkProcessable("flipX", {
    bitDepth: [8, 16]
  });
  for (let i3 = 0; i3 < this.height; i3++) {
    let offsetY = i3 * this.width * this.channels;
    for (let j2 = 0; j2 < Math.floor(this.width / 2); j2++) {
      let posCurrent = j2 * this.channels + offsetY;
      let posOpposite = (this.width - j2 - 1) * this.channels + offsetY;
      for (let k2 = 0; k2 < this.channels; k2++) {
        let tmp = this.data[posCurrent + k2];
        this.data[posCurrent + k2] = this.data[posOpposite + k2];
        this.data[posOpposite + k2] = tmp;
      }
    }
  }
  return this;
}

// node_modules/image-js/src/image/filter/flipY.js
function flipY() {
  this.checkProcessable("flipY", {
    bitDepth: [8, 16]
  });
  for (let i3 = 0; i3 < Math.floor(this.height / 2); i3++) {
    for (let j2 = 0; j2 < this.width; j2++) {
      let posCurrent = j2 * this.channels + i3 * this.width * this.channels;
      let posOpposite = j2 * this.channels + (this.height - 1 - i3) * this.channels * this.width;
      for (let k2 = 0; k2 < this.channels; k2++) {
        let tmp = this.data[posCurrent + k2];
        this.data[posCurrent + k2] = this.data[posOpposite + k2];
        this.data[posOpposite + k2] = tmp;
      }
    }
  }
  return this;
}

// node_modules/image-js/src/image/filter/blurFilter.js
function blurFilter(options = {}) {
  const { radius = 1 } = options;
  if (radius < 1) {
    throw new Error("radius must be greater than 1");
  }
  const n3 = 2 * radius + 1;
  const kernel = new Array(n3);
  for (let i3 = 0; i3 < n3; i3++) {
    kernel[i3] = new Array(n3);
    for (let j2 = 0; j2 < n3; j2++) {
      kernel[i3][j2] = 1 / (n3 * n3);
    }
  }
  return this.convolution(kernel);
}

// node_modules/image-js/src/image/filter/medianFilter.js
var import_median_quickselect = __toESM(require_median_quickselect_min());

// node_modules/image-js/src/util/channel.js
function validateArrayOfChannels(image, options = {}) {
  let {
    channels,
    allowAlpha,
    // are we allowing the selection of an alpha channel ?
    defaultAlpha
    // if no channels are selected should we take the alpha channel ?
  } = options;
  if (typeof allowAlpha !== "boolean") {
    allowAlpha = true;
  }
  if (typeof channels === "undefined") {
    return allChannels(image, defaultAlpha);
  } else {
    return validateChannels(image, channels, allowAlpha);
  }
}
function allChannels(image, defaultAlpha) {
  let length = defaultAlpha ? image.channels : image.components;
  let array3 = new Array(length);
  for (let i3 = 0; i3 < length; i3++) {
    array3[i3] = i3;
  }
  return array3;
}
function validateChannels(image, channels, allowAlpha) {
  if (!Array.isArray(channels)) {
    channels = [channels];
  }
  for (let c4 = 0; c4 < channels.length; c4++) {
    channels[c4] = validateChannel(image, channels[c4], allowAlpha);
  }
  return channels;
}
function validateChannel(image, channel, allowAlpha = true) {
  if (channel === void 0) {
    throw new RangeError(
      `validateChannel : the channel has to be >=0 and <${image.channels}`
    );
  }
  if (typeof channel === "string") {
    switch (image.colorModel) {
      case GREY:
        break;
      case RGB:
        if ("rgb".includes(channel)) {
          switch (channel) {
            case "r":
              channel = 0;
              break;
            case "g":
              channel = 1;
              break;
            case "b":
              channel = 2;
              break;
          }
        }
        break;
      case HSL:
        if ("hsl".includes(channel)) {
          switch (channel) {
            case "h":
              channel = 0;
              break;
            case "s":
              channel = 1;
              break;
            case "l":
              channel = 2;
              break;
          }
        }
        break;
      case HSV:
        if ("hsv".includes(channel)) {
          switch (channel) {
            case "h":
              channel = 0;
              break;
            case "s":
              channel = 1;
              break;
            case "v":
              channel = 2;
              break;
          }
        }
        break;
      case CMYK:
        if ("cmyk".includes(channel)) {
          switch (channel) {
            case "c":
              channel = 0;
              break;
            case "m":
              channel = 1;
              break;
            case "y":
              channel = 2;
              break;
            case "k":
              channel = 3;
              break;
          }
        }
        break;
      default:
        throw new Error(`Unexpected color model: ${image.colorModel}`);
    }
    if (channel === "a") {
      if (!image.alpha) {
        throw new Error(
          "validateChannel : the image does not contain alpha channel"
        );
      }
      channel = image.components;
    }
    if (typeof channel === "string") {
      throw new Error(`validateChannel : undefined channel: ${channel}`);
    }
  }
  if (channel >= image.channels) {
    throw new RangeError(
      `validateChannel : the channel has to be >=0 and <${image.channels}`
    );
  }
  if (!allowAlpha && channel >= image.components) {
    throw new RangeError("validateChannel : alpha channel may not be selected");
  }
  return channel;
}

// node_modules/image-js/src/image/filter/medianFilter.js
function medianFilter(options = {}) {
  let { radius = 1, border = "copy", channels } = options;
  this.checkProcessable("medianFilter", {
    bitDepth: [8, 16]
  });
  if (radius < 1) {
    throw new Error("radius must be greater than 0");
  }
  channels = validateArrayOfChannels(this, channels, true);
  let kWidth = radius;
  let kHeight = radius;
  let newImage = Image2.createFrom(this);
  let size = (kWidth * 2 + 1) * (kHeight * 2 + 1);
  let kernel = new Array(size);
  for (let channel = 0; channel < channels.length; channel++) {
    let c4 = channels[channel];
    for (let y3 = kHeight; y3 < this.height - kHeight; y3++) {
      for (let x2 = kWidth; x2 < this.width - kWidth; x2++) {
        let n3 = 0;
        for (let j2 = -kHeight; j2 <= kHeight; j2++) {
          for (let i3 = -kWidth; i3 <= kWidth; i3++) {
            let index3 = ((y3 + j2) * this.width + x2 + i3) * this.channels + c4;
            kernel[n3++] = this.data[index3];
          }
        }
        let index2 = (y3 * this.width + x2) * this.channels + c4;
        newImage.data[index2] = (0, import_median_quickselect.default)(kernel);
      }
    }
  }
  if (this.alpha && !channels.includes(this.channels)) {
    for (let i3 = this.components; i3 < this.data.length; i3 = i3 + this.channels) {
      newImage.data[i3] = this.data[i3];
    }
  }
  newImage.setBorder({ size: [kWidth, kHeight], algorithm: border });
  return newImage;
}

// node_modules/image-js/src/image/filter/gaussianFilter.js
function gaussianFilter(options = {}) {
  let { radius = 1, sigma, channels, border = "copy" } = options;
  this.checkProcessable("gaussian", {
    bitDepth: [8, 16]
  });
  const kernel = getKernel(radius, sigma);
  return this.convolution([kernel, kernel], {
    border,
    channels,
    algorithm: "separable"
  });
}
function getKernel(radius, sigma) {
  const n3 = radius * 2 + 1;
  const kernel = new Array(n3);
  const sigmaX = sigma ? sigma : ((n3 - 1) * 0.5 - 1) * 0.3 + 0.8;
  const scale2X = -0.5 / (sigmaX * sigmaX);
  let sum2 = 0;
  for (let i3 = 0; i3 < n3; i3++) {
    const x2 = i3 - radius;
    const t3 = Math.exp(scale2X * x2 * x2);
    kernel[i3] = t3;
    sum2 += t3;
  }
  for (let i3 = 0; i3 < n3; i3++) {
    kernel[i3] /= sum2;
  }
  return kernel;
}

// node_modules/image-js/src/util/kernels.js
var SOBEL_X = [
  [-1, 0, 1],
  [-2, 0, 2],
  [-1, 0, 1]
];
var SOBEL_Y = [
  [-1, -2, -1],
  [0, 0, 0],
  [1, 2, 1]
];
var SCHARR_X = [
  [3, 0, -3],
  [10, 0, -10],
  [3, 0, -3]
];
var SCHARR_Y = [
  [3, 10, 3],
  [0, 0, 0],
  [-3, -10, -3]
];

// node_modules/image-js/src/image/operator/convolution.js
var import_ml_matrix_convolution = __toESM(require_src5());

// node_modules/image-js/src/util/kernel.js
var import_is_integer = __toESM(require_is_integer());
function validateKernel(kernel) {
  let kHeight, kWidth;
  if (Array.isArray(kernel)) {
    if (Array.isArray(kernel[0])) {
      if ((kernel.length & 1) === 0 || (kernel[0].length & 1) === 0) {
        throw new RangeError(
          "validateKernel: Kernel rows and columns should be odd numbers"
        );
      } else {
        kHeight = Math.floor(kernel.length / 2);
        kWidth = Math.floor(kernel[0].length / 2);
      }
    } else {
      let kernelWidth = Math.sqrt(kernel.length);
      if ((0, import_is_integer.default)(kernelWidth)) {
        kWidth = kHeight = Math.floor(Math.sqrt(kernel.length) / 2);
      } else {
        throw new RangeError("validateKernel: Kernel array should be a square");
      }
      let newKernel = new Array(kernelWidth);
      for (let i3 = 0; i3 < kernelWidth; i3++) {
        newKernel[i3] = new Array(kernelWidth);
        for (let j2 = 0; j2 < kernelWidth; j2++) {
          newKernel[i3][j2] = kernel[i3 * kernelWidth + j2];
        }
      }
      kernel = newKernel;
    }
  } else {
    throw new Error(`validateKernel: Invalid Kernel: ${kernel}`);
  }
  return { kernel, kWidth, kHeight };
}

// node_modules/image-js/src/image/internal/clamp.js
function clamp(value, image) {
  return Math.round(Math.min(Math.max(value, 0), image.maxValue));
}

// node_modules/ml-convolution/src/directConvolution.js
function directConvolution(input, kernel, output) {
  if (output === void 0) {
    const length = input.length + kernel.length - 1;
    output = new Array(length);
  }
  fill(output);
  for (var i3 = 0; i3 < input.length; i3++) {
    for (var j2 = 0; j2 < kernel.length; j2++) {
      output[i3 + j2] += input[i3] * kernel[j2];
    }
  }
  return output;
}
function fill(array3) {
  for (var i3 = 0; i3 < array3.length; i3++) {
    array3[i3] = 0;
  }
}

// node_modules/ml-convolution/src/fftConvolution.js
var import_fft = __toESM(require_fft());
var import_next_power_of_two = __toESM(require_next_power_of_two());

// node_modules/image-js/src/image/operator/convolutionSeparable.js
function convolutionSeparable(data, separatedKernel, width, height) {
  const result = new Array(data.length);
  let tmp, conv, offset, kernel;
  kernel = separatedKernel[1];
  offset = (kernel.length - 1) / 2;
  conv = new Array(width + kernel.length - 1);
  tmp = new Array(width);
  for (let y3 = 0; y3 < height; y3++) {
    for (let x2 = 0; x2 < width; x2++) {
      tmp[x2] = data[y3 * width + x2];
    }
    directConvolution(tmp, kernel, conv);
    for (let x2 = 0; x2 < width; x2++) {
      result[y3 * width + x2] = conv[offset + x2];
    }
  }
  kernel = separatedKernel[0];
  offset = (kernel.length - 1) / 2;
  conv = new Array(height + kernel.length - 1);
  tmp = new Array(height);
  for (let x2 = 0; x2 < width; x2++) {
    for (let y3 = 0; y3 < height; y3++) {
      tmp[y3] = result[y3 * width + x2];
    }
    directConvolution(tmp, kernel, conv);
    for (let y3 = 0; y3 < height; y3++) {
      result[y3 * width + x2] = conv[offset + y3];
    }
  }
  return result;
}

// node_modules/ml-matrix/matrix.mjs
var matrix = __toESM(require_matrix(), 1);
var Matrix2 = matrix.Matrix;
var SVD2 = matrix.SVD;
var SingularValueDecomposition2 = matrix.SingularValueDecomposition;
var matrix_default = matrix.default.Matrix ? matrix.default.Matrix : matrix.Matrix;
var inverse2 = matrix.inverse;
var solve2 = matrix.solve;

// node_modules/image-js/src/image/operator/getSeparatedKernel.js
function getSeparatedKernel(kernel) {
  const svd = new SVD2(kernel, { autoTranspose: true });
  if (svd.rank !== 1)
    return null;
  const s3 = Math.sqrt(svd.s[0]);
  const v3 = svd.U.to2DArray().map((v4) => v4[0] * s3);
  const h3 = svd.V.to2DArray().map((h4) => h4[0] * s3);
  return [v3, h3];
}

// node_modules/image-js/src/image/operator/convolution.js
function convolution(kernel, options = {}) {
  let {
    channels,
    bitDepth,
    normalize: normalize2 = false,
    divisor = 1,
    border = "copy",
    algorithm = "auto"
  } = options;
  let createOptions = {};
  if (bitDepth)
    createOptions.bitDepth = bitDepth;
  let newImage = Image2.createFrom(this, createOptions);
  channels = validateArrayOfChannels(this, channels, true);
  if (algorithm !== "separable") {
    ({ kernel } = validateKernel(kernel));
  } else if (!Array.isArray(kernel) || kernel.length !== 2) {
    throw new RangeError(
      "separable convolution requires two arrays of numbers to represent the kernel"
    );
  }
  if (algorithm === "auto") {
    let separatedKernel = getSeparatedKernel(kernel);
    if (separatedKernel !== null) {
      algorithm = "separable";
      kernel = separatedKernel;
    } else if ((kernel.length > 9 || kernel[0].length > 9) && this.width <= 4096 && this.height <= 4096) {
      algorithm = "fft";
    } else {
      algorithm = "direct";
    }
  }
  let halfHeight, halfWidth;
  if (algorithm === "separable") {
    halfHeight = Math.floor(kernel[0].length / 2);
    halfWidth = Math.floor(kernel[1].length / 2);
  } else {
    halfHeight = Math.floor(kernel.length / 2);
    halfWidth = Math.floor(kernel[0].length / 2);
  }
  let clamped = newImage.isClamped;
  let tmpData = new Array(this.height * this.width);
  let index2, x2, y3, channel, c4, tmpResult;
  for (channel = 0; channel < channels.length; channel++) {
    c4 = channels[channel];
    for (y3 = 0; y3 < this.height; y3++) {
      for (x2 = 0; x2 < this.width; x2++) {
        index2 = y3 * this.width + x2;
        tmpData[index2] = this.data[index2 * this.channels + c4];
      }
    }
    if (algorithm === "direct") {
      tmpResult = (0, import_ml_matrix_convolution.direct)(tmpData, kernel, {
        rows: this.height,
        cols: this.width,
        normalize: normalize2,
        divisor
      });
    } else if (algorithm === "separable") {
      tmpResult = convolutionSeparable(
        tmpData,
        kernel,
        this.width,
        this.height
      );
      if (normalize2) {
        divisor = 0;
        for (let i3 = 0; i3 < kernel[0].length; i3++) {
          for (let j2 = 0; j2 < kernel[1].length; j2++) {
            divisor += kernel[0][i3] * kernel[1][j2];
          }
        }
      }
      if (divisor !== 1) {
        for (let i3 = 0; i3 < tmpResult.length; i3++) {
          tmpResult[i3] /= divisor;
        }
      }
    } else {
      tmpResult = (0, import_ml_matrix_convolution.fft)(tmpData, kernel, {
        rows: this.height,
        cols: this.width,
        normalize: normalize2,
        divisor
      });
    }
    for (y3 = 0; y3 < this.height; y3++) {
      for (x2 = 0; x2 < this.width; x2++) {
        index2 = y3 * this.width + x2;
        if (clamped) {
          newImage.data[index2 * this.channels + c4] = clamp(
            tmpResult[index2],
            newImage
          );
        } else {
          newImage.data[index2 * this.channels + c4] = tmpResult[index2];
        }
      }
    }
  }
  if (this.alpha && !channels.includes(this.channels)) {
    for (x2 = this.components; x2 < this.data.length; x2 = x2 + this.channels) {
      newImage.data[x2] = this.data[x2];
    }
  }
  if (border !== "periodic") {
    newImage.setBorder({ size: [halfWidth, halfHeight], algorithm: border });
  }
  return newImage;
}

// node_modules/image-js/src/image/filter/gradientFilter.js
function gradientFilter(options = {}) {
  let {
    direction = "xy",
    border = "copy",
    kernelX,
    kernelY,
    channels,
    bitDepth = this.bitDepth
  } = options;
  this.checkProcessable("gradientFilter", {
    bitDepth: [8, 16]
  });
  switch (direction) {
    case "x":
      if (!kernelX)
        throw new Error("kernelX option is missing");
      return convolution.call(this, kernelX, {
        channels,
        border,
        bitDepth
      });
    case "y":
      if (!kernelY)
        throw new Error("kernelY option is missing");
      return convolution.call(this, kernelY, {
        channels,
        border,
        bitDepth
      });
    case "xy": {
      if (!kernelX)
        throw new Error("kernelX option is missing");
      if (!kernelY)
        throw new Error("kernelY option is missing");
      const gX = convolution.call(this, kernelX, {
        channels,
        border,
        bitDepth: 32
      });
      const gY = convolution.call(this, kernelY, {
        channels,
        border,
        bitDepth: 32
      });
      return gX.hypotenuse(gY, { bitDepth, channels });
    }
    default:
      throw new Error(`Unknown parameter direction: ${direction}`);
  }
}

// node_modules/image-js/src/image/filter/sobelFilter.js
function sobelFilter(options) {
  return gradientFilter.call(
    this,
    Object.assign({}, options, {
      kernelX: SOBEL_X,
      kernelY: SOBEL_Y
    })
  );
}

// node_modules/image-js/src/image/filter/scharrFilter.js
function scharrFilter(options) {
  return gradientFilter.call(
    this,
    Object.assign({}, options, {
      kernelX: SCHARR_X,
      kernelY: SCHARR_Y
    })
  );
}

// node_modules/image-js/src/image/filter/level.js
var import_new_array = __toESM(require_new_array());
function level(options = {}) {
  let {
    algorithm = "range",
    channels,
    min: min3 = this.min,
    max: max4 = this.max
  } = options;
  this.checkProcessable("level", {
    bitDepth: [8, 16, 32]
  });
  channels = validateArrayOfChannels(this, { channels });
  if (channels.length !== this.channel) {
    if (Array.isArray(min3) && min3.length === this.channels) {
      min3 = min3.filter((a3, index2) => channels.includes(index2));
    }
    if (Array.isArray(max4) && max4.length === this.channels) {
      max4 = max4.filter((a3, index2) => channels.includes(index2));
    }
  }
  switch (algorithm) {
    case "range":
      if (min3 < 0) {
        min3 = 0;
      }
      if (max4 > this.maxValue) {
        max4 = this.maxValue;
      }
      if (!Array.isArray(min3)) {
        min3 = (0, import_new_array.default)(channels.length, min3);
      }
      if (!Array.isArray(max4)) {
        max4 = (0, import_new_array.default)(channels.length, max4);
      }
      processImage(this, min3, max4, channels);
      break;
    default:
      throw new Error(`level: algorithm not implement: ${algorithm}`);
  }
  return this;
}
function processImage(image, min3, max4, channels) {
  let delta = 1e-5;
  let factor = new Array(channels.length);
  for (let i3 = 0; i3 < channels.length; i3++) {
    if (min3[i3] === 0 && max4[i3] === image.maxValue) {
      factor[i3] = 0;
    } else if (max4[i3] === min3[i3]) {
      factor[i3] = 0;
    } else {
      factor[i3] = (image.maxValue + 1 - delta) / (max4[i3] - min3[i3]);
    }
    min3[i3] += (0.5 - delta / 2) / factor[i3];
  }
  for (let j2 = 0; j2 < channels.length; j2++) {
    let c4 = channels[j2];
    if (factor[j2] !== 0) {
      for (let i3 = 0; i3 < image.data.length; i3 += image.channels) {
        image.data[i3 + c4] = Math.min(
          Math.max(0, (image.data[i3 + c4] - min3[j2]) * factor[j2] + 0.5 | 0),
          image.maxValue
        );
      }
    }
  }
}

// node_modules/image-js/src/util/value.js
var import_is_array_type = __toESM(require_is_array_type());
function checkNumberArray(value) {
  if (!isNaN(value)) {
    if (value <= 0) {
      throw new Error("checkNumberArray: the value must be greater than 0");
    }
    return value;
  } else {
    if (value instanceof Image2) {
      return value.data;
    }
    if (!(0, import_is_array_type.default)(value)) {
      throw new Error(
        "checkNumberArray: the value should be either a number, array or Image"
      );
    }
    return value;
  }
}

// node_modules/image-js/src/image/filter/add.js
function add(value, options = {}) {
  let { channels } = options;
  this.checkProcessable("add", {
    bitDepth: [8, 16]
  });
  channels = validateArrayOfChannels(this, { channels });
  value = checkNumberArray(value);
  if (!isNaN(value)) {
    for (let j2 = 0; j2 < channels.length; j2++) {
      let c4 = channels[j2];
      for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
        this.data[i3 + c4] = Math.min(
          this.maxValue,
          this.data[i3 + c4] + value >> 0
        );
      }
    }
  } else {
    if (this.data.length !== value.length) {
      throw new Error("add: the data size is different");
    }
    for (let j2 = 0; j2 < channels.length; j2++) {
      let c4 = channels[j2];
      for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
        this.data[i3 + c4] = Math.max(
          0,
          Math.min(this.maxValue, this.data[i3 + c4] + value[i3 + c4] >> 0)
        );
      }
    }
  }
  return this;
}

// node_modules/image-js/src/image/filter/subtract.js
function subtract(value, options = {}) {
  let { channels } = options;
  this.checkProcessable("subtract", {
    bitDepth: [8, 16]
  });
  channels = validateArrayOfChannels(this, { channels });
  value = checkNumberArray(value);
  if (!isNaN(value)) {
    for (let j2 = 0; j2 < channels.length; j2++) {
      let c4 = channels[j2];
      for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
        this.data[i3 + c4] = Math.max(0, this.data[i3 + c4] - value >> 0);
      }
    }
  } else {
    if (this.data.length !== value.length) {
      throw new Error("subtract: the data size is different");
    }
    for (let j2 = 0; j2 < channels.length; j2++) {
      let c4 = channels[j2];
      for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
        this.data[i3 + c4] = Math.max(
          0,
          Math.min(this.maxValue, this.data[i3 + c4] - value[i3 + c4] >> 0)
        );
      }
    }
  }
  return this;
}

// node_modules/image-js/src/image/filter/subtractImage.js
function subtractImage(otherImage, options = {}) {
  let { channels, absolute: absolute2 = false } = options;
  this.checkProcessable("subtractImage", {
    bitDepth: [8, 16]
  });
  if (this.width !== otherImage.width || this.height !== otherImage.height) {
    throw new Error("subtractImage: both images must have the same size");
  }
  if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {
    throw new Error(
      "subtractImage: both images must have the same alpha and bitDepth"
    );
  }
  if (this.channels !== otherImage.channels) {
    throw new Error(
      "subtractImage: both images must have the same number of channels"
    );
  }
  let newImage = this.clone();
  channels = validateArrayOfChannels(this, { channels });
  for (let j2 = 0; j2 < channels.length; j2++) {
    let c4 = channels[j2];
    for (let i3 = c4; i3 < this.data.length; i3 += this.channels) {
      let value = this.data[i3] - otherImage.data[i3];
      if (absolute2) {
        newImage.data[i3] = Math.abs(value);
      } else {
        newImage.data[i3] = Math.max(value, 0);
      }
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/filter/hypotenuse.js
function hypotenuse(otherImage, options = {}) {
  let { bitDepth = this.bitDepth, channels } = options;
  this.checkProcessable("hypotenuse", {
    bitDepth: [8, 16, 32]
  });
  if (this.width !== otherImage.width || this.height !== otherImage.height) {
    throw new Error("hypotenuse: both images must have the same size");
  }
  if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {
    throw new Error(
      "hypotenuse: both images must have the same alpha and bitDepth"
    );
  }
  if (this.channels !== otherImage.channels) {
    throw new Error(
      "hypotenuse: both images must have the same number of channels"
    );
  }
  let newImage = Image2.createFrom(this, { bitDepth });
  channels = validateArrayOfChannels(this, { channels });
  let clamped = newImage.isClamped;
  for (let j2 = 0; j2 < channels.length; j2++) {
    let c4 = channels[j2];
    for (let i3 = c4; i3 < this.data.length; i3 += this.channels) {
      let value = Math.hypot(this.data[i3], otherImage.data[i3]);
      if (clamped) {
        newImage.data[i3] = Math.min(
          Math.max(Math.round(value), 0),
          newImage.maxValue
        );
      } else {
        newImage.data[i3] = value;
      }
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/filter/multiply.js
function multiply(value, options = {}) {
  let { channels } = options;
  this.checkProcessable("multiply", {
    bitDepth: [8, 16]
  });
  if (value <= 0) {
    throw new Error("multiply: the value must be greater than 0");
  }
  channels = validateArrayOfChannels(this, { channels });
  value = checkNumberArray(value);
  if (!isNaN(value)) {
    for (let j2 = 0; j2 < channels.length; j2++) {
      let c4 = channels[j2];
      for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
        this.data[i3 + c4] = Math.min(
          this.maxValue,
          this.data[i3 + c4] * value >> 0
        );
      }
    }
  } else {
    if (this.data.length !== value.length) {
      throw new Error("multiply: the data size is different");
    }
    for (let j2 = 0; j2 < channels.length; j2++) {
      let c4 = channels[j2];
      for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
        this.data[i3 + c4] = Math.max(
          0,
          Math.min(this.maxValue, this.data[i3 + c4] * value[i3 + c4] >> 0)
        );
      }
    }
  }
  return this;
}

// node_modules/image-js/src/image/filter/divide.js
function divide(value, options = {}) {
  let { channels } = options;
  this.checkProcessable("divide", {
    bitDepth: [8, 16]
  });
  channels = validateArrayOfChannels(this, { channels });
  value = checkNumberArray(value);
  if (!isNaN(value)) {
    for (let j2 = 0; j2 < channels.length; j2++) {
      let c4 = channels[j2];
      for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
        this.data[i3 + c4] = Math.min(
          this.maxValue,
          this.data[i3 + c4] / value >> 0
        );
      }
    }
  } else {
    if (this.data.length !== value.length) {
      throw new Error("divide: the: the data size is different");
    }
    for (let j2 = 0; j2 < channels.length; j2++) {
      let c4 = channels[j2];
      for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
        this.data[i3 + c4] = Math.max(
          0,
          Math.min(this.maxValue, this.data[i3 + c4] / value[i3 + c4] >> 0)
        );
      }
    }
  }
  return this;
}

// node_modules/ml-regression-base/src/index.js
var import_is_any_array = __toESM(require_lib());
var BaseRegression = class {
  constructor() {
    if (new.target === BaseRegression) {
      throw new Error("BaseRegression must be subclassed");
    }
  }
  predict(x2) {
    if (typeof x2 === "number") {
      return this._predict(x2);
    } else if ((0, import_is_any_array.isAnyArray)(x2)) {
      const y3 = [];
      for (let i3 = 0; i3 < x2.length; i3++) {
        y3.push(this._predict(x2[i3]));
      }
      return y3;
    } else {
      throw new TypeError("x must be a number or array");
    }
  }
  _predict() {
    throw new Error("_predict must be implemented");
  }
  train() {
  }
  toString() {
    return "";
  }
  toLaTeX() {
    return "";
  }
  /**
   * Return the correlation coefficient of determination (r) and chi-square.
   * @param {Array<number>} x
   * @param {Array<number>} y
   * @return {object}
   */
  score(x2, y3) {
    if (!(0, import_is_any_array.isAnyArray)(x2) || !(0, import_is_any_array.isAnyArray)(y3) || x2.length !== y3.length) {
      throw new Error("x and y must be arrays of the same length");
    }
    const n3 = x2.length;
    const y22 = new Array(n3);
    for (let i3 = 0; i3 < n3; i3++) {
      y22[i3] = this._predict(x2[i3]);
    }
    let xSum = 0;
    let ySum = 0;
    let chi2 = 0;
    let rmsd = 0;
    let xSquared = 0;
    let ySquared = 0;
    let xY = 0;
    for (let i3 = 0; i3 < n3; i3++) {
      xSum += y22[i3];
      ySum += y3[i3];
      xSquared += y22[i3] * y22[i3];
      ySquared += y3[i3] * y3[i3];
      xY += y22[i3] * y3[i3];
      if (y3[i3] !== 0) {
        chi2 += (y3[i3] - y22[i3]) * (y3[i3] - y22[i3]) / y3[i3];
      }
      rmsd += (y3[i3] - y22[i3]) * (y3[i3] - y22[i3]);
    }
    const r2 = (n3 * xY - xSum * ySum) / Math.sqrt((n3 * xSquared - xSum * xSum) * (n3 * ySquared - ySum * ySum));
    return {
      r: r2,
      r2: r2 * r2,
      chi2,
      rmsd: Math.sqrt(rmsd / n3)
    };
  }
};

// node_modules/ml-regression/src/regression/kernel-ridge-regression.js
var import_ml_kernel = __toESM(require_kernel());
var defaultOptions2 = {
  lambda: 0.1,
  kernelType: "gaussian",
  kernelOptions: {},
  computeCoefficient: false
};
var KernelRidgeRegression = class extends BaseRegression {
  constructor(inputs, outputs, options) {
    super();
    if (inputs === true) {
      this.alpha = outputs.alpha;
      this.inputs = outputs.inputs;
      this.kernelType = outputs.kernelType;
      this.kernelOptions = outputs.kernelOptions;
      this.kernel = new import_ml_kernel.default(outputs.kernelType, outputs.kernelOptions);
    } else {
      inputs = Matrix2.checkMatrix(inputs);
      options = Object.assign({}, defaultOptions2, options);
      const kernelFunction = new import_ml_kernel.default(
        options.kernelType,
        options.kernelOptions
      );
      const K2 = kernelFunction.compute(inputs);
      const n3 = inputs.rows;
      K2.add(Matrix2.eye(n3, n3).mul(options.lambda));
      this.alpha = solve2(K2, outputs);
      this.inputs = inputs;
      this.kernelType = options.kernelType;
      this.kernelOptions = options.kernelOptions;
      this.kernel = kernelFunction;
    }
  }
  _predict(newInputs) {
    return this.kernel.compute([newInputs], this.inputs).mmul(this.alpha).getRow(0);
  }
  toJSON() {
    return {
      name: "kernelRidgeRegression",
      alpha: this.alpha,
      inputs: this.inputs,
      kernelType: this.kernelType,
      kernelOptions: this.kernelOptions
    };
  }
  static load(json) {
    if (json.name !== "kernelRidgeRegression") {
      throw new TypeError("not a KRR model");
    }
    return new KernelRidgeRegression(true, json);
  }
};

// node_modules/ml-array-median/lib-es6/index.js
var import_is_any_array2 = __toESM(require_lib());
var import_median_quickselect2 = __toESM(require_median_quickselect_min());

// node_modules/image-js/src/image/filter/background.js
function background(coordinates, values, options) {
  const model = new KernelRidgeRegression(coordinates, values, options);
  const allCoordinates = new Array(this.size);
  for (let i3 = 0; i3 < this.width; i3++) {
    for (let j2 = 0; j2 < this.height; j2++) {
      allCoordinates[j2 * this.width + i3] = [i3, j2];
    }
  }
  const result = model.predict(allCoordinates);
  const background3 = Image2.createFrom(this);
  for (let i3 = 0; i3 < this.size; i3++) {
    background3.data[i3] = Math.min(this.maxValue, Math.max(0, result[i3][0]));
  }
  return background3;
}

// node_modules/image-js/src/image/morphology/dilate.js
function dilate(options = {}) {
  let {
    kernel = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations = 1
  } = options;
  this.checkProcessable("dilate", {
    bitDepth: [1, 8, 16],
    components: 1,
    alpha: 0
  });
  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
    throw new TypeError(
      "dilate: The number of rows and columns of the kernel must be odd"
    );
  }
  let onlyOnes = true;
  outer:
    for (const row of kernel) {
      for (const value of row) {
        if (value !== 1) {
          onlyOnes = false;
          break outer;
        }
      }
    }
  let result = this;
  for (let i3 = 0; i3 < iterations; i3++) {
    if (this.bitDepth === 1) {
      if (onlyOnes) {
        const newImage = result.clone();
        result = dilateOnceBinaryOnlyOnes(
          result,
          newImage,
          kernel.length,
          kernel[0].length
        );
      } else {
        const newImage = Image2.createFrom(result);
        result = dilateOnceBinary(result, newImage, kernel);
      }
    } else if (onlyOnes) {
      const newImage = Image2.createFrom(result);
      result = dilateOnceGreyOnlyOnes(
        result,
        newImage,
        kernel.length,
        kernel[0].length
      );
    } else {
      const newImage = Image2.createFrom(result);
      result = dilateOnceGrey(result, newImage, kernel);
    }
  }
  return result;
}
function dilateOnceGrey(img, newImage, kernel) {
  const kernelWidth = kernel.length;
  const kernelHeight = kernel[0].length;
  let radiusX = (kernelWidth - 1) / 2;
  let radiusY = (kernelHeight - 1) / 2;
  for (let y3 = 0; y3 < img.height; y3++) {
    for (let x2 = 0; x2 < img.width; x2++) {
      let max4 = 0;
      for (let jj = 0; jj < kernelHeight; jj++) {
        for (let ii = 0; ii < kernelWidth; ii++) {
          if (kernel[ii][jj] !== 1)
            continue;
          let i3 = ii - radiusX + x2;
          let j2 = jj - radiusY + y3;
          if (i3 < 0 || j2 < 0 || i3 >= img.width || j2 >= img.height)
            continue;
          const value = img.getValueXY(i3, j2, 0);
          if (value > max4)
            max4 = value;
        }
      }
      newImage.setValueXY(x2, y3, 0, max4);
    }
  }
  return newImage;
}
function dilateOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {
  const radiusX = (kernelWidth - 1) / 2;
  const radiusY = (kernelHeight - 1) / 2;
  const maxList = [];
  for (let x2 = 0; x2 < img.width; x2++) {
    maxList.push(0);
  }
  for (let y3 = 0; y3 < img.height; y3++) {
    for (let x2 = 0; x2 < img.width; x2++) {
      let max4 = 0;
      for (let h3 = Math.max(0, y3 - radiusY); h3 < Math.min(img.height, y3 + radiusY + 1); h3++) {
        const value = img.getValueXY(x2, h3, 0);
        if (value > max4) {
          max4 = value;
        }
      }
      maxList[x2] = max4;
    }
    for (let x2 = 0; x2 < img.width; x2++) {
      let max4 = 0;
      for (let i3 = Math.max(0, x2 - radiusX); i3 < Math.min(img.width, x2 + radiusX + 1); i3++) {
        if (maxList[i3] > max4) {
          max4 = maxList[i3];
        }
      }
      newImage.setValueXY(x2, y3, 0, max4);
    }
  }
  return newImage;
}
function dilateOnceBinary(img, newImage, kernel) {
  const kernelWidth = kernel.length;
  const kernelHeight = kernel[0].length;
  let radiusX = (kernelWidth - 1) / 2;
  let radiusY = (kernelHeight - 1) / 2;
  for (let y3 = 0; y3 < img.height; y3++) {
    for (let x2 = 0; x2 < img.width; x2++) {
      let max4 = 0;
      intLoop:
        for (let jj = 0; jj < kernelHeight; jj++) {
          for (let ii = 0; ii < kernelWidth; ii++) {
            if (kernel[ii][jj] !== 1)
              continue;
            let i3 = ii - radiusX + x2;
            let j2 = jj - radiusY + y3;
            if (j2 < 0 || i3 < 0 || i3 >= img.width || j2 >= img.height)
              continue;
            const value = img.getBitXY(i3, j2);
            if (value === 1) {
              max4 = 1;
              break intLoop;
            }
          }
        }
      if (max4 === 1) {
        newImage.setBitXY(x2, y3);
      }
    }
  }
  return newImage;
}
function dilateOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {
  const radiusX = (kernelWidth - 1) / 2;
  const radiusY = (kernelHeight - 1) / 2;
  const maxList = [];
  for (let x2 = 0; x2 < img.width; x2++) {
    maxList.push(1);
  }
  for (let y3 = 0; y3 < img.height; y3++) {
    for (let x2 = 0; x2 < img.width; x2++) {
      maxList[x2] = 0;
      for (let h3 = Math.max(0, y3 - radiusY); h3 < Math.min(img.height, y3 + radiusY + 1); h3++) {
        if (img.getBitXY(x2, h3) === 1) {
          maxList[x2] = 1;
          break;
        }
      }
    }
    for (let x2 = 0; x2 < img.width; x2++) {
      if (newImage.getBitXY(x2, y3) === 1)
        continue;
      for (let i3 = Math.max(0, x2 - radiusX); i3 < Math.min(img.width, x2 + radiusX + 1); i3++) {
        if (maxList[i3] === 1) {
          newImage.setBitXY(x2, y3);
          break;
        }
      }
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/morphology/erode.js
function erode(options = {}) {
  let {
    kernel = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations = 1
  } = options;
  this.checkProcessable("erode", {
    bitDepth: [1, 8, 16],
    components: 1,
    alpha: 0
  });
  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
    throw new TypeError(
      "erode: The number of rows and columns of the kernel must be odd"
    );
  }
  let onlyOnes = true;
  outer:
    for (const row of kernel) {
      for (const value of row) {
        if (value !== 1) {
          onlyOnes = false;
          break outer;
        }
      }
    }
  let result = this;
  for (let i3 = 0; i3 < iterations; i3++) {
    if (this.bitDepth === 1) {
      if (onlyOnes) {
        const newImage = result.clone();
        result = erodeOnceBinaryOnlyOnes(
          result,
          newImage,
          kernel.length,
          kernel[0].length
        );
      } else {
        const newImage = Image2.createFrom(result);
        result = erodeOnceBinary(result, newImage, kernel);
      }
    } else if (onlyOnes) {
      const newImage = Image2.createFrom(result);
      result = erodeOnceGreyOnlyOnes(
        result,
        newImage,
        kernel.length,
        kernel[0].length
      );
    } else {
      const newImage = Image2.createFrom(result);
      result = erodeOnceGrey(result, newImage, kernel);
    }
  }
  return result;
}
function erodeOnceGrey(img, newImage, kernel) {
  const kernelWidth = kernel.length;
  const kernelHeight = kernel[0].length;
  let radiusX = (kernelWidth - 1) / 2;
  let radiusY = (kernelHeight - 1) / 2;
  for (let y3 = 0; y3 < img.height; y3++) {
    for (let x2 = 0; x2 < img.width; x2++) {
      let min3 = img.maxValue;
      for (let jj = 0; jj < kernelHeight; jj++) {
        for (let ii = 0; ii < kernelWidth; ii++) {
          if (kernel[ii][jj] !== 1)
            continue;
          let i3 = ii - radiusX + x2;
          let j2 = jj - radiusY + y3;
          if (i3 < 0 || j2 < 0 || i3 >= img.width || j2 >= img.height)
            continue;
          const value = img.getValueXY(i3, j2, 0);
          if (value < min3)
            min3 = value;
        }
      }
      newImage.setValueXY(x2, y3, 0, min3);
    }
  }
  return newImage;
}
function erodeOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {
  const radiusX = (kernelWidth - 1) / 2;
  const radiusY = (kernelHeight - 1) / 2;
  const minList = [];
  for (let x2 = 0; x2 < img.width; x2++) {
    minList.push(0);
  }
  for (let y3 = 0; y3 < img.height; y3++) {
    for (let x2 = 0; x2 < img.width; x2++) {
      let min3 = img.maxValue;
      for (let h3 = Math.max(0, y3 - radiusY); h3 < Math.min(img.height, y3 + radiusY + 1); h3++) {
        const value = img.getValueXY(x2, h3, 0);
        if (value < min3) {
          min3 = value;
        }
      }
      minList[x2] = min3;
    }
    for (let x2 = 0; x2 < img.width; x2++) {
      let min3 = img.maxValue;
      for (let i3 = Math.max(0, x2 - radiusX); i3 < Math.min(img.width, x2 + radiusX + 1); i3++) {
        if (minList[i3] < min3) {
          min3 = minList[i3];
        }
      }
      newImage.setValueXY(x2, y3, 0, min3);
    }
  }
  return newImage;
}
function erodeOnceBinary(img, newImage, kernel) {
  const kernelWidth = kernel.length;
  const kernelHeight = kernel[0].length;
  let radiusX = (kernelWidth - 1) / 2;
  let radiusY = (kernelHeight - 1) / 2;
  for (let y3 = 0; y3 < img.height; y3++) {
    for (let x2 = 0; x2 < img.width; x2++) {
      let min3 = 1;
      intLoop:
        for (let jj = 0; jj < kernelHeight; jj++) {
          for (let ii = 0; ii < kernelWidth; ii++) {
            if (kernel[ii][jj] !== 1)
              continue;
            let i3 = ii - radiusX + x2;
            let j2 = jj - radiusY + y3;
            if (j2 < 0 || i3 < 0 || i3 >= img.width || j2 >= img.height)
              continue;
            const value = img.getBitXY(i3, j2);
            if (value === 0) {
              min3 = 0;
              break intLoop;
            }
          }
        }
      if (min3 === 1) {
        newImage.setBitXY(x2, y3);
      }
    }
  }
  return newImage;
}
function erodeOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {
  const radiusX = (kernelWidth - 1) / 2;
  const radiusY = (kernelHeight - 1) / 2;
  const minList = [];
  for (let x2 = 0; x2 < img.width; x2++) {
    minList.push(0);
  }
  for (let y3 = 0; y3 < img.height; y3++) {
    for (let x2 = 0; x2 < img.width; x2++) {
      minList[x2] = 1;
      for (let h3 = Math.max(0, y3 - radiusY); h3 < Math.min(img.height, y3 + radiusY + 1); h3++) {
        if (img.getBitXY(x2, h3) === 0) {
          minList[x2] = 0;
          break;
        }
      }
    }
    for (let x2 = 0; x2 < img.width; x2++) {
      if (newImage.getBitXY(x2, y3) === 0)
        continue;
      for (let i3 = Math.max(0, x2 - radiusX); i3 < Math.min(img.width, x2 + radiusX + 1); i3++) {
        if (minList[i3] === 0) {
          newImage.clearBitXY(x2, y3);
          break;
        }
      }
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/morphology/open.js
function open2(options = {}) {
  let {
    kernel = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations = 1
  } = options;
  this.checkProcessable("open", {
    bitDepth: [8, 16],
    components: 1,
    alpha: 0
  });
  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
    throw new TypeError(
      "open: The number of rows and columns of the kernel must be odd"
    );
  }
  let newImage = this;
  for (let i3 = 0; i3 < iterations; i3++) {
    newImage = newImage.erode({ kernel });
    newImage = newImage.dilate({ kernel });
  }
  return newImage;
}

// node_modules/image-js/src/image/morphology/close.js
function close(options = {}) {
  let {
    kernel = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations = 1
  } = options;
  this.checkProcessable("close", {
    bitDepth: [1, 8, 16],
    components: 1,
    alpha: 0
  });
  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
    throw new TypeError(
      "close: The number of rows and columns of the kernel must be odd"
    );
  }
  let newImage = this;
  for (let i3 = 0; i3 < iterations; i3++) {
    newImage = newImage.dilate({ kernel }).erode({ kernel });
  }
  return newImage;
}

// node_modules/image-js/src/image/morphology/topHat.js
function topHat(options = {}) {
  let {
    kernel = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations = 1
  } = options;
  this.checkProcessable("topHat", {
    bitDepth: [8, 16],
    components: 1,
    alpha: 0
  });
  if (kernel.length % 2 === 0 || kernel[0].length % 2 === 0) {
    throw new TypeError(
      "topHat: The number of rows and columns of the kernel must be odd"
    );
  }
  let newImage = this;
  for (let i3 = 0; i3 < iterations; i3++) {
    let openImage = newImage.open({ kernel });
    newImage = openImage.subtractImage(newImage, { absolute: true });
  }
  return newImage;
}

// node_modules/image-js/src/image/morphology/blackHat.js
function blackHat(options = {}) {
  let {
    kernel = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations = 1
  } = options;
  this.checkProcessable("blackHat", {
    bitDepth: [8, 16],
    components: 1,
    alpha: 0
  });
  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
    throw new TypeError(
      "blackHat: The number of rows and columns of the kernel must be odd"
    );
  }
  let newImage = this;
  for (let i3 = 0; i3 < iterations; i3++) {
    const closeImage = newImage.close({ kernel });
    newImage = closeImage.subtractImage(newImage, { absolute: true });
  }
  return newImage;
}

// node_modules/image-js/src/image/morphology/morphologicalGradient.js
function morphologicalGradient(options = {}) {
  let {
    kernel = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations = 1
  } = options;
  this.checkProcessable("morphologicalGradient", {
    bitDepth: [8, 16],
    components: 1,
    alpha: 0
  });
  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
    throw new TypeError(
      "morphologicalGradient: The number of rows and columns of the kernel must be odd"
    );
  }
  let newImage = this;
  for (let i3 = 0; i3 < iterations; i3++) {
    let dilatedImage = newImage.dilate({ kernel });
    let erodedImage = newImage.erode({ kernel });
    newImage = dilatedImage.subtractImage(erodedImage, { absolute: true });
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/warping.js
function order4Points(pts) {
  let tl = 0;
  let tr = 0;
  let br = 0;
  let bl = 0;
  let minX = pts[0][0];
  let indexMinX = 0;
  for (let i3 = 1; i3 < pts.length; i3++) {
    if (pts[i3][0] < minX) {
      minX = pts[i3][0];
      indexMinX = i3;
    }
  }
  let minX2 = pts[(indexMinX + 1) % pts.length][0];
  let indexMinX2 = (indexMinX + 1) % pts.length;
  for (let i3 = 1; i3 < pts.length; i3++) {
    if (pts[i3][0] < minX2 && i3 !== indexMinX) {
      minX2 = pts[i3][0];
      indexMinX2 = i3;
    }
  }
  if (pts[indexMinX2][1] < pts[indexMinX][1]) {
    tl = pts[indexMinX2];
    bl = pts[indexMinX];
    if (indexMinX !== (indexMinX2 + 1) % 4) {
      tr = pts[(indexMinX2 + 1) % 4];
      br = pts[(indexMinX2 + 2) % 4];
    } else {
      tr = pts[(indexMinX2 + 2) % 4];
      br = pts[(indexMinX2 + 3) % 4];
    }
  } else {
    bl = pts[indexMinX2];
    tl = pts[indexMinX];
    if (indexMinX2 !== (indexMinX + 1) % 4) {
      tr = pts[(indexMinX + 1) % 4];
      br = pts[(indexMinX + 2) % 4];
    } else {
      tr = pts[(indexMinX + 2) % 4];
      br = pts[(indexMinX + 3) % 4];
    }
  }
  return [tl, tr, br, bl];
}
function distance2Points(p1, p22) {
  return Math.sqrt(Math.pow(p1[0] - p22[0], 2) + Math.pow(p1[1] - p22[1], 2));
}
function crossVect(u3, v3) {
  let result = [
    u3[1] * v3[2] - u3[2] * v3[1],
    u3[2] * v3[0] - u3[0] * v3[2],
    u3[0] * v3[1] - u3[1] * v3[0]
  ];
  return result;
}
function dotVect(u3, v3) {
  let result = u3[0] * v3[0] + u3[1] * v3[1] + u3[2] * v3[2];
  return result;
}
function computeWidthAndHeigth(tl, tr, br, bl, widthImage, heightImage) {
  let w2 = Math.max(distance2Points(tl, tr), distance2Points(bl, br));
  let h3 = Math.max(distance2Points(tl, bl), distance2Points(tr, br));
  let finalW = 0;
  let finalH = 0;
  let u0 = Math.ceil(widthImage / 2);
  let v0 = Math.ceil(heightImage / 2);
  let arVis = w2 / h3;
  let m1 = [tl[0], tl[1], 1];
  let m22 = [tr[0], tr[1], 1];
  let m32 = [bl[0], bl[1], 1];
  let m4 = [br[0], br[1], 1];
  let k2 = dotVect(crossVect(m1, m4), m32) / dotVect(crossVect(m22, m4), m32);
  let k3 = dotVect(crossVect(m1, m4), m22) / dotVect(crossVect(m32, m4), m22);
  let n22 = [k2 * m22[0] - m1[0], k2 * m22[1] - m1[1], k2 * m22[2] - m1[2]];
  let n3 = [k3 * m32[0] - m1[0], k3 * m32[1] - m1[1], k3 * m32[2] - m1[2]];
  let n21 = n22[0];
  let n222 = n22[1];
  let n23 = n22[2];
  let n31 = n3[0];
  let n32 = n3[1];
  let n33 = n3[2];
  let f3 = 1 / (n23 * n33) * (n21 * n31 - (n21 * n33 + n23 * n31) * u0 + n23 * n33 * u0 * u0 + (n222 * n32 - (n222 * n33 + n23 * n32) * v0 + n23 * n33 * v0 * v0));
  if (f3 >= 0) {
    f3 = Math.sqrt(f3);
  } else {
    f3 = Math.sqrt(-f3);
  }
  let A2 = new Matrix2([
    [f3, 0, u0],
    [0, f3, v0],
    [0, 0, 1]
  ]);
  let At2 = A2.transpose();
  let Ati = inverse2(At2);
  let Ai = inverse2(A2);
  let n2R = Matrix2.rowVector(n22);
  let n3R = Matrix2.rowVector(n3);
  let arReal = Math.sqrt(
    dotVect(n2R.mmul(Ati).mmul(Ai).to1DArray(), n22) / dotVect(n3R.mmul(Ati).mmul(Ai).to1DArray(), n3)
  );
  if (arReal === 0 || arVis === 0) {
    finalW = Math.ceil(w2);
    finalH = Math.ceil(h3);
  } else if (arReal < arVis) {
    finalW = Math.ceil(w2);
    finalH = Math.ceil(finalW / arReal);
  } else {
    finalH = Math.ceil(h3);
    finalW = Math.ceil(arReal * finalH);
  }
  return [finalW, finalH];
}
function projectionPoint(x2, y3, a3, b2, c4, d2, e2, f3, g2, h3, image, channel) {
  let [newX, newY] = [
    (a3 * x2 + b2 * y3 + c4) / (g2 * x2 + h3 * y3 + 1),
    (d2 * x2 + e2 * y3 + f3) / (g2 * x2 + h3 * y3 + 1)
  ];
  return image.getValueXY(Math.floor(newX), Math.floor(newY), channel);
}
function warpingFourPoints(pts, options = {}) {
  let { calculateRatio = true } = options;
  if (pts.length !== 4) {
    throw new Error(
      `The array pts must have four elements, which are the four corners. Currently, pts have ${pts.length} elements`
    );
  }
  let [pt1, pt2, pt3, pt4] = pts;
  let quadrilaterial = [pt1, pt2, pt3, pt4];
  let [tl, tr, br, bl] = order4Points(quadrilaterial);
  let widthRect;
  let heightRect;
  if (calculateRatio) {
    [widthRect, heightRect] = computeWidthAndHeigth(
      tl,
      tr,
      br,
      bl,
      this.width,
      this.height
    );
  } else {
    widthRect = Math.ceil(
      Math.max(distance2Points(tl, tr), distance2Points(bl, br))
    );
    heightRect = Math.ceil(
      Math.max(distance2Points(tl, bl), distance2Points(tr, br))
    );
  }
  let newImage = Image2.createFrom(this, {
    width: widthRect,
    height: heightRect
  });
  let [X1, Y1] = tl;
  let [X2, Y2] = tr;
  let [X3, Y3] = br;
  let [X4, Y4] = bl;
  let [x1, y1] = [0, 0];
  let [x2, y22] = [0, widthRect - 1];
  let [x3, y3] = [heightRect - 1, widthRect - 1];
  let [x4, y4] = [heightRect - 1, 0];
  let S2 = new Matrix2([
    [x1, y1, 1, 0, 0, 0, -x1 * X1, -y1 * X1],
    [x2, y22, 1, 0, 0, 0, -x2 * X2, -y22 * X2],
    [x3, y3, 1, 0, 0, 0, -x3 * X3, -y1 * X3],
    [x4, y4, 1, 0, 0, 0, -x4 * X4, -y4 * X4],
    [0, 0, 0, x1, y1, 1, -x1 * Y1, -y1 * Y1],
    [0, 0, 0, x2, y22, 1, -x2 * Y2, -y22 * Y2],
    [0, 0, 0, x3, y3, 1, -x3 * Y3, -y3 * Y3],
    [0, 0, 0, x4, y4, 1, -x4 * Y4, -y4 * Y4]
  ]);
  let D2 = Matrix2.columnVector([X1, X2, X3, X4, Y1, Y2, Y3, Y4]);
  let svd = new SingularValueDecomposition2(S2);
  let T3 = svd.solve(D2);
  let [a3, b2, c4, d2, e2, f3, g2, h3] = T3.to1DArray();
  let Xt2 = new Matrix2(heightRect, widthRect);
  for (let channel = 0; channel < this.channels; channel++) {
    for (let i3 = 0; i3 < heightRect; i3++) {
      for (let j2 = 0; j2 < widthRect; j2++) {
        Xt2.set(
          i3,
          j2,
          projectionPoint(i3, j2, a3, b2, c4, d2, e2, f3, g2, h3, this, channel)
        );
      }
    }
    newImage.setMatrix(Xt2, { channel });
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/crop.js
function crop(options = {}) {
  let {
    x: x2 = 0,
    y: y3 = 0,
    width = this.width - x2,
    height = this.height - y3
  } = options;
  this.checkProcessable("crop", {
    bitDepth: [1, 8, 16]
  });
  x2 = Math.round(x2);
  y3 = Math.round(y3);
  width = Math.round(width);
  height = Math.round(height);
  if (x2 > this.width - 1 || y3 > this.height - 1) {
    throw new RangeError(
      `crop: origin (x:${x2}, y:${y3}) out of range (${this.width - 1}; ${this.height - 1})`
    );
  }
  if (width <= 0 || height <= 0) {
    throw new RangeError(
      `crop: width and height (width:${width}; height:${height}) must be positive numbers`
    );
  }
  if (x2 < 0 || y3 < 0) {
    throw new RangeError(
      `crop: x and y (x:${x2}, y:${y3}) must be positive numbers`
    );
  }
  if (width > this.width - x2 || height > this.height - y3) {
    throw new RangeError(
      `crop: (x: ${x2}, y:${y3}, width:${width}, height:${height}) size is out of range`
    );
  }
  let result = this;
  if (this.bitDepth === 1) {
    const newImage = new Image2(width, height, {
      kind: "BINARY",
      parent: this
    });
    result = cropBinary(this, newImage, x2, y3, width, height);
  } else {
    const newImage = Image2.createFrom(this, {
      width,
      height,
      position: [x2, y3]
    });
    result = cropDefault(this, newImage, x2, y3, width, height);
  }
  return result;
}
function cropDefault(img, newImage, x2, y3, width, height) {
  let xWidth = width * img.channels;
  let y1 = y3 + height;
  let ptr = 0;
  let jLeft = x2 * img.channels;
  for (let i3 = y3; i3 < y1; i3++) {
    let j2 = i3 * img.width * img.channels + jLeft;
    let jL = j2 + xWidth;
    for (; j2 < jL; j2++) {
      newImage.data[ptr++] = img.data[j2];
    }
  }
  return newImage;
}
function cropBinary(img, newImage, x2, y3, width, height) {
  let xWidth = width * img.channels;
  let y1 = y3 + height;
  let ptr = 0;
  let jLeft = x2 * img.channels;
  for (let i3 = y3; i3 < y1; i3++) {
    let j2 = i3 * img.width * img.channels + jLeft;
    let jL = j2 + xWidth;
    for (; j2 < jL; j2++) {
      if (img.getBit(j2)) {
        newImage.setBit(ptr);
      }
      ++ptr;
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/cropAlpha.js
function cropAlpha(options = {}) {
  this.checkProcessable("cropAlpha", {
    alpha: 1
  });
  const { threshold = this.maxValue } = options;
  let left = findLeft(this, threshold, this.components);
  if (left === -1) {
    throw new Error(
      "Could not find new dimensions. Threshold may be too high."
    );
  }
  let top = findTop(this, threshold, this.components, left);
  let bottom = findBottom(this, threshold, this.components, left);
  let right = findRight(this, threshold, this.components, left, top, bottom);
  return this.crop({
    x: left,
    y: top,
    width: right - left + 1,
    height: bottom - top + 1
  });
}
function findLeft(image, threshold, channel) {
  for (let x2 = 0; x2 < image.width; x2++) {
    for (let y3 = 0; y3 < image.height; y3++) {
      if (image.getValueXY(x2, y3, channel) >= threshold) {
        return x2;
      }
    }
  }
  return -1;
}
function findTop(image, threshold, channel, left) {
  for (let y3 = 0; y3 < image.height; y3++) {
    for (let x2 = left; x2 < image.width; x2++) {
      if (image.getValueXY(x2, y3, channel) >= threshold) {
        return y3;
      }
    }
  }
  return -1;
}
function findBottom(image, threshold, channel, left) {
  for (let y3 = image.height - 1; y3 >= 0; y3--) {
    for (let x2 = left; x2 < image.width; x2++) {
      if (image.getValueXY(x2, y3, channel) >= threshold) {
        return y3;
      }
    }
  }
  return -1;
}
function findRight(image, threshold, channel, left, top, bottom) {
  for (let x2 = image.width - 1; x2 >= left; x2--) {
    for (let y3 = top; y3 <= bottom; y3++) {
      if (image.getValueXY(x2, y3, channel) >= threshold) {
        return x2;
      }
    }
  }
  return -1;
}

// node_modules/image-js/src/util/converter.js
function getFactor(value) {
  if (typeof value === "string") {
    const last = value[value.length - 1];
    value = parseFloat(value);
    if (last === "%") {
      value /= 100;
    }
  }
  return value;
}
function getThreshold(value, maxValue) {
  if (!maxValue) {
    throw Error("getThreshold : the maxValue should be specified");
  }
  if (typeof value === "string") {
    let last = value[value.length - 1];
    if (last !== "%") {
      throw Error(
        "getThreshold : if the value is a string it must finish by %"
      );
    }
    return parseFloat(value) / 100 * maxValue;
  } else if (typeof value === "number") {
    if (value < 1) {
      return value * maxValue;
    }
    return value;
  } else {
    throw Error("getThreshold : the value is not valid");
  }
}
function factorDimensions(factor, width, height) {
  factor = getFactor(factor);
  let newWidth = Math.round(factor * width);
  let newHeight = Math.round(factor * height);
  if (newWidth <= 0) {
    newWidth = 1;
  }
  if (newHeight <= 0) {
    newHeight = 1;
  }
  return {
    width: newWidth,
    height: newHeight
  };
}

// node_modules/image-js/src/image/internal/checks.js
function checkRow(image, row) {
  if (row < 0 || row >= image.height) {
    throw new RangeError(
      `row must be included between 0 and ${image.height - 1}. Current value: ${row}`
    );
  }
}
function checkColumn(image, column) {
  if (column < 0 || column >= image.width) {
    throw new RangeError(
      `column must be included between 0 and ${image.width - 1}. Current value: ${column}`
    );
  }
}
function checkChannel(image, channel) {
  if (channel < 0 || channel >= image.channels) {
    throw new RangeError(
      `channel must be included between 0 and ${image.channels - 1}. Current value: ${channel}`
    );
  }
}
var validInterpolations = {
  nearestneighbor: "nearestNeighbor",
  nearestneighbour: "nearestNeighbor",
  bilinear: "bilinear"
};
function checkInterpolation(interpolation) {
  if (typeof interpolation !== "string") {
    throw new TypeError("interpolation must be a string");
  }
  interpolation = interpolation.toLowerCase();
  if (!validInterpolations[interpolation]) {
    throw new RangeError(`invalid interpolation algorithm: ${interpolation}`);
  }
  return validInterpolations[interpolation];
}

// node_modules/image-js/src/image/transform/resize/nearestNeighbor.js
function nearestNeighbor(newImage, newWidth, newHeight) {
  const wRatio = this.width / newWidth;
  const hRatio = this.height / newHeight;
  if (this.bitDepth > 1) {
    for (let i3 = 0; i3 < newWidth; i3++) {
      const w2 = Math.floor((i3 + 0.5) * wRatio);
      for (let j2 = 0; j2 < newHeight; j2++) {
        const h3 = Math.floor((j2 + 0.5) * hRatio);
        for (let c4 = 0; c4 < this.channels; c4++) {
          newImage.setValueXY(i3, j2, c4, this.getValueXY(w2, h3, c4));
        }
      }
    }
  } else {
    for (let i3 = 0; i3 < newWidth; i3++) {
      const w2 = Math.floor((i3 + 0.5) * wRatio);
      for (let j2 = 0; j2 < newHeight; j2++) {
        const h3 = Math.floor((j2 + 0.5) * hRatio);
        if (this.getBitXY(w2, h3)) {
          newImage.setBitXY(i3, j2);
        }
      }
    }
  }
}

// node_modules/image-js/src/image/transform/resize/resize.js
function resize(options = {}) {
  const {
    factor = 1,
    interpolation = validInterpolations.nearestneighbor,
    preserveAspectRatio = true
  } = options;
  const interpolationToUse = checkInterpolation(interpolation);
  let width = options.width;
  let height = options.height;
  if (!width) {
    if (height && preserveAspectRatio) {
      width = Math.round(height * (this.width / this.height));
    } else {
      width = this.width;
    }
  }
  if (!height) {
    if (preserveAspectRatio) {
      height = Math.round(width * (this.height / this.width));
    } else {
      height = this.height;
    }
  }
  ({ width, height } = factorDimensions(factor, width, height));
  if (width === this.width && height === this.height) {
    const newImage2 = this.clone();
    newImage2.position = [0, 0];
    return newImage2;
  }
  let shiftX = Math.round((this.width - width) / 2);
  let shiftY = Math.round((this.height - height) / 2);
  const newImage = Image2.createFrom(this, {
    width,
    height,
    position: [shiftX, shiftY]
  });
  switch (interpolationToUse) {
    case validInterpolations.nearestneighbor:
      nearestNeighbor.call(this, newImage, width, height);
      break;
    default:
      throw new Error(
        `unsupported resize interpolation: ${interpolationToUse}`
      );
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/hsv.js
function hsv() {
  this.checkProcessable("hsv", {
    bitDepth: [8, 16],
    alpha: [0, 1],
    colorModel: [RGB]
  });
  let newImage = Image2.createFrom(this, {
    colorModel: HSV
  });
  let ptr = 0;
  let data = this.data;
  for (let i3 = 0; i3 < data.length; i3 += this.channels) {
    let red = data[i3];
    let green = data[i3 + 1];
    let blue = data[i3 + 2];
    let min3 = Math.min(red, green, blue);
    let max4 = Math.max(red, green, blue);
    let delta = max4 - min3;
    let hue = 0;
    let saturation = max4 === 0 ? 0 : delta / max4;
    let value = max4;
    if (max4 !== min3) {
      switch (max4) {
        case red:
          hue = (green - blue) / delta + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / delta + 2;
          break;
        case blue:
          hue = (red - green) / delta + 4;
          break;
        default:
          throw new Error("unreachable");
      }
      hue /= 6;
    }
    newImage.data[ptr++] = hue * this.maxValue;
    newImage.data[ptr++] = saturation * this.maxValue;
    newImage.data[ptr++] = value;
    if (this.alpha) {
      newImage.data[ptr++] = data[i3 + 3];
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/hsl.js
function hsl() {
  this.checkProcessable("hsl", {
    bitDepth: [8, 16],
    alpha: [0, 1],
    colorModel: [RGB]
  });
  let newImage = Image2.createFrom(this, {
    colorModel: HSL
  });
  let threshold = Math.floor(this.maxValue / 2);
  let ptr = 0;
  let data = this.data;
  for (let i3 = 0; i3 < data.length; i3 += this.channels) {
    let red = data[i3];
    let green = data[i3 + 1];
    let blue = data[i3 + 2];
    let max4 = Math.max(red, green, blue);
    let min3 = Math.min(red, green, blue);
    let hue = 0;
    let saturation = 0;
    let luminance = (max4 + min3) / 2;
    if (max4 !== min3) {
      let delta = max4 - min3;
      saturation = luminance > threshold ? delta / (2 - max4 - min3) : delta / (max4 + min3);
      switch (max4) {
        case red:
          hue = (green - blue) / delta + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / delta + 2;
          break;
        case blue:
          hue = (red - green) / delta + 4;
          break;
        default:
          throw new Error("unreachable");
      }
      hue /= 6;
    }
    newImage.data[ptr++] = hue * this.maxValue;
    newImage.data[ptr++] = saturation * this.maxValue;
    newImage.data[ptr++] = luminance;
    if (this.alpha) {
      newImage.data[ptr++] = data[i3 + 3];
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/cmyk.js
function cmyk() {
  this.checkProcessable("cmyk", {
    bitDepth: [8, 16],
    alpha: [0, 1],
    colorModel: [RGB]
  });
  let newImage = Image2.createFrom(this, {
    components: 4,
    colorModel: CMYK
  });
  let ptr = 0;
  let data = this.data;
  for (let i3 = 0; i3 < data.length; i3 += this.channels) {
    let red = data[i3];
    let green = data[i3 + 1];
    let blue = data[i3 + 2];
    let black = Math.min(
      this.maxValue - red,
      this.maxValue - green,
      this.maxValue - blue
    );
    let cyan = (this.maxValue - red - black) / (1 - black / this.maxValue);
    let magenta = (this.maxValue - green - black) / (1 - black / this.maxValue);
    let yellow = (this.maxValue - blue - black) / (1 - black / this.maxValue);
    newImage.data[ptr++] = Math.round(cyan);
    newImage.data[ptr++] = Math.round(magenta);
    newImage.data[ptr++] = Math.round(yellow);
    newImage.data[ptr++] = Math.round(black);
    if (this.alpha) {
      newImage.data[ptr++] = data[i3 + 3];
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/rgba8.js
function rgba8() {
  return new Image2(this.width, this.height, this.getRGBAData(), {
    kind: "RGBA",
    parent: this
  });
}

// node_modules/image-js/src/image/transform/greyAlgorithms.js
var methods = {
  luma709(red, green, blue) {
    return red * 6966 + green * 23436 + blue * 2366 >> 15;
  },
  luma601(red, green, blue) {
    return red * 9798 + green * 19235 + blue * 3735 >> 15;
  },
  maximum(red, green, blue) {
    return Math.max(red, green, blue);
  },
  minimum(red, green, blue) {
    return Math.min(red, green, blue);
  },
  average(red, green, blue) {
    return (red + green + blue) / 3 >> 0;
  },
  minmax(red, green, blue) {
    return (Math.max(red, green, blue) + Math.min(red, green, blue)) / 2;
  },
  red(red) {
    return red;
  },
  green(red, green) {
    return green;
  },
  blue(red, green, blue) {
    return blue;
  },
  cyan(red, green, blue, image) {
    let black = methods.black(red, green, blue, image);
    return (image.maxValue - red - black) / (1 - black / image.maxValue) >> 0;
  },
  magenta(red, green, blue, image) {
    let black = methods.black(red, green, blue, image);
    return (image.maxValue - green - black) / (1 - black / image.maxValue) >> 0;
  },
  yellow(red, green, blue, image) {
    let black = methods.black(red, green, blue, image);
    return (image.maxValue - blue - black) / (1 - black / image.maxValue) >> 0;
  },
  black(red, green, blue, image) {
    return Math.min(
      image.maxValue - red,
      image.maxValue - green,
      image.maxValue - blue
    );
  },
  hue(red, green, blue, image) {
    let min3 = methods.min(red, green, blue);
    let max4 = methods.max(red, green, blue);
    if (max4 === min3) {
      return 0;
    }
    let hue = 0;
    let delta = max4 - min3;
    switch (max4) {
      case red:
        hue = (green - blue) / delta + (green < blue ? 6 : 0);
        break;
      case green:
        hue = (blue - red) / delta + 2;
        break;
      case blue:
        hue = (red - green) / delta + 4;
        break;
      default:
        throw new Error("unreachable");
    }
    return hue / 6 * image.maxValue >> 0;
  },
  saturation(red, green, blue, image) {
    let min3 = methods.min(red, green, blue);
    let max4 = methods.max(red, green, blue);
    let delta = max4 - min3;
    return max4 === 0 ? 0 : delta / max4 * image.maxValue;
  },
  lightness(red, green, blue) {
    let min3 = methods.min(red, green, blue);
    let max4 = methods.max(red, green, blue);
    return (max4 + min3) / 2;
  }
};
Object.defineProperty(methods, "luminosity", {
  enumerable: false,
  value: methods.lightness
});
Object.defineProperty(methods, "luminance", {
  enumerable: false,
  value: methods.lightness
});
Object.defineProperty(methods, "min", {
  enumerable: false,
  value: methods.minimum
});
Object.defineProperty(methods, "max", {
  enumerable: false,
  value: methods.maximum
});
Object.defineProperty(methods, "brightness", {
  enumerable: false,
  value: methods.maximum
});
var names = {};
Object.keys(methods).forEach((name) => {
  names[name] = name;
});

// node_modules/image-js/src/image/transform/grey.js
function grey(options = {}) {
  let { algorithm = "luma709", keepAlpha = false, mergeAlpha = true } = options;
  if (typeof algorithm !== "string" && typeof algorithm !== "function") {
    throw new TypeError("algorithm must be a string or a function");
  }
  this.checkProcessable("grey", {
    bitDepth: [8, 16],
    alpha: [0, 1]
  });
  if (this.components === 1) {
    algorithm = "red";
  }
  keepAlpha &= this.alpha;
  mergeAlpha &= this.alpha;
  if (keepAlpha) {
    mergeAlpha = false;
  }
  let newImage = getOutputImage(this, options, {
    components: 1,
    alpha: keepAlpha,
    colorModel: GREY
  });
  let method;
  if (typeof algorithm === "function") {
    method = algorithm;
  } else {
    method = methods[algorithm.toLowerCase()];
    if (!method) {
      throw new Error(`unsupported grey algorithm: ${algorithm}`);
    }
  }
  let ptr = 0;
  for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
    if (mergeAlpha) {
      newImage.data[ptr++] = clamp(
        method(this.data[i3], this.data[i3 + 1], this.data[i3 + 2], this) * this.data[i3 + this.components] / this.maxValue,
        this
      );
    } else {
      newImage.data[ptr++] = clamp(
        method(this.data[i3], this.data[i3 + 1], this.data[i3 + 2], this),
        this
      );
      if (newImage.alpha) {
        newImage.data[ptr++] = this.data[i3 + this.components];
      }
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/mask/huang.js
function huang(histogram2) {
  let firstBin = 0;
  for (let ih = 0; ih < histogram2.length; ih++) {
    if (histogram2[ih] !== 0) {
      firstBin = ih;
      break;
    }
  }
  let lastBin = histogram2.length - 1;
  for (let ih = histogram2.length - 1; ih >= firstBin; ih--) {
    if (histogram2[ih] !== 0) {
      lastBin = ih;
      break;
    }
  }
  let term = 1 / (lastBin - firstBin);
  let mu0 = new Array(histogram2.length);
  let sumPix = 0;
  let numPix = 0;
  for (let ih = firstBin; ih < histogram2.length; ih++) {
    sumPix += ih * histogram2[ih];
    numPix += histogram2[ih];
    mu0[ih] = sumPix / numPix;
  }
  let mu1 = new Array(histogram2.length);
  sumPix = numPix = 0;
  for (let ih = lastBin; ih > 0; ih--) {
    sumPix += ih * histogram2[ih];
    numPix += histogram2[ih];
    mu1[ih - 1] = sumPix / numPix;
  }
  let threshold = -1;
  let minEnt = Number.MAX_VALUE;
  for (let it2 = 0; it2 < histogram2.length; it2++) {
    let ent = 0;
    let muX;
    for (let ih = 0; ih <= it2; ih++) {
      muX = 1 / (1 + term * Math.abs(ih - mu0[it2]));
      if (!(muX < 1e-6 || muX > 0.999999)) {
        ent += histogram2[ih] * (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));
      }
    }
    for (let ih = it2 + 1; ih < histogram2.length; ih++) {
      muX = 1 / (1 + term * Math.abs(ih - mu1[it2]));
      if (!(muX < 1e-6 || muX > 0.999999)) {
        ent += histogram2[ih] * (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));
      }
    }
    if (ent < minEnt) {
      minEnt = ent;
      threshold = it2;
    }
  }
  return threshold;
}

// node_modules/image-js/src/image/transform/mask/intermodes.js
function intermodes(histogram2) {
  let iHisto = histogram2.slice();
  let iter = 0;
  while (!bimodalTest(iHisto)) {
    let previous = 0;
    let current = 0;
    let next = iHisto[0];
    for (let i3 = 0; i3 < histogram2.length - 1; i3++) {
      previous = current;
      current = next;
      next = iHisto[i3 + 1];
      iHisto[i3] = (previous + current + next) / 3;
    }
    iHisto[histogram2.length - 1] = (current + next) / 3;
    iter++;
    if (iter > 1e4) {
      throw new Error("Intermodes Threshold not found after 10000 iterations");
    }
  }
  let tt2 = 0;
  for (let i3 = 1; i3 < histogram2.length - 1; i3++) {
    if (iHisto[i3 - 1] < iHisto[i3] && iHisto[i3 + 1] < iHisto[i3]) {
      tt2 += i3;
    }
  }
  return Math.floor(tt2 / 2);
}
function bimodalTest(iHisto) {
  let b2 = false;
  let modes = 0;
  for (let k2 = 1; k2 < iHisto.length - 1; k2++) {
    if (iHisto[k2 - 1] < iHisto[k2] && iHisto[k2 + 1] < iHisto[k2]) {
      modes++;
      if (modes > 2) {
        return false;
      }
    }
  }
  if (modes === 2) {
    b2 = true;
  }
  return b2;
}

// node_modules/image-js/src/image/transform/mask/isodata.js
function isodata(histogram2) {
  let l3;
  let toth;
  let totl;
  let h3;
  let g2 = 0;
  for (let i3 = 1; i3 < histogram2.length; i3++) {
    if (histogram2[i3] > 0) {
      g2 = i3 + 1;
      break;
    }
  }
  while (true) {
    l3 = 0;
    totl = 0;
    for (let i3 = 0; i3 < g2; i3++) {
      totl = totl + histogram2[i3];
      l3 = l3 + histogram2[i3] * i3;
    }
    h3 = 0;
    toth = 0;
    for (let i3 = g2 + 1; i3 < histogram2.length; i3++) {
      toth += histogram2[i3];
      h3 += histogram2[i3] * i3;
    }
    if (totl > 0 && toth > 0) {
      l3 /= totl;
      h3 /= toth;
      if (g2 === Math.round((l3 + h3) / 2)) {
        break;
      }
    }
    g2++;
    if (g2 > histogram2.length - 2) {
      throw new Error("Threshold not found");
    }
  }
  return g2;
}

// node_modules/image-js/src/image/transform/mask/li.js
function li(histogram2, total) {
  let threshold;
  let sumBack;
  let sumObj;
  let numBack;
  let numObj;
  let oldThresh;
  let newThresh;
  let meanBack;
  let meanObj;
  let mean4;
  let tolerance;
  let temp;
  tolerance = 0.5;
  mean4 = 0;
  for (let ih = 0; ih < histogram2.length; ih++) {
    mean4 += ih * histogram2[ih];
  }
  mean4 /= total;
  newThresh = mean4;
  do {
    oldThresh = newThresh;
    threshold = oldThresh + 0.5 | 0;
    sumBack = 0;
    numBack = 0;
    for (let ih = 0; ih <= threshold; ih++) {
      sumBack += ih * histogram2[ih];
      numBack += histogram2[ih];
    }
    meanBack = numBack === 0 ? 0 : sumBack / numBack;
    sumObj = 0;
    numObj = 0;
    for (let ih = threshold + 1; ih < histogram2.length; ih++) {
      sumObj += ih * histogram2[ih];
      numObj += histogram2[ih];
    }
    meanObj = numObj === 0 ? 0 : sumObj / numObj;
    temp = (meanBack - meanObj) / (Math.log(meanBack) - Math.log(meanObj));
    if (temp < -Number.EPSILON) {
      newThresh = temp - 0.5 | 0;
    } else {
      newThresh = temp + 0.5 | 0;
    }
  } while (Math.abs(newThresh - oldThresh) > tolerance);
  return threshold;
}

// node_modules/image-js/src/image/transform/mask/maxEntropy.js
function maxEntropy(histogram2, total) {
  let normHisto = new Array(histogram2.length);
  for (let ih = 0; ih < histogram2.length; ih++) {
    normHisto[ih] = histogram2[ih] / total;
  }
  let P1 = new Array(histogram2.length);
  let P2 = new Array(histogram2.length);
  P1[0] = normHisto[0];
  P2[0] = 1 - P1[0];
  for (let ih = 1; ih < histogram2.length; ih++) {
    P1[ih] = P1[ih - 1] + normHisto[ih];
    P2[ih] = 1 - P1[ih];
  }
  let firstBin = 0;
  for (let ih = 0; ih < histogram2.length; ih++) {
    if (Math.abs(P1[ih]) >= Number.EPSILON) {
      firstBin = ih;
      break;
    }
  }
  let lastBin = histogram2.length - 1;
  for (let ih = histogram2.length - 1; ih >= firstBin; ih--) {
    if (Math.abs(P2[ih]) >= Number.EPSILON) {
      lastBin = ih;
      break;
    }
  }
  let threshold = -1;
  let totEnt;
  let maxEnt = Number.MIN_VALUE;
  let entBack;
  let entObj;
  for (let it2 = firstBin; it2 <= lastBin; it2++) {
    entBack = 0;
    for (let ih = 0; ih <= it2; ih++) {
      if (histogram2[ih] !== 0) {
        entBack -= normHisto[ih] / P1[it2] * Math.log(normHisto[ih] / P1[it2]);
      }
    }
    entObj = 0;
    for (let ih = it2 + 1; ih < histogram2.length; ih++) {
      if (histogram2[ih] !== 0) {
        entObj -= normHisto[ih] / P2[it2] * Math.log(normHisto[ih] / P2[it2]);
      }
    }
    totEnt = entBack + entObj;
    if (maxEnt < totEnt) {
      maxEnt = totEnt;
      threshold = it2;
    }
  }
  return threshold;
}

// node_modules/image-js/src/image/transform/mask/mean.js
function mean2(histogram2, total) {
  let sum2 = 0;
  for (let i3 = 0; i3 < histogram2.length; i3++) {
    sum2 += i3 * histogram2[i3];
  }
  return Math.floor(sum2 / total);
}

// node_modules/image-js/src/image/transform/mask/minError.js
function minError(histogram2, total) {
  let threshold;
  let Tprev = -2;
  let mu, nu, p3, q2, sigma2, tau2, w0, w1, w2, sqterm, temp;
  let mean4 = 0;
  for (let ih = 0; ih < histogram2.length; ih++) {
    mean4 += ih * histogram2[ih];
  }
  mean4 /= total;
  threshold = mean4;
  while (threshold !== Tprev) {
    let sumA1 = sumA(histogram2, threshold);
    let sumA2 = sumA(histogram2, histogram2.length - 1);
    let sumB1 = sumB(histogram2, threshold);
    let sumB2 = sumB(histogram2, histogram2.length - 1);
    let sumC1 = sumC(histogram2, threshold);
    let sumC2 = sumC(histogram2, histogram2.length - 1);
    mu = sumB1 / sumA1;
    nu = (sumB2 - sumB1) / (sumA2 - sumA1);
    p3 = sumA1 / sumA2;
    q2 = (sumA2 - sumA1) / sumA2;
    sigma2 = sumC1 / sumA1 - mu * mu;
    tau2 = (sumC2 - sumC1) / (sumA2 - sumA1) - nu * nu;
    w0 = 1 / sigma2 - 1 / tau2;
    w1 = mu / sigma2 - nu / tau2;
    w2 = mu * mu / sigma2 - nu * nu / tau2 + Math.log10(sigma2 * (q2 * q2) / (tau2 * (p3 * p3)));
    sqterm = w1 * w1 - w0 * w2;
    if (sqterm < 0) {
      return threshold;
    }
    Tprev = threshold;
    temp = (w1 + Math.sqrt(sqterm)) / w0;
    if (isNaN(temp)) {
      threshold = Tprev;
    } else {
      threshold = Math.floor(temp);
    }
  }
  return threshold;
}
function sumA(y3, j2) {
  let x2 = 0;
  for (let i3 = 0; i3 <= j2; i3++) {
    x2 += y3[i3];
  }
  return x2;
}
function sumB(y3, j2) {
  let x2 = 0;
  for (let i3 = 0; i3 <= j2; i3++) {
    x2 += i3 * y3[i3];
  }
  return x2;
}
function sumC(y3, j2) {
  let x2 = 0;
  for (let i3 = 0; i3 <= j2; i3++) {
    x2 += i3 * i3 * y3[i3];
  }
  return x2;
}

// node_modules/image-js/src/image/transform/mask/minimum.js
function minimum(histogram2) {
  if (histogram2.length < 2) {
    return 0;
  }
  let iterations = 0;
  let threshold = -1;
  let max4 = -1;
  let histogramCopy = new Array(histogram2.length);
  for (let i3 = 0; i3 < histogram2.length; i3++) {
    histogramCopy[i3] = histogram2[i3];
    if (histogram2[i3] > 0) {
      max4 = i3;
    }
  }
  while (!bimodalTest2(histogramCopy)) {
    histogramCopy = smoothed(histogramCopy);
    iterations++;
    if (iterations > 1e4) {
      return threshold;
    }
  }
  threshold = minimumBetweenPeeks(histogramCopy, max4);
  return threshold;
}
function smoothed(histogram2) {
  let auHistogram = new Array(histogram2.length);
  for (let i3 = 1; i3 < histogram2.length - 1; i3++) {
    auHistogram[i3] = (histogram2[i3 - 1] + histogram2[i3] + histogram2[i3 + 1]) / 3;
  }
  auHistogram[0] = (histogram2[0] + histogram2[1]) / 3;
  auHistogram[histogram2.length - 1] = (histogram2[histogram2.length - 2] + histogram2[histogram2.length - 1]) / 3;
  return auHistogram;
}
function minimumBetweenPeeks(histogramBimodal, max4) {
  let threshold;
  for (let i3 = 1; i3 < max4; i3++) {
    if (histogramBimodal[i3 - 1] > histogramBimodal[i3] && histogramBimodal[i3 + 1] >= histogramBimodal[i3]) {
      threshold = i3;
      break;
    }
  }
  return threshold;
}
function bimodalTest2(histogram2) {
  let len = histogram2.length;
  let isBimodal = false;
  let peaks = 0;
  for (let k2 = 1; k2 < len - 1; k2++) {
    if (histogram2[k2 - 1] < histogram2[k2] && histogram2[k2 + 1] < histogram2[k2]) {
      peaks++;
      if (peaks > 2) {
        return false;
      }
    }
  }
  if (peaks === 2) {
    isBimodal = true;
  }
  return isBimodal;
}

// node_modules/image-js/src/image/transform/mask/moments.js
function moments(histogram2, total) {
  let m0 = 1;
  let m1 = 0;
  let m22 = 0;
  let m32 = 0;
  let sum2 = 0;
  let p0;
  let cd, c0, c1, z0, z1;
  let threshold = -1;
  let histogramLength = histogram2.length;
  let normalizedHistogram = new Array(histogramLength);
  for (let i3 = 0; i3 < histogramLength; i3++) {
    normalizedHistogram[i3] = histogram2[i3] / total;
  }
  for (let i3 = 0; i3 < histogramLength; i3++) {
    m1 += i3 * normalizedHistogram[i3];
    m22 += i3 * i3 * normalizedHistogram[i3];
    m32 += i3 * i3 * i3 * normalizedHistogram[i3];
  }
  cd = m0 * m22 - m1 * m1;
  c0 = (-m22 * m22 + m1 * m32) / cd;
  c1 = (m0 * -m32 + m22 * m1) / cd;
  z0 = 0.5 * (-c1 - Math.sqrt(c1 * c1 - 4 * c0));
  z1 = 0.5 * (-c1 + Math.sqrt(c1 * c1 - 4 * c0));
  p0 = (z1 - m1) / (z1 - z0);
  for (let i3 = 0; i3 < histogramLength; i3++) {
    sum2 += normalizedHistogram[i3];
    if (sum2 > p0) {
      threshold = i3;
      break;
    }
  }
  return threshold;
}

// node_modules/image-js/src/image/transform/mask/otsu.js
function otsu(histogramCounts, total) {
  let sumB2 = 0;
  let wB = 0;
  let maximum = 0;
  let level2 = 0;
  let sum1 = 0;
  for (let i3 = 0; i3 < histogramCounts.length; i3++) {
    sum1 += i3 * histogramCounts[i3];
  }
  for (let ii = 0; ii < histogramCounts.length; ii++) {
    wB = wB + histogramCounts[ii];
    const wF = total - wB;
    if (wB === 0 || wF === 0) {
      continue;
    }
    sumB2 = sumB2 + ii * histogramCounts[ii];
    const mF = (sum1 - sumB2) / wF;
    const between = wB * wF * (sumB2 / wB - mF) * (sumB2 / wB - mF);
    if (between >= maximum) {
      level2 = ii;
      maximum = between;
    }
  }
  return level2;
}

// node_modules/image-js/src/image/transform/mask/percentile.js
function percentile(histogram2) {
  let threshold = -1;
  let percentile2 = 0.5;
  let avec = new Array(histogram2.length);
  let total = partialSum(histogram2, histogram2.length - 1);
  let temp = 1;
  for (let i3 = 0; i3 < histogram2.length; i3++) {
    avec[i3] = Math.abs(partialSum(histogram2, i3) / total - percentile2);
    if (avec[i3] < temp) {
      temp = avec[i3];
      threshold = i3;
    }
  }
  return threshold;
}
function partialSum(histogram2, endIndex) {
  let x2 = 0;
  for (let i3 = 0; i3 <= endIndex; i3++) {
    x2 += histogram2[i3];
  }
  return x2;
}

// node_modules/image-js/src/image/transform/mask/renyiEntropy.js
function renyiEntropy(histogram2, total) {
  let optThreshold;
  let firstBin;
  let lastBin;
  let normHisto = new Array(histogram2.length);
  let P1 = new Array(histogram2.length);
  let P2 = new Array(histogram2.length);
  let threshold1 = 0;
  let threshold2 = 0;
  let threshold3 = 0;
  let maxEnt1 = 0;
  let maxEnt2 = 0;
  let maxEnt3 = 0;
  let alpha2 = 0.5;
  let term2 = 1 / (1 - alpha2);
  let alpha3 = 2;
  let term3 = 1 / (1 - alpha3);
  for (let ih = 0; ih < histogram2.length; ih++) {
    normHisto[ih] = histogram2[ih] / total;
  }
  P1[0] = normHisto[0];
  P2[0] = 1 - P1[0];
  for (let ih = 1; ih < histogram2.length; ih++) {
    P1[ih] = P1[ih - 1] + normHisto[ih];
    P2[ih] = 1 - P1[ih];
  }
  firstBin = 0;
  for (let ih = 0; ih < histogram2.length; ih++) {
    if (Math.abs(P1[ih]) >= Number.EPSILON) {
      firstBin = ih;
      break;
    }
  }
  lastBin = histogram2.length - 1;
  for (let ih = histogram2.length - 1; ih >= firstBin; ih--) {
    if (Math.abs(P2[ih]) >= Number.EPSILON) {
      lastBin = ih;
      break;
    }
  }
  for (let it2 = firstBin; it2 <= lastBin; it2++) {
    let entBack1 = 0;
    let entBack2 = 0;
    let entBack3 = 0;
    for (let ih = 0; ih <= it2; ih++) {
      if (histogram2[ih] !== 0) {
        entBack1 -= normHisto[ih] / P1[it2] * Math.log(normHisto[ih] / P1[it2]);
      }
      entBack2 += Math.sqrt(normHisto[ih] / P1[it2]);
      entBack3 += normHisto[ih] * normHisto[ih] / (P1[it2] * P1[it2]);
    }
    let entObj1 = 0;
    let entObj2 = 0;
    let entObj3 = 0;
    for (let ih = it2 + 1; ih < histogram2.length; ih++) {
      if (histogram2[ih] !== 0) {
        entObj1 -= normHisto[ih] / P2[it2] * Math.log(normHisto[ih] / P2[it2]);
      }
      entObj2 += Math.sqrt(normHisto[ih] / P2[it2]);
      entObj3 += normHisto[ih] * normHisto[ih] / (P2[it2] * P2[it2]);
    }
    let totEnt1 = entBack1 + entObj1;
    let totEnt2 = term2 * (entBack2 * entObj2 > 0 ? Math.log(entBack2 * entObj2) : 0);
    let totEnt3 = term3 * (entBack3 * entObj3 > 0 ? Math.log(entBack3 * entObj3) : 0);
    if (totEnt1 > maxEnt1) {
      maxEnt1 = totEnt1;
      threshold1 = it2;
    }
    if (totEnt2 > maxEnt2) {
      maxEnt2 = totEnt2;
      threshold2 = it2;
    }
    if (totEnt3 > maxEnt3) {
      maxEnt3 = totEnt3;
      threshold3 = it2;
    }
  }
  let tStars = [threshold1, threshold2, threshold3];
  tStars.sort((a3, b2) => a3 - b2);
  let betas;
  if (Math.abs(tStars[0] - tStars[1]) <= 5) {
    if (Math.abs(tStars[1] - tStars[2]) <= 5) {
      betas = [1, 2, 1];
    } else {
      betas = [0, 1, 3];
    }
  } else {
    if (Math.abs(tStars[1] - tStars[2]) <= 5) {
      betas = [3, 1, 0];
    } else {
      betas = [1, 2, 1];
    }
  }
  let omega = P1[tStars[2]] - P1[tStars[0]];
  optThreshold = Math.round(
    tStars[0] * (P1[tStars[0]] + 0.25 * omega * betas[0]) + 0.25 * tStars[1] * omega * betas[1] + tStars[2] * (P2[tStars[2]] + 0.25 * omega * betas[2])
  );
  return optThreshold;
}

// node_modules/image-js/src/image/transform/mask/shanbhag.js
function shanbhag(histogram2, total) {
  let normHisto = new Array(histogram2.length);
  for (let ih = 0; ih < histogram2.length; ih++) {
    normHisto[ih] = histogram2[ih] / total;
  }
  let P1 = new Array(histogram2.length);
  let P2 = new Array(histogram2.length);
  P1[0] = normHisto[0];
  P2[0] = 1 - P1[0];
  for (let ih = 1; ih < histogram2.length; ih++) {
    P1[ih] = P1[ih - 1] + normHisto[ih];
    P2[ih] = 1 - P1[ih];
  }
  let firstBin = 0;
  for (let ih = 0; ih < histogram2.length; ih++) {
    if (Math.abs(P1[ih]) >= Number.EPSILON) {
      firstBin = ih;
      break;
    }
  }
  let lastBin = histogram2.length - 1;
  for (let ih = histogram2.length - 1; ih >= firstBin; ih--) {
    if (Math.abs(P2[ih]) >= Number.EPSILON) {
      lastBin = ih;
      break;
    }
  }
  let threshold = -1;
  let minEnt = Number.MAX_VALUE;
  let term;
  let totEnt;
  let entBack;
  let entObj;
  for (let it2 = firstBin; it2 <= lastBin; it2++) {
    entBack = 0;
    term = 0.5 / P1[it2];
    for (let ih = 1; ih <= it2; ih++) {
      entBack -= normHisto[ih] * Math.log(1 - term * P1[ih - 1]);
    }
    entBack *= term;
    entObj = 0;
    term = 0.5 / P2[it2];
    for (let ih = it2 + 1; ih < histogram2.length; ih++) {
      entObj -= normHisto[ih] * Math.log(1 - term * P2[ih]);
    }
    entObj *= term;
    totEnt = Math.abs(entBack - entObj);
    if (totEnt < minEnt) {
      minEnt = totEnt;
      threshold = it2;
    }
  }
  return threshold;
}

// node_modules/image-js/src/image/transform/mask/triangle.js
function triangle(histogram2) {
  let min3 = 0;
  let dmax = 0;
  let max4 = 0;
  let min22 = 0;
  for (let i3 = 0; i3 < histogram2.length; i3++) {
    if (histogram2[i3] > 0) {
      min3 = i3;
      break;
    }
  }
  if (min3 > 0) {
    min3--;
  }
  for (let i3 = histogram2.length - 1; i3 > 0; i3--) {
    if (histogram2[i3] > 0) {
      min22 = i3;
      break;
    }
  }
  if (min22 < histogram2.length - 1) {
    min22++;
  }
  for (let i3 = 0; i3 < histogram2.length; i3++) {
    if (histogram2[i3] > dmax) {
      max4 = i3;
      dmax = histogram2[i3];
    }
  }
  let inverted = false;
  if (max4 - min3 < min22 - max4) {
    inverted = true;
    let left = 0;
    let right = histogram2.length - 1;
    while (left < right) {
      let temp = histogram2[left];
      histogram2[left] = histogram2[right];
      histogram2[right] = temp;
      left++;
      right--;
    }
    min3 = histogram2.length - 1 - min22;
    max4 = histogram2.length - 1 - max4;
  }
  if (min3 === max4) {
    return min3;
  }
  let nx, ny, d2;
  nx = histogram2[max4];
  ny = min3 - max4;
  d2 = Math.sqrt(nx * nx + ny * ny);
  nx /= d2;
  ny /= d2;
  d2 = nx * min3 + ny * histogram2[min3];
  let split2 = min3;
  let splitDistance = 0;
  for (let i3 = min3 + 1; i3 <= max4; i3++) {
    let newDistance = nx * i3 + ny * histogram2[i3] - d2;
    if (newDistance > splitDistance) {
      split2 = i3;
      splitDistance = newDistance;
    }
  }
  split2--;
  if (inverted) {
    let left = 0;
    let right = histogram2.length - 1;
    while (left < right) {
      let temp = histogram2[left];
      histogram2[left] = histogram2[right];
      histogram2[right] = temp;
      left++;
      right--;
    }
    return histogram2.length - 1 - split2;
  } else {
    return split2;
  }
}

// node_modules/image-js/src/image/transform/mask/yen.js
function yen(histogram2, total) {
  let normHisto = new Array(histogram2.length);
  for (let ih = 0; ih < histogram2.length; ih++) {
    normHisto[ih] = histogram2[ih] / total;
  }
  let P1 = new Array(histogram2.length);
  P1[0] = normHisto[0];
  for (let ih = 1; ih < histogram2.length; ih++) {
    P1[ih] = P1[ih - 1] + normHisto[ih];
  }
  let P1Sq = new Array(histogram2.length);
  P1Sq[0] = normHisto[0] * normHisto[0];
  for (let ih = 1; ih < histogram2.length; ih++) {
    P1Sq[ih] = P1Sq[ih - 1] + normHisto[ih] * normHisto[ih];
  }
  let P2Sq = new Array(histogram2.length);
  P2Sq[histogram2.length - 1] = 0;
  for (let ih = histogram2.length - 2; ih >= 0; ih--) {
    P2Sq[ih] = P2Sq[ih + 1] + normHisto[ih + 1] * normHisto[ih + 1];
  }
  let threshold = -1;
  let maxCrit = Number.MIN_VALUE;
  let crit;
  for (let it2 = 0; it2 < histogram2.length; it2++) {
    crit = -1 * (P1Sq[it2] * P2Sq[it2] > 0 ? Math.log(P1Sq[it2] * P2Sq[it2]) : 0) + 2 * (P1[it2] * (1 - P1[it2]) > 0 ? Math.log(P1[it2] * (1 - P1[it2])) : 0);
    if (crit > maxCrit) {
      maxCrit = crit;
      threshold = it2;
    }
  }
  return threshold;
}

// node_modules/image-js/src/image/transform/mask/thresholdAlgorithms.js
var methods2 = {
  huang,
  intermodes,
  isodata,
  li,
  maxentropy: maxEntropy,
  mean: mean2,
  minerror: minError,
  minimum,
  moments,
  otsu,
  percentile,
  renyientropy: renyiEntropy,
  shanbhag,
  triangle,
  yen
};
var names2 = {};
Object.keys(methods2).forEach((name) => {
  names2[name] = name;
});

// node_modules/image-js/src/image/utility/getThreshold.js
function getThreshold2(options = {}) {
  let { algorithm = names2.otsu } = options;
  this.checkProcessable("getThreshold", {
    components: 1,
    bitDepth: [8, 16]
  });
  let method = methods2[algorithm.toLowerCase()];
  if (method) {
    let histogram2 = this.getHistogram();
    return method(histogram2, this.size);
  } else {
    throw new Error(`unknown thresholding algorithm: ${algorithm}`);
  }
}

// node_modules/image-js/src/image/transform/mask/mask.js
var THRESHOLD = "threshold";
function mask(options = {}) {
  let {
    algorithm = THRESHOLD,
    threshold = 0.5,
    useAlpha = true,
    invert: invert2 = false
  } = options;
  this.checkProcessable("mask", {
    components: 1,
    bitDepth: [8, 16]
  });
  if (algorithm === THRESHOLD) {
    threshold = getThreshold(threshold, this.maxValue);
  } else {
    threshold = getThreshold2.call(this, options);
  }
  let newImage = new Image2(this.width, this.height, {
    kind: "BINARY",
    parent: this
  });
  let ptr = 0;
  if (this.alpha && useAlpha) {
    for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
      let value = this.data[i3] + (this.maxValue - this.data[i3]) * (this.maxValue - this.data[i3 + 1]) / this.maxValue;
      if (invert2 && value <= threshold || !invert2 && value >= threshold) {
        newImage.setBit(ptr);
      }
      ptr++;
    }
  } else {
    for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
      if (invert2 && this.data[i3] <= threshold || !invert2 && this.data[i3] >= threshold) {
        newImage.setBit(ptr);
      }
      ptr++;
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/pad.js
var import_new_array2 = __toESM(require_new_array());

// node_modules/image-js/src/image/internal/copy.js
function copyImage(fromImage, toImage2, x2, y3) {
  let fromWidth = fromImage.width;
  let fromHeight = fromImage.height;
  let toWidth = toImage2.width;
  let channels = fromImage.channels;
  for (let i3 = 0; i3 < fromWidth; i3++) {
    for (let j2 = 0; j2 < fromHeight; j2++) {
      for (let k2 = 0; k2 < channels; k2++) {
        let source = (j2 * fromWidth + i3) * channels + k2;
        let target = ((y3 + j2) * toWidth + x2 + i3) * channels + k2;
        toImage2.data[target] = fromImage.data[source];
      }
    }
  }
}

// node_modules/image-js/src/image/transform/pad.js
function pad(options = {}) {
  let { size = 0, algorithm = "copy", color } = options;
  this.checkProcessable("pad", {
    bitDepth: [8, 16]
  });
  if (algorithm === "set") {
    if (color.length !== this.channels) {
      throw new Error(
        `pad: the color array must have the same length as the number of channels. Here: ${this.channels}`
      );
    }
    for (let i3 = 0; i3 < color.length; i3++) {
      if (color[i3] === 0) {
        color[i3] = 1e-3;
      }
    }
  } else {
    color = (0, import_new_array2.default)(this.channels, null);
  }
  if (!Array.isArray(size)) {
    size = [size, size];
  }
  let newWidth = this.width + size[0] * 2;
  let newHeight = this.height + size[1] * 2;
  let channels = this.channels;
  let newImage = Image2.createFrom(this, { width: newWidth, height: newHeight });
  copyImage(this, newImage, size[0], size[1]);
  for (let i3 = size[0]; i3 < newWidth - size[0]; i3++) {
    for (let k2 = 0; k2 < channels; k2++) {
      let value = color[k2] || newImage.data[(size[1] * newWidth + i3) * channels + k2];
      for (let j2 = 0; j2 < size[1]; j2++) {
        newImage.data[(j2 * newWidth + i3) * channels + k2] = value;
      }
      value = color[k2] || newImage.data[((newHeight - size[1] - 1) * newWidth + i3) * channels + k2];
      for (let j2 = newHeight - size[1]; j2 < newHeight; j2++) {
        newImage.data[(j2 * newWidth + i3) * channels + k2] = value;
      }
    }
  }
  for (let j2 = 0; j2 < newHeight; j2++) {
    for (let k2 = 0; k2 < channels; k2++) {
      let value = color[k2] || newImage.data[(j2 * newWidth + size[0]) * channels + k2];
      for (let i3 = 0; i3 < size[0]; i3++) {
        newImage.data[(j2 * newWidth + i3) * channels + k2] = value;
      }
      value = color[k2] || newImage.data[(j2 * newWidth + newWidth - size[0] - 1) * channels + k2];
      for (let i3 = newWidth - size[0]; i3 < newWidth; i3++) {
        newImage.data[(j2 * newWidth + i3) * channels + k2] = value;
      }
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/colorDepth.js
function colorDepth(newColorDepth = 8) {
  this.checkProcessable("colorDepth", {
    bitDepth: [1, 8, 16]
  });
  if (![8, 16].includes(newColorDepth)) {
    throw Error("You need to specify the new colorDepth as 8 or 16");
  }
  if (this.bitDepth === newColorDepth) {
    return this.clone();
  }
  let newImage = Image2.createFrom(this, { bitDepth: newColorDepth });
  switch (newColorDepth) {
    case 8:
      if (this.bitDepth === 1) {
        for (let i3 = 0; i3 < this.size; i3++) {
          if (this.getBit(i3)) {
            newImage.data[i3] = 255;
          }
        }
      } else {
        for (let i3 = 0; i3 < this.data.length; i3++) {
          newImage.data[i3] = this.data[i3] >> 8;
        }
      }
      break;
    case 16:
      if (this.bitDepth === 1) {
        for (let i3 = 0; i3 < this.size; i3++) {
          if (this.getBit(i3)) {
            newImage.data[i3] = 65535;
          }
        }
      } else {
        for (let i3 = 0; i3 < this.data.length; i3++) {
          newImage.data[i3] = this.data[i3] << 8 | this.data[i3];
        }
      }
      break;
    default:
      throw new Error("colorDepth conversion unexpected case");
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/rotateFree.js
function rotateFree(degrees, options = {}) {
  const {
    interpolation = validInterpolations.nearestneighbor,
    width = this.width,
    height = this.height
  } = options;
  if (typeof degrees !== "number") {
    throw new TypeError("degrees must be a number");
  }
  const interpolationToUse = (0, checkInterpolation)(interpolation);
  const radians = degrees * Math.PI / 180;
  const newWidth = Math.floor(
    Math.abs(width * Math.cos(radians)) + Math.abs(height * Math.sin(radians))
  );
  const newHeight = Math.floor(
    Math.abs(height * Math.cos(radians)) + Math.abs(width * Math.sin(radians))
  );
  const cos = Math.cos(-radians);
  const sin = Math.sin(-radians);
  let x0 = newWidth / 2;
  let y0 = newHeight / 2;
  if (newWidth % 2 === 0) {
    x0 = x0 - 0.5;
    if (newHeight % 2 === 0) {
      y0 = y0 - 0.5;
    } else {
      y0 = Math.floor(y0);
    }
  } else {
    x0 = Math.floor(x0);
    if (newHeight % 2 === 0) {
      y0 = y0 - 0.5;
    } else {
      y0 = Math.floor(y0);
    }
  }
  const incrementX = Math.floor(width / 2 - x0);
  const incrementY = Math.floor(height / 2 - y0);
  if (this.bitDepth === 1) {
    const newImage = new Image2(newWidth, newHeight, {
      kind: "BINARY",
      parent: this
    });
    switch (interpolationToUse) {
      case validInterpolations.nearestneighbor:
        return rotateBinaryNearestNeighbor(
          this,
          newImage,
          incrementX,
          incrementY,
          x0,
          y0,
          cos,
          sin
        );
      case validInterpolations.bilinear:
        return rotateBinaryBilinear(
          this,
          newImage,
          incrementX,
          incrementY,
          x0,
          y0,
          cos,
          sin
        );
      default:
        throw new Error(
          `unsupported rotate interpolation: ${interpolationToUse}`
        );
    }
  } else {
    const newImage = Image2.createFrom(this, {
      width: newWidth,
      height: newHeight
    });
    switch (interpolationToUse) {
      case validInterpolations.nearestneighbor:
        return rotateNearestNeighbor(
          this,
          newImage,
          incrementX,
          incrementY,
          x0,
          y0,
          cos,
          sin
        );
      case validInterpolations.bilinear:
        return rotateBilinear(
          this,
          newImage,
          incrementX,
          incrementY,
          x0,
          y0,
          cos,
          sin
        );
      default:
        throw new Error(
          `unsupported rotate interpolation: ${interpolationToUse}`
        );
    }
  }
}
function rotateNearestNeighbor(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {
  for (let i3 = 0; i3 < newImage.width; i3 += 1) {
    for (let j2 = 0; j2 < newImage.height; j2 += 1) {
      for (let c4 = 0; c4 < thisImage.channels; c4++) {
        let x2 = Math.round((i3 - x0) * cos - (j2 - y0) * sin + x0) + incrementX;
        let y3 = Math.round((j2 - y0) * cos + (i3 - x0) * sin + y0) + incrementY;
        if (x2 < 0 || x2 >= thisImage.width || y3 < 0 || y3 >= thisImage.height) {
          if (thisImage.alpha === 1 && c4 === thisImage.channels - 1) {
            newImage.setValueXY(i3, j2, c4, 0);
          } else {
            newImage.setValueXY(i3, j2, c4, thisImage.maxValue);
          }
        } else {
          newImage.setValueXY(i3, j2, c4, thisImage.getValueXY(x2, y3, c4));
        }
      }
    }
  }
  return newImage;
}
function rotateBinaryNearestNeighbor(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {
  for (let i3 = 0; i3 < newImage.width; i3 += 1) {
    for (let j2 = 0; j2 < newImage.height; j2 += 1) {
      let x2 = Math.round((i3 - x0) * cos - (j2 - y0) * sin + x0) + incrementX;
      let y3 = Math.round((j2 - y0) * cos + (i3 - x0) * sin + y0) + incrementY;
      if (x2 < 0 || x2 >= thisImage.width || y3 < 0 || y3 >= thisImage.height || thisImage.getBitXY(x2, y3)) {
        newImage.setBitXY(i3, j2);
      }
    }
  }
  return newImage;
}
function rotateBilinear(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {
  let stride = thisImage.width * thisImage.channels;
  for (let j2 = 0; j2 < newImage.height; j2++) {
    for (let i3 = 0; i3 < newImage.width; i3++) {
      let x2 = (i3 - x0) * cos - (j2 - y0) * sin + x0 + incrementX;
      let y3 = (j2 - y0) * cos + (i3 - x0) * sin + y0 + incrementY;
      let x1 = x2 | 0;
      let y1 = y3 | 0;
      let xDiff = x2 - x1;
      let yDiff = y3 - y1;
      for (let c4 = 0; c4 < thisImage.channels; c4++) {
        if (x2 < 0 || x2 >= thisImage.width || y3 < 0 || y3 >= thisImage.height) {
          if (thisImage.alpha === 1 && c4 === thisImage.channels - 1) {
            newImage.setValueXY(i3, j2, c4, 0);
          } else {
            newImage.setValueXY(i3, j2, c4, thisImage.maxValue);
          }
        } else {
          let index2 = (y1 * thisImage.width + x1) * thisImage.channels + c4;
          let A2 = thisImage.data[index2];
          let B2 = thisImage.data[index2 + thisImage.channels];
          let C2 = thisImage.data[index2 + stride];
          let D2 = thisImage.data[index2 + stride + thisImage.channels];
          let result = A2 + xDiff * (B2 - A2) + yDiff * (C2 - A2) + xDiff * yDiff * (A2 - B2 - C2 + D2) | 0;
          newImage.setValueXY(i3, j2, c4, result);
        }
      }
    }
  }
  return newImage;
}
function rotateBinaryBilinear(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {
  let stride = thisImage.width;
  for (let j2 = 0; j2 < newImage.height; j2++) {
    for (let i3 = 0; i3 < newImage.width; i3++) {
      let x2 = (i3 - x0) * cos - (j2 - y0) * sin + x0 + incrementX;
      let y3 = (j2 - y0) * cos + (i3 - x0) * sin + y0 + incrementY;
      let x1 = x2 | 0;
      let y1 = y3 | 0;
      let xDiff = x2 - x1;
      let yDiff = y3 - y1;
      if (x2 < 0 || x2 >= thisImage.width || y3 < 0 || y3 >= thisImage.height) {
        newImage.setBitXY(i3, j2);
      } else {
        let index2 = y1 * thisImage.width + x1;
        let A2 = thisImage.getBit(index2);
        let B2 = thisImage.getBit(index2 + 1);
        let C2 = thisImage.getBit(index2 + stride);
        let D2 = thisImage.getBit(index2 + 1 + stride);
        let result = A2 | xDiff & B2 - A2 | yDiff & C2 - A2 | xDiff & yDiff & A2 - B2 - C2 + D2;
        if (result > 0)
          newImage.setBitXY(i3, j2);
      }
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/transform/rotate.js
function rotate(angle, options) {
  this.checkProcessable("rotate", {
    bitDepth: [1, 8, 16]
  });
  if (typeof angle !== "number") {
    throw new TypeError("angle must be a number");
  }
  if (angle < 0) {
    angle = Math.ceil(-angle / 360) * 360 + angle;
  }
  switch (angle % 360) {
    case 0:
      return this.clone();
    case 90:
      return rotateRight.call(this);
    case 180:
      return rotate180.call(this);
    case 270:
      return rotateLeft.call(this);
    default:
      return rotateFree.call(this, angle, options);
  }
}
function rotateLeft() {
  if (this.bitDepth === 1) {
    const newImage = new Image2(this.height, this.width, {
      kind: "BINARY",
      parent: this
    });
    const newMaxHeight = newImage.height - 1;
    for (let i3 = 0; i3 < this.height; i3++) {
      for (let j2 = 0; j2 < this.width; j2++) {
        if (this.getBitXY(j2, i3)) {
          newImage.setBitXY(i3, newMaxHeight - j2);
        }
      }
    }
    return newImage;
  } else {
    const newImage = Image2.createFrom(this, {
      width: this.height,
      height: this.width
    });
    const newMaxHeight = newImage.height - 1;
    for (let i3 = 0; i3 < this.height; i3++) {
      for (let j2 = 0; j2 < this.width; j2++) {
        for (let k2 = 0; k2 < this.channels; k2++) {
          newImage.setValueXY(i3, newMaxHeight - j2, k2, this.getValueXY(j2, i3, k2));
        }
      }
    }
    return newImage;
  }
}
function rotateRight() {
  if (this.bitDepth === 1) {
    const newImage = new Image2(this.height, this.width, {
      kind: "BINARY",
      parent: this
    });
    const newMaxWidth = newImage.width - 1;
    for (let i3 = 0; i3 < this.height; i3++) {
      for (let j2 = 0; j2 < this.width; j2++) {
        if (this.getBitXY(j2, i3)) {
          newImage.setBitXY(newMaxWidth - i3, j2);
        }
      }
    }
    return newImage;
  } else {
    const newImage = Image2.createFrom(this, {
      width: this.height,
      height: this.width
    });
    const newMaxWidth = newImage.width - 1;
    for (let i3 = 0; i3 < this.height; i3++) {
      for (let j2 = 0; j2 < this.width; j2++) {
        for (let k2 = 0; k2 < this.channels; k2++) {
          newImage.setValueXY(newMaxWidth - i3, j2, k2, this.getValueXY(j2, i3, k2));
        }
      }
    }
    return newImage;
  }
}
function rotate180() {
  if (this.bitDepth === 1) {
    const newImage = new Image2(this.width, this.height, {
      kind: "BINARY",
      parent: this
    });
    const newMaxWidth = newImage.width - 1;
    const newMaxHeight = newImage.height - 1;
    for (let i3 = 0; i3 < this.height; i3++) {
      for (let j2 = 0; j2 < this.width; j2++) {
        if (this.getBitXY(j2, i3)) {
          newImage.setBitXY(newMaxWidth - j2, newMaxHeight - i3);
        }
      }
    }
    return newImage;
  } else {
    const newImage = Image2.createFrom(this);
    const newMaxWidth = newImage.width - 1;
    const newMaxHeight = newImage.height - 1;
    for (let i3 = 0; i3 < this.height; i3++) {
      for (let j2 = 0; j2 < this.width; j2++) {
        for (let k2 = 0; k2 < this.channels; k2++) {
          newImage.setValueXY(
            newMaxWidth - j2,
            newMaxHeight - i3,
            k2,
            this.getValueXY(j2, i3, k2)
          );
        }
      }
    }
    return newImage;
  }
}

// node_modules/image-js/src/image/transform/insert.js
function insert(toInsert, options = {}) {
  const parameters = getImageParameters(toInsert);
  this.checkProcessable("insert", parameters);
  let { x: x2 = 0, y: y3 = 0 } = options;
  const out = getOutputImageOrInPlace(this, options, { copy: true });
  const maxY = Math.min(out.height, y3 + toInsert.height);
  const maxX = Math.min(out.width, x2 + toInsert.width);
  if (out.bitDepth === 1) {
    for (let j2 = y3; j2 < maxY; j2++) {
      for (let i3 = x2; i3 < maxX; i3++) {
        const val = toInsert.getBitXY(i3 - x2, j2 - y3);
        if (val)
          out.setBitXY(i3, j2);
        else
          out.clearBitXY(i3, j2);
      }
    }
  } else {
    for (let j2 = y3; j2 < maxY; j2++) {
      for (let i3 = x2; i3 < maxX; i3++) {
        out.setPixelXY(i3, j2, toInsert.getPixelXY(i3 - x2, j2 - y3));
      }
    }
  }
  return out;
}

// node_modules/image-js/src/image/utility/setBorder.js
var import_new_array3 = __toESM(require_new_array());
function setBorder(options = {}) {
  let { size = 0, algorithm = "copy", color } = options;
  this.checkProcessable("setBorder", {
    bitDepth: [8, 16, 32, 64]
  });
  if (algorithm === "set") {
    if (color.length !== this.channels) {
      throw new Error(
        `setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`
      );
    }
    for (let i3 = 0; i3 < color.length; i3++) {
      if (color[i3] === 0) {
        color[i3] = 1e-3;
      }
    }
  } else {
    color = (0, import_new_array3.default)(this.channels, null);
  }
  if (!Array.isArray(size)) {
    size = [size, size];
  }
  let leftRightSize = size[0];
  let topBottomSize = size[1];
  let channels = this.channels;
  for (let i3 = leftRightSize; i3 < this.width - leftRightSize; i3++) {
    for (let k2 = 0; k2 < channels; k2++) {
      let value = color[k2] || this.data[(i3 + this.width * topBottomSize) * channels + k2];
      for (let j2 = 0; j2 < topBottomSize; j2++) {
        this.data[(j2 * this.width + i3) * channels + k2] = value;
      }
      value = color[k2] || this.data[(i3 + this.width * (this.height - topBottomSize - 1)) * channels + k2];
      for (let j2 = this.height - topBottomSize; j2 < this.height; j2++) {
        this.data[(j2 * this.width + i3) * channels + k2] = value;
      }
    }
  }
  for (let j2 = 0; j2 < this.height; j2++) {
    for (let k2 = 0; k2 < channels; k2++) {
      let value = color[k2] || this.data[(j2 * this.width + leftRightSize) * channels + k2];
      for (let i3 = 0; i3 < leftRightSize; i3++) {
        this.data[(j2 * this.width + i3) * channels + k2] = value;
      }
      value = color[k2] || this.data[(j2 * this.width + this.width - leftRightSize - 1) * channels + k2];
      for (let i3 = this.width - leftRightSize; i3 < this.width; i3++) {
        this.data[(j2 * this.width + i3) * channels + k2] = value;
      }
    }
  }
  return this;
}

// node_modules/image-js/src/image/utility/split.js
function split(options = {}) {
  let { preserveAlpha = true } = options;
  this.checkProcessable("split", {
    bitDepth: [8, 16]
  });
  if (this.components === 1) {
    return new Stack([this.clone()]);
  }
  let images = new Stack();
  let data = this.data;
  if (this.alpha && preserveAlpha) {
    for (let i3 = 0; i3 < this.components; i3++) {
      let newImage = Image2.createFrom(this, {
        components: 1,
        alpha: true,
        colorModel: GREY
      });
      let ptr = 0;
      for (let j2 = 0; j2 < data.length; j2 += this.channels) {
        newImage.data[ptr++] = data[j2 + i3];
        newImage.data[ptr++] = data[j2 + this.components];
      }
      images.push(newImage);
    }
  } else {
    for (let i3 = 0; i3 < this.channels; i3++) {
      let newImage = Image2.createFrom(this, {
        components: 1,
        alpha: false,
        colorModel: GREY
      });
      let ptr = 0;
      for (let j2 = 0; j2 < data.length; j2 += this.channels) {
        newImage.data[ptr++] = data[j2 + i3];
      }
      images.push(newImage);
    }
  }
  return images;
}

// node_modules/image-js/src/image/utility/getChannel.js
function getChannel(channel, options = {}) {
  let { keepAlpha = false, mergeAlpha = false } = options;
  keepAlpha &= this.alpha;
  mergeAlpha &= this.alpha;
  this.checkProcessable("getChannel", {
    bitDepth: [8, 16]
  });
  channel = validateChannel(this, channel);
  let newImage = Image2.createFrom(this, {
    components: 1,
    alpha: keepAlpha,
    colorModel: GREY
  });
  let ptr = 0;
  for (let j2 = 0; j2 < this.data.length; j2 += this.channels) {
    if (mergeAlpha) {
      newImage.data[ptr++] = this.data[j2 + channel] * this.data[j2 + this.components] / this.maxValue;
    } else {
      newImage.data[ptr++] = this.data[j2 + channel];
      if (keepAlpha) {
        newImage.data[ptr++] = this.data[j2 + this.components];
      }
    }
  }
  return newImage;
}

// node_modules/image-js/src/image/utility/combineChannels.js
function combineChannels(method = defaultCombineMethod, options = {}) {
  let { mergeAlpha = false, keepAlpha = false } = options;
  mergeAlpha &= this.alpha;
  keepAlpha &= this.alpha;
  this.checkProcessable("combineChannels", {
    bitDepth: [8, 16]
  });
  let newImage = Image2.createFrom(this, {
    components: 1,
    alpha: keepAlpha,
    colorModel: GREY
  });
  let ptr = 0;
  for (let i3 = 0; i3 < this.size; i3++) {
    let value = method(this.getPixel(i3));
    if (mergeAlpha) {
      newImage.data[ptr++] = value * this.data[i3 * this.channels + this.components] / this.maxValue;
    } else {
      newImage.data[ptr++] = value;
      if (keepAlpha) {
        newImage.data[ptr++] = this.data[i3 * this.channels + this.components];
      }
    }
  }
  return newImage;
}
function defaultCombineMethod(pixel) {
  return (pixel[0] + pixel[1] + pixel[2]) / 3;
}

// node_modules/image-js/src/image/utility/setChannel.js
function setChannel(channel, image) {
  this.checkProcessable("setChannel", {
    bitDepth: [8, 16]
  });
  image.checkProcessable("setChannel (image parameter check)", {
    bitDepth: [this.bitDepth],
    alpha: [0],
    components: [1]
  });
  if (image.width !== this.width || image.height !== this.height) {
    throw new Error("Images must have exactly the same width and height");
  }
  channel = validateChannel(this, channel);
  let ptr = channel;
  for (let i3 = 0; i3 < image.data.length; i3++) {
    this.data[ptr] = image.data[i3];
    ptr += this.channels;
  }
  return this;
}

// node_modules/image-js/src/image/utility/getSimilarity.js
var import_new_array4 = __toESM(require_new_array());
function getSimilarity(image, options = {}) {
  let {
    shift = [0, 0],
    average,
    channels,
    defaultAlpha,
    normalize: normalize2,
    border = [0, 0]
  } = options;
  this.checkProcessable("getSimilarity", {
    bitDepth: [8, 16]
  });
  if (!Array.isArray(border)) {
    border = [border, border];
  }
  channels = validateArrayOfChannels(this, {
    channels,
    defaultAlpha
  });
  if (this.bitDepth !== image.bitDepth) {
    throw new Error("Both images must have the same bitDepth");
  }
  if (this.channels !== image.channels) {
    throw new Error("Both images must have the same number of channels");
  }
  if (this.colorModel !== image.colorModel) {
    throw new Error("Both images must have the same colorModel");
  }
  if (typeof average === "undefined") {
    average = true;
  }
  let minX = Math.max(border[0], -shift[0]);
  let maxX = Math.min(this.width - border[0], this.width - shift[0]);
  let minY = Math.max(border[1], -shift[1]);
  let maxY = Math.min(this.height - border[1], this.height - shift[1]);
  let results = (0, import_new_array4.default)(channels.length, 0);
  for (let i3 = 0; i3 < channels.length; i3++) {
    let c4 = channels[i3];
    let sumThis = normalize2 ? this.sum[c4] : Math.max(this.sum[c4], image.sum[c4]);
    let sumImage = normalize2 ? image.sum[c4] : Math.max(this.sum[c4], image.sum[c4]);
    if (sumThis !== 0 && sumImage !== 0) {
      for (let x2 = minX; x2 < maxX; x2++) {
        for (let y3 = minY; y3 < maxY; y3++) {
          let indexThis = x2 * this.multiplierX + y3 * this.multiplierY + c4;
          let indexImage = indexThis + shift[0] * this.multiplierX + shift[1] * this.multiplierY;
          results[i3] += Math.min(
            this.data[indexThis] / sumThis,
            image.data[indexImage] / sumImage
          );
        }
      }
    }
  }
  if (average) {
    return results.reduce((sum2, x2) => sum2 + x2) / results.length;
  }
  return results;
}

// node_modules/image-js/src/image/utility/getPixelsGrid.js
function getPixelsGrid(options = {}) {
  let { sampling = [10, 10], painted = false, mask: mask2 } = options;
  this.checkProcessable("getPixelsGrid", {
    bitDepth: [8, 16],
    channels: 1
  });
  if (!Array.isArray(sampling)) {
    sampling = [sampling, sampling];
  }
  const xSampling = sampling[0];
  const ySampling = sampling[1];
  const xyS = [];
  const zS = [];
  const xStep = this.width / xSampling;
  const yStep = this.height / ySampling;
  let currentX = Math.floor(xStep / 2);
  for (let i3 = 0; i3 < xSampling; i3++) {
    let currentY = Math.floor(yStep / 2);
    for (let j2 = 0; j2 < ySampling; j2++) {
      let x2 = Math.round(currentX);
      let y3 = Math.round(currentY);
      if (!mask2 || mask2.getBitXY(x2, y3)) {
        xyS.push([x2, y3]);
        zS.push(this.getPixelXY(x2, y3));
      }
      currentY += yStep;
    }
    currentX += xStep;
  }
  const toReturn = { xyS, zS };
  if (painted) {
    toReturn.painted = this.rgba8().paintPoints(xyS);
  }
  return toReturn;
}

// node_modules/image-js/src/util/matrix.js
function Matrix3(width, height, defaultValue) {
  const matrix2 = new Array(width);
  for (let x2 = 0; x2 < width; x2++) {
    matrix2[x2] = new Array(height);
  }
  if (defaultValue) {
    for (let x2 = 0; x2 < width; x2++) {
      for (let y3 = 0; y3 < height; y3++) {
        matrix2[x2][y3] = defaultValue;
      }
    }
  }
  matrix2.width = width;
  matrix2.height = height;
  Object.setPrototypeOf(matrix2, Matrix3.prototype);
  return matrix2;
}
Matrix3.prototype.localMin = function(x2, y3) {
  let min3 = this[x2][y3];
  let position = [x2, y3];
  for (let i3 = Math.max(0, x2 - 1); i3 < Math.min(this.length, x2 + 2); i3++) {
    for (let j2 = Math.max(0, y3 - 1); j2 < Math.min(this[0].length, y3 + 2); j2++) {
      if (this[i3][j2] < min3) {
        min3 = this[i3][j2];
        position = [i3, j2];
      }
    }
  }
  return {
    position,
    value: min3
  };
};
Matrix3.prototype.localMax = function(x2, y3) {
  let max4 = this[x2][y3];
  let position = [x2, y3];
  for (let i3 = Math.max(0, x2 - 1); i3 < Math.min(this.length, x2 + 2); i3++) {
    for (let j2 = Math.max(0, y3 - 1); j2 < Math.min(this[0].length, y3 + 2); j2++) {
      if (this[i3][j2] > max4) {
        max4 = this[i3][j2];
        position = [i3, j2];
      }
    }
  }
  return {
    position,
    value: max4
  };
};
Matrix3.prototype.localSearch = function(x2, y3, value) {
  let results = [];
  for (let i3 = Math.max(0, x2 - 1); i3 < Math.min(this.length, x2 + 2); i3++) {
    for (let j2 = Math.max(0, y3 - 1); j2 < Math.min(this[0].length, y3 + 2); j2++) {
      if (this[i3][j2] === value) {
        results.push([i3, j2]);
      }
    }
  }
  return results;
};

// node_modules/image-js/src/image/utility/getBestMatch.js
function getBestMatch(image, options = {}) {
  let { border } = options;
  this.checkProcessable("getChannel", {
    bitDepth: [8, 16]
  });
  if (this.bitDepth !== image.bitDepth) {
    throw new Error("Both images must have the same bitDepth");
  }
  if (this.channels !== image.channels) {
    throw new Error("Both images must have the same number of channels");
  }
  if (this.colorModel !== image.colorModel) {
    throw new Error("Both images must have the same colorModel");
  }
  let similarityMatrix = new Matrix3(image.width, image.height, -Infinity);
  let currentX = Math.floor(image.width / 2);
  let currentY = Math.floor(image.height / 2);
  let middleX = currentX;
  let middleY = currentY;
  let theEnd = false;
  while (!theEnd) {
    let toCalculatePositions = similarityMatrix.localSearch(
      currentX,
      currentY,
      -Infinity
    );
    for (let i3 = 0; i3 < toCalculatePositions.length; i3++) {
      let position = toCalculatePositions[i3];
      let similarity = this.getSimilarity(image, {
        border,
        shift: [middleX - position[0], middleY - position[1]]
      });
      similarityMatrix[position[0]][position[1]] = similarity;
    }
    let max4 = similarityMatrix.localMax(currentX, currentY);
    if (max4.position[0] !== currentX || max4.position[1] !== currentY) {
      currentX = max4.position[0];
      currentY = max4.position[1];
    } else {
      theEnd = true;
    }
  }
  return [currentX - middleX, currentY - middleY];
}

// node_modules/image-js/src/image/utility/getRow.js
function getRow(row, channel = 0) {
  this.checkProcessable("getRow", {
    bitDepth: [8, 16]
  });
  checkRow(this, row);
  checkChannel(this, channel);
  let array3 = new Array(this.width);
  let ptr = 0;
  let begin = row * this.width * this.channels + channel;
  let end = begin + this.width * this.channels;
  for (let j2 = begin; j2 < end; j2 += this.channels) {
    array3[ptr++] = this.data[j2];
  }
  return array3;
}

// node_modules/image-js/src/image/utility/getColumn.js
function getColumn(column, channel = 0) {
  this.checkProcessable("getColumn", {
    bitDepth: [8, 16]
  });
  checkColumn(this, column);
  checkChannel(this, channel);
  let array3 = new Array(this.height);
  let ptr = 0;
  let step = this.width * this.channels;
  for (let j2 = channel + column * this.channels; j2 < this.data.length; j2 += step) {
    array3[ptr++] = this.data[j2];
  }
  return array3;
}

// node_modules/image-js/src/image/utility/getMatrix.js
function getMatrix(options = {}) {
  let { channel } = options;
  this.checkProcessable("getMatrix", {
    bitDepth: [8, 16]
  });
  if (channel === void 0) {
    if (this.components > 1) {
      throw new RangeError(
        "You need to define the channel for an image that contains more than one channel"
      );
    }
    channel = 0;
  }
  let matrix2 = new Matrix2(this.height, this.width);
  for (let x2 = 0; x2 < this.height; x2++) {
    for (let y3 = 0; y3 < this.width; y3++) {
      matrix2.set(x2, y3, this.getValueXY(y3, x2, channel));
    }
  }
  return matrix2;
}

// node_modules/image-js/src/image/utility/setMatrix.js
function setMatrix(matrix2, options = {}) {
  matrix2 = new Matrix2(matrix2);
  let { channel } = options;
  this.checkProcessable("getMatrix", {
    bitDepth: [8, 16]
  });
  if (channel === void 0) {
    if (this.components > 1) {
      throw new RangeError(
        "You need to define the channel for an image that contains more than one channel"
      );
    }
    channel = 0;
  }
  if (this.width !== matrix2.columns || this.height !== matrix2.rows) {
    throw new RangeError(
      "The size of the matrix must be equal to the size of the image"
    );
  }
  for (let x2 = 0; x2 < this.height; x2++) {
    for (let y3 = 0; y3 < this.width; y3++) {
      this.setValueXY(y3, x2, channel, matrix2.get(x2, y3));
    }
  }
  return this;
}

// node_modules/image-js/src/image/utility/getPixelsArray.js
function getPixelsArray() {
  this.checkProcessable("getPixelsArray", {
    bitDepth: [8, 16, 32]
  });
  let array3 = new Array(this.size);
  let ptr = 0;
  for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
    let pixel = new Array(this.components);
    for (let j2 = 0; j2 < this.components; j2++) {
      pixel[j2] = this.data[i3 + j2];
    }
    array3[ptr++] = pixel;
  }
  return array3;
}

// node_modules/image-js/src/image/utility/getIntersection.js
function getIntersection(mask2) {
  let mask1 = this;
  let closestParent = mask1.getClosestCommonParent(mask2);
  let startPos1 = mask1.getRelativePosition(closestParent, {
    defaultFurther: true
  });
  let allRelPos1 = getRelativePositionForAllPixels(mask1, startPos1);
  let startPos2 = mask2.getRelativePosition(closestParent, {
    defaultFurther: true
  });
  let allRelPos2 = getRelativePositionForAllPixels(mask2, startPos2);
  let commonSurface = getCommonSurface(allRelPos1, allRelPos2);
  let intersection = {
    whitePixelsMask1: [],
    whitePixelsMask2: [],
    commonWhitePixels: []
  };
  for (let i3 = 0; i3 < commonSurface.length; i3++) {
    let currentRelativePos = commonSurface[i3];
    let realPos1 = [
      currentRelativePos[0] - startPos1[0],
      currentRelativePos[1] - startPos1[1]
    ];
    let realPos2 = [
      currentRelativePos[0] - startPos2[0],
      currentRelativePos[1] - startPos2[1]
    ];
    let valueBitMask1 = mask1.getBitXY(realPos1[0], realPos1[1]);
    let valueBitMask2 = mask2.getBitXY(realPos2[0], realPos2[1]);
    if (valueBitMask1 === 1 && valueBitMask2 === 1) {
      intersection.commonWhitePixels.push(currentRelativePos);
    }
  }
  for (let i3 = 0; i3 < allRelPos1.length; i3++) {
    let posX;
    let posY;
    if (i3 !== 0) {
      posX = Math.floor(i3 / mask1.width);
      posY = i3 % mask1.width;
    }
    if (mask1.getBitXY(posX, posY) === 1) {
      intersection.whitePixelsMask1.push(allRelPos1[i3]);
    }
  }
  for (let i3 = 0; i3 < allRelPos2.length; i3++) {
    let posX = 0;
    let posY = 0;
    if (i3 !== 0) {
      posX = Math.floor(i3 / mask2.width);
      posY = i3 % mask2.width;
    }
    if (mask2.getBitXY(posX, posY) === 1) {
      intersection.whitePixelsMask2.push(allRelPos2[i3]);
    }
  }
  return intersection;
}
function getRelativePositionForAllPixels(mask2, startPosition) {
  let relativePositions = [];
  for (let i3 = 0; i3 < mask2.height; i3++) {
    for (let j2 = 0; j2 < mask2.width; j2++) {
      let originalPos = [i3, j2];
      relativePositions.push([
        originalPos[0] + startPosition[0],
        originalPos[1] + startPosition[1]
      ]);
    }
  }
  return relativePositions;
}
function getCommonSurface(positionArray1, positionArray2) {
  let i3 = 0;
  let j2 = 0;
  let commonSurface = [];
  while (i3 < positionArray1.length && j2 < positionArray2.length) {
    if (positionArray1[i3][0] === positionArray2[j2][0] && positionArray1[i3][1] === positionArray2[j2][1]) {
      commonSurface.push(positionArray1[i3]);
      i3++;
      j2++;
    } else if (positionArray1[i3][0] < positionArray2[j2][0] || positionArray1[i3][0] === positionArray2[j2][0] && positionArray1[i3][1] < positionArray2[j2][1]) {
      i3++;
    } else {
      j2++;
    }
  }
  return commonSurface;
}

// node_modules/image-js/src/image/utility/getClosestCommonParent.js
function getClosestCommonParent(mask2) {
  let depthMask1 = getDepth(this);
  let depthMask2 = getDepth(mask2);
  let furthestParent;
  if (depthMask1 >= depthMask2) {
    furthestParent = getFurthestParent(this, depthMask1);
  } else {
    furthestParent = getFurthestParent(mask2, depthMask2);
  }
  if (depthMask1 === 0 || depthMask2 === 0) {
    return furthestParent;
  }
  let m1 = this;
  let m22 = mask2;
  while (depthMask1 !== depthMask2) {
    if (depthMask1 > depthMask2) {
      m1 = m1.parent;
      if (m1 === null) {
        return furthestParent;
      }
      depthMask1 = depthMask1 - 1;
    } else {
      m22 = m22.parent;
      if (m22 === null) {
        return furthestParent;
      }
      depthMask2 = depthMask2 - 1;
    }
  }
  while (m1 !== m22 && m1 !== null && m22 !== null) {
    m1 = m1.parent;
    m22 = m22.parent;
    if (m1 === null || m22 === null) {
      return furthestParent;
    }
  }
  if (m1 !== m22) {
    return furthestParent;
  }
  return m1;
}
function getDepth(mask2) {
  let d2 = 0;
  let m4 = mask2;
  while (m4.parent != null) {
    m4 = m4.parent;
    d2++;
  }
  return d2;
}
function getFurthestParent(mask2, depth) {
  let m4 = mask2;
  while (depth > 0) {
    m4 = m4.parent;
    depth = depth - 1;
  }
  return m4;
}

// node_modules/canny-edge-detector/src/index.js
var defaultOptions3 = {
  lowThreshold: 10,
  highThreshold: 30,
  gaussianBlur: 1.1
};
var Gx = [
  [-1, 0, 1],
  [-2, 0, 2],
  [-1, 0, 1]
];
var Gy = [
  [-1, -2, -1],
  [0, 0, 0],
  [1, 2, 1]
];
var convOptions = {
  bitDepth: 32,
  mode: "periodic"
};
function cannyEdgeDetector(image, options) {
  image.checkProcessable("Canny edge detector", {
    bitDepth: 8,
    channels: 1,
    components: 1
  });
  options = Object.assign({}, defaultOptions3, options);
  const width = image.width;
  const height = image.height;
  const brightness = image.maxValue;
  const gfOptions = {
    sigma: options.gaussianBlur,
    radius: 3
  };
  const gf = image.gaussianFilter(gfOptions);
  const gradientX = gf.convolution(Gy, convOptions);
  const gradientY = gf.convolution(Gx, convOptions);
  const G2 = gradientY.hypotenuse(gradientX);
  const Image3 = image.constructor;
  const nms = new Image3(width, height, {
    kind: "GREY",
    bitDepth: 32
  });
  const edges = new Image3(width, height, {
    kind: "GREY",
    bitDepth: 32
  });
  const finalImage = new Image3(width, height, {
    kind: "GREY"
  });
  for (var i3 = 1; i3 < width - 1; i3++) {
    for (var j2 = 1; j2 < height - 1; j2++) {
      var dir = (Math.round(Math.atan2(gradientY.getValueXY(i3, j2, 0), gradientX.getValueXY(i3, j2, 0)) * (5 / Math.PI)) + 5) % 5;
      if (!(dir === 0 && (G2.getValueXY(i3, j2, 0) <= G2.getValueXY(i3, j2 - 1, 0) || G2.getValueXY(i3, j2, 0) <= G2.getValueXY(i3, j2 + 1, 0)) || dir === 1 && (G2.getValueXY(i3, j2, 0) <= G2.getValueXY(i3 - 1, j2 + 1, 0) || G2.getValueXY(i3, j2, 0) <= G2.getValueXY(i3 + 1, j2 - 1, 0)) || dir === 2 && (G2.getValueXY(i3, j2, 0) <= G2.getValueXY(i3 - 1, j2, 0) || G2.getValueXY(i3, j2, 0) <= G2.getValueXY(i3 + 1, j2, 0)) || dir === 3 && (G2.getValueXY(i3, j2, 0) <= G2.getValueXY(i3 - 1, j2 - 1, 0) || G2.getValueXY(i3, j2, 0) <= G2.getValueXY(i3 + 1, j2 + 1, 0)))) {
        nms.setValueXY(i3, j2, 0, G2.getValueXY(i3, j2, 0));
      }
    }
  }
  for (i3 = 0; i3 < width * height; ++i3) {
    var currentNms = nms.data[i3];
    var currentEdge = 0;
    if (currentNms > options.highThreshold) {
      currentEdge++;
      finalImage.data[i3] = brightness;
    }
    if (currentNms > options.lowThreshold) {
      currentEdge++;
    }
    edges.data[i3] = currentEdge;
  }
  var currentPixels = [];
  for (i3 = 1; i3 < width - 1; ++i3) {
    for (j2 = 1; j2 < height - 1; ++j2) {
      if (edges.getValueXY(i3, j2, 0) !== 1) {
        continue;
      }
      outer:
        for (var k2 = i3 - 1; k2 < i3 + 2; ++k2) {
          for (var l3 = j2 - 1; l3 < j2 + 2; ++l3) {
            if (edges.getValueXY(k2, l3, 0) === 2) {
              currentPixels.push([i3, j2]);
              finalImage.setValueXY(i3, j2, 0, brightness);
              break outer;
            }
          }
        }
    }
  }
  while (currentPixels.length > 0) {
    var newPixels = [];
    for (i3 = 0; i3 < currentPixels.length; ++i3) {
      for (j2 = -1; j2 < 2; ++j2) {
        for (k2 = -1; k2 < 2; ++k2) {
          if (j2 === 0 && k2 === 0) {
            continue;
          }
          var row = currentPixels[i3][0] + j2;
          var col = currentPixels[i3][1] + k2;
          if (edges.getValueXY(row, col, 0) === 1 && finalImage.getValueXY(row, col, 0) === 0) {
            newPixels.push([row, col]);
            finalImage.setValueXY(row, col, 0, brightness);
          }
        }
      }
    }
    currentPixels = newPixels;
  }
  return finalImage;
}

// node_modules/image-js/src/image/operator/cannyEdge.js
function cannyEdge(options) {
  return cannyEdgeDetector(this, options);
}

// node_modules/image-js/src/image/operator/extract.js
function extract(mask2, options = {}) {
  let { position } = options;
  this.checkProcessable("extract", {
    bitDepth: [1, 8, 16]
  });
  if (!position) {
    position = mask2.getRelativePosition(this);
    if (!position) {
      throw new Error(
        "extract : can not extract an image because the relative position can not be determined, try to specify manually the position as an array of 2 elements [x,y]."
      );
    }
  }
  if (this.bitDepth > 1) {
    let extract2 = Image2.createFrom(this, {
      width: mask2.width,
      height: mask2.height,
      alpha: 1,
      // we force the alpha, otherwise difficult to extract a mask ...
      position,
      parent: this
    });
    for (let x2 = 0; x2 < mask2.width; x2++) {
      for (let y3 = 0; y3 < mask2.height; y3++) {
        for (let channel = 0; channel < this.channels; channel++) {
          let value = this.getValueXY(
            x2 + position[0],
            y3 + position[1],
            channel
          );
          extract2.setValueXY(x2, y3, channel, value);
        }
        if (!mask2.getBitXY(x2, y3)) {
          extract2.setValueXY(x2, y3, this.components, 0);
        }
      }
    }
    return extract2;
  } else {
    let extract2 = Image2.createFrom(this, {
      width: mask2.width,
      height: mask2.height,
      position,
      parent: this
    });
    for (let y3 = 0; y3 < mask2.height; y3++) {
      for (let x2 = 0; x2 < mask2.width; x2++) {
        if (mask2.getBitXY(x2, y3)) {
          if (this.getBitXY(x2 + position[0], y3 + position[1])) {
            extract2.setBitXY(x2, y3);
          }
        }
      }
    }
    return extract2;
  }
}

// node_modules/image-js/src/image/operator/floodFill.js
var import_fast_list = __toESM(require_fast_list());
function floodFill(options = {}) {
  const { x: x2 = 0, y: y3 = 0, inPlace = true } = options;
  const destination = inPlace ? this : Image2.createFrom(this);
  this.checkProcessable("floodFill", { bitDepth: 1 });
  const bit = this.getBitXY(x2, y3);
  if (bit)
    return destination;
  const queue = new import_fast_list.default();
  queue.push(new Node2(x2, y3));
  while (queue.length > 0) {
    const node2 = queue.shift();
    destination.setBitXY(node2.x, node2.y);
    for (let i3 = node2.x + 1; i3 < this.width; i3++) {
      if (!destination.getBitXY(i3, node2.y) && !this.getBitXY(i3, node2.y)) {
        destination.setBitXY(i3, node2.y);
        if (node2.y + 1 < this.height && !this.getBitXY(i3, node2.y + 1)) {
          queue.push(new Node2(i3, node2.y + 1));
        }
        if (node2.y - 1 >= 0 && !this.getBitXY(i3, node2.y - 1)) {
          queue.push(new Node2(i3, node2.y - 1));
        }
      } else {
        break;
      }
    }
    for (let i3 = node2.x - 1; i3 >= 0; i3++) {
      if (!destination.getBitXY(i3, node2.y) && !this.getBitXY(i3, node2.y)) {
        destination.setBitXY(i3, node2.y);
        if (node2.y + 1 < this.height && !this.getBitXY(i3, node2.y + 1)) {
          queue.push(new Node2(i3, node2.y + 1));
        }
        if (node2.y - 1 >= 0 && !this.getBitXY(i3, node2.y - 1)) {
          queue.push(new Node2(i3, node2.y - 1));
        }
      } else {
        break;
      }
    }
  }
  return destination;
}
function Node2(x2, y3) {
  this.x = x2;
  this.y = y3;
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@swiftcarrot/color-fns/dist/index.esm.js
function hsv2rgb(h3, s3, v3) {
  s3 = s3 / 100;
  v3 = v3 / 100;
  var rgb2 = [];
  var c4 = v3 * s3;
  var hh = h3 / 60;
  var x2 = c4 * (1 - Math.abs(hh % 2 - 1));
  var m4 = v3 - c4;
  if (hh >= 0 && hh < 1) {
    rgb2 = [c4, x2, 0];
  } else if (hh >= 1 && hh < 2) {
    rgb2 = [x2, c4, 0];
  } else if (hh >= 2 && hh < 3) {
    rgb2 = [0, c4, x2];
  } else if (h3 >= 3 && hh < 4) {
    rgb2 = [0, x2, c4];
  } else if (h3 >= 4 && hh < 5) {
    rgb2 = [x2, 0, c4];
  } else if (h3 >= 5 && hh <= 6) {
    rgb2 = [c4, 0, x2];
  } else {
    rgb2 = [0, 0, 0];
  }
  return {
    r: Math.round(255 * (rgb2[0] + m4)),
    g: Math.round(255 * (rgb2[1] + m4)),
    b: Math.round(255 * (rgb2[2] + m4))
  };
}
function hsl2hsv(h3, s3, l3) {
  s3 *= (l3 < 50 ? l3 : 100 - l3) / 100;
  return {
    h: h3,
    s: 2 * s3 / (l3 + s3) * 100,
    v: l3 + s3
  };
}
function hsl2rgb(h3, s3, l3) {
  var hsv2 = hsl2hsv(h3, s3, l3);
  return hsv2rgb(hsv2.h, hsv2.s, hsv2.v);
}
var colors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 132, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 255, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 203],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [119, 128, 144],
  slategrey: [119, 128, 144],
  snow: [255, 255, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 5]
};
function parse(str) {
  return named(str) || hex3(str) || hex6(str) || rgb(str) || rgba$1(str) || hsl2(str) || hsla(str);
}
function named(str) {
  var c4 = colors[str.toLowerCase()];
  if (!c4)
    return;
  return {
    r: c4[0],
    g: c4[1],
    b: c4[2],
    a: 100
  };
}
function rgb(str) {
  var m4 = str.match(/rgb\(([^)]+)\)/);
  if (m4) {
    var parts = m4[1].split(/ *, */).map(Number);
    return {
      r: parts[0],
      g: parts[1],
      b: parts[2],
      a: 100
    };
  }
}
function rgba$1(str) {
  var m4 = str.match(/rgba\(([^)]+)\)/);
  if (m4) {
    var parts = m4[1].split(/ *, */).map(Number);
    return {
      r: parts[0],
      g: parts[1],
      b: parts[2],
      a: parts[3] * 100
    };
  }
}
function hex6(str) {
  if ("#" === str[0] && 7 === str.length) {
    return {
      r: parseInt(str.slice(1, 3), 16),
      g: parseInt(str.slice(3, 5), 16),
      b: parseInt(str.slice(5, 7), 16),
      a: 100
    };
  }
}
function hex3(str) {
  if ("#" === str[0] && 4 === str.length) {
    return {
      r: parseInt(str[1] + str[1], 16),
      g: parseInt(str[2] + str[2], 16),
      b: parseInt(str[3] + str[3], 16),
      a: 100
    };
  }
}
function hsl2(str) {
  var m4 = str.match(/hsl\(([^)]+)\)/);
  if (m4) {
    var parts = m4[1].split(/ *, */);
    var h3 = parseInt(parts[0], 10);
    var s3 = parseInt(parts[1], 10);
    var l3 = parseInt(parts[2], 10);
    var _rgb = hsl2rgb(h3, s3, l3);
    return _extends({}, _rgb, {
      a: 100
    });
  }
}
function hsla(str) {
  var m4 = str.match(/hsla\(([^)]+)\)/);
  if (m4) {
    var parts = m4[1].split(/ *, */);
    var h3 = parseInt(parts[0], 10);
    var s3 = parseInt(parts[1], 10);
    var l3 = parseInt(parts[2], 10);
    var a3 = parseInt(parseFloat(parts[3]) * 100, 10);
    var _rgb2 = hsl2rgb(h3, s3, l3);
    return _extends({}, _rgb2, {
      a: a3
    });
  }
}

// node_modules/image-js/src/util/color.js
function css2array(string) {
  let color = parse(string);
  return [color.r, color.g, color.b, Math.round(color.a * 255 / 100)];
}
function hue2rgb(p3, q2, t3) {
  if (t3 < 0) {
    t3 += 1;
  }
  if (t3 > 1) {
    t3 -= 1;
  }
  if (t3 < 1 / 6) {
    return p3 + (q2 - p3) * 6 * t3;
  }
  if (t3 < 1 / 2) {
    return q2;
  }
  if (t3 < 2 / 3) {
    return p3 + (q2 - p3) * (2 / 3 - t3) * 6;
  }
  return p3;
}
function hsl2rgb2(h3, s3, l3) {
  let m1, m22, hue, r2, g2, b2;
  s3 /= 100;
  l3 /= 100;
  if (s3 === 0) {
    r2 = g2 = b2 = l3 * 255;
  } else {
    if (l3 <= 0.5) {
      m22 = l3 * (s3 + 1);
    } else {
      m22 = l3 + s3 - l3 * s3;
    }
    m1 = l3 * 2 - m22;
    hue = h3 / 360;
    r2 = hue2rgb(m1, m22, hue + 1 / 3);
    g2 = hue2rgb(m1, m22, hue);
    b2 = hue2rgb(m1, m22, hue - 1 / 3);
  }
  return { r: r2, g: g2, b: b2 };
}
function getDistinctColors(numColors) {
  let colors2 = new Array(numColors);
  let j2 = 0;
  for (let i3 = 0; i3 < 360; i3 += 360 / numColors) {
    j2++;
    let color = hsl2rgb2(i3, 100, 30 + j2 % 4 * 15);
    colors2[j2 - 1] = [
      Math.round(color.r * 255),
      Math.round(color.g * 255),
      Math.round(color.b * 255)
    ];
  }
  return colors2;
}
function getRandomColor() {
  return [
    Math.floor(Math.random() * 256),
    Math.floor(Math.random() * 256),
    Math.floor(Math.random() * 256)
  ];
}
function getColors(options) {
  let {
    color,
    colors: colors2,
    randomColors,
    // true / false
    numberColors = 50
  } = options;
  if (color && !Array.isArray(color)) {
    color = css2array(color);
  }
  if (color) {
    return [color];
  }
  if (colors2) {
    colors2 = colors2.map(function(color2) {
      if (!Array.isArray(color2)) {
        return css2array(color2);
      }
      return color2;
    });
    return colors2;
  }
  if (randomColors) {
    colors2 = new Array(numberColors);
    for (let i3 = 0; i3 < numberColors; i3++) {
      colors2[i3] = getRandomColor();
    }
  }
  return getDistinctColors(numberColors);
}

// node_modules/image-js/src/image/operator/paintLabels.js
function paintLabels(labels, positions, options = {}) {
  let { color = "blue", colors: colors2, font = "12px Helvetica", rotate: rotate3 = 0 } = options;
  this.checkProcessable("paintMasks", {
    channels: [3, 4],
    bitDepth: [8, 16],
    colorModel: RGB
  });
  if (!Array.isArray(labels)) {
    throw Error("paintLabels: labels must be an array");
  }
  if (!Array.isArray(positions)) {
    throw Error("paintLabels: positions must be an array");
  }
  if (color && !Array.isArray(color)) {
    color = css2array(color);
  }
  if (colors2) {
    colors2 = colors2.map(function(color2) {
      if (!Array.isArray(color2)) {
        return css2array(color2);
      }
      return color2;
    });
  } else {
    colors2 = [color];
  }
  if (labels.length !== positions.length) {
    throw Error(
      "paintLabels: positions and labels must be arrays from the same size"
    );
  }
  if (!Array.isArray(font))
    font = [font];
  if (!Array.isArray(rotate3))
    rotate3 = [rotate3];
  let canvas = this.getCanvas();
  let ctx = canvas.getContext("2d");
  for (let i3 = 0; i3 < labels.length; i3++) {
    ctx.save();
    let color2 = colors2[i3 % colors2.length];
    ctx.fillStyle = `rgba(${color2[0]},${color2[1]},${color2[2]},${color2[3] / this.maxValue})`;
    ctx.font = font[i3 % font.length];
    let position = positions[i3];
    ctx.translate(position[0], position[1]);
    ctx.rotate(rotate3[i3 % rotate3.length] / 180 * Math.PI);
    ctx.fillText(labels[i3], 0, 0);
    ctx.restore();
  }
  this.data = Uint8Array.from(
    ctx.getImageData(0, 0, this.width, this.height).data
  );
  return this;
}

// node_modules/image-js/src/image/operator/paintMasks.js
function paintMasks(masks, options = {}) {
  let {
    alpha = 255,
    labels = [],
    labelsPosition = [],
    labelColor = "blue",
    labelFont = "12px Helvetica"
  } = options;
  this.checkProcessable("paintMasks", {
    channels: [3, 4],
    bitDepth: [8, 16],
    colorModel: RGB
  });
  let colors2 = getColors(
    Object.assign({}, options, { numberColors: masks.length })
  );
  if (!Array.isArray(masks)) {
    masks = [masks];
  }
  for (let i3 = 0; i3 < masks.length; i3++) {
    let mask2 = masks[i3];
    let color = colors2[i3 % colors2.length];
    for (let x2 = 0; x2 < mask2.width; x2++) {
      for (let y3 = 0; y3 < mask2.height; y3++) {
        if (mask2.getBitXY(x2, y3)) {
          for (let component = 0; component < Math.min(this.components, color.length); component++) {
            if (alpha === 255) {
              this.setValueXY(
                x2 + mask2.position[0],
                y3 + mask2.position[1],
                component,
                color[component]
              );
            } else {
              let value = this.getValueXY(
                x2 + mask2.position[0],
                y3 + mask2.position[1],
                component
              );
              value = Math.round(
                (value * (255 - alpha) + color[component] * alpha) / 255
              );
              this.setValueXY(
                x2 + mask2.position[0],
                y3 + mask2.position[1],
                component,
                value
              );
            }
          }
        }
      }
    }
  }
  if (Array.isArray(labels) && labels.length > 0) {
    let canvas = this.getCanvas();
    let ctx = canvas.getContext("2d");
    ctx.fillStyle = labelColor;
    ctx.font = labelFont;
    for (let i3 = 0; i3 < Math.min(masks.length, labels.length); i3++) {
      let position = labelsPosition[i3] ? labelsPosition[i3] : masks[i3].position;
      ctx.fillText(labels[i3], position[0], position[1]);
    }
    this.data = Uint8Array.from(
      ctx.getImageData(0, 0, this.width, this.height).data
    );
  }
  return this;
}

// node_modules/image-js/src/util/zerosMatrix.js
function zerosMatrix(height, width) {
  let matrix2 = new Array(height);
  for (let i3 = 0; i3 < height; i3++) {
    matrix2[i3] = new Array(width).fill(0);
  }
  return matrix2;
}

// node_modules/image-js/src/util/Shape.js
var cross = [
  [0, 0, 1, 0, 0],
  [0, 0, 1, 0, 0],
  [1, 1, 1, 1, 1],
  [0, 0, 1, 0, 0],
  [0, 0, 1, 0, 0]
];
var smallCross = [
  [0, 1, 0],
  [1, 1, 1],
  [0, 1, 0]
];
var Shape = class {
  constructor(options = {}) {
    let { kind = "cross", shape, size, width, height, filled = true } = options;
    if (size) {
      width = size;
      height = size;
    }
    if (shape) {
      switch (shape.toLowerCase()) {
        case "square":
        case "rectangle":
          this.matrix = rectangle(width, height, { filled });
          break;
        case "circle":
        case "ellipse":
          this.matrix = ellipse(width, height, { filled });
          break;
        case "triangle":
          this.matrix = triangle2(width, height, { filled });
          break;
        default:
          throw new Error(`Shape: unexpected shape: ${shape}`);
      }
    } else if (kind) {
      switch (kind.toLowerCase()) {
        case "cross":
          this.matrix = cross;
          break;
        case "smallcross":
          this.matrix = smallCross;
          break;
        default:
          throw new Error(`Shape: unexpected kind: ${kind}`);
      }
    } else {
      throw new Error("Shape: expected a kind or a shape option");
    }
    this.height = this.matrix.length;
    this.width = this.matrix[0].length;
    this.halfHeight = this.height / 2 >> 0;
    this.halfWidth = this.width / 2 >> 0;
  }
  /**
   * Returns an array of [x,y] points
   * @return {Array<Array<number>>} - Array of [x,y] points
   */
  getPoints() {
    let matrix2 = this.matrix;
    let points2 = [];
    for (let y3 = 0; y3 < matrix2.length; y3++) {
      for (let x2 = 0; x2 < matrix2[0].length; x2++) {
        if (matrix2[y3][x2]) {
          points2.push([x2 - this.halfWidth, y3 - this.halfHeight]);
        }
      }
    }
    return points2;
  }
  /**
   * Returns a Mask (1 bit Image) corresponding to this shape.
   * @return {Image}
   */
  getMask() {
    let img = new Image2(this.width, this.height, {
      kind: BINARY
    });
    for (let y3 = 0; y3 < this.matrix.length; y3++) {
      for (let x2 = 0; x2 < this.matrix[0].length; x2++) {
        if (this.matrix[y3][x2]) {
          img.setBitXY(x2, y3);
        }
      }
    }
    return img;
  }
};
function rectangle(width, height, options) {
  const matrix2 = zerosMatrix(height, width);
  if (options.filled) {
    for (let y3 = 0; y3 < height; y3++) {
      for (let x2 = 0; x2 < width; x2++) {
        matrix2[y3][x2] = 1;
      }
    }
  } else {
    for (let y3 of [0, height - 1]) {
      for (let x2 = 0; x2 < width; x2++) {
        matrix2[y3][x2] = 1;
      }
    }
    for (let y3 = 0; y3 < height; y3++) {
      for (let x2 of [0, width - 1]) {
        matrix2[y3][x2] = 1;
      }
    }
  }
  return matrix2;
}
function ellipse(width, height, options) {
  const matrix2 = zerosMatrix(height, width, options);
  let yEven = 1 - height % 2;
  let xEven = 1 - width % 2;
  let a3 = Math.floor((width - 1) / 2);
  let b2 = Math.floor((height - 1) / 2);
  let a22 = a3 * a3;
  let b22 = b2 * b2;
  if (options.filled) {
    for (let y3 = 0; y3 <= b2; y3++) {
      let shift = Math.floor(Math.sqrt(a22 - a22 * y3 * y3 / b22));
      for (let x2 = a3 - shift; x2 <= a3; x2++) {
        matrix2[b2 - y3][x2] = 1;
        matrix2[b2 + y3 + yEven][x2] = 1;
        matrix2[b2 - y3][width - x2 - 1] = 1;
        matrix2[b2 + y3 + yEven][width - x2 - 1] = 1;
      }
    }
  } else {
    for (let y3 = 0; y3 <= b2; y3++) {
      let shift = Math.floor(Math.sqrt(a22 - a22 * y3 * y3 / b22));
      let x2 = a3 - shift;
      matrix2[b2 - y3][x2] = 1;
      matrix2[b2 + y3 + yEven][x2] = 1;
      matrix2[b2 - y3][width - x2 - 1] = 1;
      matrix2[b2 + y3 + yEven][width - x2 - 1] = 1;
    }
    for (let x2 = 0; x2 <= a3; x2++) {
      let shift = Math.floor(Math.sqrt(b22 - b22 * x2 * x2 / a22));
      let y3 = b2 - shift;
      matrix2[y3][a3 - x2] = 1;
      matrix2[y3][a3 + x2 + xEven] = 1;
      matrix2[height - y3 - 1][a3 - x2] = 1;
      matrix2[height - y3 - 1][a3 + x2 + xEven] = 1;
    }
  }
  return matrix2;
}
function triangle2(width, height, options) {
  if (!options.filled) {
    throw new Error("Non filled triangle is not implemented");
  }
  const matrix2 = zerosMatrix(height, width, options);
  for (let y3 = 0; y3 < height; y3++) {
    let shift = Math.floor((1 - y3 / height) * width / 2);
    for (let x2 = shift; x2 < width - shift; x2++) {
      matrix2[y3][x2] = 1;
    }
  }
  return matrix2;
}

// node_modules/image-js/src/image/operator/paintPoints.js
function paintPoints(points2, options = {}) {
  let { shape } = options;
  this.checkProcessable("paintPoints", {
    bitDepth: [8, 16]
  });
  let colors2 = getColors(
    Object.assign({}, options, { numberColors: points2.length })
  );
  let shapePixels = new Shape(shape).getPoints();
  let numberChannels = Math.min(this.channels, colors2[0].length);
  for (let i3 = 0; i3 < points2.length; i3++) {
    let color = colors2[i3 % colors2.length];
    let xP = points2[i3][0];
    let yP = points2[i3][1];
    for (let j2 = 0; j2 < shapePixels.length; j2++) {
      let xS = shapePixels[j2][0];
      let yS = shapePixels[j2][1];
      if (xP + xS >= 0 && yP + yS >= 0 && xP + xS < this.width && yP + yS < this.height) {
        let position = (xP + xS + (yP + yS) * this.width) * this.channels;
        for (let channel = 0; channel < numberChannels; channel++) {
          this.data[position + channel] = color[channel];
        }
      }
    }
  }
  return this;
}

// node_modules/image-js/src/image/operator/paintPolyline.js
function paintPolyline(points2, options = {}) {
  let { color = [this.maxValue, 0, 0], closed = false } = options;
  this.checkProcessable("paintPoints", {
    bitDepth: [1, 8, 16]
  });
  let numberChannels = Math.min(this.channels, color.length);
  for (let i3 = 0; i3 < points2.length - 1 + closed; i3++) {
    let from = points2[i3];
    let to = points2[(i3 + 1) % points2.length];
    let dx = to[0] - from[0];
    let dy = to[1] - from[1];
    let steps = Math.max(Math.abs(dx), Math.abs(dy));
    let xIncrement = dx / steps;
    let yIncrement = dy / steps;
    let x2 = from[0];
    let y3 = from[1];
    for (let j2 = 0; j2 <= steps; j2++) {
      let xPoint = Math.round(x2);
      let yPoint = Math.round(y3);
      if (xPoint >= 0 && yPoint >= 0 && xPoint < this.width && yPoint < this.height) {
        if (this.bitDepth === 1) {
          this.setBitXY(xPoint, yPoint);
        } else {
          let position = (xPoint + yPoint * this.width) * this.channels;
          for (let channel = 0; channel < numberChannels; channel++) {
            this.data[position + channel] = color[channel];
          }
        }
      }
      x2 = x2 + xIncrement;
      y3 = y3 + yIncrement;
    }
  }
  return this;
}

// node_modules/image-js/src/image/operator/paintPolylines.js
function paintPolylines(polylines, options = {}) {
  let optionsCopy = Object.assign({}, options);
  this.checkProcessable("paintPolylines", {
    bitDepth: [8, 16]
  });
  let colors2 = getColors(
    Object.assign({}, options, { numberColors: polylines.length })
  );
  for (let i3 = 0; i3 < polylines.length; i3++) {
    optionsCopy.color = colors2[i3 % colors2.length];
    this.paintPolyline(polylines[i3], optionsCopy);
  }
  return this;
}

// node_modules/image-js/src/image/operator/paintPolygon.js
function paintPolygon(points2, options = {}) {
  let { color = [this.maxValue, 0, 0], filled = false } = options;
  this.checkProcessable("paintPoints", {
    bitDepth: [1, 8, 16]
  });
  options.closed = true;
  let filteredPoints = deleteDouble(points2);
  if (filled === false) {
    return this.paintPolyline(points2, options);
  } else {
    let matrixBinary = Array(this.height);
    for (let i3 = 0; i3 < this.height; i3++) {
      matrixBinary[i3] = [];
      for (let j2 = 0; j2 < this.width; j2++) {
        matrixBinary[i3].push(0);
      }
    }
    for (let p3 = 0; p3 < filteredPoints.length; p3++) {
      const line = lineBetweenTwoPoints(
        filteredPoints[p3],
        filteredPoints[(p3 + 1) % filteredPoints.length]
      );
      for (let y3 = 0; y3 < this.height; y3++) {
        for (let x2 = 0; x2 < this.width; x2++) {
          if (isAtTheRightOfTheLine(x2, y3, line, this.height)) {
            matrixBinary[y3][x2] = matrixBinary[y3][x2] === 0 ? 1 : 0;
          }
        }
      }
    }
    for (let y3 = 0; y3 < this.height; y3++) {
      for (let x2 = 0; x2 < this.width; x2++) {
        if (matrixBinary[y3][x2] === 1) {
          if (this.bitDepth === 1) {
            this.setBitXY(x2, y3);
          } else {
            let numberChannels = Math.min(this.channels, color.length);
            let position = (x2 + y3 * this.width) * this.channels;
            for (let channel = 0; channel < numberChannels; channel++) {
              this.data[position + channel] = color[channel];
            }
          }
        }
      }
    }
    return this.paintPolyline(points2, options);
  }
}
function deleteDouble(points2) {
  let finalPoints = [];
  for (let i3 = 0; i3 < points2.length; i3++) {
    if (points2[i3][0] === points2[(i3 + 1) % points2.length][0] && points2[i3][1] === points2[(i3 + 1) % points2.length][1]) {
      continue;
    } else if (points2[i3][0] === points2[(i3 - 1 + points2.length) % points2.length][0] && points2[i3][1] === points2[(i3 - 1 + points2.length) % points2.length][1]) {
      continue;
    } else if (points2[(i3 + 1) % points2.length][0] === points2[(i3 - 1 + points2.length) % points2.length][0] && points2[(i3 - 1 + points2.length) % points2.length][1] === points2[(i3 + 1) % points2.length][1]) {
      continue;
    } else {
      finalPoints.push(points2[i3]);
    }
  }
  return finalPoints;
}
function lineBetweenTwoPoints(p1, p22) {
  if (p1[0] === p22[0]) {
    return { a: 0, b: p1[0], vertical: true };
  } else {
    const coeffA = (p22[1] - p1[1]) / (p22[0] - p1[0]);
    const coeffB = p1[1] - coeffA * p1[0];
    return { a: coeffA, b: coeffB, vertical: false };
  }
}
function isAtTheRightOfTheLine(x2, y3, line, height) {
  if (line.vertical === true) {
    return line.b <= x2;
  } else {
    if (line.a === 0) {
      return false;
    } else {
      const xline = (y3 - line.b) / line.a;
      return xline < x2 && xline >= 0 && xline <= height;
    }
  }
}

// node_modules/image-js/src/image/operator/paintPolygons.js
function paintPolygons(polygons, options = {}) {
  let optionsCopy = Object.assign({}, options);
  this.checkProcessable("paintPolygons", {
    bitDepth: [8, 16]
  });
  let colors2 = getColors(
    Object.assign({}, options, { numberColors: polygons.length })
  );
  for (let i3 = 0; i3 < polygons.length; i3++) {
    optionsCopy.color = colors2[i3 % colors2.length];
    this.paintPolygon(polygons[i3], optionsCopy);
  }
  return this;
}

// node_modules/image-js/src/image/compute/histogram.js
var import_is_integer2 = __toESM(require_is_integer());
var import_new_array5 = __toESM(require_new_array());
function getHistogram(options = {}) {
  let { maxSlots = 256, channel, useAlpha = true } = options;
  this.checkProcessable("getHistogram", {
    bitDepth: [1, 8, 16]
  });
  if (channel === void 0) {
    if (this.components > 1) {
      throw new RangeError(
        "You need to define the channel for an image that contains more than one channel"
      );
    }
    channel = 0;
  }
  return getChannelHistogram.call(this, channel, { useAlpha, maxSlots });
}
function getHistograms(options = {}) {
  const { maxSlots = 256, useAlpha = true } = options;
  this.checkProcessable("getHistograms", {
    bitDepth: [8, 16]
  });
  let results = new Array(useAlpha ? this.components : this.channels);
  for (let i3 = 0; i3 < results.length; i3++) {
    results[i3] = getChannelHistogram.call(this, i3, { useAlpha, maxSlots });
  }
  return results;
}
function getChannelHistogram(channel, options) {
  let { useAlpha, maxSlots } = options;
  if (this.bitDepth === 1) {
    let blackWhiteCount = [0, 0];
    for (let i3 = 0; i3 < this.height; i3++) {
      for (let j2 = 0; j2 < this.width; j2++) {
        let value = this.getBitXY(i3, j2);
        if (value === 0) {
          blackWhiteCount[0] += 1;
        } else if (value === 1) {
          blackWhiteCount[1] += 1;
        }
      }
    }
    return blackWhiteCount;
  }
  let bitSlots = Math.log2(maxSlots);
  if (!(0, import_is_integer2.default)(bitSlots)) {
    throw new RangeError(
      "maxSlots must be a power of 2, for example: 64, 256, 1024"
    );
  }
  let bitShift = 0;
  if (this.bitDepth > bitSlots) {
    bitShift = this.bitDepth - bitSlots;
  }
  let data = this.data;
  let result = (0, import_new_array5.default)(Math.pow(2, Math.min(this.bitDepth, bitSlots)), 0);
  if (useAlpha && this.alpha) {
    let alphaChannelDiff = this.channels - channel - 1;
    for (let i3 = channel; i3 < data.length; i3 += this.channels) {
      result[data[i3] >> bitShift] += data[i3 + alphaChannelDiff] / this.maxValue;
    }
  } else {
    for (let i3 = channel; i3 < data.length; i3 += this.channels) {
      result[data[i3] >> bitShift]++;
    }
  }
  return result;
}

// node_modules/image-js/src/image/compute/colorHistogram.js
var import_new_array6 = __toESM(require_new_array());
function getColorHistogram(options = {}) {
  let { useAlpha = true, nbSlots = 512 } = options;
  this.checkProcessable("getColorHistogram", {
    bitDepth: [8, 16],
    components: [3]
  });
  let nbSlotsCheck = Math.log(nbSlots) / Math.log(8);
  if (nbSlotsCheck !== Math.floor(nbSlotsCheck)) {
    throw new RangeError(
      "nbSlots must be a power of 8. Usually 8, 64, 512 or 4096"
    );
  }
  let bitShift = this.bitDepth - nbSlotsCheck;
  let data = this.data;
  let result = (0, import_new_array6.default)(Math.pow(8, nbSlotsCheck), 0);
  let factor2 = Math.pow(2, nbSlotsCheck * 2);
  let factor1 = Math.pow(2, nbSlotsCheck);
  for (let i3 = 0; i3 < data.length; i3 += this.channels) {
    let slot = (data[i3] >> bitShift) * factor2 + (data[i3 + 1] >> bitShift) * factor1 + (data[i3 + 2] >> bitShift);
    if (useAlpha && this.alpha) {
      result[slot] += data[i3 + this.channels - 1] / this.maxValue;
    } else {
      result[slot]++;
    }
  }
  return result;
}

// node_modules/image-js/src/image/compute/min.js
var import_new_array7 = __toESM(require_new_array());
function min2() {
  this.checkProcessable("min", {
    bitDepth: [8, 16, 32]
  });
  let result = (0, import_new_array7.default)(this.channels, Infinity);
  for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
    for (let c4 = 0; c4 < this.channels; c4++) {
      if (this.data[i3 + c4] < result[c4]) {
        result[c4] = this.data[i3 + c4];
      }
    }
  }
  return result;
}

// node_modules/image-js/src/image/compute/max.js
var import_new_array8 = __toESM(require_new_array());
function max2() {
  this.checkProcessable("max", {
    bitDepth: [8, 16, 32]
  });
  let result = (0, import_new_array8.default)(this.channels, -Infinity);
  for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
    for (let c4 = 0; c4 < this.channels; c4++) {
      if (this.data[i3 + c4] > result[c4]) {
        result[c4] = this.data[i3 + c4];
      }
    }
  }
  return result;
}

// node_modules/image-js/src/image/compute/sum.js
var import_new_array9 = __toESM(require_new_array());
function sum() {
  this.checkProcessable("sum", {
    bitDepth: [8, 16]
  });
  let result = (0, import_new_array9.default)(this.channels, 0);
  for (let i3 = 0; i3 < this.data.length; i3 += this.channels) {
    for (let c4 = 0; c4 < this.channels; c4++) {
      result[c4] += this.data[i3 + c4];
    }
  }
  return result;
}

// node_modules/image-js/src/image/compute/moment.js
function getMoment(xPower = 0, yPower = 0) {
  this.checkProcessable("getMoment", {
    bitDepth: [1]
  });
  let m4 = 0;
  for (let x2 = 0; x2 < this.width; x2++) {
    for (let y3 = 0; y3 < this.height; y3++) {
      if (this.getBitXY(x2, y3) === 1) {
        m4 += x2 ** xPower * y3 ** yPower;
      }
    }
  }
  return m4;
}

// node_modules/image-js/src/image/compute/localMaxima.js
function localMaxima(options = {}) {
  let {
    mask: mask2,
    region = 3,
    removeClosePoints = 0,
    invert: invert2 = false,
    maxEquals = 2
  } = options;
  let image = this;
  this.checkProcessable("localMaxima", {
    bitDepth: [8, 16],
    components: 1
  });
  region *= 4;
  let maskExpectedValue = invert2 ? 0 : 1;
  let dx = [1, 0, -1, 0, 1, 1, -1, -1, 2, 0, -2, 0, 2, 2, -2, -2];
  let dy = [0, 1, 0, -1, 1, -1, 1, -1, 0, 2, 0, -2, 2, -2, 2, -2];
  let shift = region <= 8 ? 1 : 2;
  let points2 = [];
  for (let currentY = shift; currentY < image.height - shift; currentY++) {
    for (let currentX = shift; currentX < image.width - shift; currentX++) {
      if (mask2 && mask2.getBitXY(currentX, currentY) !== maskExpectedValue) {
        continue;
      }
      let counter = 0;
      let nbEquals = 0;
      let currentValue = image.data[currentX + currentY * image.width];
      for (let dir = 0; dir < region; dir++) {
        if (invert2) {
          if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] > currentValue) {
            counter++;
          }
        } else {
          if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] < currentValue) {
            counter++;
          }
        }
        if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] === currentValue) {
          nbEquals++;
        }
      }
      if (counter + nbEquals === region && nbEquals <= maxEquals) {
        points2.push([currentX, currentY]);
      }
    }
  }
  if (removeClosePoints > 0) {
    for (let i3 = 0; i3 < points2.length; i3++) {
      for (let j2 = i3 + 1; j2 < points2.length; j2++) {
        if (Math.sqrt(
          Math.pow(points2[i3][0] - points2[j2][0], 2) + Math.pow(points2[i3][1] - points2[j2][1], 2)
        ) < removeClosePoints) {
          points2[i3][0] = points2[i3][0] + points2[j2][0] >> 1;
          points2[i3][1] = points2[i3][1] + points2[j2][1] >> 1;
          points2.splice(j2, 1);
          j2--;
        }
      }
    }
  }
  return points2;
}

// node_modules/image-js/src/image/compute/mean.js
function mean3() {
  let histograms2 = this.getHistograms({ maxSlots: this.maxValue + 1 });
  let result = new Array(histograms2.length);
  for (let c4 = 0; c4 < histograms2.length; c4++) {
    let histogram2 = histograms2[c4];
    result[c4] = mean(histogram2);
  }
  return result;
}

// node_modules/image-js/src/image/compute/median.js
function median4() {
  let histograms2 = this.getHistograms({ maxSlots: this.maxValue + 1 });
  let result = new Array(histograms2.length);
  for (let c4 = 0; c4 < histograms2.length; c4++) {
    let histogram2 = histograms2[c4];
    result[c4] = median(histogram2);
  }
  return result;
}

// node_modules/image-js/src/image/compute/points.js
function points() {
  this.checkProcessable("points", {
    bitDepth: [1]
  });
  const pixels = [];
  for (let x2 = 0; x2 < this.width; x2++) {
    for (let y3 = 0; y3 < this.height; y3++) {
      if (this.getBitXY(x2, y3) === 1) {
        pixels.push([x2, y3]);
      }
    }
  }
  return pixels;
}

// node_modules/image-js/src/image/compute/extendedPoints.js
function extendedPoints() {
  this.checkProcessable("extendedPoints", {
    bitDepth: [1]
  });
  const pixels = [];
  for (let y3 = 0; y3 < this.height; y3++) {
    for (let x2 = 0; x2 < this.width; x2++) {
      if (this.getBitXY(x2, y3) === 1) {
        pixels.push([x2, y3]);
        if (this.getBitXY(x2 + 1, y3) !== 1) {
          pixels.push([x2 + 1, y3]);
          pixels.push([x2 + 1, y3 + 1]);
          if (this.getBitXY(x2, y3 + 1) !== 1) {
            pixels.push([x2, y3 + 1]);
          }
        } else {
          if (this.getBitXY(x2, y3 + 1) !== 1) {
            pixels.push([x2, y3 + 1]);
            pixels.push([x2 + 1, y3 + 1]);
          }
        }
        while (x2 < this.width - 2 && this.getBitXY(x2 + 1, y3) === 1 && this.getBitXY(x2 + 2, y3) === 1) {
          x2++;
        }
      }
    }
  }
  return pixels;
}

// node_modules/image-js/src/image/compute/relativePosition.js
function getRelativePosition(targetImage, options = {}) {
  if (this === targetImage) {
    return [0, 0];
  }
  let position = [0, 0];
  let currentImage = this;
  while (currentImage) {
    if (currentImage === targetImage) {
      return position;
    }
    if (currentImage.position) {
      position[0] += currentImage.position[0];
      position[1] += currentImage.position[1];
    }
    currentImage = currentImage.parent;
  }
  if (options.defaultFurther)
    return position;
  return false;
}

// node_modules/image-js/src/image/compute/countAlphaPixels.js
function countAlphaPixels(options = {}) {
  let { alpha = 1 } = options;
  this.checkProcessable("countAlphaPixels", {
    bitDepth: [8, 16],
    alpha: 1
  });
  let count = 0;
  if (alpha !== void 0) {
    for (let i3 = this.components; i3 < this.data.length; i3 += this.channels) {
      if (this.data[i3] === alpha) {
        count++;
      }
    }
    return count;
  } else {
    return this.size;
  }
}

// node_modules/monotone-chain-convex-hull/lib-esm/index.js
function monotoneChainConvexHull(points2, options = {}) {
  const { sorted } = options;
  if (!sorted) {
    points2 = points2.slice().sort(byXThenY);
  }
  const n3 = points2.length;
  const result = new Array(n3 * 2);
  let k2 = 0;
  for (let i3 = 0; i3 < n3; i3++) {
    const point = points2[i3];
    while (k2 >= 2 && cw(result[k2 - 2], result[k2 - 1], point) <= 0) {
      k2--;
    }
    result[k2++] = point;
  }
  const t3 = k2 + 1;
  for (let i3 = n3 - 2; i3 >= 0; i3--) {
    const point = points2[i3];
    while (k2 >= t3 && cw(result[k2 - 2], result[k2 - 1], point) <= 0) {
      k2--;
    }
    result[k2++] = point;
  }
  return result.slice(0, k2 - 1);
}
function cw(p1, p22, p3) {
  return (p22[1] - p1[1]) * (p3[0] - p1[0]) - (p22[0] - p1[0]) * (p3[1] - p1[1]);
}
function byXThenY(point1, point2) {
  if (point1[0] === point2[0]) {
    return point1[1] - point2[1];
  }
  return point1[0] - point2[0];
}

// node_modules/image-js/src/image/compute/monotoneChainConvexHull.js
function monotoneChainConvexHull2() {
  return monotoneChainConvexHull(this.extendedPoints, { sorted: false });
}

// node_modules/image-js/src/util/points.js
function round(points2) {
  for (let i3 = 0; i3 < points2.length; i3++) {
    points2[i3][0] = Math.round(points2[i3][0]);
    points2[i3][1] = Math.round(points2[i3][1]);
  }
  return points2;
}
function difference(p1, p22) {
  return [p1[0] - p22[0], p1[1] - p22[1]];
}
function normalize(p3) {
  let length = Math.sqrt(p3[0] ** 2 + p3[1] ** 2);
  return [p3[0] / length, p3[1] / length];
}
function rotate2(radians, srcPoints, destPoints) {
  if (destPoints === void 0)
    destPoints = new Array(srcPoints.length);
  let cos = Math.cos(radians);
  let sin = Math.sin(radians);
  for (let i3 = 0; i3 < destPoints.length; ++i3) {
    destPoints[i3] = [
      cos * srcPoints[i3][0] - sin * srcPoints[i3][1],
      sin * srcPoints[i3][0] + cos * srcPoints[i3][1]
    ];
  }
  return destPoints;
}
function perimeter(vertices) {
  let total = 0;
  for (let i3 = 0; i3 < vertices.length; i3++) {
    let fromX = vertices[i3][0];
    let fromY = vertices[i3][1];
    let toX = vertices[i3 === vertices.length - 1 ? 0 : i3 + 1][0];
    let toY = vertices[i3 === vertices.length - 1 ? 0 : i3 + 1][1];
    total += Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
  }
  return total;
}
function surface(vertices) {
  let total = 0;
  for (let i3 = 0; i3 < vertices.length; i3++) {
    let addX = vertices[i3][0];
    let addY = vertices[i3 === vertices.length - 1 ? 0 : i3 + 1][1];
    let subX = vertices[i3 === vertices.length - 1 ? 0 : i3 + 1][0];
    let subY = vertices[i3][1];
    total += addX * addY * 0.5;
    total -= subX * subY * 0.5;
  }
  return Math.abs(total);
}
function minMax(points2) {
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  for (let i3 = 0; i3 < points2.length; i3++) {
    if (points2[i3][0] < xMin)
      xMin = points2[i3][0];
    if (points2[i3][0] > xMax)
      xMax = points2[i3][0];
    if (points2[i3][1] < yMin)
      yMin = points2[i3][1];
    if (points2[i3][1] > yMax)
      yMax = points2[i3][1];
  }
  return [
    [xMin, yMin],
    [xMax, yMax]
  ];
}
function moveToZeroZero(srcPoints, destPoints) {
  if (destPoints === void 0) {
    destPoints = new Array(srcPoints.length).fill(0).map(() => []);
  }
  let minMaxValues = minMax(srcPoints);
  let xMin = minMaxValues[0][0];
  let yMin = minMaxValues[0][1];
  for (let i3 = 0; i3 < srcPoints.length; i3++) {
    destPoints[i3][0] = srcPoints[i3][0] - xMin;
    destPoints[i3][1] = srcPoints[i3][1] - yMin;
  }
  return destPoints;
}

// node_modules/image-js/src/image/compute/minimalBoundingRectangle.js
function minimalBoundingRectangle(options = {}) {
  const { originalPoints = monotoneChainConvexHull2.call(this) } = options;
  if (originalPoints.length === 0) {
    return [];
  }
  if (originalPoints.length === 1) {
    return [
      originalPoints[0],
      originalPoints[0],
      originalPoints[0],
      originalPoints[0]
    ];
  }
  const p3 = new Array(originalPoints.length);
  let minSurface = Infinity;
  let minSurfaceAngle = 0;
  let mbr;
  for (let i3 = 0; i3 < p3.length; i3++) {
    let angle = getAngle(originalPoints[i3], originalPoints[(i3 + 1) % p3.length]);
    rotate2(-angle, originalPoints, p3);
    let aX = p3[i3][0];
    let aY = p3[i3][1];
    let bX = p3[(i3 + 1) % p3.length][0];
    let bY = p3[(i3 + 1) % p3.length][1];
    let tUndefined = true;
    let tMin = 0;
    let tMax = 0;
    let maxWidth = 0;
    for (let j2 = 0; j2 < p3.length; j2++) {
      let cX = p3[j2][0];
      let cY = p3[j2][1];
      let t3 = (cX - aX) / (bX - aX);
      if (tUndefined === true) {
        tUndefined = false;
        tMin = t3;
        tMax = t3;
      } else {
        if (t3 < tMin)
          tMin = t3;
        if (t3 > tMax)
          tMax = t3;
      }
      let width = (-(bX - aX) * cY + bX * aY - bY * aX) / (bX - aX);
      if (Math.abs(width) > Math.abs(maxWidth))
        maxWidth = width;
    }
    let pMin = [aX + tMin * (bX - aX), aY];
    let pMax = [aX + tMax * (bX - aX), aY];
    let currentSurface = Math.abs(maxWidth * (tMin - tMax) * (bX - aX));
    if (currentSurface < minSurface) {
      minSurfaceAngle = angle;
      minSurface = currentSurface;
      mbr = [
        pMin,
        pMax,
        [pMax[0], pMax[1] - maxWidth],
        [pMin[0], pMin[1] - maxWidth]
      ];
    }
  }
  rotate2(minSurfaceAngle, mbr, mbr);
  return mbr;
}
function getAngle(p1, p22) {
  let diff = difference(p22, p1);
  let vector = normalize(diff);
  let angle = Math.acos(vector[0]);
  if (vector[1] < 0)
    return -angle;
  return angle;
}

// node_modules/image-js/src/image/extend.js
function extend2(Image3) {
  let inPlace = { inPlace: true };
  Image3.extendMethod("invert", invert);
  Image3.extendMethod("abs", abs);
  Image3.extendMethod("level", level, inPlace);
  Image3.extendMethod("add", add, inPlace);
  Image3.extendMethod("subtract", subtract, inPlace);
  Image3.extendMethod("subtractImage", subtractImage);
  Image3.extendMethod("multiply", multiply, inPlace);
  Image3.extendMethod("divide", divide, inPlace);
  Image3.extendMethod("hypotenuse", hypotenuse);
  Image3.extendMethod("background", background);
  Image3.extendMethod("flipX", flipX);
  Image3.extendMethod("flipY", flipY);
  Image3.extendMethod("blurFilter", blurFilter);
  Image3.extendMethod("medianFilter", medianFilter);
  Image3.extendMethod("gaussianFilter", gaussianFilter);
  Image3.extendMethod("sobelFilter", sobelFilter);
  Image3.extendMethod("gradientFilter", gradientFilter);
  Image3.extendMethod("scharrFilter", scharrFilter);
  Image3.extendMethod("dilate", dilate);
  Image3.extendMethod("erode", erode);
  Image3.extendMethod("open", open2);
  Image3.extendMethod("close", close);
  Image3.extendMethod("topHat", topHat);
  Image3.extendMethod("blackHat", blackHat);
  Image3.extendMethod("morphologicalGradient", morphologicalGradient);
  Image3.extendMethod("warpingFourPoints", warpingFourPoints);
  Image3.extendMethod("crop", crop);
  Image3.extendMethod("cropAlpha", cropAlpha);
  Image3.extendMethod("resize", resize).extendMethod("scale", resize);
  Image3.extendMethod("hsv", hsv);
  Image3.extendMethod("hsl", hsl);
  Image3.extendMethod("cmyk", cmyk);
  Image3.extendMethod("rgba8", rgba8);
  Image3.extendMethod("grey", grey).extendMethod("gray", grey);
  Image3.extendMethod("mask", mask);
  Image3.extendMethod("pad", pad);
  Image3.extendMethod("colorDepth", colorDepth);
  Image3.extendMethod("setBorder", setBorder, inPlace);
  Image3.extendMethod("rotate", rotate);
  Image3.extendMethod("rotateLeft", rotateLeft);
  Image3.extendMethod("rotateRight", rotateRight);
  Image3.extendMethod("insert", insert);
  Image3.extendMethod("getRow", getRow);
  Image3.extendMethod("getColumn", getColumn);
  Image3.extendMethod("getMatrix", getMatrix);
  Image3.extendMethod("setMatrix", setMatrix);
  Image3.extendMethod("getPixelsArray", getPixelsArray);
  Image3.extendMethod("getIntersection", getIntersection);
  Image3.extendMethod("getClosestCommonParent", getClosestCommonParent);
  Image3.extendMethod("getThreshold", getThreshold2);
  Image3.extendMethod("split", split);
  Image3.extendMethod("getChannel", getChannel);
  Image3.extendMethod("combineChannels", combineChannels);
  Image3.extendMethod("setChannel", setChannel);
  Image3.extendMethod("getSimilarity", getSimilarity);
  Image3.extendMethod("getPixelsGrid", getPixelsGrid);
  Image3.extendMethod("getBestMatch", getBestMatch);
  Image3.extendMethod("cannyEdge", cannyEdge);
  Image3.extendMethod("convolution", convolution);
  Image3.extendMethod("extract", extract);
  Image3.extendMethod("floodFill", floodFill);
  Image3.extendMethod("paintLabels", paintLabels, inPlace);
  Image3.extendMethod("paintMasks", paintMasks, inPlace);
  Image3.extendMethod("paintPoints", paintPoints, inPlace);
  Image3.extendMethod("paintPolyline", paintPolyline, inPlace);
  Image3.extendMethod("paintPolylines", paintPolylines, inPlace);
  Image3.extendMethod("paintPolygon", paintPolygon, inPlace);
  Image3.extendMethod("paintPolygons", paintPolygons, inPlace);
  Image3.extendMethod("countAlphaPixels", countAlphaPixels);
  Image3.extendMethod("monotoneChainConvexHull", monotoneChainConvexHull2);
  Image3.extendMethod("minimalBoundingRectangle", minimalBoundingRectangle);
  Image3.extendMethod("getHistogram", getHistogram).extendProperty(
    "histogram",
    getHistogram
  );
  Image3.extendMethod("getHistograms", getHistograms).extendProperty(
    "histograms",
    getHistograms
  );
  Image3.extendMethod("getColorHistogram", getColorHistogram).extendProperty(
    "colorHistogram",
    getColorHistogram
  );
  Image3.extendMethod("getMin", min2).extendProperty("min", min2);
  Image3.extendMethod("getMax", max2).extendProperty("max", max2);
  Image3.extendMethod("getSum", sum).extendProperty("sum", sum);
  Image3.extendMethod("getMoment", getMoment).extendProperty(
    "moment",
    getMoment
  );
  Image3.extendMethod("getLocalMaxima", localMaxima);
  Image3.extendMethod("getMedian", median4).extendProperty(
    "median",
    median4
  );
  Image3.extendMethod("getMean", mean3).extendProperty("mean", mean3);
  Image3.extendMethod("getPoints", points).extendProperty(
    "points",
    points
  );
  Image3.extendMethod("getExtendedPoints", extendedPoints).extendProperty(
    "extendedPoints",
    extendedPoints
  );
  Image3.extendMethod("getRelativePosition", getRelativePosition);
}

// node_modules/image-js/src/image/roi/manager.js
var import_js_quantities = __toESM(require_quantities());

// node_modules/image-js/src/util/deepValue.js
function deepValue(object, path = "") {
  let parts = path.split(".");
  for (let part of parts) {
    if (object[part] === void 0)
      return void 0;
    object = object[part];
  }
  return object;
}

// node_modules/image-js/src/image/roi/Roi.js
var import_robust_point_in_polygon = __toESM(require_robust_pnp());

// node_modules/image-js/src/image/roi/feretDiameters.js
function feretDiameters(options = {}) {
  const { originalPoints = monotoneChainConvexHull2.call(this) } = options;
  if (originalPoints.length === 0) {
    return { min: 0, max: 0, minLine: [], maxLine: [], aspectRatio: 1 };
  }
  if (originalPoints.length === 1) {
    return {
      min: 1,
      max: 1,
      minLine: [originalPoints[0], originalPoints[0]],
      maxLine: [originalPoints[0], originalPoints[0]],
      aspectRatio: 1
    };
  }
  const temporaryPoints = new Array(originalPoints.length);
  let minWidth = Infinity;
  let minWidthAngle = 0;
  let minLine = [];
  for (let i3 = 0; i3 < originalPoints.length; i3++) {
    let angle = getAngle2(
      originalPoints[i3],
      originalPoints[(i3 + 1) % originalPoints.length]
    );
    rotate2(-angle, originalPoints, temporaryPoints);
    let currentWidth = 0;
    let currentMinLine = [];
    for (let j2 = 0; j2 < originalPoints.length; j2++) {
      let absWidth = Math.abs(temporaryPoints[i3][1] - temporaryPoints[j2][1]);
      if (absWidth > currentWidth) {
        currentWidth = absWidth;
        currentMinLine = [];
        currentMinLine.push(
          [temporaryPoints[j2][0], temporaryPoints[i3][1]],
          [temporaryPoints[j2][0], temporaryPoints[j2][1]]
        );
      }
    }
    if (currentWidth < minWidth) {
      minWidth = currentWidth;
      minWidthAngle = angle;
      minLine = currentMinLine;
    }
  }
  rotate2(minWidthAngle, minLine, minLine);
  let maxWidth = 0;
  let maxLine = [];
  let maxSquaredWidth = 0;
  for (let i3 = 0; i3 < originalPoints.length - 1; i3++) {
    for (let j2 = i3 + 1; j2 < originalPoints.length; j2++) {
      let currentSquaredWidth = (originalPoints[i3][0] - originalPoints[j2][0]) ** 2 + (originalPoints[i3][1] - originalPoints[j2][1]) ** 2;
      if (currentSquaredWidth > maxSquaredWidth) {
        maxSquaredWidth = currentSquaredWidth;
        maxWidth = Math.sqrt(currentSquaredWidth);
        maxLine = [originalPoints[i3], originalPoints[j2]];
      }
    }
  }
  return {
    min: minWidth,
    minLine,
    max: maxWidth,
    maxLine,
    aspectRatio: minWidth / maxWidth
  };
}
function getAngle2(p1, p22) {
  let diff = difference(p22, p1);
  let vector = normalize(diff);
  let angle = Math.acos(vector[0]);
  if (vector[1] < 0)
    return -angle;
  return angle;
}

// node_modules/image-js/src/image/roi/Roi.js
var Roi = class {
  constructor(map, id) {
    this.map = map;
    this.id = id;
    this.minX = Number.POSITIVE_INFINITY;
    this.maxX = Number.NEGATIVE_INFINITY;
    this.minY = Number.POSITIVE_INFINITY;
    this.maxY = Number.NEGATIVE_INFINITY;
    this.meanX = 0;
    this.meanY = 0;
    this.surface = 0;
    this.computed = {};
  }
  /**
   * Returns a binary image (mask) for the corresponding ROI
   * @param {object} [options]
   * @param {number} [options.scale=1] - Scaling factor to apply to the mask
   * @param {string} [options.kind='normal'] - 'contour', 'box', 'filled', 'center', 'hull' or 'normal'
   * @return {Image} - Returns a mask (1 bit Image)
   */
  getMask(options = {}) {
    const { scale = 1, kind = "" } = options;
    let mask2;
    switch (kind) {
      case "contour":
        mask2 = this.contourMask;
        break;
      case "box":
        mask2 = this.boxMask;
        break;
      case "filled":
        mask2 = this.filledMask;
        break;
      case "center":
        mask2 = this.centerMask;
        break;
      case "mbr":
        mask2 = this.mbrFilledMask;
        break;
      case "hull":
        mask2 = this.convexHullFilledMask;
        break;
      case "hullContour":
        mask2 = this.convexHullMask;
        break;
      case "mbrContour":
        mask2 = this.mbrMask;
        break;
      case "feret":
        mask2 = this.feretMask;
        break;
      default:
        mask2 = this.mask;
    }
    if (scale < 1) {
      mask2 = mask2.resize({ factor: scale });
      mask2.parent = this.mask.parent;
      mask2.position[0] += this.minX;
      mask2.position[1] += this.minY;
    }
    return mask2;
  }
  get mean() {
    throw new Error("Roi mean not implemented yet");
  }
  get center() {
    if (!this.computed.center) {
      this.computed.center = [this.width / 2 >> 0, this.height / 2 >> 0];
    }
    return this.computed.center;
  }
  get ratio() {
    return this.width / this.height;
  }
  get width() {
    return this.maxX - this.minX + 1;
  }
  get height() {
    return this.maxY - this.minY + 1;
  }
  _computExternalIDs() {
    let borders = this.borderIDs;
    let lengths = this.borderLengths;
    this.computed.externalIDs = [];
    this.computed.externalLengths = [];
    let internals = this.internalIDs;
    for (let i3 = 0; i3 < borders.length; i3++) {
      if (!internals.includes(borders[i3])) {
        this.computed.externalIDs.push(borders[i3]);
        this.computed.externalLengths.push(lengths[i3]);
      }
    }
  }
  get externalIDs() {
    if (this.computed.externalIDs) {
      return this.computed.externalIDs;
    }
    this._computExternalIDs();
    return this.computed.externalIDs;
  }
  get externalLengths() {
    if (this.computed.externalLengths) {
      return this.computed.externalLengths;
    }
    this._computExternalIDs();
    return this.computed.externalLengths;
  }
  _computeBorderIDs() {
    let borders = getBorders(this);
    this.computed.borderIDs = borders.ids;
    this.computed.borderLengths = borders.lengths;
  }
  /**
     Retrieve all the IDs (array of number) of the regions that are in contact with this
     specific region. It may be external or internal
     */
  get borderIDs() {
    if (this.computed.borderIDs) {
      return this.computed.borderIDs;
    }
    this._computeBorderIDs();
    return this.computed.borderIDs;
  }
  /**
     Retrieve all the length (array of number) of the contacts with this
     specific region. It may be external or internal
     */
  get borderLengths() {
    if (this.computed.borderLengths) {
      return this.computed.borderLengths;
    }
    this._computeBorderIDs();
    return this.computed.borderLengths;
  }
  /**
       Retrieve all the IDs or the Roi touching the box surrouding the region
  
       It should really be an array to solve complex cases related to border effect
  
       Like the image
       <pre>
       0000
       1111
       0000
       1111
       </pre>
  
       The first row of 1 will be surrouned by 2 differents zones
  
       Or even worse
       <pre>
       010
       111
       010
       </pre>
       The cross will be surrouned by 4 differents zones
  
       However in most of the cases it will be an array of one element
       */
  get boxIDs() {
    if (!this.computed.boxIDs) {
      this.computed.boxIDs = getBoxIDs(this);
    }
    return this.computed.boxIDs;
  }
  get internalIDs() {
    if (!this.computed.internalIDs) {
      this.computed.internalIDs = getInternalIDs(this);
    }
    return this.computed.internalIDs;
  }
  /**
     Number of pixels of the Roi that touch the rectangle
     This is useful for the calculation of the border
     because we will ignore those special pixels of the rectangle
     border that don't have neighbours all around them.
     */
  get box() {
    if (!this.computed.box) {
      this.computed.box = getBox(this);
    }
    return this.computed.box;
  }
  /**
     Calculates the number of pixels that are in the external border of the Roi
     Contour are all the pixels that touch an external "zone".
     All the pixels that touch the box are part of the border and
     are calculated in the getBoxPixels procedure
     */
  get external() {
    if (!this.computed.external) {
      this.computed.external = getExternal(this);
    }
    return this.computed.external;
  }
  /**
     Calculates information about holes
     */
  get holesInfo() {
    if (!this.computed.holesInfo) {
      this.computed.holesInfo = getHolesInfo(this);
    }
    return this.computed.holesInfo;
  }
  /**
     Calculates the number of pixels that are involved in border
     Border are all the pixels that touch another "zone". It could be external
     or internal. If there is a hole in the zone it will be counted as a border.
     All the pixels that touch the box are part of the border and
     are calculated in the getBoxPixels procedure
     */
  get border() {
    if (!this.computed.border) {
      this.computed.border = getBorder(this);
    }
    return this.computed.border;
  }
  /**
    Returns a binary image (mask) containing only the border of the mask
  */
  get contourMask() {
    if (!this.computed.contourMask) {
      let img = new Image2(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let x2 = 0; x2 < this.width; x2++) {
        for (let y3 = 0; y3 < this.height; y3++) {
          if (this.map.data[x2 + this.minX + (y3 + this.minY) * this.map.width] === this.id) {
            if (x2 > 0 && x2 < this.width - 1 && y3 > 0 && y3 < this.height - 1) {
              if (this.map.data[x2 - 1 + this.minX + (y3 + this.minY) * this.map.width] !== this.id || this.map.data[x2 + 1 + this.minX + (y3 + this.minY) * this.map.width] !== this.id || this.map.data[x2 + this.minX + (y3 - 1 + this.minY) * this.map.width] !== this.id || this.map.data[x2 + this.minX + (y3 + 1 + this.minY) * this.map.width] !== this.id) {
                img.setBitXY(x2, y3);
              }
            } else {
              img.setBitXY(x2, y3);
            }
          }
        }
      }
      this.computed.contourMask = img;
    }
    return this.computed.contourMask;
  }
  get boxMask() {
    if (!this.computed.boxMask) {
      let img = new Image2(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let x2 = 0; x2 < this.width; x2++) {
        img.setBitXY(x2, 0);
        img.setBitXY(x2, this.height - 1);
      }
      for (let y3 = 0; y3 < this.height; y3++) {
        img.setBitXY(0, y3);
        img.setBitXY(this.width - 1, y3);
      }
      this.computed.boxMask = img;
    }
    return this.computed.boxMask;
  }
  /**
     Returns a binary image containing the mask
     */
  get mask() {
    if (!this.computed.mask) {
      let img = new Image2(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let x2 = 0; x2 < this.width; x2++) {
        for (let y3 = 0; y3 < this.height; y3++) {
          if (this.map.data[x2 + this.minX + (y3 + this.minY) * this.map.width] === this.id) {
            img.setBitXY(x2, y3);
          }
        }
      }
      this.computed.mask = img;
    }
    return this.computed.mask;
  }
  get filledMask() {
    if (!this.computed.filledMask) {
      let img = new Image2(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let x2 = 0; x2 < this.width; x2++) {
        for (let y3 = 0; y3 < this.height; y3++) {
          let target = x2 + this.minX + (y3 + this.minY) * this.map.width;
          if (this.internalIDs.includes(this.map.data[target])) {
            img.setBitXY(x2, y3);
          }
        }
      }
      this.computed.filledMask = img;
    }
    return this.computed.filledMask;
  }
  get centerMask() {
    if (!this.computed.centerMask) {
      let img = new Shape({ kind: "smallCross" }).getMask();
      img.parent = this.map.parent;
      img.position = [
        this.minX + this.center[0] - 1,
        this.minY + this.center[1] - 1
      ];
      this.computed.centerMask = img;
    }
    return this.computed.centerMask;
  }
  get convexHull() {
    if (!this.computed.convexHull) {
      const calculationPoints = [];
      for (let x2 = 0; x2 < this.width; x2++) {
        for (let y3 = 0; y3 < this.height; y3++) {
          if (this.map.data[x2 + this.minX + (y3 + this.minY) * this.map.width] === this.id) {
            if (x2 > 0 && x2 < this.width - 1 && y3 > 0 && y3 < this.height - 1) {
              if (this.map.data[x2 - 1 + this.minX + (y3 + this.minY) * this.map.width] !== this.id || this.map.data[x2 + 1 + this.minX + (y3 + this.minY) * this.map.width] !== this.id || this.map.data[x2 + this.minX + (y3 - 1 + this.minY) * this.map.width] !== this.id || this.map.data[x2 + this.minX + (y3 + 1 + this.minY) * this.map.width] !== this.id) {
                calculationPoints.push([x2, y3]);
                calculationPoints.push([x2 + 1, y3]);
                calculationPoints.push([x2, y3 + 1]);
                calculationPoints.push([x2 + 1, y3 + 1]);
              }
            } else {
              calculationPoints.push([x2, y3]);
              calculationPoints.push([x2 + 1, y3]);
              calculationPoints.push([x2, y3 + 1]);
              calculationPoints.push([x2 + 1, y3 + 1]);
            }
          }
        }
      }
      const convexHull = monotoneChainConvexHull(calculationPoints);
      this.computed.convexHull = {
        polyline: convexHull,
        surface: surface(convexHull),
        perimeter: perimeter(convexHull)
      };
    }
    return this.computed.convexHull;
  }
  get convexHullMask() {
    if (!this.computed.convexHullMask) {
      const convexHull = this.convexHull;
      const img = new Image2(this.width + 1, this.height + 1, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      img.paintPolyline(convexHull.polyline, { closed: true });
      this.computed.convexHullMask = img;
    }
    return this.computed.convexHullMask;
  }
  get convexHullFilledMask() {
    if (!this.computed.convexHullFilledMask) {
      const convexHull = this.convexHull;
      const img = new Image2(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let x2 = 0; x2 < this.width; x2++) {
        for (let y3 = 0; y3 < this.height; y3++) {
          if ((0, import_robust_point_in_polygon.default)(convexHull.polyline, [x2, y3]) !== 1) {
            img.setBitXY(x2, y3);
          }
        }
      }
      this.computed.convexHullFilledMask = img;
    }
    return this.computed.convexHullFilledMask;
  }
  get mbr() {
    if (!this.computed.mbr) {
      let mbr = minimalBoundingRectangle({
        originalPoints: this.convexHull.polyline
      });
      if (mbr.length === 0) {
        this.computed.mbr = {
          width: 0,
          height: 0,
          surface: 0,
          perimeter: 0,
          rectangle: mbr
        };
      } else {
        let first = mbr[0];
        let second = mbr[1];
        let third = mbr[2];
        let width = Math.sqrt(
          (first[0] - second[0]) ** 2 + (first[1] - second[1]) ** 2
        );
        let height = Math.sqrt(
          (third[0] - second[0]) ** 2 + (third[1] - second[1]) ** 2
        );
        this.computed.mbr = {
          width,
          height,
          elongation: 1 - width / height,
          aspectRatio: width / height,
          surface: width * height,
          perimeter: (width + height) * 2,
          rectangle: mbr
        };
      }
    }
    return this.computed.mbr;
  }
  get fillRatio() {
    return this.surface / (this.surface + this.holesInfo.surface);
  }
  get feretDiameters() {
    if (!this.computed.feretDiameters) {
      this.computed.feretDiameters = feretDiameters({
        originalPoints: this.convexHull.polyline
      });
    }
    return this.computed.feretDiameters;
  }
  /**
   * Diameter of a circle of equal projection area
   */
  get eqpc() {
    if (!this.computed.eqpc) {
      this.computed.eqpc = 2 * Math.sqrt(this.surface / Math.PI);
    }
    return this.computed.eqpc;
  }
  /**
   * Get the category in which each external pixel belongs
   */
  get perimeterInfo() {
    if (!this.computed.perimeterInfo) {
      this.computed.perimeterInfo = getPerimeterInfo(this);
    }
    return this.computed.perimeterInfo;
  }
  /**
   * Return the perimeter of the ROI
   */
  get perimeter() {
    let info = this.perimeterInfo;
    let delta = 2 - Math.sqrt(2);
    return info.one + info.two * 2 + info.three * 3 + info.four * 4 - delta * (info.two + info.three * 2 + info.four);
  }
  /**
   * Diameter of a circle of equal perimeter
   */
  get ped() {
    if (!this.computed.ped) {
      this.computed.ped = this.perimeter / Math.PI;
    }
    return this.computed.ped;
  }
  get feretMask() {
    if (!this.computed.feretMask) {
      const image = new Image2(this.width + 1, this.height + 1, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      image.paintPolyline(this.feretDiameters.minLine);
      image.paintPolyline(this.feretDiameters.maxLine);
      this.computed.feretMask = image;
    }
    return this.computed.feretMask;
  }
  get mbrMask() {
    if (!this.computed.mbrMask) {
      let rectangle2 = round(this.mbr.rectangle);
      if (rectangle2.length > 0) {
        const minMax2 = minMax(rectangle2);
        const img = new Image2(
          minMax2[1][0] - minMax2[0][0] + 1,
          minMax2[1][1] - minMax2[0][1] + 1,
          {
            kind: BINARY,
            position: [this.minX + minMax2[0][0], this.minY + minMax2[0][1]],
            parent: this.map.parent
          }
        );
        rectangle2 = moveToZeroZero(rectangle2);
        img.paintPolyline(rectangle2, { closed: true });
        this.computed.mbrMask = img;
      } else {
        this.computed.mbrMask = new Image2(1, 1, {
          kind: BINARY,
          position: [this.minX, this.minY],
          parent: this.map.parent
        });
      }
    }
    return this.computed.mbrMask;
  }
  get mbrFilledMask() {
    if (!this.computed.mbrFilledMask) {
      const img = new Image2(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      const mbr = this.mask.minimalBoundingRectangle();
      for (let x2 = 0; x2 < this.width; x2++) {
        for (let y3 = 0; y3 < this.height; y3++) {
          if ((0, import_robust_point_in_polygon.default)(mbr, [x2, y3]) !== 1) {
            img.setBitXY(x2, y3);
          }
        }
      }
      this.computed.mbrFilledMask = img;
    }
    return this.computed.mbrFilledMask;
  }
  get points() {
    if (!this.computed.points) {
      let points2 = [];
      for (let y3 = 0; y3 < this.height; y3++) {
        for (let x2 = 0; x2 < this.width; x2++) {
          let target = (y3 + this.minY) * this.map.width + x2 + this.minX;
          if (this.map.data[target] === this.id) {
            points2.push([x2, y3]);
          }
        }
      }
      this.computed.points = points2;
    }
    return this.computed.points;
  }
  get maxLengthPoints() {
    if (!this.computed.maxLengthPoints) {
      let maxLength = 0;
      let maxLengthPoints;
      const points2 = this.points;
      for (let i3 = 0; i3 < points2.length; i3++) {
        for (let j2 = i3 + 1; j2 < points2.length; j2++) {
          let currentML = Math.pow(points2[i3][0] - points2[j2][0], 2) + Math.pow(points2[i3][1] - points2[j2][1], 2);
          if (currentML >= maxLength) {
            maxLength = currentML;
            maxLengthPoints = [points2[i3], points2[j2]];
          }
        }
      }
      this.computed.maxLengthPoints = maxLengthPoints;
    }
    return this.computed.maxLengthPoints;
  }
  /**
        Calculates the maximum length between two pixels of the Roi.
     */
  get maxLength() {
    if (!this.computed.maxLength) {
      let maxLength = Math.sqrt(
        Math.pow(this.maxLengthPoints[0][0] - this.maxLengthPoints[1][0], 2) + Math.pow(this.maxLengthPoints[0][1] - this.maxLengthPoints[1][1], 2)
      );
      this.computed.maxLength = maxLength;
    }
    return this.computed.maxLength;
  }
  get roundness() {
    return 4 * this.surface / (Math.PI * this.feretDiameters.max ** 2);
  }
  get sphericity() {
    return 2 * Math.sqrt(this.surface * Math.PI) / this.perimeter;
  }
  get solidity() {
    return this.surface / this.convexHull.surface;
  }
  get angle() {
    if (!this.computed.angle) {
      let points2 = this.maxLengthPoints;
      let angle = -Math.atan2(points2[0][1] - points2[1][1], points2[0][0] - points2[1][0]) * 180 / Math.PI;
      this.computed.angle = angle;
    }
    return this.computed.angle;
  }
  toJSON() {
    return {
      id: this.id,
      minX: this.minX,
      maxX: this.maxX,
      minY: this.minY,
      maxY: this.maxY,
      meanX: this.meanX,
      meanY: this.meanY,
      height: this.height,
      width: this.width,
      surface: this.surface,
      mbrWidth: this.mbr.width,
      mbrHeight: this.mbr.height,
      mbrSurface: this.mbr.surface,
      eqpc: this.eqpc,
      ped: this.ped,
      feretDiameterMin: this.feretDiameters.min,
      feretDiameterMax: this.feretDiameters.max,
      aspectRatio: this.feretDiameters.aspectRatio,
      fillRatio: this.fillRatio,
      sphericity: this.sphericity,
      roundness: this.roundness,
      solidity: this.solidity,
      perimeter: this.perimeter
    };
  }
};
function getBorders(roi) {
  let roiMap = roi.map;
  let data = roiMap.data;
  let surroudingIDs = /* @__PURE__ */ new Set();
  let surroundingBorders = /* @__PURE__ */ new Map();
  let visitedData = /* @__PURE__ */ new Set();
  let dx = [1, 0, -1, 0];
  let dy = [0, 1, 0, -1];
  for (let x2 = roi.minX; x2 <= roi.maxX; x2++) {
    for (let y3 = roi.minY; y3 <= roi.maxY; y3++) {
      let target = x2 + y3 * roiMap.width;
      if (data[target] === roi.id) {
        for (let dir = 0; dir < 4; dir++) {
          let newX = x2 + dx[dir];
          let newY = y3 + dy[dir];
          if (newX >= 0 && newY >= 0 && newX < roiMap.width && newY < roiMap.height) {
            let neighbour = newX + newY * roiMap.width;
            if (data[neighbour] !== roi.id && !visitedData.has(neighbour)) {
              visitedData.add(neighbour);
              surroudingIDs.add(data[neighbour]);
              let surroundingBorder = surroundingBorders.get(data[neighbour]);
              if (!surroundingBorder) {
                surroundingBorders.set(data[neighbour], 1);
              } else {
                surroundingBorders.set(data[neighbour], ++surroundingBorder);
              }
            }
          }
        }
      }
    }
  }
  let ids = Array.from(surroudingIDs);
  let borderLengths = ids.map(function(id) {
    return surroundingBorders.get(id);
  });
  return {
    ids,
    lengths: borderLengths
  };
}
function getBoxIDs(roi) {
  let surroundingIDs = /* @__PURE__ */ new Set();
  let roiMap = roi.map;
  let data = roiMap.data;
  for (let y3 of [0, roi.height - 1]) {
    for (let x2 = 0; x2 < roi.width; x2++) {
      let target = (y3 + roi.minY) * roiMap.width + x2 + roi.minX;
      if (x2 - roi.minX > 0 && data[target] === roi.id && data[target - 1] !== roi.id) {
        let value = data[target - 1];
        surroundingIDs.add(value);
      }
      if (roiMap.width - x2 - roi.minX > 1 && data[target] === roi.id && data[target + 1] !== roi.id) {
        let value = data[target + 1];
        surroundingIDs.add(value);
      }
    }
  }
  for (let x2 of [0, roi.width - 1]) {
    for (let y3 = 0; y3 < roi.height; y3++) {
      let target = (y3 + roi.minY) * roiMap.width + x2 + roi.minX;
      if (y3 - roi.minY > 0 && data[target] === roi.id && data[target - roiMap.width] !== roi.id) {
        let value = data[target - roiMap.width];
        surroundingIDs.add(value);
      }
      if (roiMap.height - y3 - roi.minY > 1 && data[target] === roi.id && data[target + roiMap.width] !== roi.id) {
        let value = data[target + roiMap.width];
        surroundingIDs.add(value);
      }
    }
  }
  return Array.from(surroundingIDs);
}
function getBox(roi) {
  let total = 0;
  let roiMap = roi.map;
  let data = roiMap.data;
  let topBottom = [0];
  if (roi.height > 1) {
    topBottom[1] = roi.height - 1;
  }
  for (let y3 of topBottom) {
    for (let x2 = 1; x2 < roi.width - 1; x2++) {
      let target = (y3 + roi.minY) * roiMap.width + x2 + roi.minX;
      if (data[target] === roi.id) {
        total++;
      }
    }
  }
  let leftRight = [0];
  if (roi.width > 1) {
    leftRight[1] = roi.width - 1;
  }
  for (let x2 of leftRight) {
    for (let y3 = 0; y3 < roi.height; y3++) {
      let target = (y3 + roi.minY) * roiMap.width + x2 + roi.minX;
      if (data[target] === roi.id) {
        total++;
      }
    }
  }
  return total;
}
function getBorder(roi) {
  let total = 0;
  let roiMap = roi.map;
  let data = roiMap.data;
  for (let x2 = 1; x2 < roi.width - 1; x2++) {
    for (let y3 = 1; y3 < roi.height - 1; y3++) {
      let target = (y3 + roi.minY) * roiMap.width + x2 + roi.minX;
      if (data[target] === roi.id) {
        if (data[target - 1] !== roi.id || data[target + 1] !== roi.id || data[target - roiMap.width] !== roi.id || data[target + roiMap.width] !== roi.id) {
          total++;
        }
      }
    }
  }
  return total + roi.box;
}
function getPerimeterInfo(roi) {
  let roiMap = roi.map;
  let data = roiMap.data;
  let one = 0;
  let two = 0;
  let three = 0;
  let four = 0;
  for (let x2 = 0; x2 < roi.width; x2++) {
    for (let y3 = 0; y3 < roi.height; y3++) {
      let target = (y3 + roi.minY) * roiMap.width + x2 + roi.minX;
      if (data[target] === roi.id) {
        let nbAround = 0;
        if (x2 === 0) {
          nbAround++;
        } else if (roi.externalIDs.includes(data[target - 1])) {
          nbAround++;
        }
        if (x2 === roi.width - 1) {
          nbAround++;
        } else if (roi.externalIDs.includes(data[target + 1])) {
          nbAround++;
        }
        if (y3 === 0) {
          nbAround++;
        } else if (roi.externalIDs.includes(data[target - roiMap.width])) {
          nbAround++;
        }
        if (y3 === roi.height - 1) {
          nbAround++;
        } else if (roi.externalIDs.includes(data[target + roiMap.width])) {
          nbAround++;
        }
        switch (nbAround) {
          case 1:
            one++;
            break;
          case 2:
            two++;
            break;
          case 3:
            three++;
            break;
          case 4:
            four++;
            break;
          default:
        }
      }
    }
  }
  return { one, two, three, four };
}
function getExternal(roi) {
  let total = 0;
  let roiMap = roi.map;
  let data = roiMap.data;
  for (let x2 = 1; x2 < roi.width - 1; x2++) {
    for (let y3 = 1; y3 < roi.height - 1; y3++) {
      let target = (y3 + roi.minY) * roiMap.width + x2 + roi.minX;
      if (data[target] === roi.id) {
        if (roi.externalIDs.includes(data[target - 1]) || roi.externalIDs.includes(data[target + 1]) || roi.externalIDs.includes(data[target - roiMap.width]) || roi.externalIDs.includes(data[target + roiMap.width])) {
          total++;
        }
      }
    }
  }
  return total + roi.box;
}
function getHolesInfo(roi) {
  let surface2 = 0;
  let width = roi.map.width;
  let data = roi.map.data;
  for (let x2 = 1; x2 < roi.width - 1; x2++) {
    for (let y3 = 1; y3 < roi.height - 1; y3++) {
      let target = (y3 + roi.minY) * width + x2 + roi.minX;
      if (roi.internalIDs.includes(data[target]) && data[target] !== roi.id) {
        surface2++;
      }
    }
  }
  return {
    number: roi.internalIDs.length - 1,
    surface: surface2
  };
}
function getInternalIDs(roi) {
  let internal = [roi.id];
  let roiMap = roi.map;
  let data = roiMap.data;
  if (roi.height > 2) {
    for (let x2 = 0; x2 < roi.width; x2++) {
      let target = roi.minY * roiMap.width + x2 + roi.minX;
      if (internal.includes(data[target])) {
        let id = data[target + roiMap.width];
        if (!internal.includes(id) && !roi.boxIDs.includes(id)) {
          internal.push(id);
        }
      }
    }
  }
  let array3 = new Array(4);
  for (let x2 = 1; x2 < roi.width - 1; x2++) {
    for (let y3 = 1; y3 < roi.height - 1; y3++) {
      let target = (y3 + roi.minY) * roiMap.width + x2 + roi.minX;
      if (internal.includes(data[target])) {
        array3[0] = data[target - 1];
        array3[1] = data[target + 1];
        array3[2] = data[target - roiMap.width];
        array3[3] = data[target + roiMap.width];
        for (let i3 = 0; i3 < 4; i3++) {
          let id = array3[i3];
          if (!internal.includes(id) && !roi.boxIDs.includes(id)) {
            internal.push(id);
          }
        }
      }
    }
  }
  return internal;
}

// node_modules/image-js/src/image/roi/RoiLayer.js
var RoiLayer = class {
  constructor(roiMap, options) {
    this.roiMap = roiMap;
    this.options = options;
    this.roi = this.createRoi();
  }
  /**
   * Roi are created from a roiMap
   * The roiMap contains mainty an array of identifiers that define
   * for each data to which Roi it belongs
   * @memberof RoiManager
   * @instance
   * @return {Roi[]}
   */
  createRoi() {
    let data = this.roiMap.data;
    let mapIDs = {};
    this.roiMap.positive = 0;
    this.roiMap.negative = 0;
    for (let i3 = 0; i3 < data.length; i3++) {
      if (data[i3] && !mapIDs[data[i3]]) {
        mapIDs[data[i3]] = true;
        if (data[i3] > 0) {
          this.roiMap.positive++;
        } else {
          this.roiMap.negative++;
        }
      }
    }
    let rois = {};
    for (let mapID in mapIDs) {
      rois[mapID] = new Roi(this.roiMap, mapID * 1);
    }
    let width = this.roiMap.width;
    let height = this.roiMap.height;
    for (let y3 = 0; y3 < height; y3++) {
      for (let x2 = 0; x2 < width; x2++) {
        let target = y3 * width + x2;
        if (data[target] !== 0) {
          const mapID = data[target];
          const roi = rois[mapID];
          if (x2 < roi.minX) {
            roi.minX = x2;
          }
          if (x2 > roi.maxX) {
            roi.maxX = x2;
          }
          if (y3 < roi.minY) {
            roi.minY = y3;
          }
          if (y3 > roi.maxY) {
            roi.maxY = y3;
          }
          roi.meanX += x2;
          roi.meanY += y3;
          roi.surface++;
        }
      }
    }
    let roiArray = [];
    for (let mapID in mapIDs) {
      rois[mapID].meanX /= rois[mapID].surface;
      rois[mapID].meanY /= rois[mapID].surface;
      roiArray.push(rois[mapID]);
    }
    return roiArray;
  }
};

// node_modules/image-js/src/image/roi/util/commonBorderLength.js
function commonBorderLength(roiMap) {
  let data = roiMap.data;
  let dx = [1, 0, -1, 0];
  let dy = [0, 1, 0, -1];
  let minMax2 = roiMap.minMax;
  let shift = -minMax2.min;
  let max4 = minMax2.max + shift;
  let borderInfo = [];
  for (let i3 = 0; i3 <= max4; i3++) {
    borderInfo.push(/* @__PURE__ */ Object.create(null));
  }
  for (let x2 = 0; x2 < roiMap.width; x2++) {
    for (let y3 = 0; y3 < roiMap.height; y3++) {
      let target = x2 + y3 * roiMap.width;
      let currentRoiID = data[target];
      if (currentRoiID !== 0) {
        let used = /* @__PURE__ */ Object.create(null);
        let isBorder = false;
        for (let dir = 0; dir < 4; dir++) {
          let newX = x2 + dx[dir];
          let newY = y3 + dy[dir];
          if (newX >= 0 && newY >= 0 && newX < roiMap.width && newY < roiMap.height) {
            let neighbourRoiID = data[newX + newY * roiMap.width];
            if (currentRoiID !== neighbourRoiID) {
              isBorder = true;
              if (neighbourRoiID !== 0 && used[neighbourRoiID] === void 0) {
                used[neighbourRoiID] = true;
                if (!borderInfo[neighbourRoiID + shift][currentRoiID]) {
                  borderInfo[neighbourRoiID + shift][currentRoiID] = 1;
                } else {
                  borderInfo[neighbourRoiID + shift][currentRoiID]++;
                }
              }
            }
          } else {
            isBorder = true;
          }
        }
        if (isBorder) {
          if (!borderInfo[currentRoiID + shift][currentRoiID]) {
            borderInfo[currentRoiID + shift][currentRoiID] = 1;
          } else {
            borderInfo[currentRoiID + shift][currentRoiID]++;
          }
        }
      }
    }
  }
  let result = {};
  for (let i3 = 0; i3 < borderInfo.length; i3++) {
    if (Object.keys(borderInfo[i3]).length > 0) {
      result[i3 - shift] = borderInfo[i3];
    }
  }
  return result;
}

// node_modules/image-js/src/image/roi/util/mergeRoi.js
function mergeRoi(options = {}) {
  const {
    algorithm = "commonBorderLength",
    minCommonBorderLength = 5,
    maxCommonBorderLength = 100,
    minCommonBorderRatio = 0.3,
    maxCommonBorderRatio = 1
  } = options;
  let checkFunction = function(currentInfo, currentID, neighbourID) {
    return currentInfo[neighbourID] >= minCommonBorderLength && currentInfo[neighbourID] <= maxCommonBorderLength;
  };
  if (typeof algorithm === "function") {
    checkFunction = algorithm;
  }
  if (algorithm.toLowerCase() === "commonborderratio") {
    checkFunction = function(currentInfo, currentID, neighbourID) {
      let ratio = Math.min(
        currentInfo[neighbourID] / currentInfo[currentID],
        1
      );
      return ratio >= minCommonBorderRatio && ratio <= maxCommonBorderRatio;
    };
  }
  const roiMap = this;
  const borderLengths = roiMap.commonBorderLength;
  let newMap = {};
  let oldToNew = {};
  for (let currentID of Object.keys(borderLengths)) {
    let currentInfo = borderLengths[currentID];
    let neighbourIDs = Object.keys(currentInfo);
    for (let neighbourID of neighbourIDs) {
      if (neighbourID !== currentID) {
        if (checkFunction(currentInfo, currentID, neighbourID)) {
          let newNeighbourID = neighbourID;
          if (oldToNew[neighbourID])
            newNeighbourID = oldToNew[neighbourID];
          let newCurrentID = currentID;
          if (oldToNew[currentID])
            newCurrentID = oldToNew[currentID];
          if (Number(newNeighbourID) !== newCurrentID) {
            let smallerID = Math.min(newNeighbourID, newCurrentID);
            let largerID = Math.max(newNeighbourID, newCurrentID);
            if (!newMap[smallerID]) {
              newMap[smallerID] = {};
            }
            newMap[smallerID][largerID] = true;
            oldToNew[largerID] = smallerID;
            if (newMap[largerID]) {
              for (let id of Object.keys(newMap[largerID])) {
                newMap[smallerID][id] = true;
                oldToNew[id] = smallerID;
              }
              delete newMap[largerID];
            }
          }
        }
      }
    }
  }
  let minMax2 = roiMap.minMax;
  let shift = -minMax2.min;
  let max4 = minMax2.max + shift;
  let oldToNewArray = new Array(max4 + 1).fill(0);
  for (let key of Object.keys(oldToNew)) {
    oldToNewArray[Number(key) + shift] = oldToNew[key];
  }
  let data = roiMap.data;
  for (let i3 = 0; i3 < data.length; i3++) {
    let currentValue = data[i3];
    if (currentValue !== 0) {
      let newValue = oldToNewArray[currentValue + shift];
      if (newValue !== 0) {
        data[i3] = newValue;
      }
    }
  }
  roiMap.computed = {};
  return roiMap;
}

// node_modules/image-js/src/image/roi/RoiMap.js
var RoiMap = class {
  constructor(parent, data) {
    this.parent = parent;
    this.width = parent.width;
    this.height = parent.height;
    this.data = data;
    this.negative = 0;
    this.positive = 0;
  }
  get total() {
    return this.negative + this.positive;
  }
  get minMax() {
    let min3 = Number.MAX_SAFE_INTEGER;
    let max4 = Number.MIN_SAFE_INTEGER;
    for (let i3 = 0; i3 < this.data.length; i3++) {
      if (this.data[i3] < min3)
        min3 = this.data[i3];
      if (this.data[i3] > max4)
        max4 = this.data[i3];
    }
    return { min: min3, max: max4 };
  }
  get commonBorderLength() {
    return commonBorderLength(this);
  }
  mergeRoi(options = {}) {
    return mergeRoi.call(this, options);
  }
  mergeRois(rois) {
    const first = rois[0];
    const others = rois.slice(1);
    for (let i3 = 0; i3 < this.data.length; i3++) {
      if (others.includes(this.data[i3])) {
        this.data[i3] = first;
      }
    }
  }
  rowsInfo() {
    let rowsInfo = new Array(this.height);
    let currentRow = 0;
    for (let i3 = 0; i3 < this.data.length; i3 += this.width) {
      let info = {
        row: currentRow,
        positivePixel: 0,
        negativePixel: 0,
        zeroPixel: 0,
        positiveRoi: 0,
        negativeRoi: 0,
        medianChange: 0
      };
      rowsInfo[currentRow++] = info;
      let positives = {};
      let negatives = {};
      let changes = [];
      let previous = this.data[i3];
      let current = 0;
      for (let j2 = i3; j2 < i3 + this.width; j2++) {
        let value = this.data[j2];
        if (previous !== value) {
          previous = value;
          changes.push(current);
          current = 0;
        }
        current++;
        if (value > 0) {
          info.positivePixel++;
          if (!positives[value]) {
            positives[value] = true;
          }
        } else if (value < 0) {
          info.negativePixel++;
          if (!negatives[value]) {
            negatives[value] = true;
          }
        } else {
          info.zeroPixel++;
        }
      }
      changes.push(current);
      info.medianChange = changes.sort((a3, b2) => a3 - b2)[Math.floor(changes.length / 2)];
      info.positiveRoiIDs = Object.keys(positives);
      info.negativeRoiIDs = Object.keys(negatives);
      info.positiveRoi = info.positiveRoiIDs.length;
      info.negativeRoi = info.negativeRoiIDs.length;
    }
    return rowsInfo;
  }
  colsInfo() {
    let colsInfo = new Array(this.width);
    let currentCol = 0;
    for (let i3 = 0; i3 < this.width; i3++) {
      let info = {
        col: currentCol,
        positivePixel: 0,
        negativePixel: 0,
        zeroPixel: 0,
        positiveRoi: 0,
        negativeRoi: 0,
        medianChange: 0
      };
      colsInfo[currentCol++] = info;
      let positives = {};
      let negatives = {};
      let changes = [];
      let previous = this.data[i3];
      let current = 0;
      for (let j2 = i3; j2 < i3 + this.data.length; j2 += this.width) {
        let value = this.data[j2];
        if (previous !== value) {
          previous = value;
          changes.push(current);
          current = 0;
        }
        current++;
        if (value > 0) {
          info.positivePixel++;
          if (!positives[value]) {
            positives[value] = true;
          }
        } else if (value < 0) {
          info.negativePixel++;
          if (!negatives[value]) {
            negatives[value] = true;
          }
        } else {
          info.zeroPixel++;
        }
      }
      changes.push(current);
      info.medianChange = changes.sort((a3, b2) => a3 - b2)[Math.floor(changes.length / 2)];
      info.positiveRoiIDs = Object.keys(positives);
      info.negativeRoiIDs = Object.keys(negatives);
      info.positiveRoi = info.positiveRoiIDs.length;
      info.negativeRoi = info.negativeRoiIDs.length;
    }
    return colsInfo;
  }
};

// node_modules/image-js/src/image/roi/creator/fromMask.js
function fromMask(mask2, options = {}) {
  const { allowCorners = false } = options;
  const MAX_ARRAY = 65535;
  let data = new Int16Array(mask2.size);
  let positiveID = 0;
  let negativeID = 0;
  let xToProcess = new Uint16Array(MAX_ARRAY + 1);
  let yToProcess = new Uint16Array(MAX_ARRAY + 1);
  for (let x2 = 0; x2 < mask2.width; x2++) {
    for (let y3 = 0; y3 < mask2.height; y3++) {
      if (data[y3 * mask2.width + x2] === 0) {
        analyseSurface(x2, y3);
      }
    }
  }
  function analyseSurface(x2, y3) {
    let from = 0;
    let to = 0;
    let targetState = mask2.getBitXY(x2, y3);
    let id = targetState ? ++positiveID : --negativeID;
    if (positiveID > 32767 || negativeID < -32768) {
      throw new Error("Too many regions of interest");
    }
    xToProcess[0] = x2;
    yToProcess[0] = y3;
    while (from <= to) {
      let currentX = xToProcess[from & MAX_ARRAY];
      let currentY = yToProcess[from & MAX_ARRAY];
      data[currentY * mask2.width + currentX] = id;
      if (currentX > 0 && data[currentY * mask2.width + currentX - 1] === 0 && mask2.getBitXY(currentX - 1, currentY) === targetState) {
        to++;
        xToProcess[to & MAX_ARRAY] = currentX - 1;
        yToProcess[to & MAX_ARRAY] = currentY;
        data[currentY * mask2.width + currentX - 1] = -32768;
      }
      if (currentY > 0 && data[(currentY - 1) * mask2.width + currentX] === 0 && mask2.getBitXY(currentX, currentY - 1) === targetState) {
        to++;
        xToProcess[to & MAX_ARRAY] = currentX;
        yToProcess[to & MAX_ARRAY] = currentY - 1;
        data[(currentY - 1) * mask2.width + currentX] = -32768;
      }
      if (currentX < mask2.width - 1 && data[currentY * mask2.width + currentX + 1] === 0 && mask2.getBitXY(currentX + 1, currentY) === targetState) {
        to++;
        xToProcess[to & MAX_ARRAY] = currentX + 1;
        yToProcess[to & MAX_ARRAY] = currentY;
        data[currentY * mask2.width + currentX + 1] = -32768;
      }
      if (currentY < mask2.height - 1 && data[(currentY + 1) * mask2.width + currentX] === 0 && mask2.getBitXY(currentX, currentY + 1) === targetState) {
        to++;
        xToProcess[to & MAX_ARRAY] = currentX;
        yToProcess[to & MAX_ARRAY] = currentY + 1;
        data[(currentY + 1) * mask2.width + currentX] = -32768;
      }
      if (allowCorners) {
        if (currentX > 0 && currentY > 0 && data[(currentY - 1) * mask2.width + currentX - 1] === 0 && mask2.getBitXY(currentX - 1, currentY - 1) === targetState) {
          to++;
          xToProcess[to & MAX_ARRAY] = currentX - 1;
          yToProcess[to & MAX_ARRAY] = currentY - 1;
          data[(currentY - 1) * mask2.width + currentX - 1] = -32768;
        }
        if (currentX < mask2.width - 1 && currentY > 0 && data[(currentY - 1) * mask2.width + currentX + 1] === 0 && mask2.getBitXY(currentX + 1, currentY - 1) === targetState) {
          to++;
          xToProcess[to & MAX_ARRAY] = currentX + 1;
          yToProcess[to & MAX_ARRAY] = currentY - 1;
          data[(currentY - 1) * mask2.width + currentX + 1] = -32768;
        }
        if (currentX > 0 && currentY < mask2.height - 1 && data[(currentY + 1) * mask2.width + currentX - 1] === 0 && mask2.getBitXY(currentX - 1, currentY + 1) === targetState) {
          to++;
          xToProcess[to & MAX_ARRAY] = currentX - 1;
          yToProcess[to & MAX_ARRAY] = currentY + 1;
          data[(currentY + 1) * mask2.width + currentX - 1] = -32768;
        }
        if (currentX < mask2.width - 1 && currentY < mask2.height - 1 && data[(currentY + 1) * mask2.width + currentX + 1] === 0 && mask2.getBitXY(currentX + 1, currentY + 1) === targetState) {
          to++;
          xToProcess[to & MAX_ARRAY] = currentX + 1;
          yToProcess[to & MAX_ARRAY] = currentY + 1;
          data[(currentY + 1) * mask2.width + currentX + 1] = -32768;
        }
      }
      from++;
      if (to - from > MAX_ARRAY) {
        throw new Error(
          "analyseMask can not finish, the array to manage internal data is not big enough.You could improve mask by changing MAX_ARRAY"
        );
      }
    }
  }
  return new RoiMap(mask2, data);
}

// node_modules/image-js/src/image/roi/creator/fromMaskConnectedComponentLabelingAlgorithm.js
var import_ml_disjoint_set = __toESM(require_DisjointSet());
var direction4X = [-1, 0];
var direction4Y = [0, -1];
var neighbours4 = [null, null];
var direction8X = [-1, -1, 0, 1];
var direction8Y = [0, -1, -1, -1];
var neighbours8 = [null, null, null, null];
function fromMaskConnectedComponentLabelingAlgorithm(mask2, options = {}) {
  const { allowCorners = false } = options;
  let neighbours = 4;
  if (allowCorners) {
    neighbours = 8;
  }
  let directionX;
  let directionY;
  let neighboursList;
  if (neighbours === 8) {
    directionX = direction8X;
    directionY = direction8Y;
    neighboursList = neighbours8;
  } else if (neighbours === 4) {
    directionX = direction4X;
    directionY = direction4Y;
    neighboursList = neighbours4;
  } else {
    throw new RangeError(`unsupported neighbours count: ${neighbours}`);
  }
  const size = mask2.size;
  const width = mask2.width;
  const height = mask2.height;
  const labels = new Array(size);
  const data = new Uint32Array(size);
  const linked = new import_ml_disjoint_set.default();
  let currentLabel = 1;
  for (let j2 = 0; j2 < height; j2++) {
    for (let i3 = 0; i3 < width; i3++) {
      const index2 = i3 + j2 * width;
      if (mask2.getBit(index2)) {
        let smallestNeighbour = null;
        for (let k2 = 0; k2 < neighboursList.length; k2++) {
          const ii = i3 + directionX[k2];
          const jj = j2 + directionY[k2];
          if (ii >= 0 && jj >= 0 && ii < width && jj < height) {
            const index3 = ii + jj * width;
            let neighbour = labels[index3];
            if (!neighbour) {
              neighboursList[k2] = null;
            } else {
              neighboursList[k2] = neighbour;
              if (!smallestNeighbour || neighboursList[k2].value < smallestNeighbour.value) {
                smallestNeighbour = neighboursList[k2];
              }
            }
          }
        }
        if (!smallestNeighbour) {
          labels[index2] = linked.add(currentLabel++);
        } else {
          labels[index2] = smallestNeighbour;
          for (let k2 = 0; k2 < neighboursList.length; k2++) {
            if (neighboursList[k2] && neighboursList[k2] !== smallestNeighbour) {
              linked.union(smallestNeighbour, neighboursList[k2]);
            }
          }
        }
      }
    }
  }
  for (let j2 = 0; j2 < height; j2++) {
    for (let i3 = 0; i3 < width; i3++) {
      const index2 = i3 + j2 * width;
      if (mask2.getBit(index2)) {
        data[index2] = linked.find(labels[index2]).value;
      }
    }
  }
  return new RoiMap(mask2, data);
}

// node_modules/image-js/src/image/roi/creator/fromMaxima.js
function fromMaxima(options = {}) {
  let { allowCorner = true, onlyTop = false, invert: invert2 = false } = options;
  let image = this;
  image.checkProcessable("fromMaxima", { components: [1] });
  const PROCESS_TOP = 1;
  const PROCESS_NORMAL = 2;
  let positiveID = 0;
  let negativeID = 0;
  let data = new Int16Array(image.size);
  let processed = new Int8Array(image.size);
  let variations = new Float32Array(image.size);
  let MAX_ARRAY = 1048575;
  let xToProcess = new Uint16Array(MAX_ARRAY + 1);
  let yToProcess = new Uint16Array(MAX_ARRAY + 1);
  let from = 0;
  let to = 0;
  let xToProcessTop = new Uint16Array(MAX_ARRAY + 1);
  let yToProcessTop = new Uint16Array(MAX_ARRAY + 1);
  let fromTop = 0;
  let toTop = 0;
  appendMaxima(image, { maxima: !invert2 });
  while (from < to) {
    let currentX = xToProcess[from & MAX_ARRAY];
    let currentY = yToProcess[from & MAX_ARRAY];
    process2(currentX, currentY, PROCESS_NORMAL);
    from++;
  }
  return new RoiMap(image, data);
  function appendMaxima({ maxima = true }) {
    for (let y3 = 1; y3 < image.height - 1; y3++) {
      for (let x2 = 1; x2 < image.width - 1; x2++) {
        let index2 = x2 + y3 * image.width;
        if (processed[index2] === 0) {
          let currentValue = maxima ? image.data[index2] : -image.data[x2 + y3 * image.width];
          if (image.data[y3 * image.width + x2 - 1] > currentValue) {
            continue;
          }
          if (image.data[y3 * image.width + x2 + 1] > currentValue) {
            continue;
          }
          if (image.data[(y3 - 1) * image.width + x2] > currentValue) {
            continue;
          }
          if (image.data[(y3 + 1) * image.width + x2] > currentValue) {
            continue;
          }
          if (allowCorner) {
            if (image.data[(y3 - 1) * image.width + x2 - 1] > currentValue) {
              continue;
            }
            if (image.data[(y3 - 1) * image.width + x2 + 1] > currentValue) {
              continue;
            }
            if (image.data[(y3 + 1) * image.width + x2 - 1] > currentValue) {
              continue;
            }
            if (image.data[(y3 + 1) * image.width + x2 + 1] > currentValue) {
              continue;
            }
          }
          data[index2] = maxima ? ++positiveID : --negativeID;
          let valid = processTop(x2, y3, PROCESS_TOP);
          if (!valid) {
            if (maxima) {
              --positiveID;
            } else {
              ++negativeID;
            }
          }
        }
      }
    }
  }
  function processTop(xToProcess2, yToProcess2) {
    let currentTo = to;
    fromTop = 0;
    toTop = 1;
    xToProcessTop[0] = xToProcess2;
    yToProcessTop[0] = yToProcess2;
    let valid = true;
    while (fromTop < toTop) {
      let currentX = xToProcessTop[fromTop & MAX_ARRAY];
      let currentY = yToProcessTop[fromTop & MAX_ARRAY];
      valid &= process2(currentX, currentY, PROCESS_TOP);
      fromTop++;
    }
    if (!valid) {
      for (let i3 = 0; i3 < toTop; i3++) {
        let currentX = xToProcessTop[i3 & MAX_ARRAY];
        let currentY = yToProcessTop[i3 & MAX_ARRAY];
        let index2 = currentY * image.width + currentX;
        data[index2] = 0;
      }
      to = currentTo;
    }
    return valid;
  }
  function process2(xCenter, yCenter, type) {
    let currentID = data[yCenter * image.width + xCenter];
    let currentValue = image.data[yCenter * image.width + xCenter];
    for (let y3 = yCenter - 1; y3 <= yCenter + 1; y3++) {
      for (let x2 = xCenter - 1; x2 <= xCenter + 1; x2++) {
        let index2 = y3 * image.width + x2;
        if (processed[index2] === 0) {
          processed[index2] = 1;
          variations[index2] = image.data[index2] - currentValue;
          switch (type) {
            case PROCESS_TOP:
              if (variations[index2] === 0) {
                if (x2 === 0 || y3 === 0 || x2 === image.width - 1 || y3 === image.height - 1) {
                  return false;
                }
                data[index2] = currentID;
                xToProcessTop[toTop & MAX_ARRAY] = x2;
                yToProcessTop[toTop & MAX_ARRAY] = y3;
                toTop++;
              } else if (variations[index2] > 0) {
                return false;
              } else {
                if (!onlyTop) {
                  data[index2] = currentID;
                  xToProcess[to & MAX_ARRAY] = x2;
                  yToProcess[to & MAX_ARRAY] = y3;
                  to++;
                }
              }
              break;
            case PROCESS_NORMAL:
              if (variations[index2] <= 0) {
                data[index2] = currentID;
                xToProcess[to & MAX_ARRAY] = x2;
                yToProcess[to & MAX_ARRAY] = y3;
                to++;
              }
              break;
            default:
              throw new Error("unreachable");
          }
        }
      }
    }
    return true;
  }
}

// node_modules/image-js/src/image/roi/creator/fromPoints.js
function fromPoints(pointsToPaint, options = {}) {
  let shape = new Shape(options);
  let data = new Int16Array(this.size);
  let positiveID = 0;
  let shapePoints = shape.getPoints();
  for (let i3 = 0; i3 < pointsToPaint.length; i3++) {
    positiveID++;
    let xP = pointsToPaint[i3][0];
    let yP = pointsToPaint[i3][1];
    for (let j2 = 0; j2 < shapePoints.length; j2++) {
      let xS = shapePoints[j2][0];
      let yS = shapePoints[j2][1];
      if (xP + xS >= 0 && yP + yS >= 0 && xP + xS < this.width && yP + yS < this.height) {
        data[xP + xS + (yP + yS) * this.width] = positiveID;
      }
    }
  }
  return new RoiMap(this, data);
}

// node_modules/image-js/src/image/roi/creator/fromWaterShed.js
var import_js_priority_queue = __toESM(require_priority_queue());

// node_modules/image-js/src/util/dxdy.js
var dxs = [1, 0, -1, 0, 1, 1, -1, -1];
var dys = [0, 1, 0, -1, 1, -1, 1, -1];

// node_modules/image-js/src/image/roi/creator/fromWaterShed.js
function fromWaterShed(options = {}) {
  let {
    points: points2,
    mask: mask2,
    image,
    fillMaxValue = this.maxValue,
    invert: invert2 = false
  } = options;
  let currentImage = image || this;
  currentImage.checkProcessable("fromWaterShed", {
    bitDepth: [8, 16],
    components: 1
  });
  invert2 = !invert2;
  if (!points2) {
    points2 = currentImage.getLocalMaxima({
      invert: invert2,
      mask: mask2
    });
  }
  let maskExpectedValue = invert2 ? 0 : 1;
  let data = new Int16Array(currentImage.size);
  let width = currentImage.width;
  let height = currentImage.height;
  let toProcess = new import_js_priority_queue.default({
    comparator: (a3, b2) => a3[2] - b2[2],
    strategy: import_js_priority_queue.default.BinaryHeapStrategy
  });
  for (let i3 = 0; i3 < points2.length; i3++) {
    let index2 = points2[i3][0] + points2[i3][1] * width;
    data[index2] = i3 + 1;
    let intensity = currentImage.data[index2];
    if (invert2 && intensity <= fillMaxValue || !invert2 && intensity >= fillMaxValue) {
      toProcess.queue([points2[i3][0], points2[i3][1], intensity]);
    }
  }
  while (toProcess.length > 0) {
    let currentPoint = toProcess.dequeue();
    let currentValueIndex = currentPoint[0] + currentPoint[1] * width;
    for (let dir = 0; dir < 4; dir++) {
      let newX = currentPoint[0] + dxs[dir];
      let newY = currentPoint[1] + dys[dir];
      if (newX >= 0 && newY >= 0 && newX < width && newY < height) {
        let currentNeighbourIndex = newX + newY * width;
        if (!mask2 || mask2.getBit(currentNeighbourIndex) === maskExpectedValue) {
          let intensity = currentImage.data[currentNeighbourIndex];
          if (invert2 && intensity <= fillMaxValue || !invert2 && intensity >= fillMaxValue) {
            if (data[currentNeighbourIndex] === 0) {
              data[currentNeighbourIndex] = data[currentValueIndex];
              toProcess.queue([
                currentPoint[0] + dxs[dir],
                currentPoint[1] + dys[dir],
                intensity
              ]);
            }
          }
        }
      }
    }
  }
  return new RoiMap(currentImage, data);
}

// node_modules/image-js/src/image/roi/manager.js
var RoiManager = class {
  constructor(image, options = {}) {
    this._image = image;
    this._options = options;
    if (!this._options.label) {
      this._options.label = "default";
    }
    this._layers = {};
    this._painted = null;
  }
  // docs is in the corresponding file
  fromMaxima(options = {}) {
    let opt = Object.assign({}, this._options, options);
    let roiMap = fromMaxima.call(this._image, options);
    this._layers[opt.label] = new RoiLayer(roiMap, opt);
  }
  // docs is in the corresponding file
  fromPoints(points2, options = {}) {
    let opt = Object.assign({}, this._options, options);
    let roiMap = fromPoints.call(this._image, points2, options);
    this._layers[opt.label] = new RoiLayer(roiMap, opt);
    return this;
  }
  /**
   * @param {number[]} map
   * @param {object} [options]
   * @return {this}
   */
  putMap(map, options = {}) {
    let roiMap = new RoiMap(this._image, map);
    let opt = Object.assign({}, this._options, options);
    this._layers[opt.label] = new RoiLayer(roiMap, opt);
    return this;
  }
  // docs is in the corresponding file
  fromWaterShed(options = {}) {
    let opt = Object.assign({}, this._options, options);
    let roiMap = fromWaterShed.call(this._image, options);
    this._layers[opt.label] = new RoiLayer(roiMap, opt);
  }
  // docs is in the corresponding file
  fromMask(mask2, options = {}) {
    let opt = Object.assign({}, this._options, options);
    let roiMap = fromMask.call(this._image, mask2, options);
    this._layers[opt.label] = new RoiLayer(roiMap, opt);
    return this;
  }
  fromMaskConnectedComponentLabelingAlgorithm(mask2, options = {}) {
    let opt = Object.assign({}, this._options, options);
    let roiMap = fromMaskConnectedComponentLabelingAlgorithm.call(
      this._image,
      mask2,
      options
    );
    this._layers[opt.label] = new RoiLayer(roiMap, opt);
    return this;
  }
  /**
   *
   * @param {object} [options]
   * @return {RoiMap}
   */
  getMap(options = {}) {
    let opt = Object.assign({}, this._options, options);
    this._assertLayerWithLabel(opt.label);
    return this._layers[opt.label].roiMap;
  }
  /**
   * Return statistics about rows
   * @param {object} [options]
   * @return {object[]}
   */
  rowsInfo(options = {}) {
    return this.getMap(options).rowsInfo();
  }
  /**
   * Return statistics about columns
   * @param {object} [options]
   * @return {object[]}
   */
  colsInfo(options = {}) {
    return this.getMap(options).rowsInfo();
  }
  /**
   * Return the IDs of the Regions Of Interest (Roi) as an array of number
   * @param {object} [options]
   * @return {number[]}
   */
  getRoiIds(options = {}) {
    let rois = this.getRois(options);
    if (rois) {
      let ids = new Array(rois.length);
      for (let i3 = 0; i3 < rois.length; i3++) {
        ids[i3] = rois[i3].id;
      }
      return ids;
    }
    throw new Error("ROIs not found");
  }
  /**
   * Allows to select ROI based on size, label and sign.
   * @param {object} [options={}]
   * @param {string} [options.label='default'] Label of the layer containing the ROI
   * @param {boolean} [options.positive=true] Select the positive region of interest
   * @param {boolean} [options.negative=true] Select he negative region of interest
   * @param {number} [options.minSurface=0]
   * @param {number} [options.maxSurface=Number.POSITIVE_INFINITY]
   * @param {number} [options.minWidth=0]
   * @param {number} [options.minHeight=Number.POSITIVE_INFINITY]
   * @param {number} [options.maxWidth=0]
   * @param {number} [options.maxHeight=Number.POSITIVE_INFINITY]
   * @param {number} [options.minRatio=0] Ratio width / height
   * @param {number} [options.maxRatio=Number.POSITIVE_INFINITY]
   * @return {Roi[]}
   */
  getRois(options = {}) {
    let {
      label = this._options.label,
      positive = true,
      negative = true,
      minSurface = 0,
      maxSurface = Number.POSITIVE_INFINITY,
      minWidth = 0,
      maxWidth = Number.POSITIVE_INFINITY,
      minHeight = 0,
      maxHeight = Number.POSITIVE_INFINITY,
      minRatio = 0,
      maxRatio = Number.POSITIVE_INFINITY
    } = options;
    if (!this._layers[label]) {
      throw new Error(`this Roi layer (${label}) does not exist`);
    }
    const allRois = this._layers[label].roi;
    const rois = [];
    for (const roi of allRois) {
      if ((roi.id < 0 && negative || roi.id > 0 && positive) && roi.surface >= minSurface && roi.surface <= maxSurface && roi.width >= minWidth && roi.width <= maxWidth && roi.height >= minHeight && roi.height <= maxHeight && roi.ratio >= minRatio && roi.ratio <= maxRatio) {
        rois.push(roi);
      }
    }
    return rois;
  }
  /**
   * Get an ROI by its id.
   * @param {number} roiId
   * @param {object} [options={}]
   * @param {string} [options.label='default'] Label of the layer containing the ROI
   * @return {Roi}
   */
  getRoi(roiId, options = {}) {
    const { label = this._options.label } = options;
    if (!this._layers[label]) {
      throw new Error(`this Roi layer (${label}) does not exist`);
    }
    const roi = this._layers[label].roi.find((roi2) => roi2.id === roiId);
    if (!roi) {
      throw new Error(`found no Roi with id ${roiId}`);
    }
    return roi;
  }
  /**
   * Returns an array of masks
   * See {@link Roi.getMask} for the options
   * @param {object} [options]
   * @return {Image[]} Retuns an array of masks (1 bit Image)
   */
  getMasks(options = {}) {
    let rois = this.getRois(options);
    let masks = new Array(rois.length);
    for (let i3 = 0; i3 < rois.length; i3++) {
      masks[i3] = rois[i3].getMask(options);
    }
    return masks;
  }
  /**
   * Returns an array of masks
   * See {@link Roi.getAnalysisMasks} for the options
   * @param {object} [options]
   * @return {Image[]} Retuns an array of masks (1 bit Image)
   */
  getAnalysisMasks(options = {}) {
    const { analysisProperty } = options;
    let maskProperty = `${analysisProperty}Mask`;
    let rois = this.getRois(options);
    if (rois.length === 0 || !rois[0][maskProperty])
      return [];
    return rois.map((roi) => roi[maskProperty]);
  }
  /**
   *
   * @param {object} [options]
   * @return {number[]}
   */
  getData(options = {}) {
    let opt = Object.assign({}, this._options, options);
    this._assertLayerWithLabel(opt.label);
    return this._layers[opt.label].roiMap.data;
  }
  /**
   * Paint the ROI on a copy of the image and return this image.
   * For painting options {@link Image.paintMasks}
   * For ROI selection options, see {@link RoiManager.getMasks}
   * @param {object} [options] - all the options to select ROIs
   * @param {string} [options.labelProperty] - Paint a mask property on the image.
   *                                  May be any property of the ROI like
   *                                  for example id, surface, width, height, meanX, meanY.
   * @param {number} [options.pixelSize] Size of a pixel in SI
   * @param {string} [options.unit="pixel"] Unit in which to display the values
   * @return {Image} - The painted RGBA 8 bits image
   */
  paint(options = {}) {
    let { labelProperty, analysisProperty } = options;
    if (!this._painted) {
      this._painted = this._image.rgba8();
    }
    let masks = this.getMasks(options);
    if (labelProperty) {
      const rois = this.getRois(options);
      options.labels = rois.map((roi) => deepValue(roi, labelProperty));
      const max4 = Math.max(...options.labels);
      let isSurface = false;
      let isDistance = false;
      if (labelProperty.includes("surface")) {
        isSurface = true;
      } else if (/(?:perimeter|min|max|external|width|height|length)/.test(labelProperty)) {
        isDistance = true;
      }
      if (isFinite(max4)) {
        let unitLabel = "";
        if (options.unit !== "pixel" && options.pixelSize && (isDistance || isSurface)) {
          unitLabel = isSurface ? `${options.unit}^2` : options.unit;
          let siLabel = isSurface ? "m^2" : "m";
          let factor = isSurface ? options.pixelSize ** 2 : options.pixelSize;
          const convert = import_js_quantities.default.swiftConverter(siLabel, unitLabel);
          options.labels = options.labels.map((value) => {
            return convert(factor * value);
          });
        }
        if (max4 > 50) {
          options.labels = options.labels.map(
            (number) => Math.round(number) + unitLabel
          );
        } else if (max4 > 10) {
          options.labels = options.labels.map(
            (number) => number.toFixed(1) + unitLabel
          );
        } else {
          options.labels = options.labels.map(
            (number) => number.toFixed(2) + unitLabel
          );
        }
      }
      options.labelsPosition = rois.map((roi) => [roi.meanX, roi.meanY]);
    }
    this._painted.paintMasks(masks, options);
    if (analysisProperty) {
      let analysisMasks = this.getAnalysisMasks(options);
      this._painted.paintMasks(analysisMasks, {
        color: options.analysisColor,
        alpha: options.analysisAlpha
      });
    }
    return this._painted;
  }
  // return a mask corresponding to all the selected masks
  getMask(options = {}) {
    let mask2 = new Image2(this._image.width, this._image.height, {
      kind: "BINARY"
    });
    let masks = this.getMasks(options);
    for (let i3 = 0; i3 < masks.length; i3++) {
      let roi = masks[i3];
      for (let x2 = 0; x2 < roi.width; x2++) {
        for (let y3 = 0; y3 < roi.height; y3++) {
          if (roi.getBitXY(x2, y3)) {
            mask2.setBitXY(x2 + roi.position[0], y3 + roi.position[1]);
          }
        }
      }
    }
    return mask2;
  }
  /**
   * Reset the changes to the current painted iamge to the image that was
   * used during the creation of the RoiManager except if a new image is
   * specified as parameter;
   * @param {object} [options]
   * @param {Image} [options.image] A new iamge that you would like to sue for painting over
   */
  resetPainted(options = {}) {
    const { image } = options;
    if (image) {
      this._painted = this.image.rgba8();
    } else {
      this._painted = this._image.rgba8();
    }
  }
  /**
   * In place modification of the roiMap that joins regions of interest
   * @param {object} [options]
   * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.
   *      Current implemented algorithms are 'commonBorderLength' that use the parameters
   *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses
   *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.
   * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging
   * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging
   * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging
   * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging
   * @return {this}
   */
  mergeRoi(options = {}) {
    const roiMap = this.getMap(options);
    roiMap.mergeRoi(options);
    this.putMap(roiMap.data, options);
    return this;
  }
  /**
   * Merge multiple rois into one.
   * All rois in the provided array will be merged into the first one.
   * @param {Array<number>} roiIds - A list of Roi ids to merge
   * @param {object} [options]
   */
  mergeRois(roiIds, options = {}) {
    if (!Array.isArray(roiIds) || roiIds.some((id) => !Number.isInteger(id))) {
      throw new Error("Roi ids must be an array of integers");
    }
    if (roiIds.length < 2) {
      throw new Error("Roi ids must have at least two elements");
    }
    if (new Set(roiIds).size !== roiIds.length) {
      throw new Error("Roi ids must be all different");
    }
    roiIds.forEach((roiId) => this.getRoi(roiId));
    const roiMap = this.getMap(options);
    roiMap.mergeRois(roiIds);
    this.putMap(roiMap.data, options);
    return this;
  }
  /**
   * Finds all corresponding ROIs for all ROIs in the manager
   * @param {number[]} roiMap
   * @param {object} [options]
   * @return {Array} array of objects returned in correspondingRoisInformation
   */
  findCorrespondingRoi(roiMap, options = {}) {
    let allRois = this.getRois(options);
    let allRelated = [];
    for (let i3 = 0; i3 < allRois.length; i3++) {
      let currentRoi = allRois[i3];
      let x2 = currentRoi.minX;
      let y3 = currentRoi.minY;
      let allPoints = currentRoi.points;
      let roiSign = Math.sign(currentRoi.id);
      let currentRelated = correspondingRoisInformation(
        x2,
        y3,
        allPoints,
        roiMap,
        roiSign
      );
      allRelated.push(currentRelated);
    }
    return allRelated;
  }
  _assertLayerWithLabel(label) {
    if (!this._layers[label]) {
      throw new Error(`no layer with label ${label}`);
    }
  }
};
function correspondingRoisInformation(x2, y3, points2, roiMap, roiSign) {
  let correspondingRois = {
    id: [],
    surface: [],
    roiSurfaceCovered: [],
    same: 0,
    opposite: 0,
    total: 0
  };
  for (let i3 = 0; i3 < points2.length; i3++) {
    let currentPoint = points2[i3];
    let currentX = currentPoint[0];
    let currentY = currentPoint[1];
    let correspondingRoiMapIndex = currentX + x2 + (currentY + y3) * roiMap.width;
    let value = roiMap.data[correspondingRoiMapIndex];
    if (value > 0 || value < 0) {
      if (correspondingRois.id.includes(value)) {
        correspondingRois.surface[correspondingRois.id.indexOf(value)] += 1;
      } else {
        correspondingRois.id.push(value);
        correspondingRois.surface.push(1);
      }
    }
  }
  for (let i3 = 0; i3 < correspondingRois.id.length; i3++) {
    let currentSign = Math.sign(correspondingRois.id[i3]);
    if (currentSign === roiSign) {
      correspondingRois.same += correspondingRois.surface[i3];
    } else {
      correspondingRois.opposite += correspondingRois.surface[i3];
    }
    correspondingRois.roiSurfaceCovered[i3] = correspondingRois.surface[i3] / points2.length;
  }
  correspondingRois.total = correspondingRois.opposite + correspondingRois.same;
  return correspondingRois;
}

// node_modules/image-js/src/image/Image.js
var objectToString = Object.prototype.toString;
var Image2 = class {
  constructor(width, height, data, options) {
    if (arguments.length === 1) {
      options = width;
      ({ width, height, data } = options);
    } else if (data && !data.length) {
      options = data;
      ({ data } = options);
    }
    if (width === void 0)
      width = 1;
    if (height === void 0)
      height = 1;
    if (options === void 0)
      options = {};
    if (typeof options !== "object" || options === null) {
      throw new TypeError("options must be an object");
    }
    if (!Number.isInteger(width) || width <= 0) {
      throw new RangeError("width must be a positive integer");
    }
    if (!Number.isInteger(height) || height <= 0) {
      throw new RangeError("height must be a positive integer");
    }
    const { kind = RGBA } = options;
    if (typeof kind !== "string") {
      throw new TypeError("kind must be a string");
    }
    const theKind = getKind(kind);
    const kindDefinition = Object.assign({}, options);
    for (const prop in theKind) {
      if (kindDefinition[prop] === void 0) {
        kindDefinition[prop] = theKind[prop];
      }
    }
    verifyKindDefinition(kindDefinition);
    const { components, bitDepth, colorModel } = kindDefinition;
    const alpha = kindDefinition.alpha + 0;
    const size = width * height;
    const channels = components + alpha;
    const maxValue = bitDepth === 32 ? Number.MAX_VALUE : 2 ** bitDepth - 1;
    if (data === void 0) {
      data = createPixelArray(
        size,
        components,
        alpha,
        channels,
        bitDepth,
        maxValue
      );
    } else {
      const expectedLength = getTheoreticalPixelArraySize(
        size,
        channels,
        bitDepth
      );
      if (data.length !== expectedLength) {
        throw new RangeError(
          `incorrect data size: ${data.length}. Should be ${expectedLength}`
        );
      }
    }
    this.width = width;
    this.height = height;
    this.data = data;
    this.size = size;
    this.components = components;
    this.alpha = alpha;
    this.bitDepth = bitDepth;
    this.maxValue = maxValue;
    this.colorModel = colorModel;
    this.channels = channels;
    this.meta = options.meta || {};
    Object.defineProperty(this, "parent", {
      enumerable: false,
      writable: true,
      configurable: true,
      value: options.parent || null
    });
    this.position = options.position || [0, 0];
    this.computed = null;
    this.sizes = [this.width, this.height];
    this.multiplierX = this.channels;
    this.multiplierY = this.channels * this.width;
    this.isClamped = this.bitDepth < 32;
    this.borderSizes = [0, 0];
  }
  get [Symbol.toStringTag]() {
    return "IJSImage";
  }
  static isImage(object) {
    return objectToString.call(object) === "[object IJSImage]";
  }
  /**
   * Creates an image from an HTML Canvas object
   * @param {Canvas} canvas
   * @return {Image}
   */
  static fromCanvas(canvas) {
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    return new Image2(imageData.width, imageData.height, imageData.data);
  }
  /**
   * Create a new Image based on the characteristics of another one.
   * @param {Image} other
   * @param {object} [options] - Override options to change some parameters
   * @return {Image}
   * @example
   * const newImage = Image.createFrom(image, { width: 100 });
   */
  static createFrom(other, options) {
    const newOptions = getImageParameters(other);
    Object.assign(
      newOptions,
      {
        parent: other,
        position: [0, 0]
      },
      options
    );
    return new Image2(newOptions);
  }
  /**
   * Create a new manager for regions of interest based on the current image.
   * @param {object} [options]
   * @return {RoiManager}
   */
  getRoiManager(options) {
    return new RoiManager(this, options);
  }
  /**
   * Create a copy a the current image, including its data.
   * @instance
   * @return {Image}
   */
  clone() {
    const newData = this.data.slice();
    return new Image2(this.width, this.height, newData, this);
  }
  apply(filter) {
    for (let y3 = 0; y3 < this.height; y3++) {
      for (let x2 = 0; x2 < this.width; x2++) {
        let index2 = (y3 * this.width + x2) * this.channels;
        filter.call(this, index2);
      }
    }
  }
};
setValueMethods(Image2);
setBitMethods(Image2);
setExportMethods(Image2);
Image2.prototype.checkProcessable = checkProcessable;
Image2.prototype.getRGBAData = getRGBAData;
Image2.load = load;
Image2.extendMethod = extendMethod;
Image2.extendProperty = extendProperty;
extend2(Image2);

// node_modules/image-js/src/browser/worker/worker.js
var import_web_worker_manager = __toESM(require_src6());

// node_modules/image-js/src/browser/worker/process/background.js
var defaultOptions4 = {
  regression: {
    kernelType: "polynomial",
    kernelOptions: { degree: 2, constant: 1 }
  },
  threshold: 0.02,
  roi: {
    minSurface: 100,
    positive: false
  },
  sampling: 20,
  include: []
};
function run(image, options, onStep) {
  options = Object.assign({}, defaultOptions4, options);
  const manager = this.manager;
  if (Array.isArray(image)) {
    return Promise.all(
      image.map(function(img) {
        const run2 = runOnce(manager, img, options);
        if (typeof onStep === "function") {
          run2.then(onStep);
        }
        return run2;
      })
    );
  } else {
    return runOnce(manager, image, options);
  }
}
function runOnce(manager, image, options) {
  return manager.post("data", [image, options]).then(function(response) {
    for (let i3 in response) {
      response[i3] = new Image2(response[i3]);
    }
    return response;
  });
}
function work() {
  worker.on("data", function(send, image, options) {
    image = new IJS(image);
    const result = {};
    const toTransfer = [];
    const grey2 = image.grey();
    const sobel = grey2.sobelFilter();
    maybeInclude("sobel", sobel);
    const mask2 = sobel.level().mask({ threshold: options.threshold });
    maybeInclude("mask", mask2);
    const roiManager = sobel.getRoiManager();
    roiManager.fromMask(mask2);
    const realMask = roiManager.getMask(options.roi);
    maybeInclude("realMask", realMask);
    const pixels = grey2.getPixelsGrid({
      sampling: options.sampling,
      mask: realMask
    });
    const background3 = image.getBackground(
      pixels.xyS,
      pixels.zS,
      options.regression
    );
    maybeInclude("background", background3);
    const corrected = image.subtract(background3);
    result.result = corrected;
    toTransfer.push(corrected.data.buffer);
    send(result, toTransfer);
    function maybeInclude(name, image2) {
      if (options.include.includes(name)) {
        result[name] = image2;
        toTransfer.push(image2.data.buffer);
      }
    }
  });
}
var background2 = { run, work };
var background_default = background2;

// node_modules/image-js/src/browser/worker/extend.js
function extend3(Worker4) {
  Worker4.extendMethod("background", background_default);
}

// node_modules/image-js/src/browser/worker/worker.js
var Worker2 = class {
  constructor() {
    this._url = null;
    this._deps = [null];
  }
  checkUrl() {
    if (this._url === null) {
      throw new Error("image worker must be initialized with an URL");
    }
  }
  get url() {
    return this._url;
  }
  set url(value) {
    if (typeof value !== "string") {
      throw new TypeError("worker URL must be a string");
    }
    this._url = value;
    this._deps[0] = value;
  }
  static extendMethod(name, method) {
    let manager;
    let url;
    let runner = {};
    function run2(...args) {
      if (!manager) {
        this.checkUrl();
        url = this.url;
        manager = new import_web_worker_manager.default(method.work, { deps: url });
        runner.manager = manager;
      }
      return method.run.call(runner, ...args);
    }
    run2.reset = function() {
      if (manager) {
        manager.terminate();
        manager = new import_web_worker_manager.default(method.work, { deps: url });
        runner.manager = manager;
      }
    };
    Worker2.prototype[name] = run2;
  }
};
extend3(Worker2);
var worker_default = new Worker2();

// supernote-typescript/src/conversion.ts
var import_color6 = __toESM(require_color());
var defaultPalette = {
  background: (0, import_color6.default)("transparent"),
  black: (0, import_color6.default)("black"),
  darkGray: (0, import_color6.default)("darkgray"),
  gray: (0, import_color6.default)("gray"),
  white: (0, import_color6.default)("white"),
  markerBlack: (0, import_color6.default)("black"),
  markerDarkGray: (0, import_color6.default)("darkgray"),
  markerGray: (0, import_color6.default)("gray"),
  darkGrayX2: (0, import_color6.default)("darkgray"),
  grayX2: (0, import_color6.default)("gray"),
  markerDarkGrayX2: (0, import_color6.default)("darkgray"),
  markerGrayX2: (0, import_color6.default)("gray")
};

// supernote-typescript/src/mirror.ts
async function fetchMirrorFrame(ipAddress) {
  var _a2;
  const url = `http://${ipAddress}/screencast.mjpeg`;
  const controller = new AbortController();
  const response = await fetch(url, {
    method: "GET",
    signal: controller.signal
  });
  if (!response.ok) {
    throw new Error("Failed to fetch the resource.");
  }
  const contentType = response.headers.get("content-type");
  if (!contentType || !contentType.includes("multipart")) {
    throw new Error("Invalid response. Expected multipart content type.");
  }
  const reader = (_a2 = response.body) == null ? void 0 : _a2.getReader();
  if (!reader) {
    throw new Error("Failed to get reader for response body.");
  }
  let boundary = contentType.split("boundary=")[1];
  if (!boundary) {
    throw new Error("Boundary not found in response headers.");
  }
  let currentPartHeaders = [];
  let buffer = new Uint8Array();
  return new Promise((resolve2, reject2) => {
    let found = false;
    const headerEnd = "\r\n\r\n";
    const processChunk = async (chunk) => {
      buffer = concatUint8Arrays(buffer, chunk);
      let start = new TextDecoder().decode(buffer).indexOf("Content-Type:", 0);
      let end = findBoundary(buffer, boundary, start + 2);
      const part = buffer.slice(start, end);
      const headerEndIndex = new TextDecoder().decode(part).indexOf(headerEnd);
      if (currentPartHeaders.length === 0) {
        if (headerEndIndex !== -1) {
          const headerStr = new TextDecoder().decode(
            part.slice(0, headerEndIndex)
          );
          currentPartHeaders = headerStr.split("\r\n");
        }
      }
      const contentTypeHeader = currentPartHeaders.find(
        (header) => header.toLowerCase().startsWith("content-type:")
      );
      const contentLengthHeader = currentPartHeaders.find(
        (header) => header.toLowerCase().startsWith("content-length:")
      );
      if (contentTypeHeader && contentTypeHeader.includes("image/jpeg")) {
        if (contentLengthHeader) {
          found = true;
          const contentLength = parseInt(
            contentLengthHeader.split(":")[1].trim()
          );
          if (buffer.length < headerEndIndex + contentLength + 1) {
            return;
          }
          const imageData = buffer.slice(
            headerEndIndex + headerEnd.length,
            headerEndIndex + contentLength + 1
          );
          const image = Image2.load(imageData);
          resolve2(image);
          controller.abort();
        }
      }
    };
    const read = async () => {
      const { done, value } = await reader.read();
      const txt = new TextDecoder().decode(value);
      if (done) {
        if (!found) {
          reject2(new Error("No JPEG image found in multipart stream."));
        }
        return;
      }
      await processChunk(value);
      await read();
    };
    read().catch((error) => reject2(error));
  });
}
function findBoundary(data, boundary, startIndex = 0) {
  const boundaryStr = `${boundary}`;
  return new TextDecoder().decode(data).indexOf(boundaryStr);
}
function concatUint8Arrays(a3, b2) {
  const result = new Uint8Array(a3.length + b2.length);
  result.set(a3, 0);
  result.set(b2, a3.length);
  return result;
}

// src/FileListModal.ts
var import_obsidian = require("obsidian");
var FileListModal = class extends import_obsidian.SuggestModal {
  constructor(app, settings) {
    super(app);
    this.files = [];
    this.currentPath = "/";
    this.settings = settings;
    this.setPlaceholder("Select a file to download or directory to open");
  }
  async loadFiles() {
    try {
      const response = await fetch(`http://${this.settings.mirrorIP}:8089${this.currentPath}`);
      if (!response.ok) {
        throw new Error(`Failed to fetch file list: ${response.statusText}`);
      }
      const html = await response.text();
      const match = html.match(/const json = '(.+?)'/);
      if (!match) {
        throw new Error("Could not find file list data");
      }
      const data = JSON.parse(match[1]);
      this.files = data.fileList;
    } catch (err3) {
      new import_obsidian.Notice(`Failed to load files: ${err3.message}`);
      this.close();
    }
  }
  async getSuggestions(query) {
    if (this.files.length === 0) {
      await this.loadFiles();
    }
    return this.files.filter(
      (file) => file.name.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(file, el) {
    const container = el.createDiv({ cls: "suggestion-item" });
    const iconEl = container.createSpan({ cls: "suggestion-icon" });
    iconEl.textContent = file.isDirectory ? "\u{1F4C1}" : "\u{1F4C4}";
    const contentEl = container.createDiv({ cls: "suggestion-content" });
    contentEl.createDiv({ text: file.name, cls: "suggestion-title" });
    if (!file.isDirectory) {
      contentEl.createDiv({
        text: `${this.formatSize(file.size)} - ${file.date}`,
        cls: "suggestion-note"
      });
    } else {
      contentEl.createDiv({
        text: file.date,
        cls: "suggestion-note"
      });
    }
  }
  formatSize(bytes) {
    if (bytes < 1024)
      return bytes + " B";
    if (bytes < 1048576)
      return (bytes / 1024).toFixed(2) + " KB";
    if (bytes < 1073741824)
      return (bytes / 1048576).toFixed(2) + " MB";
    return (bytes / 1073741824).toFixed(2) + " GB";
  }
  async onChooseSuggestion(file) {
    if (file.isDirectory) {
      this.currentPath = file.uri;
      await this.loadFiles();
      this.open();
    } else {
      try {
        const fileResponse = await fetch(`http://${this.settings.mirrorIP}:8089${file.uri}`);
        if (!fileResponse.ok) {
          throw new Error(`Failed to download file: ${fileResponse.statusText}`);
        }
        const buffer = await fileResponse.arrayBuffer();
        const filename = await this.app.fileManager.getAvailablePathForAttachment(file.name);
        const tfile = await this.app.vault.createBinary(filename, buffer);
        new import_obsidian.Notice(`Downloaded ${file.name}`);
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view) {
          const link = this.app.fileManager.generateMarkdownLink(tfile, filename);
          view.editor.replaceSelection(link);
        }
      } catch (err3) {
        new import_obsidian.Notice(`Failed to download file: ${err3.message}`);
      }
    }
  }
};

// node_modules/jspdf/dist/jspdf.es.min.js
init_typeof();

// node_modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b2 = new u16(31);
  for (var i3 = 0; i3 < 31; ++i3) {
    b2[i3] = start += 1 << eb[i3 - 1];
  }
  var r2 = new i32(b2[30]);
  for (var i3 = 1; i3 < 30; ++i3) {
    for (var j2 = b2[i3]; j2 < b2[i3 + 1]; ++j2) {
      r2[j2] = j2 - b2[i3] << 5 | i3;
    }
  }
  return { b: b2, r: r2 };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i3 = 0; i3 < 32768; ++i3) {
  x2 = (i3 & 43690) >> 1 | (i3 & 21845) << 1;
  x2 = (x2 & 52428) >> 2 | (x2 & 13107) << 2;
  x2 = (x2 & 61680) >> 4 | (x2 & 3855) << 4;
  rev[i3] = ((x2 & 65280) >> 8 | (x2 & 255) << 8) >> 1;
}
var x2;
var i3;
var hMap = function(cd, mb, r2) {
  var s3 = cd.length;
  var i3 = 0;
  var l3 = new u16(mb);
  for (; i3 < s3; ++i3) {
    if (cd[i3])
      ++l3[cd[i3] - 1];
  }
  var le2 = new u16(mb);
  for (i3 = 1; i3 < mb; ++i3) {
    le2[i3] = le2[i3 - 1] + l3[i3 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0; i3 < s3; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v3 = le2[cd[i3] - 1]++ << r_1;
        for (var m4 = v3 | (1 << r_1) - 1; v3 <= m4; ++v3) {
          co[rev[v3] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s3);
    for (i3 = 0; i3 < s3; ++i3) {
      if (cd[i3]) {
        co[i3] = rev[le2[cd[i3] - 1]++] >> 15 - cd[i3];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i3 = 0; i3 < 144; ++i3)
  flt[i3] = 8;
var i3;
for (i3 = 144; i3 < 256; ++i3)
  flt[i3] = 9;
var i3;
for (i3 = 256; i3 < 280; ++i3)
  flt[i3] = 7;
var i3;
for (i3 = 280; i3 < 288; ++i3)
  flt[i3] = 8;
var i3;
var fdt = new u8(32);
for (i3 = 0; i3 < 32; ++i3)
  fdt[i3] = 5;
var i3;
var flm = /* @__PURE__ */ hMap(flt, 9, 0);
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max3 = function(a3) {
  var m4 = a3[0];
  for (var i3 = 1; i3 < a3.length; ++i3) {
    if (a3[i3] > m4)
      m4 = a3[i3];
  }
  return m4;
};
var bits = function(d2, p3, m4) {
  var o3 = p3 / 8 | 0;
  return (d2[o3] | d2[o3 + 1] << 8) >> (p3 & 7) & m4;
};
var bits16 = function(d2, p3) {
  var o3 = p3 / 8 | 0;
  return (d2[o3] | d2[o3 + 1] << 8 | d2[o3 + 2] << 16) >> (p3 & 7);
};
var shft = function(p3) {
  return (p3 + 7) / 8 | 0;
};
var slc = function(v3, s3, e2) {
  if (s3 == null || s3 < 0)
    s3 = 0;
  if (e2 == null || e2 > v3.length)
    e2 = v3.length;
  return new u8(v3.subarray(s3, e2));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err2 = function(ind, msg, nt2) {
  var e2 = new Error(msg || ec[ind]);
  e2.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e2, err2);
  if (!nt2)
    throw e2;
  return e2;
};
var inflt = function(dat, st2, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st2.f && !st2.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize2 = noBuf || st2.i != 2;
  var noSt = st2.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l4) {
    var bl = buf.length;
    if (l4 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l4));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s3 = shft(pos) + 4, l3 = dat[s3 - 4] | dat[s3 - 3] << 8, t3 = s3 + l3;
        if (t3 > sl) {
          if (noSt)
            err2(0);
          break;
        }
        if (resize2)
          cbuf(bt2 + l3);
        buf.set(dat.subarray(s3, t3), bt2);
        st2.b = bt2 += l3, st2.p = pos = t3 * 8, st2.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i3 = 0; i3 < hcLen; ++i3) {
          clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max3(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i3 = 0; i3 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s3 = r2 >> 4;
          if (s3 < 16) {
            ldt[i3++] = s3;
          } else {
            var c4 = 0, n3 = 0;
            if (s3 == 16)
              n3 = 3 + bits(dat, pos, 3), pos += 2, c4 = ldt[i3 - 1];
            else if (s3 == 17)
              n3 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s3 == 18)
              n3 = 11 + bits(dat, pos, 127), pos += 7;
            while (n3--)
              ldt[i3++] = c4;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max3(lt2);
        dbt = max3(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        err2(1);
      if (pos > tbts) {
        if (noSt)
          err2(0);
        break;
      }
    }
    if (resize2)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c4 = lm[bits16(dat, pos) & lms], sym = c4 >> 4;
      pos += c4 & 15;
      if (pos > tbts) {
        if (noSt)
          err2(0);
        break;
      }
      if (!c4)
        err2(2);
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add2 = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b2 = fleb[i3];
          add2 = bits(dat, pos, (1 << b2) - 1) + fl[i3];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
        if (!d2)
          err2(3);
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts) {
          if (noSt)
            err2(0);
          break;
        }
        if (resize2)
          cbuf(bt2 + 131072);
        var end = bt2 + add2;
        if (bt2 < dt2) {
          var shift = dl - dt2, dend = Math.min(dt2, end);
          if (shift + bt2 < 0)
            err2(3);
          for (; bt2 < dend; ++bt2)
            buf[bt2] = dict[shift + bt2];
        }
        for (; bt2 < end; ++bt2)
          buf[bt2] = buf[bt2 - dt2];
      }
    }
    st2.l = lm, st2.p = lpos, st2.b = bt2, st2.f = final;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 != buf.length && noBuf ? slc(buf, 0, bt2) : buf.subarray(0, bt2);
};
var wbits = function(d2, p3, v3) {
  v3 <<= p3 & 7;
  var o3 = p3 / 8 | 0;
  d2[o3] |= v3;
  d2[o3 + 1] |= v3 >> 8;
};
var wbits16 = function(d2, p3, v3) {
  v3 <<= p3 & 7;
  var o3 = p3 / 8 | 0;
  d2[o3] |= v3;
  d2[o3 + 1] |= v3 >> 8;
  d2[o3 + 2] |= v3 >> 16;
};
var hTree = function(d2, mb) {
  var t3 = [];
  for (var i3 = 0; i3 < d2.length; ++i3) {
    if (d2[i3])
      t3.push({ s: i3, f: d2[i3] });
  }
  var s3 = t3.length;
  var t22 = t3.slice();
  if (!s3)
    return { t: et, l: 0 };
  if (s3 == 1) {
    var v3 = new u8(t3[0].s + 1);
    v3[t3[0].s] = 1;
    return { t: v3, l: 1 };
  }
  t3.sort(function(a3, b2) {
    return a3.f - b2.f;
  });
  t3.push({ s: -1, f: 25001 });
  var l3 = t3[0], r2 = t3[1], i0 = 0, i1 = 1, i22 = 2;
  t3[0] = { s: -1, f: l3.f + r2.f, l: l3, r: r2 };
  while (i1 != s3 - 1) {
    l3 = t3[t3[i0].f < t3[i22].f ? i0++ : i22++];
    r2 = t3[i0 != i1 && t3[i0].f < t3[i22].f ? i0++ : i22++];
    t3[i1++] = { s: -1, f: l3.f + r2.f, l: l3, r: r2 };
  }
  var maxSym = t22[0].s;
  for (var i3 = 1; i3 < s3; ++i3) {
    if (t22[i3].s > maxSym)
      maxSym = t22[i3].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t3[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i3 = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a3, b2) {
      return tr[b2.s] - tr[a3.s] || a3.f - b2.f;
    });
    for (; i3 < s3; ++i3) {
      var i2_1 = t22[i3].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i3].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i3;
    }
    for (; i3 >= 0 && dt2; --i3) {
      var i2_3 = t22[i3].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n3, l3, d2) {
  return n3.s == -1 ? Math.max(ln(n3.l, l3, d2 + 1), ln(n3.r, l3, d2 + 1)) : l3[n3.s] = d2;
};
var lc = function(c4) {
  var s3 = c4.length;
  while (s3 && !c4[--s3])
    ;
  var cl = new u16(++s3);
  var cli = 0, cln = c4[0], cls = 1;
  var w2 = function(v3) {
    cl[cli++] = v3;
  };
  for (var i3 = 1; i3 <= s3; ++i3) {
    if (c4[i3] == cln && i3 != s3)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c4[i3];
    }
  }
  return { c: cl.subarray(0, cli), n: s3 };
};
var clen = function(cf, cl) {
  var l3 = 0;
  for (var i3 = 0; i3 < cl.length; ++i3)
    l3 += cf[i3] * cl[i3];
  return l3;
};
var wfblk = function(out, pos, dat) {
  var s3 = dat.length;
  var o3 = shft(pos + 2);
  out[o3] = s3 & 255;
  out[o3 + 1] = s3 >> 8;
  out[o3 + 2] = out[o3] ^ 255;
  out[o3 + 3] = out[o3 + 1] ^ 255;
  for (var i3 = 0; i3 < s3; ++i3)
    out[o3 + i3 + 4] = dat[i3];
  return (o3 + 4 + s3) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li2, bs, bl, p3) {
  wbits(out, p3++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i3 = 0; i3 < lclt.length; ++i3)
    ++lcfreq[lclt[i3] & 31];
  for (var i3 = 0; i3 < lcdt.length; ++i3)
    ++lcfreq[lcdt[i3] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p3, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p3, 1 + (dtlen < ftlen)), p3 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p3, nlc - 257);
    wbits(out, p3 + 5, ndc - 1);
    wbits(out, p3 + 10, nlcc - 4);
    p3 += 14;
    for (var i3 = 0; i3 < nlcc; ++i3)
      wbits(out, p3 + 3 * i3, lct[clim[i3]]);
    p3 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i3 = 0; i3 < clct.length; ++i3) {
        var len = clct[i3] & 31;
        wbits(out, p3, llm[len]), p3 += lct[len];
        if (len > 15)
          wbits(out, p3, clct[i3] >> 5 & 127), p3 += clct[i3] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i3 = 0; i3 < li2; ++i3) {
    var sym = syms[i3];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p3, lm[len + 257]), p3 += ll[len + 257];
      if (len > 7)
        wbits(out, p3, sym >> 23 & 31), p3 += fleb[len];
      var dst = sym & 31;
      wbits16(out, p3, dm[dst]), p3 += dl[dst];
      if (dst > 3)
        wbits16(out, p3, sym >> 5 & 8191), p3 += fdeb[dst];
    } else {
      wbits16(out, p3, lm[sym]), p3 += ll[sym];
    }
  }
  wbits16(out, p3, lm[256]);
  return p3 + ll[256];
};
var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st2) {
  var s3 = st2.z || dat.length;
  var o3 = new u8(pre + s3 + 5 * (1 + Math.ceil(s3 / 7e3)) + post);
  var w2 = o3.subarray(pre, o3.length - post);
  var lst = st2.l;
  var pos = (st2.r || 0) & 7;
  if (lvl) {
    if (pos)
      w2[0] = st2.r >> 3;
    var opt = deo[lvl - 1];
    var n3 = opt >> 13, c4 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st2.p || new u16(32768), head = st2.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i4) {
      return (dat[i4] ^ dat[i4 + 1] << bs1_1 ^ dat[i4 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i3 = st2.i || 0, li2 = 0, wi = st2.w || 0, bs = 0;
    for (; i3 + 2 < s3; ++i3) {
      var hv = hsh(i3);
      var imod = i3 & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i3) {
        var rem = s3 - i3;
        if ((lc_1 > 7e3 || li2 > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li2, bs, i3 - bs, pos);
          li2 = lc_1 = eb = 0, bs = i3;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l3 = 2, d2 = 0, ch_1 = c4, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i3 - dif)) {
          var maxn = Math.min(n3, rem) - 1;
          var maxd = Math.min(32767, i3);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i3 + l3] == dat[i3 + l3 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i3 + nl] == dat[i3 + nl - dif]; ++nl)
                ;
              if (nl > l3) {
                l3 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i3 - dif + j2 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d2) {
          syms[li2++] = 268435456 | revfl[l3] << 18 | revfd[d2];
          var lin = revfl[l3] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i3 + l3;
          ++lc_1;
        } else {
          syms[li2++] = dat[i3];
          ++lf[dat[i3]];
        }
      }
    }
    for (i3 = Math.max(i3, wi); i3 < s3; ++i3) {
      syms[li2++] = dat[i3];
      ++lf[dat[i3]];
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li2, bs, i3 - bs, pos);
    if (!lst) {
      st2.r = pos & 7 | w2[pos / 8 | 0] << 3;
      pos -= 7;
      st2.h = head, st2.p = prev, st2.i = i3, st2.w = wi;
    }
  } else {
    for (var i3 = st2.w || 0; i3 < s3 + lst; i3 += 65535) {
      var e2 = i3 + 65535;
      if (e2 >= s3) {
        w2[pos / 8 | 0] = lst;
        e2 = s3;
      }
      pos = wfblk(w2, pos + 1, dat.subarray(i3, e2));
    }
    st2.i = s3;
  }
  return slc(o3, 0, pre + shft(pos) + post);
};
var adler = function() {
  var a3 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n3 = a3, m4 = b2;
      var l3 = d2.length | 0;
      for (var i3 = 0; i3 != l3; ) {
        var e2 = Math.min(i3 + 2655, l3);
        for (; i3 < e2; ++i3)
          m4 += n3 += d2[i3];
        n3 = (n3 & 65535) + 15 * (n3 >> 16), m4 = (m4 & 65535) + 15 * (m4 >> 16);
      }
      a3 = n3, b2 = m4;
    },
    d: function() {
      a3 %= 65521, b2 %= 65521;
      return (a3 & 255) << 24 | (a3 & 65280) << 8 | (b2 & 255) << 8 | b2 >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st2) {
  if (!st2) {
    st2 = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st2.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st2.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st2);
};
var wbytes = function(d2, b2, v3) {
  for (; v3; ++b2)
    d2[b2] = v3, v3 >>>= 8;
};
var zlh = function(c4, o3) {
  var lv = o3.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c4[0] = 120, c4[1] = fl2 << 6 | (o3.dictionary && 32);
  c4[1] |= 31 - (c4[0] << 8 | c4[1]) % 31;
  if (o3.dictionary) {
    var h3 = adler();
    h3.p(o3.dictionary);
    wbytes(c4, 2, h3.d());
  }
};
var zls = function(d2, dict) {
  if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    err2(6, "invalid zlib data");
  if ((d2[1] >> 5 & 1) == +!dict)
    err2(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d2[1] >> 3 & 4) + 2;
};
function zlibSync(data, opts) {
  if (!opts)
    opts = {};
  var a3 = adler();
  a3.p(data);
  var d2 = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a3.d()), d2;
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e2) {
}

// node_modules/jspdf/dist/jspdf.es.min.js
var n2 = function() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
}();
function i2() {
  n2.console && "function" == typeof n2.console.log && n2.console.log.apply(n2.console, arguments);
}
var a2 = { log: i2, warn: function(t3) {
  n2.console && ("function" == typeof n2.console.warn ? n2.console.warn.apply(n2.console, arguments) : i2.call(null, arguments));
}, error: function(t3) {
  n2.console && ("function" == typeof n2.console.error ? n2.console.error.apply(n2.console, arguments) : i2(t3));
} };
function o2(t3, e2, r2) {
  var n3 = new XMLHttpRequest();
  n3.open("GET", t3), n3.responseType = "blob", n3.onload = function() {
    l2(n3.response, e2, r2);
  }, n3.onerror = function() {
    a2.error("could not download file");
  }, n3.send();
}
function s2(t3) {
  var e2 = new XMLHttpRequest();
  e2.open("HEAD", t3, false);
  try {
    e2.send();
  } catch (t4) {
  }
  return e2.status >= 200 && e2.status <= 299;
}
function c3(t3) {
  try {
    t3.dispatchEvent(new MouseEvent("click"));
  } catch (r2) {
    var e2 = document.createEvent("MouseEvents");
    e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t3.dispatchEvent(e2);
  }
}
var u2;
var h2;
var l2 = n2.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof(window)) || window !== n2 ? function() {
} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t3, e2, r2) {
  var i3 = n2.URL || n2.webkitURL, a3 = document.createElement("a");
  e2 = e2 || t3.name || "download", a3.download = e2, a3.rel = "noopener", "string" == typeof t3 ? (a3.href = t3, a3.origin !== location.origin ? s2(a3.href) ? o2(t3, e2, r2) : c3(a3, a3.target = "_blank") : c3(a3)) : (a3.href = i3.createObjectURL(t3), setTimeout(function() {
    i3.revokeObjectURL(a3.href);
  }, 4e4), setTimeout(function() {
    c3(a3);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e2, r2, n3) {
  if (r2 = r2 || e2.name || "download", "string" == typeof e2)
    if (s2(e2))
      o2(e2, r2, n3);
    else {
      var i3 = document.createElement("a");
      i3.href = e2, i3.target = "_blank", setTimeout(function() {
        c3(i3);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(e3, r3) {
      return void 0 === r3 ? r3 = { autoBom: false } : "object" !== _typeof(r3) && (a2.warn("Deprecated: Expected third argument to be a object"), r3 = { autoBom: !r3 }), r3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
    }(e2, n3), r2);
} : function(e2, r2, i3, a3) {
  if ((a3 = a3 || open("", "_blank")) && (a3.document.title = a3.document.body.innerText = "downloading..."), "string" == typeof e2)
    return o2(e2, r2, i3);
  var s3 = "application/octet-stream" === e2.type, c4 = /constructor/i.test(n2.HTMLElement) || n2.safari, u3 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u3 || s3 && c4) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof(FileReader))) {
    var h3 = new FileReader();
    h3.onloadend = function() {
      var t3 = h3.result;
      t3 = u3 ? t3 : t3.replace(/^data:[^;]*;/, "data:attachment/file;"), a3 ? a3.location.href = t3 : location = t3, a3 = null;
    }, h3.readAsDataURL(e2);
  } else {
    var l3 = n2.URL || n2.webkitURL, f3 = l3.createObjectURL(e2);
    a3 ? a3.location = f3 : location.href = f3, a3 = null, setTimeout(function() {
      l3.revokeObjectURL(f3);
    }, 4e4);
  }
});
function f2(t3) {
  var e2;
  t3 = t3 || "", this.ok = false, "#" == t3.charAt(0) && (t3 = t3.substr(1, 6));
  t3 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t3 = (t3 = t3.replace(/ /g, "")).toLowerCase()] || t3;
  for (var r2 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t4) {
    return [parseInt(t4[1]), parseInt(t4[2]), parseInt(t4[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t4) {
    return [parseInt(t4[1], 16), parseInt(t4[2], 16), parseInt(t4[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t4) {
    return [parseInt(t4[1] + t4[1], 16), parseInt(t4[2] + t4[2], 16), parseInt(t4[3] + t4[3], 16)];
  } }], n3 = 0; n3 < r2.length; n3++) {
    var i3 = r2[n3].re, a3 = r2[n3].process, o3 = i3.exec(t3);
    o3 && (e2 = a3(o3), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t4 = this.r.toString(16), e3 = this.g.toString(16), r3 = this.b.toString(16);
    return 1 == t4.length && (t4 = "0" + t4), 1 == e3.length && (e3 = "0" + e3), 1 == r3.length && (r3 = "0" + r3), "#" + t4 + e3 + r3;
  };
}
function d(t3, e2) {
  var r2 = t3[0], n3 = t3[1], i3 = t3[2], a3 = t3[3];
  r2 = g(r2, n3, i3, a3, e2[0], 7, -680876936), a3 = g(a3, r2, n3, i3, e2[1], 12, -389564586), i3 = g(i3, a3, r2, n3, e2[2], 17, 606105819), n3 = g(n3, i3, a3, r2, e2[3], 22, -1044525330), r2 = g(r2, n3, i3, a3, e2[4], 7, -176418897), a3 = g(a3, r2, n3, i3, e2[5], 12, 1200080426), i3 = g(i3, a3, r2, n3, e2[6], 17, -1473231341), n3 = g(n3, i3, a3, r2, e2[7], 22, -45705983), r2 = g(r2, n3, i3, a3, e2[8], 7, 1770035416), a3 = g(a3, r2, n3, i3, e2[9], 12, -1958414417), i3 = g(i3, a3, r2, n3, e2[10], 17, -42063), n3 = g(n3, i3, a3, r2, e2[11], 22, -1990404162), r2 = g(r2, n3, i3, a3, e2[12], 7, 1804603682), a3 = g(a3, r2, n3, i3, e2[13], 12, -40341101), i3 = g(i3, a3, r2, n3, e2[14], 17, -1502002290), r2 = m3(r2, n3 = g(n3, i3, a3, r2, e2[15], 22, 1236535329), i3, a3, e2[1], 5, -165796510), a3 = m3(a3, r2, n3, i3, e2[6], 9, -1069501632), i3 = m3(i3, a3, r2, n3, e2[11], 14, 643717713), n3 = m3(n3, i3, a3, r2, e2[0], 20, -373897302), r2 = m3(r2, n3, i3, a3, e2[5], 5, -701558691), a3 = m3(a3, r2, n3, i3, e2[10], 9, 38016083), i3 = m3(i3, a3, r2, n3, e2[15], 14, -660478335), n3 = m3(n3, i3, a3, r2, e2[4], 20, -405537848), r2 = m3(r2, n3, i3, a3, e2[9], 5, 568446438), a3 = m3(a3, r2, n3, i3, e2[14], 9, -1019803690), i3 = m3(i3, a3, r2, n3, e2[3], 14, -187363961), n3 = m3(n3, i3, a3, r2, e2[8], 20, 1163531501), r2 = m3(r2, n3, i3, a3, e2[13], 5, -1444681467), a3 = m3(a3, r2, n3, i3, e2[2], 9, -51403784), i3 = m3(i3, a3, r2, n3, e2[7], 14, 1735328473), r2 = v2(r2, n3 = m3(n3, i3, a3, r2, e2[12], 20, -1926607734), i3, a3, e2[5], 4, -378558), a3 = v2(a3, r2, n3, i3, e2[8], 11, -2022574463), i3 = v2(i3, a3, r2, n3, e2[11], 16, 1839030562), n3 = v2(n3, i3, a3, r2, e2[14], 23, -35309556), r2 = v2(r2, n3, i3, a3, e2[1], 4, -1530992060), a3 = v2(a3, r2, n3, i3, e2[4], 11, 1272893353), i3 = v2(i3, a3, r2, n3, e2[7], 16, -155497632), n3 = v2(n3, i3, a3, r2, e2[10], 23, -1094730640), r2 = v2(r2, n3, i3, a3, e2[13], 4, 681279174), a3 = v2(a3, r2, n3, i3, e2[0], 11, -358537222), i3 = v2(i3, a3, r2, n3, e2[3], 16, -722521979), n3 = v2(n3, i3, a3, r2, e2[6], 23, 76029189), r2 = v2(r2, n3, i3, a3, e2[9], 4, -640364487), a3 = v2(a3, r2, n3, i3, e2[12], 11, -421815835), i3 = v2(i3, a3, r2, n3, e2[15], 16, 530742520), r2 = b(r2, n3 = v2(n3, i3, a3, r2, e2[2], 23, -995338651), i3, a3, e2[0], 6, -198630844), a3 = b(a3, r2, n3, i3, e2[7], 10, 1126891415), i3 = b(i3, a3, r2, n3, e2[14], 15, -1416354905), n3 = b(n3, i3, a3, r2, e2[5], 21, -57434055), r2 = b(r2, n3, i3, a3, e2[12], 6, 1700485571), a3 = b(a3, r2, n3, i3, e2[3], 10, -1894986606), i3 = b(i3, a3, r2, n3, e2[10], 15, -1051523), n3 = b(n3, i3, a3, r2, e2[1], 21, -2054922799), r2 = b(r2, n3, i3, a3, e2[8], 6, 1873313359), a3 = b(a3, r2, n3, i3, e2[15], 10, -30611744), i3 = b(i3, a3, r2, n3, e2[6], 15, -1560198380), n3 = b(n3, i3, a3, r2, e2[13], 21, 1309151649), r2 = b(r2, n3, i3, a3, e2[4], 6, -145523070), a3 = b(a3, r2, n3, i3, e2[11], 10, -1120210379), i3 = b(i3, a3, r2, n3, e2[2], 15, 718787259), n3 = b(n3, i3, a3, r2, e2[9], 21, -343485551), t3[0] = _2(r2, t3[0]), t3[1] = _2(n3, t3[1]), t3[2] = _2(i3, t3[2]), t3[3] = _2(a3, t3[3]);
}
function p2(t3, e2, r2, n3, i3, a3) {
  return e2 = _2(_2(e2, t3), _2(n3, a3)), _2(e2 << i3 | e2 >>> 32 - i3, r2);
}
function g(t3, e2, r2, n3, i3, a3, o3) {
  return p2(e2 & r2 | ~e2 & n3, t3, e2, i3, a3, o3);
}
function m3(t3, e2, r2, n3, i3, a3, o3) {
  return p2(e2 & n3 | r2 & ~n3, t3, e2, i3, a3, o3);
}
function v2(t3, e2, r2, n3, i3, a3, o3) {
  return p2(e2 ^ r2 ^ n3, t3, e2, i3, a3, o3);
}
function b(t3, e2, r2, n3, i3, a3, o3) {
  return p2(r2 ^ (e2 | ~n3), t3, e2, i3, a3, o3);
}
function y2(t3) {
  var e2, r2 = t3.length, n3 = [1732584193, -271733879, -1732584194, 271733878];
  for (e2 = 64; e2 <= t3.length; e2 += 64)
    d(n3, w(t3.substring(e2 - 64, e2)));
  t3 = t3.substring(e2 - 64);
  var i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e2 = 0; e2 < t3.length; e2++)
    i3[e2 >> 2] |= t3.charCodeAt(e2) << (e2 % 4 << 3);
  if (i3[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55)
    for (d(n3, i3), e2 = 0; e2 < 16; e2++)
      i3[e2] = 0;
  return i3[14] = 8 * r2, d(n3, i3), n3;
}
function w(t3) {
  var e2, r2 = [];
  for (e2 = 0; e2 < 64; e2 += 4)
    r2[e2 >> 2] = t3.charCodeAt(e2) + (t3.charCodeAt(e2 + 1) << 8) + (t3.charCodeAt(e2 + 2) << 16) + (t3.charCodeAt(e2 + 3) << 24);
  return r2;
}
u2 = n2.atob.bind(n2), h2 = n2.btoa.bind(n2);
var N2 = "0123456789abcdef".split("");
function L(t3) {
  for (var e2 = "", r2 = 0; r2 < 4; r2++)
    e2 += N2[t3 >> 8 * r2 + 4 & 15] + N2[t3 >> 8 * r2 & 15];
  return e2;
}
function A(t3) {
  return String.fromCharCode((255 & t3) >> 0, (65280 & t3) >> 8, (16711680 & t3) >> 16, (4278190080 & t3) >> 24);
}
function x(t3) {
  return y2(t3).map(A).join("");
}
var S = "5d41402abc4b2a76b9719d911017c592" != function(t3) {
  for (var e2 = 0; e2 < t3.length; e2++)
    t3[e2] = L(t3[e2]);
  return t3.join("");
}(y2("hello"));
function _2(t3, e2) {
  if (S) {
    var r2 = (65535 & t3) + (65535 & e2);
    return (t3 >> 16) + (e2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
  }
  return t3 + e2 & 4294967295;
}
function P(t3, e2) {
  var r2, n3, i3, a3;
  if (t3 !== r2) {
    for (var o3 = (i3 = t3, a3 = 1 + (256 / t3.length >> 0), new Array(a3 + 1).join(i3)), s3 = [], c4 = 0; c4 < 256; c4++)
      s3[c4] = c4;
    var u3 = 0;
    for (c4 = 0; c4 < 256; c4++) {
      var h3 = s3[c4];
      u3 = (u3 + h3 + o3.charCodeAt(c4)) % 256, s3[c4] = s3[u3], s3[u3] = h3;
    }
    r2 = t3, n3 = s3;
  } else
    s3 = n3;
  var l3 = e2.length, f3 = 0, d2 = 0, p3 = "";
  for (c4 = 0; c4 < l3; c4++)
    d2 = (d2 + (h3 = s3[f3 = (f3 + 1) % 256])) % 256, s3[f3] = s3[d2], s3[d2] = h3, o3 = s3[(s3[f3] + s3[d2]) % 256], p3 += String.fromCharCode(e2.charCodeAt(c4) ^ o3);
  return p3;
}
var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t3, e2, r2, n3) {
  this.v = 1, this.r = 2;
  var i3 = 192;
  t3.forEach(function(t4) {
    if (void 0 !== k.perm)
      throw new Error("Invalid permission: " + t4);
    i3 += k[t4];
  }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
  var a3 = (e2 + this.padding).substr(0, 32), o3 = (r2 + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a3, o3), this.P = -(1 + (255 ^ i3)), this.encryptionKey = x(a3 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n3)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F(t3) {
  if (/[^\u0000-\u00ff]/.test(t3))
    throw new Error("Invalid PDF Name Object: " + t3 + ", Only accept ASCII characters.");
  for (var e2 = "", r2 = t3.length, n3 = 0; n3 < r2; n3++) {
    var i3 = t3.charCodeAt(n3);
    if (i3 < 33 || 35 === i3 || 37 === i3 || 40 === i3 || 41 === i3 || 47 === i3 || 60 === i3 || 62 === i3 || 91 === i3 || 93 === i3 || 123 === i3 || 125 === i3 || i3 > 126)
      e2 += "#" + ("0" + i3.toString(16)).slice(-2);
    else
      e2 += t3[n3];
  }
  return e2;
}
function C(e2) {
  if ("object" !== _typeof(e2))
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r2 = {};
  this.subscribe = function(t3, e3, n3) {
    if (n3 = n3 || false, "string" != typeof t3 || "function" != typeof e3 || "boolean" != typeof n3)
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r2.hasOwnProperty(t3) || (r2[t3] = {});
    var i3 = Math.random().toString(35);
    return r2[t3][i3] = [e3, !!n3], i3;
  }, this.unsubscribe = function(t3) {
    for (var e3 in r2)
      if (r2[e3][t3])
        return delete r2[e3][t3], 0 === Object.keys(r2[e3]).length && delete r2[e3], true;
    return false;
  }, this.publish = function(t3) {
    if (r2.hasOwnProperty(t3)) {
      var i3 = Array.prototype.slice.call(arguments, 1), o3 = [];
      for (var s3 in r2[t3]) {
        var c4 = r2[t3][s3];
        try {
          c4[0].apply(e2, i3);
        } catch (t4) {
          n2.console && a2.error("jsPDF PubSub Error", t4.message, t4);
        }
        c4[1] && o3.push(s3);
      }
      o3.length && o3.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r2;
  };
}
function j(t3) {
  if (!(this instanceof j))
    return new j(t3);
  var e2 = "opacity,stroke-opacity".split(",");
  for (var r2 in t3)
    t3.hasOwnProperty(r2) && e2.indexOf(r2) >= 0 && (this[r2] = t3[r2]);
  this.id = "", this.objectNumber = -1;
}
function O2(t3, e2) {
  this.gState = t3, this.matrix = e2, this.id = "", this.objectNumber = -1;
}
function B(t3, e2, r2, n3, i3) {
  if (!(this instanceof B))
    return new B(t3, e2, r2, n3, i3);
  this.type = "axial" === t3 ? 2 : 3, this.coords = e2, this.colors = r2, O2.call(this, n3, i3);
}
function M(t3, e2, r2, n3, i3) {
  if (!(this instanceof M))
    return new M(t3, e2, r2, n3, i3);
  this.boundingBox = t3, this.xStep = e2, this.yStep = r2, this.stream = "", this.cloneIndex = 0, O2.call(this, n3, i3);
}
function E(e2) {
  var r2, i3 = "string" == typeof arguments[0] ? arguments[0] : "p", o3 = arguments[1], s3 = arguments[2], c4 = arguments[3], u3 = [], d2 = 1, p3 = 16, g2 = "S", m4 = null;
  "object" === _typeof(e2 = e2 || {}) && (i3 = e2.orientation, o3 = e2.unit || o3, s3 = e2.format || s3, c4 = e2.compress || e2.compressPdf || c4, null !== (m4 = e2.encryption || null) && (m4.userPassword = m4.userPassword || "", m4.ownerPassword = m4.ownerPassword || "", m4.userPermissions = m4.userPermissions || []), d2 = "number" == typeof e2.userUnit ? Math.abs(e2.userUnit) : 1, void 0 !== e2.precision && (r2 = e2.precision), void 0 !== e2.floatPrecision && (p3 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), u3 = e2.filters || (true === c4 ? ["FlateEncode"] : u3), o3 = o3 || "mm", i3 = ("" + (i3 || "P")).toLowerCase();
  var v3 = e2.putOnlyUsedFonts || false, b2 = {}, y3 = { internal: {}, __private__: {} };
  y3.__private__.PubSub = C;
  var w2 = "1.3", N3 = y3.__private__.getPdfVersion = function() {
    return w2;
  };
  y3.__private__.setPdfVersion = function(t3) {
    w2 = t3;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y3.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y3.__private__.getPageFormat = function(t3) {
    return L2[t3];
  };
  s3 = s3 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _3() {
    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
  }
  var k2 = y3.__private__.combineFontStyleAndFontWeight = function(t3, e3) {
    if ("bold" == t3 && "normal" == e3 || "bold" == t3 && 400 == e3 || "normal" == t3 && "italic" == e3 || "bold" == t3 && "italic" == e3)
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return e3 && (t3 = 400 == e3 || "normal" === e3 ? "italic" === t3 ? "italic" : "normal" : 700 != e3 && "bold" !== e3 || "normal" !== t3 ? (700 == e3 ? "bold" : e3) + "" + t3 : "bold"), t3;
  };
  y3.advancedAPI = function(t3) {
    var e3 = S2 === x2.COMPAT;
    return e3 && _3.call(this), "function" != typeof t3 || (t3(this), e3 && P2.call(this)), this;
  }, y3.compatAPI = function(t3) {
    var e3 = S2 === x2.ADVANCED;
    return e3 && P2.call(this), "function" != typeof t3 || (t3(this), e3 && _3.call(this)), this;
  }, y3.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O3, q2 = function(t3) {
    if (S2 !== x2.ADVANCED)
      throw new Error(t3 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y3.roundToPrecision = y3.__private__.roundToPrecision = function(t3, e3) {
    var n3 = r2 || e3;
    if (isNaN(t3) || isNaN(n3))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t3.toFixed(n3).replace(/0+$/, "");
  };
  O3 = y3.hpf = y3.__private__.hpf = "number" == typeof p3 ? function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, p3);
  } : "smart" === p3 ? function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, t3 > -1 && t3 < 1 ? 16 : 5);
  } : function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, 16);
  };
  var R2 = y3.f2 = y3.__private__.f2 = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t3, 2);
  }, T3 = y3.__private__.f3 = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t3, 3);
  }, U2 = y3.scale = y3.__private__.scale = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t3 * _t2 : S2 === x2.ADVANCED ? t3 : void 0;
  }, z2 = function(t3) {
    return S2 === x2.COMPAT ? Rr() - t3 : S2 === x2.ADVANCED ? t3 : void 0;
  }, H2 = function(t3) {
    return U2(z2(t3));
  };
  y3.__private__.setPrecision = y3.setPrecision = function(t3) {
    "number" == typeof parseInt(t3, 10) && (r2 = parseInt(t3, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y3.__private__.getFileId = function() {
    return V2;
  }, Y2 = y3.__private__.setFileId = function(t3) {
    return V2 = void 0 !== t3 && /^[a-fA-F0-9]{32}$/.test(t3) ? t3.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m4 && (Ye = new I(m4.userPermissions, m4.userPassword, m4.ownerPassword, V2)), V2;
  };
  y3.setFileId = function(t3) {
    return Y2(t3), this;
  }, y3.getFileId = function() {
    return G2();
  };
  var J2 = y3.__private__.convertDateToPDFDate = function(t3) {
    var e3 = t3.getTimezoneOffset(), r3 = e3 < 0 ? "+" : "-", n3 = Math.floor(Math.abs(e3 / 60)), i4 = Math.abs(e3 % 60), a3 = [r3, Q2(n3), "'", Q2(i4), "'"].join("");
    return ["D:", t3.getFullYear(), Q2(t3.getMonth() + 1), Q2(t3.getDate()), Q2(t3.getHours()), Q2(t3.getMinutes()), Q2(t3.getSeconds()), a3].join("");
  }, X2 = y3.__private__.convertPDFDateToDate = function(t3) {
    var e3 = parseInt(t3.substr(2, 4), 10), r3 = parseInt(t3.substr(6, 2), 10) - 1, n3 = parseInt(t3.substr(8, 2), 10), i4 = parseInt(t3.substr(10, 2), 10), a3 = parseInt(t3.substr(12, 2), 10), o4 = parseInt(t3.substr(14, 2), 10);
    return new Date(e3, r3, n3, i4, a3, o4, 0);
  }, K2 = y3.__private__.setCreationDate = function(t3) {
    var e3;
    if (void 0 === t3 && (t3 = new Date()), t3 instanceof Date)
      e3 = J2(t3);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t3))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e3 = t3;
    }
    return W2 = e3;
  }, Z2 = y3.__private__.getCreationDate = function(t3) {
    var e3 = W2;
    return "jsDate" === t3 && (e3 = X2(W2)), e3;
  };
  y3.setCreationDate = function(t3) {
    return K2(t3), this;
  }, y3.getCreationDate = function(t3) {
    return Z2(t3);
  };
  var $2, Q2 = y3.__private__.padd2 = function(t3) {
    return ("0" + parseInt(t3)).slice(-2);
  }, tt2 = y3.__private__.padd2Hex = function(t3) {
    return ("00" + (t3 = t3.toString())).substr(t3.length);
  }, et3 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
    et3 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  };
  y3.__private__.setCustomOutputDestination = function(t3) {
    st2 = true, ct2 = t3;
  };
  var ht2 = function(t3) {
    st2 || (ct2 = t3);
  };
  y3.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y3.__private__.out = function(t3) {
    return t3 = t3.toString(), it2 += t3.length + 1, ct2.push(t3), ct2;
  }, ft2 = y3.__private__.write = function(t3) {
    return lt2(1 === arguments.length ? t3.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y3.__private__.getArrayBuffer = function(t3) {
    for (var e3 = t3.length, r3 = new ArrayBuffer(e3), n3 = new Uint8Array(r3); e3--; )
      n3[e3] = t3.charCodeAt(e3);
    return r3;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y3.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e2.fontSize || 16;
  y3.__private__.setFontSize = y3.setFontSize = function(t3) {
    return gt2 = S2 === x2.ADVANCED ? t3 / _t2 : t3, this;
  };
  var mt2, vt2 = y3.__private__.getFontSize = y3.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
  }, bt2 = e2.R2L || false;
  y3.__private__.setR2L = y3.setR2L = function(t3) {
    return bt2 = t3, this;
  }, y3.__private__.getR2L = y3.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y3.__private__.setZoomMode = function(t3) {
    var e3 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t3))
      mt2 = t3;
    else if (isNaN(t3)) {
      if (-1 === e3.indexOf(t3))
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t3 + '" is not recognized.');
      mt2 = t3;
    } else
      mt2 = parseInt(t3, 10);
  };
  y3.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y3.__private__.setPageMode = function(t3) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t3))
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t3 + '" is not recognized.');
    yt2 = t3;
  };
  y3.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y3.__private__.setLayoutMode = function(t3) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t3))
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t3 + '" is not recognized.');
    Nt2 = t3;
  };
  y3.__private__.getLayoutMode = function() {
    return Nt2;
  }, y3.__private__.setDisplayMode = y3.setDisplayMode = function(t3, e3, r3) {
    return wt2(t3), At2(e3), Lt2(r3), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y3.__private__.getDocumentProperty = function(t3) {
    if (-1 === Object.keys(xt2).indexOf(t3))
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t3];
  }, y3.__private__.getDocumentProperties = function() {
    return xt2;
  }, y3.__private__.setDocumentProperties = y3.setProperties = y3.setDocumentProperties = function(t3) {
    for (var e3 in xt2)
      xt2.hasOwnProperty(e3) && t3[e3] && (xt2[e3] = t3[e3]);
    return this;
  }, y3.__private__.setDocumentProperty = function(t3, e3) {
    if (-1 === Object.keys(xt2).indexOf(t3))
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t3] = e3;
  };
  var St2, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y3), Ut2 = e2.hotfixes || [], zt2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t3(e3, r3, n3, i4, a3, o4) {
    if (!(this instanceof t3))
      return new t3(e3, r3, n3, i4, a3, o4);
    isNaN(e3) && (e3 = 1), isNaN(r3) && (r3 = 0), isNaN(n3) && (n3 = 0), isNaN(i4) && (i4 = 1), isNaN(a3) && (a3 = 0), isNaN(o4) && (o4 = 0), this._matrix = [e3, r3, n3, i4, a3, o4];
  };
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && (0 === this.shy && (0 === this.shx && (1 === this.sy && (0 === this.tx && 0 === this.ty))));
  } }), Vt2.prototype.join = function(t3) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O3).join(t3);
  }, Vt2.prototype.multiply = function(t3) {
    var e3 = t3.sx * this.sx + t3.shy * this.shx, r3 = t3.sx * this.shy + t3.shy * this.sy, n3 = t3.shx * this.sx + t3.sy * this.shx, i4 = t3.shx * this.shy + t3.sy * this.sy, a3 = t3.tx * this.sx + t3.ty * this.shx + this.tx, o4 = t3.tx * this.shy + t3.ty * this.sy + this.ty;
    return new Vt2(e3, r3, n3, i4, a3, o4);
  }, Vt2.prototype.decompose = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n3 = this.sy, i4 = this.tx, a3 = this.ty, o4 = Math.sqrt(t3 * t3 + e3 * e3), s4 = (t3 /= o4) * r3 + (e3 /= o4) * n3;
    r3 -= t3 * s4, n3 -= e3 * s4;
    var c5 = Math.sqrt(r3 * r3 + n3 * n3);
    return s4 /= c5, t3 * (n3 /= c5) < e3 * (r3 /= c5) && (t3 = -t3, e3 = -e3, s4 = -s4, o4 = -o4), { scale: new Vt2(o4, 0, 0, c5, 0, 0), translate: new Vt2(1, 0, 0, 1, i4, a3), rotate: new Vt2(t3, e3, -e3, t3, 0, 0), skew: new Vt2(1, 0, s4, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t3) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n3 = this.sy, i4 = this.tx, a3 = this.ty, o4 = 1 / (t3 * n3 - e3 * r3), s4 = n3 * o4, c5 = -e3 * o4, u4 = -r3 * o4, h3 = t3 * o4;
    return new Vt2(s4, c5, u4, h3, -s4 * i4 - u4 * a3, -c5 * i4 - h3 * a3);
  }, Vt2.prototype.applyToPoint = function(t3) {
    var e3 = t3.x * this.sx + t3.y * this.shx + this.tx, r3 = t3.x * this.shy + t3.y * this.sy + this.ty;
    return new Cr(e3, r3);
  }, Vt2.prototype.applyToRectangle = function(t3) {
    var e3 = this.applyToPoint(t3), r3 = this.applyToPoint(new Cr(t3.x + t3.w, t3.y + t3.h));
    return new jr(e3.x, e3.y, r3.x - e3.x, r3.y - e3.y);
  }, Vt2.prototype.clone = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n3 = this.sy, i4 = this.tx, a3 = this.ty;
    return new Vt2(t3, e3, r3, n3, i4, a3);
  }, y3.Matrix = Vt2;
  var Gt2 = y3.matrixMult = function(t3, e3) {
    return e3.multiply(t3);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y3.unitMatrix = y3.identityMatrix = Yt2;
  var Jt2 = function(t3, e3) {
    if (!Bt2[t3]) {
      var r3 = (e3 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e3.id = r3, Bt2[t3] = r3, Ot2[r3] = e3, Tt2.publish("addPattern", e3);
    }
  };
  y3.ShadingPattern = B, y3.TilingPattern = M, y3.addShadingPattern = function(t3, e3) {
    return q2("addShadingPattern()"), Jt2(t3, e3), this;
  }, y3.beginTilingPattern = function(t3) {
    q2("beginTilingPattern()"), Br(t3.boundingBox[0], t3.boundingBox[1], t3.boundingBox[2] - t3.boundingBox[0], t3.boundingBox[3] - t3.boundingBox[1], t3.matrix);
  }, y3.endTilingPattern = function(t3, e3) {
    q2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Jt2(t3, e3), Tt2.publish("endTilingPattern", e3), Wt2.pop().restore();
  };
  var Xt2 = y3.__private__.newObject = function() {
    var t3 = Kt2();
    return Zt2(t3, true), t3;
  }, Kt2 = y3.__private__.newObjectDeferred = function() {
    return et3++, rt2[et3] = function() {
      return it2;
    }, et3;
  }, Zt2 = function(t3, e3) {
    return e3 = "boolean" == typeof e3 && e3, rt2[t3] = it2, e3 && lt2(t3 + " 0 obj"), t3;
  }, $t2 = y3.__private__.newAdditionalObject = function() {
    var t3 = { objId: Kt2(), content: "" };
    return at2.push(t3), t3;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y3.__private__.decodeColorString = function(t3) {
    var e3 = t3.split(" ");
    if (2 !== e3.length || "g" !== e3[1] && "G" !== e3[1]) {
      if (5 === e3.length && ("k" === e3[4] || "K" === e3[4])) {
        e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"];
      }
    } else {
      var r3 = parseFloat(e3[0]);
      e3 = [r3, r3, r3, "r"];
    }
    for (var n3 = "#", i4 = 0; i4 < 3; i4++)
      n3 += ("0" + Math.floor(255 * parseFloat(e3[i4])).toString(16)).slice(-2);
    return n3;
  }, re2 = y3.__private__.encodeColorString = function(e3) {
    var r3;
    "string" == typeof e3 && (e3 = { ch1: e3 });
    var n3 = e3.ch1, i4 = e3.ch2, a3 = e3.ch3, o4 = e3.ch4, s4 = "draw" === e3.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof n3 && "#" !== n3.charAt(0)) {
      var c5 = new f2(n3);
      if (c5.ok)
        n3 = c5.toHex();
      else if (!/^\d*\.?\d*$/.test(n3))
        throw new Error('Invalid color "' + n3 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof n3 && /^#[0-9A-Fa-f]{3}$/.test(n3) && (n3 = "#" + n3[1] + n3[1] + n3[2] + n3[2] + n3[3] + n3[3]), "string" == typeof n3 && /^#[0-9A-Fa-f]{6}$/.test(n3)) {
      var u4 = parseInt(n3.substr(1), 16);
      n3 = u4 >> 16 & 255, i4 = u4 >> 8 & 255, a3 = 255 & u4;
    }
    if (void 0 === i4 || void 0 === o4 && n3 === i4 && i4 === a3)
      if ("string" == typeof n3)
        r3 = n3 + " " + s4[0];
      else
        switch (e3.precision) {
          case 2:
            r3 = R2(n3 / 255) + " " + s4[0];
            break;
          case 3:
          default:
            r3 = T3(n3 / 255) + " " + s4[0];
        }
    else if (void 0 === o4 || "object" === _typeof(o4)) {
      if (o4 && !isNaN(o4.a) && 0 === o4.a)
        return r3 = ["1.", "1.", "1.", s4[1]].join(" ");
      if ("string" == typeof n3)
        r3 = [n3, i4, a3, s4[1]].join(" ");
      else
        switch (e3.precision) {
          case 2:
            r3 = [R2(n3 / 255), R2(i4 / 255), R2(a3 / 255), s4[1]].join(" ");
            break;
          default:
          case 3:
            r3 = [T3(n3 / 255), T3(i4 / 255), T3(a3 / 255), s4[1]].join(" ");
        }
    } else if ("string" == typeof n3)
      r3 = [n3, i4, a3, o4, s4[2]].join(" ");
    else
      switch (e3.precision) {
        case 2:
          r3 = [R2(n3), R2(i4), R2(a3), R2(o4), s4[2]].join(" ");
          break;
        case 3:
        default:
          r3 = [T3(n3), T3(i4), T3(a3), T3(o4), s4[2]].join(" ");
      }
    return r3;
  }, ne2 = y3.__private__.getFilters = function() {
    return u3;
  }, ie2 = y3.__private__.putStream = function(t3) {
    var e3 = (t3 = t3 || {}).data || "", r3 = t3.filters || ne2(), n3 = t3.alreadyAppliedFilters || [], i4 = t3.addLength1 || false, a3 = e3.length, o4 = t3.objectId, s4 = function(t4) {
      return t4;
    };
    if (null !== m4 && void 0 === o4)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m4 && (s4 = Ye.encryptor(o4, 0));
    var c5 = {};
    true === r3 && (r3 = ["FlateEncode"]);
    var u4 = t3.additionalKeyValues || [], h3 = (c5 = void 0 !== E.API.processDataByFilters ? E.API.processDataByFilters(e3, r3) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(n3) ? n3.join(" ") : n3.toString());
    if (0 !== c5.data.length && (u4.push({ key: "Length", value: c5.data.length }), true === i4 && u4.push({ key: "Length1", value: a3 })), 0 != h3.length)
      if (h3.split("/").length - 1 == 1)
        u4.push({ key: "Filter", value: h3 });
      else {
        u4.push({ key: "Filter", value: "[" + h3 + "]" });
        for (var l3 = 0; l3 < u4.length; l3 += 1)
          if ("DecodeParms" === u4[l3].key) {
            for (var f3 = [], d3 = 0; d3 < c5.reverseChain.split("/").length - 1; d3 += 1)
              f3.push("null");
            f3.push(u4[l3].value), u4[l3].value = "[" + f3.join(" ") + "]";
          }
      }
    lt2("<<");
    for (var p4 = 0; p4 < u4.length; p4++)
      lt2("/" + u4[p4].key + " " + u4[p4].value);
    lt2(">>"), 0 !== c5.data.length && (lt2("stream"), lt2(s4(c5.data)), lt2("endstream"));
  }, ae2 = y3.__private__.putPage = function(t3) {
    var e3 = t3.number, r3 = t3.data, n3 = t3.objId, i4 = t3.contentsObjId;
    Zt2(n3, true), lt2("<</Type /Page"), lt2("/Parent " + t3.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t3.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O3(t3.mediaBox.bottomLeftX)) + " " + parseFloat(O3(t3.mediaBox.bottomLeftY)) + " " + O3(t3.mediaBox.topRightX) + " " + O3(t3.mediaBox.topRightY) + "]"), null !== t3.cropBox && lt2("/CropBox [" + O3(t3.cropBox.bottomLeftX) + " " + O3(t3.cropBox.bottomLeftY) + " " + O3(t3.cropBox.topRightX) + " " + O3(t3.cropBox.topRightY) + "]"), null !== t3.bleedBox && lt2("/BleedBox [" + O3(t3.bleedBox.bottomLeftX) + " " + O3(t3.bleedBox.bottomLeftY) + " " + O3(t3.bleedBox.topRightX) + " " + O3(t3.bleedBox.topRightY) + "]"), null !== t3.trimBox && lt2("/TrimBox [" + O3(t3.trimBox.bottomLeftX) + " " + O3(t3.trimBox.bottomLeftY) + " " + O3(t3.trimBox.topRightX) + " " + O3(t3.trimBox.topRightY) + "]"), null !== t3.artBox && lt2("/ArtBox [" + O3(t3.artBox.bottomLeftX) + " " + O3(t3.artBox.bottomLeftY) + " " + O3(t3.artBox.topRightX) + " " + O3(t3.artBox.topRightY) + "]"), "number" == typeof t3.userUnit && 1 !== t3.userUnit && lt2("/UserUnit " + t3.userUnit), Tt2.publish("putPage", { objId: n3, pageContext: Rt2[e3], pageNumber: e3, page: r3 }), lt2("/Contents " + i4 + " 0 R"), lt2(">>"), lt2("endobj");
    var a3 = r3.join("\n");
    return S2 === x2.ADVANCED && (a3 += "\nQ"), Zt2(i4, true), ie2({ data: a3, filters: ne2(), objectId: i4 }), lt2("endobj"), n3;
  }, oe2 = y3.__private__.putPages = function() {
    var t3, e3, r3 = [];
    for (t3 = 1; t3 <= Dt2; t3++)
      Rt2[t3].objId = Kt2(), Rt2[t3].contentsObjId = Kt2();
    for (t3 = 1; t3 <= Dt2; t3++)
      r3.push(ae2({ number: t3, data: ot2[t3], objId: Rt2[t3].objId, contentsObjId: Rt2[t3].contentsObjId, mediaBox: Rt2[t3].mediaBox, cropBox: Rt2[t3].cropBox, bleedBox: Rt2[t3].bleedBox, trimBox: Rt2[t3].trimBox, artBox: Rt2[t3].artBox, userUnit: Rt2[t3].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n3 = "/Kids [";
    for (e3 = 0; e3 < Dt2; e3++)
      n3 += r3[e3] + " 0 R ";
    lt2(n3 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = function(t3) {
    Tt2.publish("putFont", { font: t3, out: lt2, newObject: Xt2, putStream: ie2 }), true !== t3.isAlreadyPutted && (t3.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F(t3.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t3.encoding && lt2("/Encoding /" + t3.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ce2 = function() {
    for (var t3 in Ft2)
      Ft2.hasOwnProperty(t3) && (false === v3 || true === v3 && b2.hasOwnProperty(t3)) && se2(Ft2[t3]);
  }, ue2 = function(t3) {
    t3.objectNumber = Xt2();
    var e3 = [];
    e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [O3(t3.x), O3(t3.y), O3(t3.x + t3.width), O3(t3.y + t3.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" });
    var r3 = t3.pages[1].join("\n");
    ie2({ data: r3, additionalKeyValues: e3, objectId: t3.objectNumber }), lt2("endobj");
  }, he2 = function() {
    for (var t3 in zt2)
      zt2.hasOwnProperty(t3) && ue2(zt2[t3]);
  }, le2 = function(t3, e3) {
    var r3, n3 = [], i4 = 1 / (e3 - 1);
    for (r3 = 0; r3 < 1; r3 += i4)
      n3.push(r3);
    if (n3.push(1), 0 != t3[0].offset) {
      var a3 = { offset: 0, color: t3[0].color };
      t3.unshift(a3);
    }
    if (1 != t3[t3.length - 1].offset) {
      var o4 = { offset: 1, color: t3[t3.length - 1].color };
      t3.push(o4);
    }
    for (var s4 = "", c5 = 0, u4 = 0; u4 < n3.length; u4++) {
      for (r3 = n3[u4]; r3 > t3[c5 + 1].offset; )
        c5++;
      var h3 = t3[c5].offset, l3 = (r3 - h3) / (t3[c5 + 1].offset - h3), f3 = t3[c5].color, d3 = t3[c5 + 1].color;
      s4 += tt2(Math.round((1 - l3) * f3[0] + l3 * d3[0]).toString(16)) + tt2(Math.round((1 - l3) * f3[1] + l3 * d3[1]).toString(16)) + tt2(Math.round((1 - l3) * f3[2] + l3 * d3[2]).toString(16));
    }
    return s4.trim();
  }, fe2 = function(t3, e3) {
    e3 || (e3 = 21);
    var r3 = Xt2(), n3 = le2(t3.colors, e3), i4 = [];
    i4.push({ key: "FunctionType", value: "0" }), i4.push({ key: "Domain", value: "[0.0 1.0]" }), i4.push({ key: "Size", value: "[" + e3 + "]" }), i4.push({ key: "BitsPerSample", value: "8" }), i4.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i4.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n3, additionalKeyValues: i4, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r3 }), lt2("endobj"), t3.objectNumber = Xt2(), lt2("<< /ShadingType " + t3.type), lt2("/ColorSpace /DeviceRGB");
    var a3 = "/Coords [" + O3(parseFloat(t3.coords[0])) + " " + O3(parseFloat(t3.coords[1])) + " ";
    2 === t3.type ? a3 += O3(parseFloat(t3.coords[2])) + " " + O3(parseFloat(t3.coords[3])) : a3 += O3(parseFloat(t3.coords[2])) + " " + O3(parseFloat(t3.coords[3])) + " " + O3(parseFloat(t3.coords[4])) + " " + O3(parseFloat(t3.coords[5])), lt2(a3 += "]"), t3.matrix && lt2("/Matrix [" + t3.matrix.toString() + "]"), lt2("/Function " + r3 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, de2 = function(t3, e3) {
    var r3 = Kt2(), n3 = Xt2();
    e3.push({ resourcesOid: r3, objectOid: n3 }), t3.objectNumber = n3;
    var i4 = [];
    i4.push({ key: "Type", value: "/Pattern" }), i4.push({ key: "PatternType", value: "1" }), i4.push({ key: "PaintType", value: "1" }), i4.push({ key: "TilingType", value: "1" }), i4.push({ key: "BBox", value: "[" + t3.boundingBox.map(O3).join(" ") + "]" }), i4.push({ key: "XStep", value: O3(t3.xStep) }), i4.push({ key: "YStep", value: O3(t3.yStep) }), i4.push({ key: "Resources", value: r3 + " 0 R" }), t3.matrix && i4.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" }), ie2({ data: t3.stream, additionalKeyValues: i4, objectId: t3.objectNumber }), lt2("endobj");
  }, pe2 = function(t3) {
    var e3;
    for (e3 in Ot2)
      Ot2.hasOwnProperty(e3) && (Ot2[e3] instanceof B ? fe2(Ot2[e3]) : Ot2[e3] instanceof M && de2(Ot2[e3], t3));
  }, ge2 = function(t3) {
    for (var e3 in t3.objectNumber = Xt2(), lt2("<<"), t3)
      switch (e3) {
        case "opacity":
          lt2("/ca " + R2(t3[e3]));
          break;
        case "stroke-opacity":
          lt2("/CA " + R2(t3[e3]));
      }
    lt2(">>"), lt2("endobj");
  }, me2 = function() {
    var t3;
    for (t3 in Mt2)
      Mt2.hasOwnProperty(t3) && ge2(Mt2[t3]);
  }, ve2 = function() {
    for (var t3 in lt2("/XObject <<"), zt2)
      zt2.hasOwnProperty(t3) && zt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + zt2[t3].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, be2 = function() {
    Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
  }, ye2 = function() {
    for (var t3 in lt2("/Font <<"), Ft2)
      Ft2.hasOwnProperty(t3) && (false === v3 || true === v3 && b2.hasOwnProperty(t3)) && lt2("/" + t3 + " " + Ft2[t3].objectNumber + " 0 R");
    lt2(">>");
  }, we2 = function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t3 in lt2("/Shading <<"), Ot2)
        Ot2.hasOwnProperty(t3) && Ot2[t3] instanceof B && Ot2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ot2[t3].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, Ne2 = function(t3) {
    if (Object.keys(Ot2).length > 0) {
      for (var e3 in lt2("/Pattern <<"), Ot2)
        Ot2.hasOwnProperty(e3) && Ot2[e3] instanceof y3.TilingPattern && Ot2[e3].objectNumber >= 0 && Ot2[e3].objectNumber < t3 && lt2("/" + e3 + " " + Ot2[e3].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, Le2 = function() {
    if (Object.keys(Mt2).length > 0) {
      var t3;
      for (t3 in lt2("/ExtGState <<"), Mt2)
        Mt2.hasOwnProperty(t3) && Mt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Mt2[t3].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, Ae = function(t3) {
    Zt2(t3.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t3.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, xe = function() {
    var t3 = [];
    ce2(), me2(), he2(), pe2(t3), Tt2.publish("putResources"), t3.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, Se = function() {
    Tt2.publish("putAdditionalObjects");
    for (var t3 = 0; t3 < at2.length; t3++) {
      var e3 = at2[t3];
      Zt2(e3.objId, true), lt2(e3.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, _e = function(t3) {
    Ct2[t3.fontName] = Ct2[t3.fontName] || {}, Ct2[t3.fontName][t3.fontStyle] = t3.id;
  }, Pe = function(t3, e3, r3, n3, i4) {
    var a3 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t3, fontName: e3, fontStyle: r3, encoding: n3, isStandardFont: i4 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a3, instance: this }), Ft2[a3.id] = a3, _e(a3), a3.id;
  }, ke = function(t3) {
    for (var e3 = 0, r3 = pt2.length; e3 < r3; e3++) {
      var n3 = Pe.call(this, t3[e3][0], t3[e3][1], t3[e3][2], pt2[e3][3], true);
      false === v3 && (b2[n3] = true);
      var i4 = t3[e3][0].split("-");
      _e({ id: n3, fontName: i4[0], fontStyle: i4[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
  }, Ie = function(t3) {
    return t3.foo = function() {
      try {
        return t3.apply(this, arguments);
      } catch (t4) {
        var e3 = t4.stack || "";
        ~e3.indexOf(" at ") && (e3 = e3.split(" at ")[1]);
        var r3 = "Error in function " + e3.split("\n")[0].split("<")[0] + ": " + t4.message;
        if (!n2.console)
          throw new Error(r3);
        n2.console.error(r3, t4), n2.alert && alert(r3);
      }
    }, t3.foo.bar = t3, t3.foo;
  }, Fe = function(t3, e3) {
    var r3, n3, i4, a3, o4, s4, c5, u4, h3;
    if (i4 = (e3 = e3 || {}).sourceEncoding || "Unicode", o4 = e3.outputEncoding, (e3.autoencode || o4) && Ft2[St2].metadata && Ft2[St2].metadata[i4] && Ft2[St2].metadata[i4].encoding && (a3 = Ft2[St2].metadata[i4].encoding, !o4 && Ft2[St2].encoding && (o4 = Ft2[St2].encoding), !o4 && a3.codePages && (o4 = a3.codePages[0]), "string" == typeof o4 && (o4 = a3[o4]), o4)) {
      for (c5 = false, s4 = [], r3 = 0, n3 = t3.length; r3 < n3; r3++)
        (u4 = o4[t3.charCodeAt(r3)]) ? s4.push(String.fromCharCode(u4)) : s4.push(t3[r3]), s4[r3].charCodeAt(0) >> 8 && (c5 = true);
      t3 = s4.join("");
    }
    for (r3 = t3.length; void 0 === c5 && 0 !== r3; )
      t3.charCodeAt(r3 - 1) >> 8 && (c5 = true), r3--;
    if (!c5)
      return t3;
    for (s4 = e3.noBOM ? [] : [254, 255], r3 = 0, n3 = t3.length; r3 < n3; r3++) {
      if ((h3 = (u4 = t3.charCodeAt(r3)) >> 8) >> 8)
        throw new Error("Character at position " + r3 + " of string '" + t3 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s4.push(h3), s4.push(u4 - (h3 << 8));
    }
    return String.fromCharCode.apply(void 0, s4);
  }, Ce = y3.__private__.pdfEscape = y3.pdfEscape = function(t3, e3) {
    return Fe(t3, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y3.__private__.beginPage = function(t3) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t3[0]), topRightY: Number(t3[1]) } }, Me(Dt2), ht2(ot2[$2]);
  }, Oe = function(t3, e3) {
    var r3, n3, o4;
    switch (i3 = e3 || i3, "string" == typeof t3 && (r3 = A2(t3.toLowerCase()), Array.isArray(r3) && (n3 = r3[0], o4 = r3[1])), Array.isArray(t3) && (n3 = t3[0] * _t2, o4 = t3[1] * _t2), isNaN(n3) && (n3 = s3[0], o4 = s3[1]), (n3 > 14400 || o4 > 14400) && (a2.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n3 = Math.min(14400, n3), o4 = Math.min(14400, o4)), s3 = [n3, o4], i3.substr(0, 1)) {
      case "l":
        o4 > n3 && (s3 = [o4, n3]);
        break;
      case "p":
        n3 > o4 && (s3 = [o4, n3]);
    }
    je(s3), pr(fr), lt2(Lr), 0 !== kr && lt2(kr + " J"), 0 !== Ir && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, Be = function(t3) {
    t3 > 0 && t3 <= Dt2 && (ot2.splice(t3, 1), Rt2.splice(t3, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, Me = function(t3) {
    t3 > 0 && t3 <= Dt2 && ($2 = t3);
  }, Ee = y3.__private__.getNumberOfPages = y3.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe = function(t3, e3, r3) {
    var n3, i4 = void 0;
    return r3 = r3 || {}, t3 = void 0 !== t3 ? t3 : Ft2[St2].fontName, e3 = void 0 !== e3 ? e3 : Ft2[St2].fontStyle, n3 = t3.toLowerCase(), void 0 !== Ct2[n3] && void 0 !== Ct2[n3][e3] ? i4 = Ct2[n3][e3] : void 0 !== Ct2[t3] && void 0 !== Ct2[t3][e3] ? i4 = Ct2[t3][e3] : false === r3.disableWarning && a2.warn("Unable to look up font label for font '" + t3 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i4 || r3.noFallback || null == (i4 = Ct2.times[e3]) && (i4 = Ct2.times.normal), i4;
  }, De = y3.__private__.putInfo = function() {
    var t3 = Xt2(), e3 = function(t4) {
      return t4;
    };
    for (var r3 in null !== m4 && (e3 = Ye.encryptor(t3, 0)), lt2("<<"), lt2("/Producer (" + Ce(e3("jsPDF " + E.version)) + ")"), xt2)
      xt2.hasOwnProperty(r3) && xt2[r3] && lt2("/" + r3.substr(0, 1).toUpperCase() + r3.substr(1) + " (" + Ce(e3(xt2[r3])) + ")");
    lt2("/CreationDate (" + Ce(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re = y3.__private__.putCatalog = function(t3) {
    var e3 = (t3 = t3 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r3 = "" + mt2;
        "%" === r3.substr(r3.length - 1) && (mt2 = parseInt(mt2) / 100), "number" == typeof mt2 && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te = y3.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et3 + 1)), lt2("/Root " + et3 + " 0 R"), lt2("/Info " + (et3 - 1) + " 0 R"), null !== m4 && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, Ue = y3.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%\xBA\xDF\xAC\xE0");
  }, ze = y3.__private__.putXRef = function() {
    var t3 = "0000000000";
    lt2("xref"), lt2("0 " + (et3 + 1)), lt2("0000000000 65535 f ");
    for (var e3 = 1; e3 <= et3; e3++) {
      "function" == typeof rt2[e3] ? lt2((t3 + rt2[e3]()).slice(-10) + " 00000 n ") : void 0 !== rt2[e3] ? lt2((t3 + rt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He = y3.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), Ue(), oe2(), Se(), xe(), null !== m4 && be2(), De(), Re();
    var t3 = it2;
    return ze(), Te(), lt2("startxref"), lt2("" + t3), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We = y3.__private__.getBlob = function(t3) {
    return new Blob([dt2(t3)], { type: "application/pdf" });
  }, Ve = y3.output = y3.__private__.output = Ie(function(t3, e3) {
    switch ("string" == typeof (e3 = e3 || {}) ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t3) {
      case void 0:
        return He();
      case "save":
        y3.save(e3.filename);
        break;
      case "arraybuffer":
        return dt2(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (void 0 !== n2.URL && "function" == typeof n2.URL.createObjectURL)
          return n2.URL && n2.URL.createObjectURL(We(He())) || void 0;
        a2.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r3 = "", i4 = He();
        try {
          r3 = h2(i4);
        } catch (t4) {
          r3 = h2(unescape(encodeURIComponent(i4)));
        }
        return "data:application/pdf;filename=" + e3.filename + ";base64," + r3;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n2)) {
          var o4 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s4 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e3.pdfObjectUrl && (o4 = e3.pdfObjectUrl, s4 = "");
          var c5 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o4 + '"' + s4 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", u4 = n2.open();
          return null !== u4 && u4.document.write(c5), u4;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n2)) {
          var l3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', f3 = n2.open();
          if (null !== f3) {
            f3.document.write(l3);
            var d3 = this;
            f3.document.documentElement.querySelector("#pdfViewer").onload = function() {
              f3.document.title = e3.filename, f3.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d3.output("bloburl"));
            };
          }
          return f3;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(n2))
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p4 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', g3 = n2.open();
        if (null !== g3 && (g3.document.write(p4), g3.document.title = e3.filename), g3 || "undefined" == typeof safari)
          return g3;
        break;
      case "datauri":
      case "dataurl":
        return n2.document.location.href = this.output("datauristring", e3);
      default:
        return null;
    }
  }), Ge = function(t3) {
    return true === Array.isArray(Ut2) && Ut2.indexOf(t3) > -1;
  };
  switch (o3) {
    case "pt":
      _t2 = 1;
      break;
    case "mm":
      _t2 = 72 / 25.4;
      break;
    case "cm":
      _t2 = 72 / 2.54;
      break;
    case "in":
      _t2 = 72;
      break;
    case "px":
      _t2 = 1 == Ge("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t2 = 12;
      break;
    case "ex":
      _t2 = 6;
      break;
    default:
      if ("number" != typeof o3)
        throw new Error("Invalid unit: " + o3);
      _t2 = o3;
  }
  var Ye = null;
  K2(), Y2();
  var Je = function(t3) {
    return null !== m4 ? Ye.encryptor(t3, 0) : function(t4) {
      return t4;
    };
  }, Xe = y3.__private__.getPageInfo = y3.getPageInfo = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t3].objId, pageNumber: t3, pageContext: Rt2[t3] };
  }, Ke = y3.__private__.getPageInfoByObjId = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e3 in Rt2)
      if (Rt2[e3].objId === t3)
        break;
    return Xe(e3);
  }, Ze = y3.__private__.getCurrentPageInfo = y3.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y3.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y3.setPage = function() {
    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y3.insertPage = function(t3) {
    return this.addPage(), this.movePage($2, t3), this;
  }, y3.movePage = function(t3, e3) {
    var r3, n3;
    if (t3 > e3) {
      r3 = ot2[t3], n3 = Rt2[t3];
      for (var i4 = t3; i4 > e3; i4--)
        ot2[i4] = ot2[i4 - 1], Rt2[i4] = Rt2[i4 - 1];
      ot2[e3] = r3, Rt2[e3] = n3, this.setPage(e3);
    } else if (t3 < e3) {
      r3 = ot2[t3], n3 = Rt2[t3];
      for (var a3 = t3; a3 < e3; a3++)
        ot2[a3] = ot2[a3 + 1], Rt2[a3] = Rt2[a3 + 1];
      ot2[e3] = r3, Rt2[e3] = n3, this.setPage(e3);
    }
    return this;
  }, y3.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y3.__private__.text = y3.text = function(e3, r3, n3, i4, a3) {
    var o4, s4, c5, u4, h3, l3, f3, d3, p4, g3 = (i4 = i4 || {}).scope || this;
    if ("number" == typeof e3 && "number" == typeof r3 && ("string" == typeof n3 || Array.isArray(n3))) {
      var m5 = n3;
      n3 = r3, r3 = e3, e3 = m5;
    }
    if (arguments[3] instanceof Vt2 == false ? (c5 = arguments[4], u4 = arguments[5], "object" === _typeof(f3 = arguments[3]) && null !== f3 || ("string" == typeof c5 && (u4 = c5, c5 = null), "string" == typeof f3 && (u4 = f3, f3 = null), "number" == typeof f3 && (c5 = f3, f3 = null), i4 = { flags: f3, angle: c5, align: u4 })) : (q2("The transform parameter of text() with a Matrix value"), p4 = a3), isNaN(r3) || isNaN(n3) || null == e3)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e3.length)
      return g3;
    var v4 = "", y4 = false, w3 = "number" == typeof i4.lineHeightFactor ? i4.lineHeightFactor : lr, N4 = g3.internal.scaleFactor;
    function L3(t3) {
      return t3 = t3.split("	").join(Array(i4.TabLen || 9).join(" ")), Ce(t3, f3);
    }
    function A3(t3) {
      for (var e4, r4 = t3.concat(), n4 = [], i5 = r4.length; i5--; )
        "string" == typeof (e4 = r4.shift()) ? n4.push(e4) : Array.isArray(t3) && (1 === e4.length || void 0 === e4[1] && void 0 === e4[2]) ? n4.push(e4[0]) : n4.push([e4[0], e4[1], e4[2]]);
      return n4;
    }
    function _4(t3, e4) {
      var r4;
      if ("string" == typeof t3)
        r4 = e4(t3)[0];
      else if (Array.isArray(t3)) {
        for (var n4, i5, a4 = t3.concat(), o5 = [], s5 = a4.length; s5--; )
          "string" == typeof (n4 = a4.shift()) ? o5.push(e4(n4)[0]) : Array.isArray(n4) && "string" == typeof n4[0] && (i5 = e4(n4[0], n4[1], n4[2]), o5.push([i5[0], i5[1], i5[2]]));
        r4 = o5;
      }
      return r4;
    }
    var P3 = false, k3 = true;
    if ("string" == typeof e3)
      P3 = true;
    else if (Array.isArray(e3)) {
      var I2 = e3.concat();
      s4 = [];
      for (var F2, C2 = I2.length; C2--; )
        ("string" != typeof (F2 = I2.shift()) || Array.isArray(F2) && "string" != typeof F2[0]) && (k3 = false);
      P3 = k3;
    }
    if (false === P3)
      throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
    "string" == typeof e3 && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
    var j2 = gt2 / g3.internal.scaleFactor, B2 = j2 * (w3 - 1);
    switch (i4.baseline) {
      case "bottom":
        n3 -= B2;
        break;
      case "top":
        n3 += j2 - B2;
        break;
      case "hanging":
        n3 += j2 - 2 * B2;
        break;
      case "middle":
        n3 += j2 / 2 - B2;
    }
    if ((l3 = i4.maxWidth || 0) > 0 && ("string" == typeof e3 ? e3 = g3.splitTextToSize(e3, l3) : "[object Array]" === Object.prototype.toString.call(e3) && (e3 = e3.reduce(function(t3, e4) {
      return t3.concat(g3.splitTextToSize(e4, l3));
    }, []))), o4 = { text: e3, x: r3, y: n3, options: i4, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o4), e3 = o4.text, c5 = (i4 = o4.options).angle, p4 instanceof Vt2 == false && c5 && "number" == typeof c5) {
      c5 *= Math.PI / 180, 0 === i4.rotationDirection && (c5 = -c5), S2 === x2.ADVANCED && (c5 = -c5);
      var M2 = Math.cos(c5), E2 = Math.sin(c5);
      p4 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else
      c5 && c5 instanceof Vt2 && (p4 = c5);
    S2 !== x2.ADVANCED || p4 || (p4 = Yt2), void 0 !== (h3 = i4.charSpace || _r) && (v4 += O3(U2(h3)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d3 = i4.horizontalScale) && (v4 += O3(100 * d3) + " Tz\n");
    i4.lang;
    var D3 = -1, R3 = void 0 !== i4.renderingMode ? i4.renderingMode : i4.stroke, T4 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var z3 = void 0 !== T4.usedRenderingMode ? T4.usedRenderingMode : -1;
    -1 !== D3 ? v4 += D3 + " Tr\n" : -1 !== z3 && (v4 += "0 Tr\n"), -1 !== D3 && (T4.usedRenderingMode = D3), u4 = i4.align || "left";
    var H3, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St2];
    h3 = i4.charSpace || _r, l3 = i4.maxWidth || 0, f3 = Object.assign({ autoencode: true, noBOM: true }, i4.flags);
    var Y3 = [], J3 = function(t3) {
      return g3.getStringUnitWidth(t3, { font: G3, charSpace: h3, fontSize: gt2, doKerning: false }) * gt2 / N4;
    };
    if ("[object Array]" === Object.prototype.toString.call(e3)) {
      var X3;
      s4 = A3(e3), "left" !== u4 && (H3 = s4.map(J3));
      var K3, Z3 = 0;
      if ("right" === u4) {
        r3 -= H3[0], e3 = [], C2 = s4.length;
        for (var $3 = 0; $3 < C2; $3++)
          0 === $3 ? (K3 = br(r3), X3 = yr(n3)) : (K3 = U2(Z3 - H3[$3]), X3 = -W3), e3.push([s4[$3], K3, X3]), Z3 = H3[$3];
      } else if ("center" === u4) {
        r3 -= H3[0] / 2, e3 = [], C2 = s4.length;
        for (var Q3 = 0; Q3 < C2; Q3++)
          0 === Q3 ? (K3 = br(r3), X3 = yr(n3)) : (K3 = U2((Z3 - H3[Q3]) / 2), X3 = -W3), e3.push([s4[Q3], K3, X3]), Z3 = H3[Q3];
      } else if ("left" === u4) {
        e3 = [], C2 = s4.length;
        for (var tt3 = 0; tt3 < C2; tt3++)
          e3.push(s4[tt3]);
      } else if ("justify" === u4 && "Identity-H" === G3.encoding) {
        e3 = [], C2 = s4.length, l3 = 0 !== l3 ? l3 : V3;
        for (var et4 = 0, rt3 = 0; rt3 < C2; rt3++)
          if (X3 = 0 === rt3 ? yr(n3) : -W3, K3 = 0 === rt3 ? br(r3) : et4, rt3 < C2 - 1) {
            var nt3 = U2((l3 - H3[rt3]) / (s4[rt3].split(" ").length - 1)), it3 = s4[rt3].split(" ");
            e3.push([it3[0] + " ", K3, X3]), et4 = 0;
            for (var at3 = 1; at3 < it3.length; at3++) {
              var ot3 = (J3(it3[at3 - 1] + " " + it3[at3]) - J3(it3[at3])) * N4 + nt3;
              at3 == it3.length - 1 ? e3.push([it3[at3], ot3, 0]) : e3.push([it3[at3] + " ", ot3, 0]), et4 -= ot3;
            }
          } else
            e3.push([s4[rt3], K3, X3]);
        e3.push(["", et4, 0]);
      } else {
        if ("justify" !== u4)
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e3 = [], C2 = s4.length, l3 = 0 !== l3 ? l3 : V3;
        for (rt3 = 0; rt3 < C2; rt3++)
          X3 = 0 === rt3 ? yr(n3) : -W3, K3 = 0 === rt3 ? br(r3) : 0, rt3 < C2 - 1 ? Y3.push(O3(U2((l3 - H3[rt3]) / (s4[rt3].split(" ").length - 1)))) : Y3.push(0), e3.push([s4[rt3], K3, X3]);
      }
    }
    var st3 = "boolean" == typeof i4.R2L ? i4.R2L : bt2;
    true === st3 && (e3 = _4(e3, function(t3, e4, r4) {
      return [t3.split("").reverse().join(""), e4, r4];
    })), o4 = { text: e3, x: r3, y: n3, options: i4, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o4), e3 = o4.text, y4 = o4.mutex.isHex || false;
    var ct3 = Ft2[St2].encoding;
    "WinAnsiEncoding" !== ct3 && "StandardEncoding" !== ct3 || (e3 = _4(e3, function(t3, e4, r4) {
      return [L3(t3), e4, r4];
    })), s4 = A3(e3), e3 = [];
    for (var ut3, ht3, ft3, dt3 = 0, pt3 = 1, mt3 = Array.isArray(s4[0]) ? pt3 : dt3, vt3 = "", yt3 = function(t3, e4, r4) {
      var n4 = "";
      return r4 instanceof Vt2 ? (r4 = "number" == typeof i4.angle ? Gt2(r4, new Vt2(1, 0, 0, 1, t3, e4)) : Gt2(new Vt2(1, 0, 0, 1, t3, e4), r4), S2 === x2.ADVANCED && (r4 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r4)), n4 = r4.join(" ") + " Tm\n") : n4 = O3(t3) + " " + O3(e4) + " Td\n", n4;
    }, wt3 = 0; wt3 < s4.length; wt3++) {
      switch (vt3 = "", mt3) {
        case pt3:
          ft3 = (y4 ? "<" : "(") + s4[wt3][0] + (y4 ? ">" : ")"), ut3 = parseFloat(s4[wt3][1]), ht3 = parseFloat(s4[wt3][2]);
          break;
        case dt3:
          ft3 = (y4 ? "<" : "(") + s4[wt3] + (y4 ? ">" : ")"), ut3 = br(r3), ht3 = yr(n3);
      }
      void 0 !== Y3 && void 0 !== Y3[wt3] && (vt3 = Y3[wt3] + " Tw\n"), 0 === wt3 ? e3.push(vt3 + yt3(ut3, ht3, p4) + ft3) : mt3 === dt3 ? e3.push(vt3 + ft3) : mt3 === pt3 && e3.push(vt3 + yt3(ut3, ht3, p4) + ft3);
    }
    e3 = mt3 === dt3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
    var Nt3 = "BT\n/";
    return Nt3 += St2 + " " + gt2 + " Tf\n", Nt3 += O3(gt2 * w3) + " TL\n", Nt3 += xr + "\n", Nt3 += v4, Nt3 += e3, lt2(Nt3 += "ET"), b2[St2] = true, g3;
  };
  var $e = y3.__private__.clip = y3.clip = function(t3) {
    return lt2("evenodd" === t3 ? "W*" : "W"), this;
  };
  y3.clipEvenOdd = function() {
    return $e("evenodd");
  }, y3.__private__.discardPath = y3.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe = y3.__private__.isValidStyle = function(t3) {
    var e3 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t3) && (e3 = true), e3;
  };
  y3.__private__.setDefaultPathOperation = y3.setDefaultPathOperation = function(t3) {
    return Qe(t3) && (g2 = t3), this;
  };
  var tr = y3.__private__.getStyle = y3.getStyle = function(t3) {
    var e3 = g2;
    switch (t3) {
      case "D":
      case "S":
        e3 = "S";
        break;
      case "F":
        e3 = "f";
        break;
      case "FD":
      case "DF":
        e3 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e3 = t3;
    }
    return e3;
  }, er = y3.close = function() {
    return lt2("h"), this;
  };
  y3.stroke = function() {
    return lt2("S"), this;
  }, y3.fill = function(t3) {
    return rr("f", t3), this;
  }, y3.fillEvenOdd = function(t3) {
    return rr("f*", t3), this;
  }, y3.fillStroke = function(t3) {
    return rr("B", t3), this;
  }, y3.fillStrokeEvenOdd = function(t3) {
    return rr("B*", t3), this;
  };
  var rr = function(e3, r3) {
    "object" === _typeof(r3) ? ar(r3, e3) : lt2(e3);
  }, nr = function(t3) {
    null === t3 || S2 === x2.ADVANCED && void 0 === t3 || (t3 = tr(t3), lt2(t3));
  };
  function ir(t3, e3, r3, n3, i4) {
    var a3 = new M(e3 || this.boundingBox, r3 || this.xStep, n3 || this.yStep, this.gState, i4 || this.matrix);
    a3.stream = this.stream;
    var o4 = t3 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o4, a3), a3;
  }
  var ar = function(t3, e3) {
    var r3 = Bt2[t3.key], n3 = Ot2[r3];
    if (n3 instanceof B)
      lt2("q"), lt2(or(e3)), n3.gState && y3.setGState(n3.gState), lt2(t3.matrix.toString() + " cm"), lt2("/" + r3 + " sh"), lt2("Q");
    else if (n3 instanceof M) {
      var i4 = new Vt2(1, 0, 0, -1, 0, Rr());
      t3.matrix && (i4 = i4.multiply(t3.matrix || Yt2), r3 = ir.call(n3, t3.key, t3.boundingBox, t3.xStep, t3.yStep, i4).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r3 + " scn"), n3.gState && y3.setGState(n3.gState), lt2(e3), lt2("Q");
    }
  }, or = function(t3) {
    switch (t3) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y3.moveTo = function(t3, e3) {
    return lt2(O3(U2(t3)) + " " + O3(H2(e3)) + " m"), this;
  }, cr = y3.lineTo = function(t3, e3) {
    return lt2(O3(U2(t3)) + " " + O3(H2(e3)) + " l"), this;
  }, ur = y3.curveTo = function(t3, e3, r3, n3, i4, a3) {
    return lt2([O3(U2(t3)), O3(H2(e3)), O3(U2(r3)), O3(H2(n3)), O3(U2(i4)), O3(H2(a3)), "c"].join(" ")), this;
  };
  y3.__private__.line = y3.line = function(t3, e3, r3, n3, i4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || !Qe(i4))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r3 - t3, n3 - e3]], t3, e3, [1, 1], i4 || "S") : this.lines([[r3 - t3, n3 - e3]], t3, e3, [1, 1]).stroke();
  }, y3.__private__.lines = y3.lines = function(t3, e3, r3, n3, i4, a3) {
    var o4, s4, c5, u4, h3, l3, f3, d3, p4, g3, m5, v4;
    if ("number" == typeof t3 && (v4 = r3, r3 = e3, e3 = t3, t3 = v4), n3 = n3 || [1, 1], a3 = a3 || false, isNaN(e3) || isNaN(r3) || !Array.isArray(t3) || !Array.isArray(n3) || !Qe(i4) || "boolean" != typeof a3)
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e3, r3), o4 = n3[0], s4 = n3[1], u4 = t3.length, g3 = e3, m5 = r3, c5 = 0; c5 < u4; c5++)
      2 === (h3 = t3[c5]).length ? (g3 = h3[0] * o4 + g3, m5 = h3[1] * s4 + m5, cr(g3, m5)) : (l3 = h3[0] * o4 + g3, f3 = h3[1] * s4 + m5, d3 = h3[2] * o4 + g3, p4 = h3[3] * s4 + m5, g3 = h3[4] * o4 + g3, m5 = h3[5] * s4 + m5, ur(l3, f3, d3, p4, g3, m5));
    return a3 && er(), nr(i4), this;
  }, y3.path = function(t3) {
    for (var e3 = 0; e3 < t3.length; e3++) {
      var r3 = t3[e3], n3 = r3.c;
      switch (r3.op) {
        case "m":
          sr(n3[0], n3[1]);
          break;
        case "l":
          cr(n3[0], n3[1]);
          break;
        case "c":
          ur.apply(this, n3);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y3.__private__.rect = y3.rect = function(t3, e3, r3, n3, i4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || !Qe(i4))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n3 = -n3), lt2([O3(U2(t3)), O3(H2(e3)), O3(U2(r3)), O3(U2(n3)), "re"].join(" ")), nr(i4), this;
  }, y3.__private__.triangle = y3.triangle = function(t3, e3, r3, n3, i4, a3, o4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i4) || isNaN(a3) || !Qe(o4))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r3 - t3, n3 - e3], [i4 - r3, a3 - n3], [t3 - i4, e3 - a3]], t3, e3, [1, 1], o4, true), this;
  }, y3.__private__.roundedRect = y3.roundedRect = function(t3, e3, r3, n3, i4, a3, o4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i4) || isNaN(a3) || !Qe(o4))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s4 = 4 / 3 * (Math.SQRT2 - 1);
    return i4 = Math.min(i4, 0.5 * r3), a3 = Math.min(a3, 0.5 * n3), this.lines([[r3 - 2 * i4, 0], [i4 * s4, 0, i4, a3 - a3 * s4, i4, a3], [0, n3 - 2 * a3], [0, a3 * s4, -i4 * s4, a3, -i4, a3], [2 * i4 - r3, 0], [-i4 * s4, 0, -i4, -a3 * s4, -i4, -a3], [0, 2 * a3 - n3], [0, -a3 * s4, i4 * s4, -a3, i4, -a3]], t3 + i4, e3, [1, 1], o4, true), this;
  }, y3.__private__.ellipse = y3.ellipse = function(t3, e3, r3, n3, i4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || !Qe(i4))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a3 = 4 / 3 * (Math.SQRT2 - 1) * r3, o4 = 4 / 3 * (Math.SQRT2 - 1) * n3;
    return sr(t3 + r3, e3), ur(t3 + r3, e3 - o4, t3 + a3, e3 - n3, t3, e3 - n3), ur(t3 - a3, e3 - n3, t3 - r3, e3 - o4, t3 - r3, e3), ur(t3 - r3, e3 + o4, t3 - a3, e3 + n3, t3, e3 + n3), ur(t3 + a3, e3 + n3, t3 + r3, e3 + o4, t3 + r3, e3), nr(i4), this;
  }, y3.__private__.circle = y3.circle = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || !Qe(n3))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t3, e3, r3, r3, n3);
  }, y3.setFont = function(t3, e3, r3) {
    return r3 && (e3 = k2(e3, r3)), St2 = qe(t3, e3, { disableWarning: false }), this;
  };
  var hr = y3.__private__.getFont = y3.getFont = function() {
    return Ft2[qe.apply(y3, arguments)];
  };
  y3.__private__.getFontList = y3.getFontList = function() {
    var t3, e3, r3 = {};
    for (t3 in Ct2)
      if (Ct2.hasOwnProperty(t3))
        for (e3 in r3[t3] = [], Ct2[t3])
          Ct2[t3].hasOwnProperty(e3) && r3[t3].push(e3);
    return r3;
  }, y3.addFont = function(t3, e3, r3, n3, i4) {
    var a3 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a3.indexOf(arguments[3]) ? i4 = arguments[3] : arguments[3] && -1 == a3.indexOf(arguments[3]) && (r3 = k2(r3, n3)), i4 = i4 || "Identity-H", Pe.call(this, t3, e3, r3, i4);
  };
  var lr, fr = e2.lineWidth || 0.200025, dr = y3.__private__.getLineWidth = y3.getLineWidth = function() {
    return fr;
  }, pr = y3.__private__.setLineWidth = y3.setLineWidth = function(t3) {
    return fr = t3, lt2(O3(U2(t3)) + " w"), this;
  };
  y3.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t3, e3) {
    if (t3 = t3 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t3))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t3 = t3.map(function(t4) {
      return O3(U2(t4));
    }).join(" "), e3 = O3(U2(e3)), lt2("[" + t3 + "] " + e3 + " d"), this;
  };
  var gr = y3.__private__.getLineHeight = y3.getLineHeight = function() {
    return gt2 * lr;
  };
  y3.__private__.getLineHeight = y3.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y3.__private__.setLineHeightFactor = y3.setLineHeightFactor = function(t3) {
    return "number" == typeof (t3 = t3 || 1.15) && (lr = t3), this;
  }, vr = y3.__private__.getLineHeightFactor = y3.getLineHeightFactor = function() {
    return lr;
  };
  mr(e2.lineHeight);
  var br = y3.__private__.getHorizontalCoordinate = function(t3) {
    return U2(t3);
  }, yr = y3.__private__.getVerticalCoordinate = function(t3) {
    return S2 === x2.ADVANCED ? t3 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t3);
  }, wr = y3.__private__.getHorizontalCoordinateString = y3.getHorizontalCoordinateString = function(t3) {
    return O3(br(t3));
  }, Nr = y3.__private__.getVerticalCoordinateString = y3.getVerticalCoordinateString = function(t3) {
    return O3(yr(t3));
  }, Lr = e2.strokeColor || "0 G";
  y3.__private__.getStrokeColor = y3.getDrawColor = function() {
    return ee2(Lr);
  }, y3.__private__.setStrokeColor = y3.setDrawColor = function(t3, e3, r3, n3) {
    return Lr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n3, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e2.fillColor || "0 g";
  y3.__private__.getFillColor = y3.getFillColor = function() {
    return ee2(Ar);
  }, y3.__private__.setFillColor = y3.setFillColor = function(t3, e3, r3, n3) {
    return Ar = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n3, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e2.textColor || "0 g", Sr = y3.__private__.getTextColor = y3.getTextColor = function() {
    return ee2(xr);
  };
  y3.__private__.setTextColor = y3.setTextColor = function(t3, e3, r3, n3) {
    return xr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n3, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e2.charSpace, Pr = y3.__private__.getCharSpace = y3.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y3.__private__.setCharSpace = y3.setCharSpace = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t3, this;
  };
  var kr = 0;
  y3.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y3.__private__.setLineCap = y3.setLineCap = function(t3) {
    var e3 = y3.CapJoinStyles[t3];
    if (void 0 === e3)
      throw new Error("Line cap style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e3, lt2(e3 + " J"), this;
  };
  var Ir = 0;
  y3.__private__.setLineJoin = y3.setLineJoin = function(t3) {
    var e3 = y3.CapJoinStyles[t3];
    if (void 0 === e3)
      throw new Error("Line join style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e3, lt2(e3 + " j"), this;
  }, y3.__private__.setLineMiterLimit = y3.__private__.setMiterLimit = y3.setLineMiterLimit = y3.setMiterLimit = function(t3) {
    if (t3 = t3 || 0, isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O3(U2(t3)) + " M"), this;
  }, y3.GState = j, y3.setGState = function(t3) {
    (t3 = "string" == typeof t3 ? Mt2[Et2[t3]] : Fr(null, t3)).equals(qt2) || (lt2("/" + t3.id + " gs"), qt2 = t3);
  };
  var Fr = function(t3, e3) {
    if (!t3 || !Et2[t3]) {
      var r3 = false;
      for (var n3 in Mt2)
        if (Mt2.hasOwnProperty(n3) && Mt2[n3].equals(e3)) {
          r3 = true;
          break;
        }
      if (r3)
        e3 = Mt2[n3];
      else {
        var i4 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i4] = e3, e3.id = i4;
      }
      return t3 && (Et2[t3] = e3.id), Tt2.publish("addGState", e3), e3;
    }
  };
  y3.addGState = function(t3, e3) {
    return Fr(t3, e3), this;
  }, y3.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St2, size: gt2, color: xr }), this;
  }, y3.restoreGraphicsState = function() {
    lt2("Q");
    var t3 = jt2.pop();
    return St2 = t3.key, gt2 = t3.size, xr = t3.color, qt2 = null, this;
  }, y3.setCurrentTransformationMatrix = function(t3) {
    return lt2(t3.toString() + " cm"), this;
  }, y3.comment = function(t3) {
    return lt2("#" + t3), this;
  };
  var Cr = function(t3, e3) {
    var r3 = t3 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      isNaN(t4) || (r3 = parseFloat(t4));
    } });
    var n3 = e3 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n3;
    }, set: function(t4) {
      isNaN(t4) || (n3 = parseFloat(t4));
    } });
    var i4 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i4;
    }, set: function(t4) {
      i4 = t4.toString();
    } }), this;
  }, jr = function(t3, e3, r3, n3) {
    Cr.call(this, t3, e3), this.type = "rect";
    var i4 = r3 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i4;
    }, set: function(t4) {
      isNaN(t4) || (i4 = parseFloat(t4));
    } });
    var a3 = n3 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a3;
    }, set: function(t4) {
      isNaN(t4) || (a3 = parseFloat(t4));
    } }), this;
  }, Or = function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = function(t3, e3, r3, n3, i4) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t3, kt2 = e3, It2 = i4, je([r3, n3]);
  }, Mr = function(t3) {
    if (Ht2[t3])
      Wt2.pop().restore();
    else {
      var e3 = new Or(), r3 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
      e3.id = r3, Ht2[t3] = r3, zt2[r3] = e3, Tt2.publish("addFormObject", e3), Wt2.pop().restore();
    }
  };
  for (var Er in y3.beginFormObject = function(t3, e3, r3, n3, i4) {
    return Br(t3, e3, r3, n3, i4), this;
  }, y3.endFormObject = function(t3) {
    return Mr(t3), this;
  }, y3.doFormObject = function(t3, e3) {
    var r3 = zt2[Ht2[t3]];
    return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + r3.id + " Do"), lt2("Q"), this;
  }, y3.getFormObject = function(t3) {
    var e3 = zt2[Ht2[t3]];
    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
  }, y3.save = function(t3, e3) {
    return t3 = t3 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, false === e3.returnPromise ? (l2(We(He()), t3), "function" == typeof l2.unload && n2.setTimeout && setTimeout(l2.unload, 911), this) : new Promise(function(e4, r3) {
      try {
        var i4 = l2(We(He()), t3);
        "function" == typeof l2.unload && n2.setTimeout && setTimeout(l2.unload, 911), e4(i4);
      } catch (t4) {
        r3(t4.message);
      }
    });
  }, E.API)
    E.API.hasOwnProperty(Er) && ("events" === Er && E.API.events.length ? function(t3, e3) {
      var r3, n3, i4;
      for (i4 = e3.length - 1; -1 !== i4; i4--)
        r3 = e3[i4][0], n3 = e3[i4][1], t3.subscribe.apply(t3, [r3].concat("function" == typeof n3 ? [n3] : n3));
    }(Tt2, E.API.events) : y3[Er] = E.API[Er]);
  var qr = y3.getPageWidth = function(t3) {
    return (Rt2[t3 = t3 || $2].mediaBox.topRightX - Rt2[t3].mediaBox.bottomLeftX) / _t2;
  }, Dr = y3.setPageWidth = function(t3, e3) {
    Rt2[t3].mediaBox.topRightX = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftX;
  }, Rr = y3.getPageHeight = function(t3) {
    return (Rt2[t3 = t3 || $2].mediaBox.topRightY - Rt2[t3].mediaBox.bottomLeftY) / _t2;
  }, Tr = y3.setPageHeight = function(t3, e3) {
    Rt2[t3].mediaBox.topRightY = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftY;
  };
  return y3.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t3) {
    Dr($2, t3);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t3) {
    Tr($2, t3);
  } }, encryptionOptions: m4, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T3, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N3, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y3.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t3) {
    Dr($2, t3);
  }, enumerable: true, configurable: true }), Object.defineProperty(y3.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t3) {
    Tr($2, t3);
  }, enumerable: true, configurable: true }), ke.call(y3, pt2), St2 = "F1", Oe(s3, i3), Tt2.publish("initialized"), y3;
}
I.prototype.lsbFirstWord = function(t3) {
  return String.fromCharCode(t3 >> 0 & 255, t3 >> 8 & 255, t3 >> 16 & 255, t3 >> 24 & 255);
}, I.prototype.toHexString = function(t3) {
  return t3.split("").map(function(t4) {
    return ("0" + (255 & t4.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t3) {
  for (var e2 = [], r2 = 0; r2 < t3.length; r2 += 2)
    e2.push(String.fromCharCode(parseInt(t3.substr(r2, 2), 16)));
  return e2.join("");
}, I.prototype.processOwnerPassword = function(t3, e2) {
  return P(x(e2).substr(0, 5), t3);
}, I.prototype.encryptor = function(t3, e2) {
  var r2 = x(this.encryptionKey + String.fromCharCode(255 & t3, t3 >> 8 & 255, t3 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
  return function(t4) {
    return P(r2, t4);
  };
}, j.prototype.equals = function(e2) {
  var r2, n3 = "id,objectNumber,equals";
  if (!e2 || _typeof(e2) !== _typeof(this))
    return false;
  var i3 = 0;
  for (r2 in this)
    if (!(n3.indexOf(r2) >= 0)) {
      if (this.hasOwnProperty(r2) && !e2.hasOwnProperty(r2))
        return false;
      if (this[r2] !== e2[r2])
        return false;
      i3++;
    }
  for (r2 in e2)
    e2.hasOwnProperty(r2) && n3.indexOf(r2) < 0 && i3--;
  return 0 === i3;
}, E.API = { events: [] }, E.version = "2.5.2";
var q = E.API;
var D = 1;
var R = function(t3) {
  return t3.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
};
var T2 = function(t3) {
  return t3.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var U = function(t3) {
  return t3.toFixed(2);
};
var z = function(t3) {
  return t3.toFixed(5);
};
q.__acroform__ = {};
var H = function(t3, e2) {
  t3.prototype = Object.create(e2.prototype), t3.prototype.constructor = t3;
};
var W = function(t3) {
  return t3 * D;
};
var V = function(t3) {
  var e2 = new ut(), r2 = At.internal.getHeight(t3) || 0, n3 = At.internal.getWidth(t3) || 0;
  return e2.BBox = [0, 0, Number(U(n3)), Number(U(r2))], e2;
};
var G = q.__acroform__.setBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t3 |= 1 << e2;
};
var Y = q.__acroform__.clearBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t3 &= ~(1 << e2);
};
var J = q.__acroform__.getBit = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return 0 == (t3 & 1 << e2) ? 0 : 1;
};
var X = q.__acroform__.getBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t3, e2 - 1);
};
var K = q.__acroform__.setBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t3, e2 - 1);
};
var Z = q.__acroform__.clearBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t3, e2 - 1);
};
var $ = q.__acroform__.calculateCoordinates = function(t3, e2) {
  var r2 = e2.internal.getHorizontalCoordinate, n3 = e2.internal.getVerticalCoordinate, i3 = t3[0], a3 = t3[1], o3 = t3[2], s3 = t3[3], c4 = {};
  return c4.lowerLeft_X = r2(i3) || 0, c4.lowerLeft_Y = n3(a3 + s3) || 0, c4.upperRight_X = r2(i3 + o3) || 0, c4.upperRight_Y = n3(a3) || 0, [Number(U(c4.lowerLeft_X)), Number(U(c4.lowerLeft_Y)), Number(U(c4.upperRight_X)), Number(U(c4.upperRight_Y))];
};
var Q = function(t3) {
  if (t3.appearanceStreamContent)
    return t3.appearanceStreamContent;
  if (t3.V || t3.DV) {
    var e2 = [], r2 = t3._V || t3.DV, n3 = tt(t3, r2), i3 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id;
    e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t3.scope.__private__.encodeColorString(t3.color)), e2.push("/" + i3 + " " + U(n3.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(n3.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
    var a3 = V(t3);
    return a3.scope = t3.scope, a3.stream = e2.join("\n"), a3;
  }
};
var tt = function(t3, e2) {
  var r2 = 0 === t3.fontSize ? t3.maxFontSize : t3.fontSize, n3 = { text: "", fontSize: "" }, i3 = (e2 = ")" == (e2 = "(" == e2.substr(0, 1) ? e2.substr(1) : e2).substr(e2.length - 1) ? e2.substr(0, e2.length - 1) : e2).split(" ");
  i3 = t3.multiline ? i3.map(function(t4) {
    return t4.split("\n");
  }) : i3.map(function(t4) {
    return [t4];
  });
  var a3 = r2, o3 = At.internal.getHeight(t3) || 0;
  o3 = o3 < 0 ? -o3 : o3;
  var s3 = At.internal.getWidth(t3) || 0;
  s3 = s3 < 0 ? -s3 : s3;
  var c4 = function(e3, r3, n4) {
    if (e3 + 1 < i3.length) {
      var a4 = r3 + " " + i3[e3 + 1][0];
      return et2(a4, t3, n4).width <= s3 - 4;
    }
    return false;
  };
  a3++;
  t:
    for (; a3 > 0; ) {
      e2 = "", a3--;
      var u3, h3, l3 = et2("3", t3, a3).height, f3 = t3.multiline ? o3 - a3 : (o3 - l3) / 2, d2 = f3 += 2, p3 = 0, g2 = 0, m4 = 0;
      if (a3 <= 0) {
        e2 = "(...) Tj\n", e2 += "% Width of Text: " + et2(e2, t3, a3 = 12).width + ", FieldWidth:" + s3 + "\n";
        break;
      }
      for (var v3 = "", b2 = 0, y3 = 0; y3 < i3.length; y3++)
        if (i3.hasOwnProperty(y3)) {
          var w2 = false;
          if (1 !== i3[y3].length && m4 !== i3[y3].length - 1) {
            if ((l3 + 2) * (b2 + 2) + 2 > o3)
              continue t;
            v3 += i3[y3][m4], w2 = true, g2 = y3, y3--;
          } else {
            v3 = " " == (v3 += i3[y3][m4] + " ").substr(v3.length - 1) ? v3.substr(0, v3.length - 1) : v3;
            var N3 = parseInt(y3), L2 = c4(N3, v3, a3), A2 = y3 >= i3.length - 1;
            if (L2 && !A2) {
              v3 += " ", m4 = 0;
              continue;
            }
            if (L2 || A2) {
              if (A2)
                g2 = N3;
              else if (t3.multiline && (l3 + 2) * (b2 + 2) + 2 > o3)
                continue t;
            } else {
              if (!t3.multiline)
                continue t;
              if ((l3 + 2) * (b2 + 2) + 2 > o3)
                continue t;
              g2 = N3;
            }
          }
          for (var x2 = "", S2 = p3; S2 <= g2; S2++) {
            var _3 = i3[S2];
            if (t3.multiline) {
              if (S2 === g2) {
                x2 += _3[m4] + " ", m4 = (m4 + 1) % _3.length;
                continue;
              }
              if (S2 === p3) {
                x2 += _3[_3.length - 1] + " ";
                continue;
              }
            }
            x2 += _3[0] + " ";
          }
          switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, h3 = et2(x2, t3, a3).width, t3.textAlign) {
            case "right":
              u3 = s3 - h3 - 2;
              break;
            case "center":
              u3 = (s3 - h3) / 2;
              break;
            case "left":
            default:
              u3 = 2;
          }
          e2 += U(u3) + " " + U(d2) + " Td\n", e2 += "(" + R(x2) + ") Tj\n", e2 += -U(u3) + " 0 Td\n", d2 = -(a3 + 2), h3 = 0, p3 = w2 ? g2 : g2 + 1, b2++, v3 = "";
        } else
          ;
      break;
    }
  return n3.text = e2, n3.fontSize = a3, n3;
};
var et2 = function(t3, e2, r2) {
  var n3 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i3 = e2.scope.getStringUnitWidth(t3, { font: n3, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2);
  return { height: e2.scope.getStringUnitWidth("3", { font: n3, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2) * 1.5, width: i3 };
};
var rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false };
var nt = function(t3, e2) {
  var r2 = { type: "reference", object: t3 };
  void 0 === e2.internal.getPageInfo(t3.page).pageContext.annotations.find(function(t4) {
    return t4.type === r2.type && t4.object === r2.object;
  }) && e2.internal.getPageInfo(t3.page).pageContext.annotations.push(r2);
};
var it = function(e2, r2) {
  for (var n3 in e2)
    if (e2.hasOwnProperty(n3)) {
      var i3 = n3, a3 = e2[n3];
      r2.internal.newObjectDeferredBegin(a3.objId, true), "object" === _typeof(a3) && "function" == typeof a3.putStream && a3.putStream(), delete e2[i3];
    }
};
var at = function(e2, r2) {
  if (r2.scope = e2, void 0 !== e2.internal && (void 0 === e2.internal.acroformPlugin || false === e2.internal.acroformPlugin.isInitialized)) {
    if (lt.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
      !function(t3) {
        t3.internal.events.unsubscribe(t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t3.internal.acroformPlugin.printedOut = true;
      }(e2);
    }), e2.internal.events.subscribe("buildDocument", function() {
      !function(t3) {
        t3.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e3 = t3.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r3 in e3)
          if (e3.hasOwnProperty(r3)) {
            var n3 = e3[r3];
            n3.objId = void 0, n3.hasAnnotation && nt(n3, t3);
          }
      }(e2);
    }), e2.internal.events.subscribe("putCatalog", function() {
      !function(t3) {
        if (void 0 === t3.internal.acroformPlugin.acroFormDictionaryRoot)
          throw new Error("putCatalogCallback: Root missing.");
        t3.internal.write("/AcroForm " + t3.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e2);
    }), e2.internal.events.subscribe("postPutPages", function(r3) {
      !function(e3, r4) {
        var n3 = !e3;
        for (var i3 in e3 || (r4.internal.newObjectDeferredBegin(r4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r4.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (e3.hasOwnProperty(i3)) {
            var a3 = e3[i3], o3 = [], s3 = a3.Rect;
            if (a3.Rect && (a3.Rect = $(a3.Rect, r4)), r4.internal.newObjectDeferredBegin(a3.objId, true), a3.DA = At.createDefaultAppearanceStream(a3), "object" === _typeof(a3) && "function" == typeof a3.getKeyValueListForStream && (o3 = a3.getKeyValueListForStream()), a3.Rect = s3, a3.hasAppearanceStream && !a3.appearanceStreamContent) {
              var c4 = Q(a3);
              o3.push({ key: "AP", value: "<</N " + c4 + ">>" }), r4.internal.acroformPlugin.xForms.push(c4);
            }
            if (a3.appearanceStreamContent) {
              var u3 = "";
              for (var h3 in a3.appearanceStreamContent)
                if (a3.appearanceStreamContent.hasOwnProperty(h3)) {
                  var l3 = a3.appearanceStreamContent[h3];
                  if (u3 += "/" + h3 + " ", u3 += "<<", Object.keys(l3).length >= 1 || Array.isArray(l3)) {
                    for (var i3 in l3)
                      if (l3.hasOwnProperty(i3)) {
                        var f3 = l3[i3];
                        "function" == typeof f3 && (f3 = f3.call(r4, a3)), u3 += "/" + i3 + " " + f3 + " ", r4.internal.acroformPlugin.xForms.indexOf(f3) >= 0 || r4.internal.acroformPlugin.xForms.push(f3);
                      }
                  } else
                    "function" == typeof (f3 = l3) && (f3 = f3.call(r4, a3)), u3 += "/" + i3 + " " + f3, r4.internal.acroformPlugin.xForms.indexOf(f3) >= 0 || r4.internal.acroformPlugin.xForms.push(f3);
                  u3 += ">>";
                }
              o3.push({ key: "AP", value: "<<\n" + u3 + ">>" });
            }
            r4.internal.putStream({ additionalKeyValues: o3, objectId: a3.objId }), r4.internal.out("endobj");
          }
        n3 && it(r4.internal.acroformPlugin.xForms, r4);
      }(r3, e2);
    }), e2.internal.acroformPlugin.isInitialized = true;
  }
};
var ot = q.__acroform__.arrayToPdfArray = function(e2, r2, n3) {
  var i3 = function(t3) {
    return t3;
  };
  if (Array.isArray(e2)) {
    for (var a3 = "[", o3 = 0; o3 < e2.length; o3++)
      switch (0 !== o3 && (a3 += " "), _typeof(e2[o3])) {
        case "boolean":
        case "number":
        case "object":
          a3 += e2[o3].toString();
          break;
        case "string":
          "/" !== e2[o3].substr(0, 1) ? (void 0 !== r2 && n3 && (i3 = n3.internal.getEncryptor(r2)), a3 += "(" + R(i3(e2[o3].toString())) + ")") : a3 += e2[o3].toString();
      }
    return a3 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t3, e2, r2) {
  var n3 = function(t4) {
    return t4;
  };
  return void 0 !== e2 && r2 && (n3 = r2.internal.getEncryptor(e2)), (t3 = t3 || "").toString(), t3 = "(" + R(n3(t3)) + ")";
};
var ct = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (void 0 === this._objId) {
      if (void 0 === this.scope)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t3) {
    this._objId = t3;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t3 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t3, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t3 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t4) {
    return "content" != t4 && "appearanceStreamContent" != t4 && "scope" != t4 && "objId" != t4 && "_" != t4.substring(0, 1);
  });
  for (var r2 in e2)
    if (false === Object.getOwnPropertyDescriptor(this, e2[r2]).configurable) {
      var n3 = e2[r2], i3 = this[n3];
      i3 && (Array.isArray(i3) ? t3.push({ key: n3, value: ot(i3, this.objId, this.scope) }) : i3 instanceof ct ? (i3.scope = this.scope, t3.push({ key: n3, value: i3.objId + " 0 R" })) : "function" != typeof i3 && t3.push({ key: n3, value: i3 }));
    }
  return t3;
};
var ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t3, e2 = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e2;
  }, set: function(t4) {
    e2 = t4;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
    t3 = e3.trim();
  }, get: function() {
    return t3 || null;
  } });
};
H(ut, ct);
var ht = function() {
  ct.call(this);
  var t3, e2 = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e2.length > 0 ? e2 : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e2;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t3) {
      var e3 = function(t4) {
        return t4;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(t3)) + ")";
    }
  }, set: function(e3) {
    t3 = e3;
  } });
};
H(ht, ct);
var lt = function t2() {
  ct.call(this);
  var e2 = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute F supplied.');
    e2 = t3;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e2, 3));
  }, set: function(t3) {
    true === Boolean(t3) ? this.F = K(e2, 3) : this.F = Z(e2, 3);
  } });
  var r2 = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
    r2 = t3;
  } });
  var n3 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (0 !== n3.length)
      return n3;
  }, set: function(t3) {
    n3 = void 0 !== t3 ? t3 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n3 || isNaN(n3[0]) ? 0 : n3[0];
  }, set: function(t3) {
    n3[0] = t3;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n3 || isNaN(n3[1]) ? 0 : n3[1];
  }, set: function(t3) {
    n3[1] = t3;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n3 || isNaN(n3[2]) ? 0 : n3[2];
  }, set: function(t3) {
    n3[2] = t3;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n3 || isNaN(n3[3]) ? 0 : n3[3];
  }, set: function(t3) {
    n3[3] = t3;
  } });
  var i3 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i3;
  }, set: function(t3) {
    switch (t3) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i3 = t3;
        break;
      default:
        throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
    }
  } });
  var a3 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a3 || a3.length < 1) {
      if (this instanceof yt)
        return;
      a3 = "FieldObject" + t2.FieldNum++;
    }
    var e3 = function(t3) {
      return t3;
    };
    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(a3)) + ")";
  }, set: function(t3) {
    a3 = t3.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a3;
  }, set: function(t3) {
    a3 = t3;
  } });
  var o3 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o3;
  }, set: function(t3) {
    o3 = t3;
  } });
  var s3 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s3;
  }, set: function(t3) {
    s3 = t3;
  } });
  var c4 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c4;
  }, set: function(t3) {
    c4 = t3;
  } });
  var u3 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return void 0 === u3 ? 50 / D : u3;
  }, set: function(t3) {
    u3 = t3;
  } });
  var h3 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h3;
  }, set: function(t3) {
    h3 = t3;
  } });
  var l3 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l3 || this instanceof yt || this instanceof Nt))
      return st(l3, this.objId, this.scope);
  }, set: function(t3) {
    t3 = t3.toString(), l3 = t3;
  } });
  var f3 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f3)
      return this instanceof mt == false ? st(f3, this.objId, this.scope) : f3;
  }, set: function(t3) {
    t3 = t3.toString(), f3 = this instanceof mt == false ? "(" === t3.substr(0, 1) ? T2(t3.substr(1, t3.length - 2)) : T2(t3) : t3;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T2(f3.substr(1, f3.length - 1)) : f3;
  }, set: function(t3) {
    t3 = t3.toString(), f3 = this instanceof mt == true ? "/" + t3 : t3;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return d2;
  }, set: function(t3) {
    this.V = t3;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == false ? "(" === t3.substr(0, 1) ? T2(t3.substr(1, t3.length - 2)) : T2(t3) : t3;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T2(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == true ? "/" + t3 : t3;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p3, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t3) {
    t3 = Boolean(t3), g2 = t3;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p3)
      return p3;
  }, set: function(t3) {
    p3 = t3;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
  } });
  var m4 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (null !== m4)
      return m4;
  }, set: function(t3) {
    if (-1 === [0, 1, 2].indexOf(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
    m4 = t3;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t3;
    switch (m4) {
      case 0:
      default:
        t3 = "left";
        break;
      case 1:
        t3 = "center";
        break;
      case 2:
        t3 = "right";
    }
    return t3;
  }, configurable: true, enumerable: true, set: function(t3) {
    switch (t3) {
      case "right":
      case 2:
        m4 = 2;
        break;
      case "center":
      case 1:
        m4 = 1;
        break;
      case "left":
      case 0:
      default:
        m4 = 0;
    }
  } });
};
H(lt, ct);
var ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t3 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } });
  var e2 = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e2, this.objId, this.scope);
  }, set: function(t4) {
    var r2, n3;
    n3 = [], "string" == typeof (r2 = t4) && (n3 = function(t5, e3, r3) {
      r3 || (r3 = 1);
      for (var n4, i3 = []; n4 = e3.exec(t5); )
        i3.push(n4[r3]);
      return i3;
    }(r2, /\((.*?)\)/g)), e2 = n3;
  } }), this.getOptions = function() {
    return e2;
  }, this.setOptions = function(t4) {
    e2 = t4, this.sort && e2.sort();
  }, this.addOption = function(t4) {
    t4 = (t4 = t4 || "").toString(), e2.push(t4), this.sort && e2.sort();
  }, this.removeOption = function(t4, r2) {
    for (r2 = r2 || false, t4 = (t4 = t4 || "").toString(); -1 !== e2.indexOf(t4) && (e2.splice(e2.indexOf(t4), 1), false !== r2); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t4) {
    true === this.combo && (true === Boolean(t4) ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t4) {
    true === Boolean(t4) ? (this.Ff = K(this.Ff, 20), e2.sort()) : this.Ff = Z(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
H(ft, lt);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
H(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
H(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
H(gt, pt);
var mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var e2, r2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r2).length) {
      var e3, n3 = [];
      for (e3 in n3.push("<<"), r2)
        n3.push("/" + e3 + " (" + R(t3(r2[e3])) + ")");
      return n3.push(">>"), n3.join("\n");
    }
  }, set: function(e3) {
    "object" === _typeof(e3) && (r2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r2.CA || "";
  }, set: function(t3) {
    "string" == typeof t3 && (r2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e2.substr(1, e2.length - 1);
  }, set: function(t3) {
    e2 = "/" + t3;
  } });
};
H(mt, lt);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
H(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t3 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = void 0 !== e2 ? e2 : [];
  } });
};
H(bt, mt);
var yt = function() {
  var e2, r2;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r2;
  }, set: function(t3) {
    r2 = t3;
  } });
  var n3, i3 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));
    var e3, r3 = [];
    for (e3 in r3.push("<<"), i3)
      r3.push("/" + e3 + " (" + R(t3(i3[e3])) + ")");
    return r3.push(">>"), r3.join("\n");
  }, set: function(e3) {
    "object" === _typeof(e3) && (i3 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i3.CA || "";
  }, set: function(t3) {
    "string" == typeof t3 && (i3.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n3;
  }, set: function(t3) {
    n3 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n3.substr(1, n3.length - 1);
  }, set: function(t3) {
    n3 = "/" + t3;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t3) {
  if (!("createAppearanceStream" in t3) || !("getCA" in t3))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e2 in this.Kids)
    if (this.Kids.hasOwnProperty(e2)) {
      var r2 = this.Kids[e2];
      r2.appearanceStreamContent = t3.createAppearanceStream(r2.optionName), r2.caption = t3.getCA();
    }
}, bt.prototype.createOption = function(t3) {
  var e2 = new yt();
  return e2.Parent = this, e2.optionName = t3, this.Kids.push(e2), xt.call(this.scope, e2), e2;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var t3 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e2) {
    Number.isInteger(e2) && (t3 = e2);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
H(Nt, lt);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
  } }), this.password = true;
};
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n3 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, i3 = t3.scope.__private__.encodeColorString(t3.color), a3 = tt(t3, t3.caption);
  return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), r2.push("BMC"), r2.push("q"), r2.push("0 0 1 rg"), r2.push("/" + n3 + " " + U(a3.fontSize) + " Tf " + i3), r2.push("BT"), r2.push(a3.text), r2.push("ET"), r2.push("Q"), r2.push("EMC"), e2.stream = r2.join("\n"), e2;
}, YesNormal: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, n3 = t3.scope.__private__.encodeColorString(t3.color), i3 = [], a3 = At.internal.getHeight(t3), o3 = At.internal.getWidth(t3), s3 = tt(t3, t3.caption);
  return i3.push("1 g"), i3.push("0 0 " + U(o3) + " " + U(a3) + " re"), i3.push("f"), i3.push("q"), i3.push("0 0 1 rg"), i3.push("0 0 " + U(o3 - 1) + " " + U(a3 - 1) + " re"), i3.push("W"), i3.push("n"), i3.push("0 g"), i3.push("BT"), i3.push("/" + r2 + " " + U(s3.fontSize) + " Tf " + n3), i3.push(s3.text), i3.push("ET"), i3.push("Q"), e2.stream = i3.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
} }, RadioButton: { Circle: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e2.N[t3] = At.RadioButton.Circle.YesNormal, e2.D[t3] = At.RadioButton.Circle.YesPushDown, e2;
}, getCA: function() {
  return "l";
}, YesNormal: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n3 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n3 = Number((0.9 * n3).toFixed(5));
  var i3 = At.internal.Bezier_C, a3 = Number((n3 * i3).toFixed(5));
  return r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n3 + " 0 m"), r2.push(n3 + " " + a3 + " " + a3 + " " + n3 + " 0 " + n3 + " c"), r2.push("-" + a3 + " " + n3 + " -" + n3 + " " + a3 + " -" + n3 + " 0 c"), r2.push("-" + n3 + " -" + a3 + " -" + a3 + " -" + n3 + " 0 -" + n3 + " c"), r2.push(a3 + " -" + n3 + " " + n3 + " -" + a3 + " " + n3 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n3 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n3 = Number((0.9 * n3).toFixed(5));
  var i3 = Number((2 * n3).toFixed(5)), a3 = Number((i3 * At.internal.Bezier_C).toFixed(5)), o3 = Number((n3 * At.internal.Bezier_C).toFixed(5));
  return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i3 + " 0 m"), r2.push(i3 + " " + a3 + " " + a3 + " " + i3 + " 0 " + i3 + " c"), r2.push("-" + a3 + " " + i3 + " -" + i3 + " " + a3 + " -" + i3 + " 0 c"), r2.push("-" + i3 + " -" + a3 + " -" + a3 + " -" + i3 + " 0 -" + i3 + " c"), r2.push(a3 + " -" + i3 + " " + i3 + " -" + a3 + " " + i3 + " 0 c"), r2.push("f"), r2.push("Q"), r2.push("0 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n3 + " 0 m"), r2.push(n3 + " " + o3 + " " + o3 + " " + n3 + " 0 " + n3 + " c"), r2.push("-" + o3 + " " + n3 + " -" + n3 + " " + o3 + " -" + n3 + " 0 c"), r2.push("-" + n3 + " -" + o3 + " -" + o3 + " -" + n3 + " 0 -" + n3 + " c"), r2.push(o3 + " -" + n3 + " " + n3 + " -" + o3 + " " + n3 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n3 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n3 = Number((0.9 * n3).toFixed(5));
  var i3 = Number((2 * n3).toFixed(5)), a3 = Number((i3 * At.internal.Bezier_C).toFixed(5));
  return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i3 + " 0 m"), r2.push(i3 + " " + a3 + " " + a3 + " " + i3 + " 0 " + i3 + " c"), r2.push("-" + a3 + " " + i3 + " -" + i3 + " " + a3 + " -" + i3 + " 0 c"), r2.push("-" + i3 + " -" + a3 + " -" + a3 + " -" + i3 + " 0 -" + i3 + " c"), r2.push(a3 + " -" + i3 + " " + i3 + " -" + a3 + " " + i3 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
} }, Cross: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e2.N[t3] = At.RadioButton.Cross.YesNormal, e2.D[t3] = At.RadioButton.Cross.YesPushDown, e2;
}, getCA: function() {
  return "8";
}, YesNormal: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n3 = At.internal.calculateCross(t3);
  return r2.push("q"), r2.push("1 1 " + U(At.internal.getWidth(t3) - 2) + " " + U(At.internal.getHeight(t3) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(U(n3.x1.x) + " " + U(n3.x1.y) + " m"), r2.push(U(n3.x2.x) + " " + U(n3.x2.y) + " l"), r2.push(U(n3.x4.x) + " " + U(n3.x4.y) + " m"), r2.push(U(n3.x3.x) + " " + U(n3.x3.y) + " l"), r2.push("s"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = At.internal.calculateCross(t3), n3 = [];
  return n3.push("0.749023 g"), n3.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), n3.push("f"), n3.push("q"), n3.push("1 1 " + U(At.internal.getWidth(t3) - 2) + " " + U(At.internal.getHeight(t3) - 2) + " re"), n3.push("W"), n3.push("n"), n3.push(U(r2.x1.x) + " " + U(r2.x1.y) + " m"), n3.push(U(r2.x2.x) + " " + U(r2.x2.y) + " l"), n3.push(U(r2.x4.x) + " " + U(r2.x4.y) + " m"), n3.push(U(r2.x3.x) + " " + U(r2.x3.y) + " l"), n3.push("s"), n3.push("Q"), e2.stream = n3.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
} } }, createDefaultAppearanceStream: function(t3) {
  var e2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, r2 = t3.scope.__private__.encodeColorString(t3.color);
  return "/" + e2 + " " + t3.fontSize + " Tf " + r2;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t3) {
  var e2 = At.internal.getWidth(t3), r2 = At.internal.getHeight(t3), n3 = Math.min(e2, r2);
  return { x1: { x: (e2 - n3) / 2, y: (r2 - n3) / 2 + n3 }, x2: { x: (e2 - n3) / 2 + n3, y: (r2 - n3) / 2 }, x3: { x: (e2 - n3) / 2, y: (r2 - n3) / 2 }, x4: { x: (e2 - n3) / 2 + n3, y: (r2 - n3) / 2 + n3 } };
} }, At.internal.getWidth = function(e2) {
  var r2 = 0;
  return "object" === _typeof(e2) && (r2 = W(e2.Rect[2])), r2;
}, At.internal.getHeight = function(e2) {
  var r2 = 0;
  return "object" === _typeof(e2) && (r2 = W(e2.Rect[3])), r2;
};
var xt = q.addField = function(t3) {
  if (at(this, t3), !(t3 instanceof lt))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e2;
  return (e2 = t3).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t3.page = t3.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
var St = E.AcroForm;
function _t(t3) {
  return t3.reduce(function(t4, e2, r2) {
    return t4[e2] = r2, t4;
  }, {});
}
!function(e2) {
  e2.__addimage__ = {};
  var r2 = "UNKNOWN", n3 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i3 = e2.__addimage__.getImageFileTypeByImageData = function(t3, e3) {
    var i4, a4, o4, s4, c5, u3 = r2;
    if ("RGBA" === (e3 = e3 || r2) || void 0 !== t3.data && t3.data instanceof Uint8ClampedArray && "height" in t3 && "width" in t3)
      return "RGBA";
    if (x2(t3))
      for (c5 in n3)
        for (o4 = n3[c5], i4 = 0; i4 < o4.length; i4 += 1) {
          for (s4 = true, a4 = 0; a4 < o4[i4].length; a4 += 1)
            if (void 0 !== o4[i4][a4] && o4[i4][a4] !== t3[a4]) {
              s4 = false;
              break;
            }
          if (true === s4) {
            u3 = c5;
            break;
          }
        }
    else
      for (c5 in n3)
        for (o4 = n3[c5], i4 = 0; i4 < o4.length; i4 += 1) {
          for (s4 = true, a4 = 0; a4 < o4[i4].length; a4 += 1)
            if (void 0 !== o4[i4][a4] && o4[i4][a4] !== t3.charCodeAt(a4)) {
              s4 = false;
              break;
            }
          if (true === s4) {
            u3 = c5;
            break;
          }
        }
    return u3 === r2 && e3 !== r2 && (u3 = e3), u3;
  }, a3 = function t3(e3) {
    for (var r3 = this.internal.write, n4 = this.internal.putStream, i4 = (0, this.internal.getFilters)(); -1 !== i4.indexOf("FlateEncode"); )
      i4.splice(i4.indexOf("FlateEncode"), 1);
    e3.objectId = this.internal.newObject();
    var a4 = [];
    if (a4.push({ key: "Type", value: "/XObject" }), a4.push({ key: "Subtype", value: "/Image" }), a4.push({ key: "Width", value: e3.width }), a4.push({ key: "Height", value: e3.height }), e3.colorSpace === b2.INDEXED ? a4.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && void 0 !== e3.sMask ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a4.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === b2.DEVICE_CMYK && a4.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a4.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && void 0 !== e3.decodeParameters && a4.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency)) {
      for (var o4 = "", s4 = 0, c5 = e3.transparency.length; s4 < c5; s4++)
        o4 += e3.transparency[s4] + " " + e3.transparency[s4] + " ";
      a4.push({ key: "Mask", value: "[" + o4 + "]" });
    }
    void 0 !== e3.sMask && a4.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
    var u3 = void 0 !== e3.filter ? ["/" + e3.filter] : void 0;
    if (n4({ data: e3.data, additionalKeyValues: a4, alreadyAppliedFilters: u3, objectId: e3.objectId }), r3("endobj"), "sMask" in e3 && void 0 !== e3.sMask) {
      var h4 = "/Predictor " + e3.predictor + " /Colors 1 /BitsPerComponent " + e3.bitsPerComponent + " /Columns " + e3.width, l4 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: e3.bitsPerComponent, decodeParameters: h4, data: e3.sMask };
      "filter" in e3 && (l4.filter = e3.filter), t3.call(this, l4);
    }
    if (e3.colorSpace === b2.INDEXED) {
      var f4 = this.internal.newObject();
      n4({ data: _3(new Uint8Array(e3.palette)), objectId: f4 }), r3("endobj");
    }
  }, o3 = function() {
    var t3 = this.internal.collections.addImage_images;
    for (var e3 in t3)
      a3.call(this, t3[e3]);
  }, s3 = function() {
    var t3, e3 = this.internal.collections.addImage_images, r3 = this.internal.write;
    for (var n4 in e3)
      r3("/I" + (t3 = e3[n4]).index, t3.objectId, "0", "R");
  }, c4 = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o3), this.internal.events.subscribe("putXobjectDict", s3));
  }, h3 = function() {
    var t3 = this.internal.collections.addImage_images;
    return c4.call(this), t3;
  }, l3 = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, f3 = function(t3) {
    return "function" == typeof e2["process" + t3.toUpperCase()];
  }, d2 = function(e3) {
    return "object" === _typeof(e3) && 1 === e3.nodeType;
  }, p3 = function(t3, r3) {
    if ("IMG" === t3.nodeName && t3.hasAttribute("src")) {
      var n4 = "" + t3.getAttribute("src");
      if (0 === n4.indexOf("data:image/"))
        return u2(unescape(n4).split("base64,").pop());
      var i4 = e2.loadFile(n4, true);
      if (void 0 !== i4)
        return i4;
    }
    if ("CANVAS" === t3.nodeName) {
      if (0 === t3.width || 0 === t3.height)
        throw new Error("Given canvas must have data. Canvas width: " + t3.width + ", height: " + t3.height);
      var a4;
      switch (r3) {
        case "PNG":
          a4 = "image/png";
          break;
        case "WEBP":
          a4 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a4 = "image/jpeg";
      }
      return u2(t3.toDataURL(a4, 1).split("base64,").pop());
    }
  }, g2 = function(t3) {
    var e3 = this.internal.collections.addImage_images;
    if (e3) {
      for (var r3 in e3)
        if (t3 === e3[r3].alias)
          return e3[r3];
    }
  }, m4 = function(t3, e3, r3) {
    return t3 || e3 || (t3 = -96, e3 = -96), t3 < 0 && (t3 = -1 * r3.width * 72 / t3 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r3.height * 72 / e3 / this.internal.scaleFactor), 0 === t3 && (t3 = e3 * r3.width / r3.height), 0 === e3 && (e3 = t3 * r3.height / r3.width), [t3, e3];
  }, v3 = function(t3, e3, r3, n4, i4, a4) {
    var o4 = m4.call(this, r3, n4, i4), s4 = this.internal.getCoordinateString, c5 = this.internal.getVerticalCoordinateString, u3 = h3.call(this);
    if (r3 = o4[0], n4 = o4[1], u3[i4.index] = i4, a4) {
      a4 *= Math.PI / 180;
      var l4 = Math.cos(a4), f4 = Math.sin(a4), d3 = function(t4) {
        return t4.toFixed(4);
      }, p4 = [d3(l4), d3(f4), d3(-1 * f4), d3(l4), 0, 0, "cm"];
    }
    this.internal.write("q"), a4 ? (this.internal.write([1, "0", "0", 1, s4(t3), c5(e3 + n4), "cm"].join(" ")), this.internal.write(p4.join(" ")), this.internal.write([s4(r3), "0", "0", s4(n4), "0", "0", "cm"].join(" "))) : this.internal.write([s4(r3), "0", "0", s4(n4), s4(t3), c5(e3 + n4), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i4.index + " Do"), this.internal.write("Q");
  }, b2 = e2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y3 = e2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e2.__addimage__.sHashCode = function(t3) {
    var e3, r3, n4 = 0;
    if ("string" == typeof t3)
      for (r3 = t3.length, e3 = 0; e3 < r3; e3++)
        n4 = (n4 << 5) - n4 + t3.charCodeAt(e3), n4 |= 0;
    else if (x2(t3))
      for (r3 = t3.byteLength / 2, e3 = 0; e3 < r3; e3++)
        n4 = (n4 << 5) - n4 + t3[e3], n4 |= 0;
    return n4;
  }, N3 = e2.__addimage__.validateStringAsBase64 = function(t3) {
    (t3 = t3 || "").toString().trim();
    var e3 = true;
    return 0 === t3.length && (e3 = false), t3.length % 4 != 0 && (e3 = false), false === /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) && (e3 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) && (e3 = false), e3;
  }, L2 = e2.__addimage__.extractImageFromDataUrl = function(t3) {
    var e3 = (t3 = t3 || "").split("base64,"), r3 = null;
    if (2 === e3.length) {
      var n4 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e3[0]);
      Array.isArray(n4) && (r3 = { mimeType: n4[1], charset: n4[2], data: e3[1] });
    }
    return r3;
  }, A2 = e2.__addimage__.supportsArrayBuffer = function() {
    return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
  };
  e2.__addimage__.isArrayBuffer = function(t3) {
    return A2() && t3 instanceof ArrayBuffer;
  };
  var x2 = e2.__addimage__.isArrayBufferView = function(t3) {
    return A2() && "undefined" != typeof Uint32Array && (t3 instanceof Int8Array || t3 instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array);
  }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t3) {
    for (var e3 = t3.length, r3 = new Uint8Array(e3), n4 = 0; n4 < e3; n4++)
      r3[n4] = t3.charCodeAt(n4);
    return r3;
  }, _3 = e2.__addimage__.arrayBufferToBinaryString = function(t3) {
    for (var e3 = "", r3 = x2(t3) ? t3 : new Uint8Array(t3), n4 = 0; n4 < r3.length; n4 += 8192)
      e3 += String.fromCharCode.apply(null, r3.subarray(n4, n4 + 8192));
    return e3;
  };
  e2.addImage = function() {
    var e3, n4, i4, a4, o4, s4, u3, h4, l4;
    if ("number" == typeof arguments[1] ? (n4 = r2, i4 = arguments[1], a4 = arguments[2], o4 = arguments[3], s4 = arguments[4], u3 = arguments[5], h4 = arguments[6], l4 = arguments[7]) : (n4 = arguments[1], i4 = arguments[2], a4 = arguments[3], o4 = arguments[4], s4 = arguments[5], u3 = arguments[6], h4 = arguments[7], l4 = arguments[8]), "object" === _typeof(e3 = arguments[0]) && !d2(e3) && "imageData" in e3) {
      var f4 = e3;
      e3 = f4.imageData, n4 = f4.format || n4 || r2, i4 = f4.x || i4 || 0, a4 = f4.y || a4 || 0, o4 = f4.w || f4.width || o4, s4 = f4.h || f4.height || s4, u3 = f4.alias || u3, h4 = f4.compression || h4, l4 = f4.rotation || f4.angle || l4;
    }
    var p4 = this.internal.getFilters();
    if (void 0 === h4 && -1 !== p4.indexOf("FlateEncode") && (h4 = "SLOW"), isNaN(i4) || isNaN(a4))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c4.call(this);
    var g3 = P2.call(this, e3, n4, u3, h4);
    return v3.call(this, i4, a4, o4, s4, g3, l4), this;
  };
  var P2 = function(t3, n4, a4, o4) {
    var s4, c5, u3;
    if ("string" == typeof t3 && i3(t3) === r2) {
      t3 = unescape(t3);
      var h4 = k2(t3, false);
      ("" !== h4 || void 0 !== (h4 = e2.loadFile(t3, true))) && (t3 = h4);
    }
    if (d2(t3) && (t3 = p3(t3, n4)), n4 = i3(t3, n4), !f3(n4))
      throw new Error("addImage does not support files of type '" + n4 + "', please ensure that a plugin for '" + n4 + "' support is added.");
    if ((null == (u3 = a4) || 0 === u3.length) && (a4 = function(t4) {
      return "string" == typeof t4 || x2(t4) ? w2(t4) : x2(t4.data) ? w2(t4.data) : null;
    }(t3)), (s4 = g2.call(this, a4)) || (A2() && (t3 instanceof Uint8Array || "RGBA" === n4 || (c5 = t3, t3 = S2(t3))), s4 = this["process" + n4.toUpperCase()](t3, l3.call(this), a4, function(t4) {
      return t4 && "string" == typeof t4 && (t4 = t4.toUpperCase()), t4 in e2.image_compression ? t4 : y3.NONE;
    }(o4), c5)), !s4)
      throw new Error("An unknown error occurred whilst processing the image.");
    return s4;
  }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t3, e3) {
    var r3;
    e3 = "boolean" != typeof e3 || e3;
    var n4, i4 = "";
    if ("string" == typeof t3) {
      n4 = null !== (r3 = L2(t3)) ? r3.data : t3;
      try {
        i4 = u2(n4);
      } catch (t4) {
        if (e3)
          throw N3(n4) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t4.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i4;
  };
  e2.getImageProperties = function(t3) {
    var n4, a4, o4 = "";
    if (d2(t3) && (t3 = p3(t3)), "string" == typeof t3 && i3(t3) === r2 && ("" === (o4 = k2(t3, false)) && (o4 = e2.loadFile(t3) || ""), t3 = o4), a4 = i3(t3), !f3(a4))
      throw new Error("addImage does not support files of type '" + a4 + "', please ensure that a plugin for '" + a4 + "' support is added.");
    if (!A2() || t3 instanceof Uint8Array || (t3 = S2(t3)), !(n4 = this["process" + a4.toUpperCase()](t3)))
      throw new Error("An unknown error occurred whilst processing the image");
    return n4.fileType = a4, n4;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = function(t4) {
    if (void 0 !== t4 && "" != t4)
      return true;
  };
  E.API.events.push(["addPage", function(t4) {
    this.internal.getPageInfo(t4.pageNumber).pageContext.annotations = [];
  }]), t3.events.push(["putPage", function(t4) {
    for (var r2, n3, i3, a3 = this.internal.getCoordinateString, o3 = this.internal.getVerticalCoordinateString, s3 = this.internal.getPageInfoByObjId(t4.objId), c4 = t4.pageContext.annotations, u3 = false, h3 = 0; h3 < c4.length && !u3; h3++)
      switch ((r2 = c4[h3]).type) {
        case "link":
          (e2(r2.options.url) || e2(r2.options.pageNumber)) && (u3 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          u3 = true;
      }
    if (0 != u3) {
      this.internal.write("/Annots [");
      for (var l3 = 0; l3 < c4.length; l3++) {
        r2 = c4[l3];
        var f3 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t4.objId);
        switch (r2.type) {
          case "reference":
            this.internal.write(" " + r2.object.objId + " 0 R ");
            break;
          case "text":
            var p3 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m4 = this.internal.getEncryptor(p3.objId), v3 = r2.title || "Note";
            i3 = "<</Type /Annot /Subtype /Text " + (n3 = "/Rect [" + a3(r2.bounds.x) + " " + o3(r2.bounds.y + r2.bounds.h) + " " + a3(r2.bounds.x + r2.bounds.w) + " " + o3(r2.bounds.y) + "] ") + "/Contents (" + f3(m4(r2.contents)) + ")", i3 += " /Popup " + g2.objId + " 0 R", i3 += " /P " + s3.objId + " 0 R", i3 += " /T (" + f3(m4(v3)) + ") >>", p3.content = i3;
            var b2 = p3.objId + " 0 R";
            i3 = "<</Type /Annot /Subtype /Popup " + (n3 = "/Rect [" + a3(r2.bounds.x + 30) + " " + o3(r2.bounds.y + r2.bounds.h) + " " + a3(r2.bounds.x + r2.bounds.w + 30) + " " + o3(r2.bounds.y) + "] ") + " /Parent " + b2, r2.open && (i3 += " /Open true"), i3 += " >>", g2.content = i3, this.internal.write(p3.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            n3 = "/Rect [" + a3(r2.bounds.x) + " " + o3(r2.bounds.y) + " " + a3(r2.bounds.x + r2.bounds.w) + " " + o3(r2.bounds.y + r2.bounds.h) + "] ";
            var y3 = r2.color || "#000000";
            i3 = "<</Type /Annot /Subtype /FreeText " + n3 + "/Contents (" + f3(d2(r2.contents)) + ")", i3 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y3 + ")", i3 += " /Border [0 0 0]", i3 += " >>", this.internal.write(i3);
            break;
          case "link":
            if (r2.options.name) {
              var w2 = this.annotations._nameMap[r2.options.name];
              r2.options.pageNumber = w2.page, r2.options.top = w2.y;
            } else
              r2.options.top || (r2.options.top = 0);
            if (n3 = "/Rect [" + r2.finalBounds.x + " " + r2.finalBounds.y + " " + r2.finalBounds.w + " " + r2.finalBounds.h + "] ", i3 = "", r2.options.url)
              i3 = "<</Type /Annot /Subtype /Link " + n3 + "/Border [0 0 0] /A <</S /URI /URI (" + f3(d2(r2.options.url)) + ") >>";
            else if (r2.options.pageNumber) {
              switch (i3 = "<</Type /Annot /Subtype /Link " + n3 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r2.options.pageNumber).objId + " 0 R", r2.options.magFactor = r2.options.magFactor || "XYZ", r2.options.magFactor) {
                case "Fit":
                  i3 += " /Fit]";
                  break;
                case "FitH":
                  i3 += " /FitH " + r2.options.top + "]";
                  break;
                case "FitV":
                  r2.options.left = r2.options.left || 0, i3 += " /FitV " + r2.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N3 = o3(r2.options.top);
                  r2.options.left = r2.options.left || 0, void 0 === r2.options.zoom && (r2.options.zoom = 0), i3 += " /XYZ " + r2.options.left + " " + N3 + " " + r2.options.zoom + "]";
              }
            }
            "" != i3 && (i3 += " >>", this.internal.write(i3));
        }
      }
      this.internal.write("]");
    }
  }]), t3.createAnnotation = function(t4) {
    var e3 = this.internal.getCurrentPageInfo();
    switch (t4.type) {
      case "link":
        this.link(t4.bounds.x, t4.bounds.y, t4.bounds.w, t4.bounds.h, t4);
        break;
      case "text":
      case "freetext":
        e3.pageContext.annotations.push(t4);
    }
  }, t3.link = function(t4, e3, r2, n3, i3) {
    var a3 = this.internal.getCurrentPageInfo(), o3 = this.internal.getCoordinateString, s3 = this.internal.getVerticalCoordinateString;
    a3.pageContext.annotations.push({ finalBounds: { x: o3(t4), y: s3(e3), w: o3(t4 + r2), h: s3(e3 + n3) }, options: i3, type: "link" });
  }, t3.textWithLink = function(t4, e3, r2, n3) {
    var i3, a3, o3 = this.getTextWidth(t4), s3 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (void 0 !== n3.maxWidth) {
      a3 = n3.maxWidth;
      var c4 = this.splitTextToSize(t4, a3).length;
      i3 = Math.ceil(s3 * c4);
    } else
      a3 = o3, i3 = s3;
    return this.text(t4, e3, r2, n3), r2 += 0.2 * s3, "center" === n3.align && (e3 -= o3 / 2), "right" === n3.align && (e3 -= o3), this.link(e3, r2 - s3, a3, i3, n3), o3;
  }, t3.getTextWidth = function(t4) {
    var e3 = this.internal.getFontSize();
    return this.getStringUnitWidth(t4) * e3 / this.internal.scaleFactor;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n3 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i3 = [1570, 1571, 1573, 1575];
  t3.__arabicParser__ = {};
  var a3 = t3.__arabicParser__.isInArabicSubstitutionA = function(t4) {
    return void 0 !== e2[t4.charCodeAt(0)];
  }, o3 = t3.__arabicParser__.isArabicLetter = function(t4) {
    return "string" == typeof t4 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t4);
  }, s3 = t3.__arabicParser__.isArabicEndLetter = function(t4) {
    return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length <= 2;
  }, c4 = t3.__arabicParser__.isArabicAlfLetter = function(t4) {
    return o3(t4) && i3.indexOf(t4.charCodeAt(0)) >= 0;
  };
  t3.__arabicParser__.arabicLetterHasIsolatedForm = function(t4) {
    return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length >= 1;
  };
  var u3 = t3.__arabicParser__.arabicLetterHasFinalForm = function(t4) {
    return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length >= 2;
  };
  t3.__arabicParser__.arabicLetterHasInitialForm = function(t4) {
    return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length >= 3;
  };
  var h3 = t3.__arabicParser__.arabicLetterHasMedialForm = function(t4) {
    return o3(t4) && a3(t4) && 4 == e2[t4.charCodeAt(0)].length;
  }, l3 = t3.__arabicParser__.resolveLigatures = function(t4) {
    var e3 = 0, n4 = r2, i4 = "", a4 = 0;
    for (e3 = 0; e3 < t4.length; e3 += 1)
      void 0 !== n4[t4.charCodeAt(e3)] ? (a4++, "number" == typeof (n4 = n4[t4.charCodeAt(e3)]) && (i4 += String.fromCharCode(n4), n4 = r2, a4 = 0), e3 === t4.length - 1 && (n4 = r2, i4 += t4.charAt(e3 - (a4 - 1)), e3 -= a4 - 1, a4 = 0)) : (n4 = r2, i4 += t4.charAt(e3 - a4), e3 -= a4, a4 = 0);
    return i4;
  };
  t3.__arabicParser__.isArabicDiacritic = function(t4) {
    return void 0 !== t4 && void 0 !== n3[t4.charCodeAt(0)];
  };
  var f3 = t3.__arabicParser__.getCorrectForm = function(t4, e3, r3) {
    return o3(t4) ? false === a3(t4) ? -1 : !u3(t4) || !o3(e3) && !o3(r3) || !o3(r3) && s3(e3) || s3(t4) && !o3(e3) || s3(t4) && c4(e3) || s3(t4) && s3(e3) ? 0 : h3(t4) && o3(e3) && !s3(e3) && o3(r3) && u3(r3) ? 3 : s3(t4) || !o3(r3) ? 1 : 2 : -1;
  }, d2 = function(t4) {
    var r3 = 0, n4 = 0, i4 = 0, a4 = "", s4 = "", c5 = "", u4 = (t4 = t4 || "").split("\\s+"), h4 = [];
    for (r3 = 0; r3 < u4.length; r3 += 1) {
      for (h4.push(""), n4 = 0; n4 < u4[r3].length; n4 += 1)
        a4 = u4[r3][n4], s4 = u4[r3][n4 - 1], c5 = u4[r3][n4 + 1], o3(a4) ? (i4 = f3(a4, s4, c5), h4[r3] += -1 !== i4 ? String.fromCharCode(e2[a4.charCodeAt(0)][i4]) : a4) : h4[r3] += a4;
      h4[r3] = l3(h4[r3]);
    }
    return h4.join(" ");
  }, p3 = t3.__arabicParser__.processArabic = t3.processArabic = function() {
    var t4, e3 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r3 = [];
    if (Array.isArray(e3)) {
      var n4 = 0;
      for (r3 = [], n4 = 0; n4 < e3.length; n4 += 1)
        Array.isArray(e3[n4]) ? r3.push([d2(e3[n4][0]), e3[n4][1], e3[n4][2]]) : r3.push([d2(e3[n4])]);
      t4 = r3;
    } else
      t4 = d2(e3);
    return "string" == typeof arguments[0] ? t4 : (arguments[0].text = t4, arguments[0]);
  };
  t3.events.push(["preProcessText", p3]);
}(E.API), E.API.autoPrint = function(t3) {
  var e2;
  switch ((t3 = t3 || {}).variant = t3.variant || "non-conform", t3.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e2 + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = function() {
    var t4 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t4;
    }, set: function(e4) {
      t4 = e4;
    } });
    var e3 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e3;
    }, set: function(t5) {
      e3 = isNaN(t5) || false === Number.isInteger(t5) || t5 < 0 ? 150 : t5, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
    } });
    var r2 = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r2;
    }, set: function(t5) {
      r2 = isNaN(t5) || false === Number.isInteger(t5) || t5 < 0 ? 300 : t5, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r2 + 1);
    } });
    var n3 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n3;
    }, set: function(t5) {
      n3 = t5;
    } });
    var i3 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i3;
    }, set: function(t5) {
      i3 = t5;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e2.prototype.getContext = function(t4, e3) {
    var r2;
    if ("2d" !== (t4 = t4 || "2d"))
      return null;
    for (r2 in e3)
      this.pdf.context2d.hasOwnProperty(r2) && (this.pdf.context2d[r2] = e3[r2]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e2.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t3.events.push(["initialized", function() {
    this.canvas = new e2(), this.canvas.pdf = this;
  }]);
}(E.API), function(e2) {
  var r2 = { left: 0, top: 0, bottom: 0, right: 0 }, n3 = false, i3 = function() {
    void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r2), this.internal.__cell__.margins.width = this.getPageWidth(), a3.call(this));
  }, a3 = function() {
    this.internal.__cell__.lastCell = new o3(), this.internal.__cell__.pages = 1;
  }, o3 = function() {
    var t3 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t3;
    }, set: function(e4) {
      t3 = e4;
    } });
    var e3 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e3;
    }, set: function(t4) {
      e3 = t4;
    } });
    var r3 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      r3 = t4;
    } });
    var n4 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n4;
    }, set: function(t4) {
      n4 = t4;
    } });
    var i4 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i4;
    }, set: function(t4) {
      i4 = t4;
    } });
    var a4 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a4;
    }, set: function(t4) {
      a4 = t4;
    } });
    var o4 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o4;
    }, set: function(t4) {
      o4 = t4;
    } }), this;
  };
  o3.prototype.clone = function() {
    return new o3(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o3.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e2.setHeaderFunction = function(t3) {
    return i3.call(this), this.internal.__cell__.headerFunction = "function" == typeof t3 ? t3 : void 0, this;
  }, e2.getTextDimensions = function(t3, e3) {
    i3.call(this);
    var r3 = (e3 = e3 || {}).fontSize || this.getFontSize(), n4 = e3.font || this.getFont(), a4 = e3.scaleFactor || this.internal.scaleFactor, o4 = 0, s4 = 0, c5 = 0, u3 = this;
    if (!Array.isArray(t3) && "string" != typeof t3) {
      if ("number" != typeof t3)
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t3 = String(t3);
    }
    var h3 = e3.maxWidth;
    h3 > 0 ? "string" == typeof t3 ? t3 = this.splitTextToSize(t3, h3) : "[object Array]" === Object.prototype.toString.call(t3) && (t3 = t3.reduce(function(t4, e4) {
      return t4.concat(u3.splitTextToSize(e4, h3));
    }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];
    for (var l3 = 0; l3 < t3.length; l3++)
      o4 < (c5 = this.getStringUnitWidth(t3[l3], { font: n4 }) * r3) && (o4 = c5);
    return 0 !== o4 && (s4 = t3.length), { w: o4 /= a4, h: Math.max((s4 * r3 * this.getLineHeightFactor() - r3 * (this.getLineHeightFactor() - 1)) / a4, 0) };
  }, e2.cellAddPage = function() {
    i3.call(this), this.addPage();
    var t3 = this.internal.__cell__.margins || r2;
    return this.internal.__cell__.lastCell = new o3(t3.left, t3.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s3 = e2.cell = function() {
    var t3;
    t3 = arguments[0] instanceof o3 ? arguments[0] : new o3(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i3.call(this);
    var e3 = this.internal.__cell__.lastCell, a4 = this.internal.__cell__.padding, s4 = this.internal.__cell__.margins || r2, c5 = this.internal.__cell__.tableHeaderRow, u3 = this.internal.__cell__.printHeaders;
    return void 0 !== e3.lineNumber && (e3.lineNumber === t3.lineNumber ? (t3.x = (e3.x || 0) + (e3.width || 0), t3.y = e3.y || 0) : e3.y + e3.height + t3.height + s4.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s4.top, u3 && c5 && (this.printHeaderRow(t3.lineNumber, true), t3.y += c5[0].height)) : t3.y = e3.y + e3.height || t3.y), void 0 !== t3.text[0] && (this.rect(t3.x, t3.y, t3.width, t3.height, true === n3 ? "FD" : void 0), "right" === t3.align ? this.text(t3.text, t3.x + t3.width - a4, t3.y + a4, { align: "right", baseline: "top" }) : "center" === t3.align ? this.text(t3.text, t3.x + t3.width / 2, t3.y + a4, { align: "center", baseline: "top", maxWidth: t3.width - a4 - a4 }) : this.text(t3.text, t3.x + a4, t3.y + a4, { align: "left", baseline: "top", maxWidth: t3.width - a4 - a4 })), this.internal.__cell__.lastCell = t3, this;
  };
  e2.table = function(e3, n4, u3, h3, l3) {
    if (i3.call(this), !u3)
      throw new Error("No data for PDF table.");
    var f3, d2, p3, g2, m4 = [], v3 = [], b2 = [], y3 = {}, w2 = {}, N3 = [], L2 = [], A2 = (l3 = l3 || {}).autoSize || false, x2 = false !== l3.printHeaders, S2 = l3.css && void 0 !== l3.css["font-size"] ? 16 * l3.css["font-size"] : l3.fontSize || 12, _3 = l3.margins || Object.assign({ width: this.getPageWidth() }, r2), P2 = "number" == typeof l3.padding ? l3.padding : 3, k2 = l3.headerBackgroundColor || "#c8c8c8", I2 = l3.headerTextColor || "#000";
    if (a3.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _3, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), null == h3)
      v3 = m4 = Object.keys(u3[0]), b2 = m4.map(function() {
        return "left";
      });
    else if (Array.isArray(h3) && "object" === _typeof(h3[0]))
      for (m4 = h3.map(function(t3) {
        return t3.name;
      }), v3 = h3.map(function(t3) {
        return t3.prompt || t3.name || "";
      }), b2 = h3.map(function(t3) {
        return t3.align || "left";
      }), f3 = 0; f3 < h3.length; f3 += 1)
        w2[h3[f3].name] = h3[f3].width * (19.049976 / 25.4);
    else
      Array.isArray(h3) && "string" == typeof h3[0] && (v3 = m4 = h3, b2 = m4.map(function() {
        return "left";
      }));
    if (A2 || Array.isArray(h3) && "string" == typeof h3[0])
      for (f3 = 0; f3 < m4.length; f3 += 1) {
        for (y3[g2 = m4[f3]] = u3.map(function(t3) {
          return t3[g2];
        }), this.setFont(void 0, "bold"), N3.push(this.getTextDimensions(v3[f3], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y3[g2], this.setFont(void 0, "normal"), p3 = 0; p3 < d2.length; p3 += 1)
          N3.push(this.getTextDimensions(d2[p3], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        w2[g2] = Math.max.apply(null, N3) + P2 + P2, N3 = [];
      }
    if (x2) {
      var F2 = {};
      for (f3 = 0; f3 < m4.length; f3 += 1)
        F2[m4[f3]] = {}, F2[m4[f3]].text = v3[f3], F2[m4[f3]].align = b2[f3];
      var C2 = c4.call(this, F2, w2);
      L2 = m4.map(function(t3) {
        return new o3(e3, n4, w2[t3], C2, F2[t3].text, void 0, F2[t3].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j2 = h3.reduce(function(t3, e4) {
      return t3[e4.name] = e4.align, t3;
    }, {});
    for (f3 = 0; f3 < u3.length; f3 += 1) {
      "rowStart" in l3 && l3.rowStart instanceof Function && l3.rowStart({ row: f3, data: u3[f3] }, this);
      var O3 = c4.call(this, u3[f3], w2);
      for (p3 = 0; p3 < m4.length; p3 += 1) {
        var B2 = u3[f3][m4[p3]];
        "cellStart" in l3 && l3.cellStart instanceof Function && l3.cellStart({ row: f3, col: p3, data: B2 }, this), s3.call(this, new o3(e3, n4, w2[m4[p3]], O3, B2, f3 + 2, j2[m4[p3]]));
      }
    }
    return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n4, this;
  };
  var c4 = function(t3, e3) {
    var r3 = this.internal.__cell__.padding, n4 = this.internal.__cell__.table_font_size, i4 = this.internal.scaleFactor;
    return Object.keys(t3).map(function(n5) {
      var i5 = t3[n5];
      return this.splitTextToSize(i5.hasOwnProperty("text") ? i5.text : i5, e3[n5] - r3 - r3);
    }, this).map(function(t4) {
      return this.getLineHeightFactor() * t4.length * n4 / i4 + r3 + r3;
    }, this).reduce(function(t4, e4) {
      return Math.max(t4, e4);
    }, 0);
  };
  e2.setTableHeaderRow = function(t3) {
    i3.call(this), this.internal.__cell__.tableHeaderRow = t3;
  }, e2.printHeaderRow = function(t3, e3) {
    if (i3.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var r3;
    if (n3 = true, "function" == typeof this.internal.__cell__.headerFunction) {
      var a4 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o3(a4[0], a4[1], a4[2], a4[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c5 = [], u3 = 0; u3 < this.internal.__cell__.tableHeaderRow.length; u3 += 1) {
      r3 = this.internal.__cell__.tableHeaderRow[u3].clone(), e3 && (r3.y = this.internal.__cell__.margins.top || 0, c5.push(r3)), r3.lineNumber = t3;
      var h3 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s3.call(this, r3), this.setTextColor(h3);
    }
    c5.length > 0 && this.setTableHeaderRow(c5), this.setFont(void 0, "normal"), n3 = false;
  };
}(E.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] };
var kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
var It = _t(kt);
var Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900];
var Ct = _t(Ft);
function jt(t3) {
  var e2 = t3.family.replace(/"|'/g, "").toLowerCase(), r2 = function(t4) {
    return Pt[t4 = t4 || "normal"] ? t4 : "normal";
  }(t3.style), n3 = function(t4) {
    if (!t4)
      return 400;
    if ("number" == typeof t4)
      return t4 >= 100 && t4 <= 900 && t4 % 100 == 0 ? t4 : 400;
    if (/^\d00$/.test(t4))
      return parseInt(t4);
    switch (t4) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t3.weight), i3 = function(t4) {
    return "number" == typeof It[t4 = t4 || "normal"] ? t4 : "normal";
  }(t3.stretch);
  return { family: e2, style: r2, weight: n3, stretch: i3, src: t3.src || [], ref: t3.ref || { name: e2, style: [i3, r2, n3].join(" ") } };
}
function Ot(t3, e2, r2, n3) {
  var i3;
  for (i3 = r2; i3 >= 0 && i3 < e2.length; i3 += n3)
    if (t3[e2[i3]])
      return t3[e2[i3]];
  for (i3 = r2; i3 >= 0 && i3 < e2.length; i3 -= n3)
    if (t3[e2[i3]])
      return t3[e2[i3]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" };
var Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et(t3) {
  return [t3.stretch, t3.style, t3.weight, t3.family].join(" ");
}
function qt(t3, e2, r2) {
  for (var n3 = (r2 = r2 || {}).defaultFontFamily || "times", i3 = Object.assign({}, Bt, r2.genericFontFamilies || {}), a3 = null, o3 = null, s3 = 0; s3 < e2.length; ++s3)
    if (i3[(a3 = jt(e2[s3])).family] && (a3.family = i3[a3.family]), t3.hasOwnProperty(a3.family)) {
      o3 = t3[a3.family];
      break;
    }
  if (!(o3 = o3 || t3[n3]))
    throw new Error("Could not find a font-family for the rule '" + Et(a3) + "' and default family '" + n3 + "'.");
  if (o3 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    var r3 = It[t4], n4 = r3 <= It.normal ? -1 : 1, i4 = Ot(e3, kt, r3, n4);
    if (!i4)
      throw new Error("Could not find a matching font-stretch value for " + t4);
    return i4;
  }(a3.stretch, o3), o3 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    for (var r3 = Pt[t4], n4 = 0; n4 < r3.length; ++n4)
      if (e3[r3[n4]])
        return e3[r3[n4]];
    throw new Error("Could not find a matching font-style for " + t4);
  }(a3.style, o3), !(o3 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    if (400 === t4 && e3[500])
      return e3[500];
    if (500 === t4 && e3[400])
      return e3[400];
    var r3 = Ct[t4], n4 = Ot(e3, Ft, r3, t4 < 400 ? -1 : 1);
    if (!n4)
      throw new Error("Could not find a matching font-weight for value " + t4);
    return n4;
  }(a3.weight, o3)))
    throw new Error("Failed to resolve a font for the rule '" + Et(a3) + "'.");
  return o3;
}
function Dt(t3) {
  return t3.trimLeft();
}
function Rt(t3, e2) {
  for (var r2 = 0; r2 < t3.length; ) {
    if (t3.charAt(r2) === e2)
      return [t3.substring(0, r2), t3.substring(r2 + 1)];
    r2 += 1;
  }
  return null;
}
function Tt(t3) {
  var e2 = t3.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e2 ? null : [e2[0], t3.substring(e2[0].length)];
}
var Ut;
var zt;
var Ht;
var Wt = ["times"];
!function(e2) {
  var r2, n3, i3, o3, s3, c4, u3, h3, l3, d2 = function(t3) {
    return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || "#000000", this.fillStyle = t3.fillStyle || "#000000", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || "10px sans-serif", this.textBaseline = t3.textBaseline || "alphabetic", this.textAlign = t3.textAlign || "left", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || "miter", this.lineCap = t3.lineCap || "butt", this.path = t3.path || [], this.transform = void 0 !== t3.transform ? t3.transform.clone() : new h3(), this.globalCompositeOperation = t3.globalCompositeOperation || "normal", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new c4(), this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new c4(), this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t3.ignoreClearRect || t3.ignoreClearRect, this;
  };
  e2.events.push(["initialized", function() {
    this.context2d = new p3(this), r2 = this.internal.f2, n3 = this.internal.getCoordinateString, i3 = this.internal.getVerticalCoordinateString, o3 = this.internal.getHorizontalCoordinate, s3 = this.internal.getVerticalCoordinate, c4 = this.internal.Point, u3 = this.internal.Rectangle, h3 = this.internal.Matrix, l3 = new d2();
  }]);
  var p3 = function(t3) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e3 = t3;
    Object.defineProperty(this, "pdf", { get: function() {
      return e3;
    } });
    var r3 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r3;
    }, set: function(t4) {
      r3 = Boolean(t4);
    } });
    var n4 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n4;
    }, set: function(t4) {
      n4 = Boolean(t4);
    } });
    var i4 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i4;
    }, set: function(t4) {
      isNaN(t4) || (i4 = t4);
    } });
    var a3 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a3;
    }, set: function(t4) {
      isNaN(t4) || (a3 = t4);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l3.margin;
    }, set: function(t4) {
      var e4;
      "number" == typeof t4 ? e4 = [t4, t4, t4, t4] : ((e4 = new Array(4))[0] = t4[0], e4[1] = t4.length >= 2 ? t4[1] : e4[0], e4[2] = t4.length >= 3 ? t4[2] : e4[0], e4[3] = t4.length >= 4 ? t4[3] : e4[1]), l3.margin = e4;
    } });
    var o4 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o4;
    }, set: function(t4) {
      o4 = t4;
    } });
    var s4 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s4;
    }, set: function(t4) {
      s4 = t4;
    } });
    var c5 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c5;
    }, set: function(t4) {
      c5 = t4;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l3;
    }, set: function(t4) {
      t4 instanceof d2 && (l3 = t4);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l3.path;
    }, set: function(t4) {
      l3.path = t4;
    } });
    var u4 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u4;
    }, set: function(t4) {
      u4 = t4;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t4) {
      var e4;
      e4 = g2(t4), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = 0 === e4.a, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t4) {
      var e4 = g2(t4);
      this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = 0 === e4.a, this.ctx.strokeOpacity = e4.a, 0 === e4.a ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t4) {
      -1 !== ["butt", "round", "square"].indexOf(t4) && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t4) {
      -1 !== ["bevel", "round", "miter"].indexOf(t4) && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t4) {
      this.ctx.textBaseline = t4;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t4) {
      -1 !== ["right", "end", "center", "left", "start"].indexOf(t4) && (this.ctx.textAlign = t4);
    } });
    var h4 = null;
    function f3(t4, e4) {
      if (null === h4) {
        var r4 = function(t5) {
          var e5 = [];
          return Object.keys(t5).forEach(function(r5) {
            t5[r5].forEach(function(t6) {
              var n5 = null;
              switch (t6) {
                case "bold":
                  n5 = { family: r5, weight: "bold" };
                  break;
                case "italic":
                  n5 = { family: r5, style: "italic" };
                  break;
                case "bolditalic":
                  n5 = { family: r5, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n5 = { family: r5 };
              }
              null !== n5 && (n5.ref = { name: r5, style: t6 }, e5.push(n5));
            });
          }), e5;
        }(t4.getFontList());
        h4 = function(t5) {
          for (var e5 = {}, r5 = 0; r5 < t5.length; ++r5) {
            var n5 = jt(t5[r5]), i5 = n5.family, a4 = n5.stretch, o5 = n5.style, s5 = n5.weight;
            e5[i5] = e5[i5] || {}, e5[i5][a4] = e5[i5][a4] || {}, e5[i5][a4][o5] = e5[i5][a4][o5] || {}, e5[i5][a4][o5][s5] = n5;
          }
          return e5;
        }(r4.concat(e4));
      }
      return h4;
    }
    var p4 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p4;
    }, set: function(t4) {
      h4 = null, p4 = t4;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t4) {
      var e4;
      if (this.ctx.font = t4, null !== (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t4))) {
        var r4 = e4[1], n5 = (e4[2], e4[3]), i5 = e4[4], a4 = (e4[5], e4[6]), o5 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i5)[2];
        i5 = "px" === o5 ? Math.floor(parseFloat(i5) * this.pdf.internal.scaleFactor) : "em" === o5 ? Math.floor(parseFloat(i5) * this.pdf.getFontSize()) : Math.floor(parseFloat(i5) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i5);
        var s5 = function(t5) {
          var e5, r5, n6 = [], i6 = t5.trim();
          if ("" === i6)
            return Wt;
          if (i6 in Mt)
            return [Mt[i6]];
          for (; "" !== i6; ) {
            switch (r5 = null, e5 = (i6 = Dt(i6)).charAt(0)) {
              case '"':
              case "'":
                r5 = Rt(i6.substring(1), e5);
                break;
              default:
                r5 = Tt(i6);
            }
            if (null === r5)
              return Wt;
            if (n6.push(r5[0]), "" !== (i6 = Dt(r5[1])) && "," !== i6.charAt(0))
              return Wt;
            i6 = i6.replace(/^,/, "");
          }
          return n6;
        }(a4);
        if (this.fontFaces) {
          var c6 = qt(f3(this.pdf, this.fontFaces), s5.map(function(t5) {
            return { family: t5, stretch: "normal", weight: n5, style: r4 };
          }));
          this.pdf.setFont(c6.ref.name, c6.ref.style);
        } else {
          var u5 = "";
          ("bold" === n5 || parseInt(n5, 10) >= 700 || "bold" === r4) && (u5 = "bold"), "italic" === r4 && (u5 += "italic"), 0 === u5.length && (u5 = "normal");
          for (var h5 = "", l4 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0; d3 < s5.length; d3++) {
            if (void 0 !== this.pdf.internal.getFont(s5[d3], u5, { noFallback: true, disableWarning: true })) {
              h5 = s5[d3];
              break;
            }
            if ("bolditalic" === u5 && void 0 !== this.pdf.internal.getFont(s5[d3], "bold", { noFallback: true, disableWarning: true }))
              h5 = s5[d3], u5 = "bold";
            else if (void 0 !== this.pdf.internal.getFont(s5[d3], "normal", { noFallback: true, disableWarning: true })) {
              h5 = s5[d3], u5 = "normal";
              break;
            }
          }
          if ("" === h5) {
            for (var p5 = 0; p5 < s5.length; p5++)
              if (l4[s5[p5]]) {
                h5 = l4[s5[p5]];
                break;
              }
          }
          h5 = "" === h5 ? "Times" : h5, this.pdf.setFont(h5, u5);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t4) {
      this.ctx.globalCompositeOperation = t4;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t4) {
      this.ctx.globalAlpha = t4;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t4) {
      this.ctx.lineDashOffset = t4, T3.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t4) {
      this.ctx.lineDash = t4, T3.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t4) {
      this.ctx.ignoreClearRect = Boolean(t4);
    } });
  };
  p3.prototype.setLineDash = function(t3) {
    this.lineDash = t3;
  }, p3.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p3.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p3.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p3.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p3.prototype.moveTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a2.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r3 = this.ctx.transform.applyToPoint(new c4(t3, e3));
    this.path.push({ type: "mt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c4(t3, e3);
  }, p3.prototype.closePath = function() {
    var e3 = new c4(0, 0), r3 = 0;
    for (r3 = this.path.length - 1; -1 !== r3; r3--)
      if ("begin" === this.path[r3].type && "object" === _typeof(this.path[r3 + 1]) && "number" == typeof this.path[r3 + 1].x) {
        e3 = new c4(this.path[r3 + 1].x, this.path[r3 + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c4(e3.x, e3.y);
  }, p3.prototype.lineTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a2.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r3 = this.ctx.transform.applyToPoint(new c4(t3, e3));
    this.path.push({ type: "lt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c4(r3.x, r3.y);
  }, p3.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p3.prototype.quadraticCurveTo = function(t3, e3, r3, n4) {
    if (isNaN(r3) || isNaN(n4) || isNaN(t3) || isNaN(e3))
      throw a2.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i4 = this.ctx.transform.applyToPoint(new c4(r3, n4)), o4 = this.ctx.transform.applyToPoint(new c4(t3, e3));
    this.path.push({ type: "qct", x1: o4.x, y1: o4.y, x: i4.x, y: i4.y }), this.ctx.lastPoint = new c4(i4.x, i4.y);
  }, p3.prototype.bezierCurveTo = function(t3, e3, r3, n4, i4, o4) {
    if (isNaN(i4) || isNaN(o4) || isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
      throw a2.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s4 = this.ctx.transform.applyToPoint(new c4(i4, o4)), u4 = this.ctx.transform.applyToPoint(new c4(t3, e3)), h4 = this.ctx.transform.applyToPoint(new c4(r3, n4));
    this.path.push({ type: "bct", x1: u4.x, y1: u4.y, x2: h4.x, y2: h4.y, x: s4.x, y: s4.y }), this.ctx.lastPoint = new c4(s4.x, s4.y);
  }, p3.prototype.arc = function(t3, e3, r3, n4, i4, o4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4) || isNaN(i4))
      throw a2.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o4 = Boolean(o4), !this.ctx.transform.isIdentity) {
      var s4 = this.ctx.transform.applyToPoint(new c4(t3, e3));
      t3 = s4.x, e3 = s4.y;
      var u4 = this.ctx.transform.applyToPoint(new c4(0, r3)), h4 = this.ctx.transform.applyToPoint(new c4(0, 0));
      r3 = Math.sqrt(Math.pow(u4.x - h4.x, 2) + Math.pow(u4.y - h4.y, 2));
    }
    Math.abs(i4 - n4) >= 2 * Math.PI && (n4 = 0, i4 = 2 * Math.PI), this.path.push({ type: "arc", x: t3, y: e3, radius: r3, startAngle: n4, endAngle: i4, counterclockwise: o4 });
  }, p3.prototype.arcTo = function(t3, e3, r3, n4, i4) {
    throw new Error("arcTo not implemented.");
  }, p3.prototype.rect = function(t3, e3, r3, n4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
      throw a2.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3 + r3, e3 + n4), this.lineTo(t3, e3 + n4), this.lineTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3, e3);
  }, p3.prototype.fillRect = function(t3, e3, r3, n4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
      throw a2.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m4.call(this)) {
      var i4 = {};
      "butt" !== this.lineCap && (i4.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i4.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t3, e3, r3, n4), this.fill(), i4.hasOwnProperty("lineCap") && (this.lineCap = i4.lineCap), i4.hasOwnProperty("lineJoin") && (this.lineJoin = i4.lineJoin);
    }
  }, p3.prototype.strokeRect = function(t3, e3, r3, n4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
      throw a2.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v3.call(this) || (this.beginPath(), this.rect(t3, e3, r3, n4), this.stroke());
  }, p3.prototype.clearRect = function(t3, e3, r3, n4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
      throw a2.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t3, e3, r3, n4));
  }, p3.prototype.save = function(t3) {
    t3 = "boolean" != typeof t3 || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)
      this.pdf.setPage(r3 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e3), t3) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n4 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n4;
    }
  }, p3.prototype.restore = function(t3) {
    t3 = "boolean" != typeof t3 || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)
      this.pdf.setPage(r3 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e3), t3 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p3.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = function(t3) {
    var e3, r3, n4, i4;
    if (true === t3.isCanvasGradient && (t3 = t3.getColor()), !t3)
      return { r: 0, g: 0, b: 0, a: 0, style: t3 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t3))
      e3 = 0, r3 = 0, n4 = 0, i4 = 0;
    else {
      var a3 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t3);
      if (null !== a3)
        e3 = parseInt(a3[1]), r3 = parseInt(a3[2]), n4 = parseInt(a3[3]), i4 = 1;
      else if (null !== (a3 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t3)))
        e3 = parseInt(a3[1]), r3 = parseInt(a3[2]), n4 = parseInt(a3[3]), i4 = parseFloat(a3[4]);
      else {
        if (i4 = 1, "string" == typeof t3 && "#" !== t3.charAt(0)) {
          var o4 = new f2(t3);
          t3 = o4.ok ? o4.toHex() : "#000000";
        }
        4 === t3.length ? (e3 = t3.substring(1, 2), e3 += e3, r3 = t3.substring(2, 3), r3 += r3, n4 = t3.substring(3, 4), n4 += n4) : (e3 = t3.substring(1, 3), r3 = t3.substring(3, 5), n4 = t3.substring(5, 7)), e3 = parseInt(e3, 16), r3 = parseInt(r3, 16), n4 = parseInt(n4, 16);
      }
    }
    return { r: e3, g: r3, b: n4, a: i4, style: t3 };
  }, m4 = function() {
    return this.ctx.isFillTransparent || 0 == this.globalAlpha;
  }, v3 = function() {
    return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
  };
  p3.prototype.fillText = function(t3, e3, r3, n4) {
    if (isNaN(e3) || isNaN(r3) || "string" != typeof t3)
      throw a2.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n4 = isNaN(n4) ? void 0 : n4, !m4.call(this)) {
      var i4 = q2(this.ctx.transform.rotation), o4 = this.ctx.transform.scaleX;
      C2.call(this, { text: t3, x: e3, y: r3, scale: o4, angle: i4, align: this.textAlign, maxWidth: n4 });
    }
  }, p3.prototype.strokeText = function(t3, e3, r3, n4) {
    if (isNaN(e3) || isNaN(r3) || "string" != typeof t3)
      throw a2.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v3.call(this)) {
      n4 = isNaN(n4) ? void 0 : n4;
      var i4 = q2(this.ctx.transform.rotation), o4 = this.ctx.transform.scaleX;
      C2.call(this, { text: t3, x: e3, y: r3, scale: o4, renderingMode: "stroke", angle: i4, align: this.textAlign, maxWidth: n4 });
    }
  }, p3.prototype.measureText = function(t3) {
    if ("string" != typeof t3)
      throw a2.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e3 = this.pdf, r3 = this.pdf.internal.scaleFactor, n4 = e3.internal.getFontSize(), i4 = e3.getStringUnitWidth(t3) * n4 / e3.internal.scaleFactor, o4 = function(t4) {
      var e4 = (t4 = t4 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e4;
      } }), this;
    };
    return new o4({ width: i4 *= Math.round(96 * r3 / 72 * 1e4) / 1e4 });
  }, p3.prototype.scale = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a2.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r3 = new h3(t3, 0, 0, e3, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r3);
  }, p3.prototype.rotate = function(t3) {
    if (isNaN(t3))
      throw a2.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e3 = new h3(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e3);
  }, p3.prototype.translate = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a2.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r3 = new h3(1, 0, 0, 1, t3, e3);
    this.ctx.transform = this.ctx.transform.multiply(r3);
  }, p3.prototype.transform = function(t3, e3, r3, n4, i4, o4) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4) || isNaN(i4) || isNaN(o4))
      throw a2.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s4 = new h3(t3, e3, r3, n4, i4, o4);
    this.ctx.transform = this.ctx.transform.multiply(s4);
  }, p3.prototype.setTransform = function(t3, e3, r3, n4, i4, a3) {
    t3 = isNaN(t3) ? 1 : t3, e3 = isNaN(e3) ? 0 : e3, r3 = isNaN(r3) ? 0 : r3, n4 = isNaN(n4) ? 1 : n4, i4 = isNaN(i4) ? 0 : i4, a3 = isNaN(a3) ? 0 : a3, this.ctx.transform = new h3(t3, e3, r3, n4, i4, a3);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p3.prototype.drawImage = function(t3, e3, r3, n4, i4, a3, o4, s4, c5) {
    var l4 = this.pdf.getImageProperties(t3), f3 = 1, d3 = 1, p4 = 1, g3 = 1;
    void 0 !== n4 && void 0 !== s4 && (p4 = s4 / n4, g3 = c5 / i4, f3 = l4.width / n4 * s4 / n4, d3 = l4.height / i4 * c5 / i4), void 0 === a3 && (a3 = e3, o4 = r3, e3 = 0, r3 = 0), void 0 !== n4 && void 0 === s4 && (s4 = n4, c5 = i4), void 0 === n4 && void 0 === s4 && (s4 = l4.width, c5 = l4.height);
    for (var m5, v4 = this.ctx.transform.decompose(), w3 = q2(v4.rotate.shx), A3 = new h3(), S3 = (A3 = (A3 = (A3 = A3.multiply(v4.translate)).multiply(v4.skew)).multiply(v4.scale)).applyToRectangle(new u3(a3 - e3 * p4, o4 - r3 * g3, n4 * f3, i4 * d3)), _4 = y3.call(this, S3), P3 = [], k3 = 0; k3 < _4.length; k3 += 1)
      -1 === P3.indexOf(_4[k3]) && P3.push(_4[k3]);
    if (L2(P3), this.autoPaging)
      for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
        this.pdf.setPage(C3);
        var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O4 = 1 === C3 ? this.posY + this.margin[0] : this.margin[0], B3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = 1 === C3 ? 0 : B3 + (C3 - 2) * M3;
        if (0 !== this.ctx.clip_path.length) {
          var D3 = this.path;
          m5 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(m5, this.posX + this.margin[3], -E3 + O4 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
        }
        var R3 = JSON.parse(JSON.stringify(S3));
        R3 = N3([R3], this.posX + this.margin[3], -E3 + O4 + this.ctx.prevPageLastElemOffset)[0];
        var T4 = (C3 > I3 || C3 < F3) && b2.call(this);
        T4 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t3, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T4 && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(t3, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y3 = function(t3, e3, r3) {
    var n4 = [];
    e3 = e3 || this.pdf.internal.pageSize.width, r3 = r3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i4 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t3.type) {
      default:
      case "mt":
      case "lt":
        n4.push(Math.floor((t3.y + i4) / r3) + 1);
        break;
      case "arc":
        n4.push(Math.floor((t3.y + i4 - t3.radius) / r3) + 1), n4.push(Math.floor((t3.y + i4 + t3.radius) / r3) + 1);
        break;
      case "qct":
        var a3 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);
        n4.push(Math.floor((a3.y + i4) / r3) + 1), n4.push(Math.floor((a3.y + a3.h + i4) / r3) + 1);
        break;
      case "bct":
        var o4 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
        n4.push(Math.floor((o4.y + i4) / r3) + 1), n4.push(Math.floor((o4.y + o4.h + i4) / r3) + 1);
        break;
      case "rect":
        n4.push(Math.floor((t3.y + i4) / r3) + 1), n4.push(Math.floor((t3.y + t3.h + i4) / r3) + 1);
    }
    for (var s4 = 0; s4 < n4.length; s4 += 1)
      for (; this.pdf.internal.getNumberOfPages() < n4[s4]; )
        w2.call(this);
    return n4;
  }, w2 = function() {
    var t3 = this.fillStyle, e3 = this.strokeStyle, r3 = this.font, n4 = this.lineCap, i4 = this.lineWidth, a3 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e3, this.font = r3, this.lineCap = n4, this.lineWidth = i4, this.lineJoin = a3;
  }, N3 = function(t3, e3, r3) {
    for (var n4 = 0; n4 < t3.length; n4++)
      switch (t3[n4].type) {
        case "bct":
          t3[n4].x2 += e3, t3[n4].y2 += r3;
        case "qct":
          t3[n4].x1 += e3, t3[n4].y1 += r3;
        case "mt":
        case "lt":
        case "arc":
        default:
          t3[n4].x += e3, t3[n4].y += r3;
      }
    return t3;
  }, L2 = function(t3) {
    return t3.sort(function(t4, e3) {
      return t4 - e3;
    });
  }, A2 = function(t3, e3) {
    for (var r3, n4, i4 = this.fillStyle, a3 = this.strokeStyle, o4 = this.lineCap, s4 = this.lineWidth, c5 = Math.abs(s4 * this.ctx.transform.scaleX), u4 = this.lineJoin, h4 = JSON.parse(JSON.stringify(this.path)), l4 = JSON.parse(JSON.stringify(this.path)), f3 = [], d3 = 0; d3 < l4.length; d3++)
      if (void 0 !== l4[d3].x)
        for (var p4 = y3.call(this, l4[d3]), g3 = 0; g3 < p4.length; g3 += 1)
          -1 === f3.indexOf(p4[g3]) && f3.push(p4[g3]);
    for (var m5 = 0; m5 < f3.length; m5++)
      for (; this.pdf.internal.getNumberOfPages() < f3[m5]; )
        w2.call(this);
    if (L2(f3), this.autoPaging)
      for (var v4 = f3[0], A3 = f3[f3.length - 1], S3 = v4; S3 < A3 + 1; S3++) {
        this.pdf.setPage(S3), this.fillStyle = i4, this.strokeStyle = a3, this.lineCap = o4, this.lineWidth = c5, this.lineJoin = u4;
        var _4 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = 1 === S3 ? 0 : k3 + (S3 - 2) * I3;
        if (0 !== this.ctx.clip_path.length) {
          var C3 = this.path;
          r3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(r3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t3, true), this.path = C3;
        }
        if (n4 = JSON.parse(JSON.stringify(h4)), this.path = N3(n4, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), false === e3 || 0 === S3) {
          var j3 = (S3 > v4 || S3 < A3) && b2.call(this);
          j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _4, I3, null).clip().discardPath()), x2.call(this, t3, e3), j3 && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = s4;
      }
    else
      this.lineWidth = c5, x2.call(this, t3, e3), this.lineWidth = s4;
    this.path = h4;
  }, x2 = function(t3, e3) {
    if (("stroke" !== t3 || e3 || !v3.call(this)) && ("stroke" === t3 || e3 || !m4.call(this))) {
      for (var r3, n4, i4 = [], a3 = this.path, o4 = 0; o4 < a3.length; o4++) {
        var s4 = a3[o4];
        switch (s4.type) {
          case "begin":
            i4.push({ begin: true });
            break;
          case "close":
            i4.push({ close: true });
            break;
          case "mt":
            i4.push({ start: s4, deltas: [], abs: [] });
            break;
          case "lt":
            var c5 = i4.length;
            if (a3[o4 - 1] && !isNaN(a3[o4 - 1].x) && (r3 = [s4.x - a3[o4 - 1].x, s4.y - a3[o4 - 1].y], c5 > 0)) {
              for (; c5 >= 0; c5--)
                if (true !== i4[c5 - 1].close && true !== i4[c5 - 1].begin) {
                  i4[c5 - 1].deltas.push(r3), i4[c5 - 1].abs.push(s4);
                  break;
                }
            }
            break;
          case "bct":
            r3 = [s4.x1 - a3[o4 - 1].x, s4.y1 - a3[o4 - 1].y, s4.x2 - a3[o4 - 1].x, s4.y2 - a3[o4 - 1].y, s4.x - a3[o4 - 1].x, s4.y - a3[o4 - 1].y], i4[i4.length - 1].deltas.push(r3);
            break;
          case "qct":
            var u4 = a3[o4 - 1].x + 2 / 3 * (s4.x1 - a3[o4 - 1].x), h4 = a3[o4 - 1].y + 2 / 3 * (s4.y1 - a3[o4 - 1].y), l4 = s4.x + 2 / 3 * (s4.x1 - s4.x), f3 = s4.y + 2 / 3 * (s4.y1 - s4.y), d3 = s4.x, p4 = s4.y;
            r3 = [u4 - a3[o4 - 1].x, h4 - a3[o4 - 1].y, l4 - a3[o4 - 1].x, f3 - a3[o4 - 1].y, d3 - a3[o4 - 1].x, p4 - a3[o4 - 1].y], i4[i4.length - 1].deltas.push(r3);
            break;
          case "arc":
            i4.push({ deltas: [], abs: [], arc: true }), Array.isArray(i4[i4.length - 1].abs) && i4[i4.length - 1].abs.push(s4);
        }
      }
      n4 = e3 ? null : "stroke" === t3 ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i4.length; b3++)
        if (i4[b3].arc)
          for (var y4 = i4[b3].abs, w3 = 0; w3 < y4.length; w3++) {
            var N4 = y4[w3];
            "arc" === N4.type ? P2.call(this, N4.x, N4.y, N4.radius, N4.startAngle, N4.endAngle, N4.counterclockwise, void 0, e3, !g3) : j2.call(this, N4.x, N4.y), g3 = true;
          }
        else if (true === i4[b3].close)
          this.pdf.internal.out("h"), g3 = false;
        else if (true !== i4[b3].begin) {
          var L3 = i4[b3].start.x, A3 = i4[b3].start.y;
          O3.call(this, i4[b3].deltas, L3, A3), g3 = true;
        }
      n4 && k2.call(this, n4), e3 && I2.call(this);
    }
  }, S2 = function(t3) {
    var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t3 - r3;
      case "top":
        return t3 + e3 - r3;
      case "hanging":
        return t3 + e3 - 2 * r3;
      case "middle":
        return t3 + e3 / 2 - r3;
      case "ideographic":
        return t3;
      case "alphabetic":
      default:
        return t3;
    }
  }, _3 = function(t3) {
    return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p3.prototype.createLinearGradient = function() {
    var t3 = function() {
    };
    return t3.colorStops = [], t3.addColorStop = function(t4, e3) {
      this.colorStops.push([t4, e3]);
    }, t3.getColor = function() {
      return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
    }, t3.isCanvasGradient = true, t3;
  }, p3.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p3.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t3, e3, r3, n4, i4, a3, o4, s4, c5) {
    for (var u4 = M2.call(this, r3, n4, i4, a3), h4 = 0; h4 < u4.length; h4++) {
      var l4 = u4[h4];
      0 === h4 && (c5 ? F2.call(this, l4.x1 + t3, l4.y1 + e3) : j2.call(this, l4.x1 + t3, l4.y1 + e3)), B2.call(this, t3, e3, l4.x2, l4.y2, l4.x3, l4.y3, l4.x4, l4.y4);
    }
    s4 ? I2.call(this) : k2.call(this, o4);
  }, k2 = function(t3) {
    switch (t3) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, I2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F2 = function(t3, e3) {
    this.pdf.internal.out(n3(t3) + " " + i3(e3) + " m");
  }, C2 = function(t3) {
    var e3;
    switch (t3.align) {
      case "right":
      case "end":
        e3 = "right";
        break;
      case "center":
        e3 = "center";
        break;
      case "left":
      case "start":
      default:
        e3 = "left";
    }
    var r3 = this.pdf.getTextDimensions(t3.text), n4 = S2.call(this, t3.y), i4 = _3.call(this, n4) - r3.h, a3 = this.ctx.transform.applyToPoint(new c4(t3.x, n4)), o4 = this.ctx.transform.decompose(), s4 = new h3();
    s4 = (s4 = (s4 = s4.multiply(o4.translate)).multiply(o4.skew)).multiply(o4.scale);
    for (var l4, f3, d3, p4 = this.ctx.transform.applyToRectangle(new u3(t3.x, n4, r3.w, r3.h)), g3 = s4.applyToRectangle(new u3(t3.x, i4, r3.w, r3.h)), m5 = y3.call(this, g3), v4 = [], w3 = 0; w3 < m5.length; w3 += 1)
      -1 === v4.indexOf(m5[w3]) && v4.push(m5[w3]);
    if (L2(v4), this.autoPaging)
      for (var A3 = v4[0], P3 = v4[v4.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
        this.pdf.setPage(k3);
        var I3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O4 = this.pdf.internal.pageSize.width - this.margin[1], B3 = O4 - this.margin[3], M3 = 1 === k3 ? 0 : F3 + (k3 - 2) * j3;
        if (0 !== this.ctx.clip_path.length) {
          var E3 = this.path;
          l4 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(l4, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
        }
        var q3 = N3([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
        t3.scale >= 0.01 && (f3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f3 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale);
        var D3 = "text" !== this.autoPaging;
        if (D3 || q3.y + q3.h <= C3) {
          if (D3 || q3.y >= I3 && q3.x <= O4) {
            var R3 = D3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O4 - q3.x)[0], T4 = N3([JSON.parse(JSON.stringify(p4))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
            U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B3, j3, null).clip().discardPath()), this.pdf.text(R3, T4.x, T4.y, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode }), U2 && this.pdf.restoreGraphicsState();
          }
        } else
          q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
        t3.scale >= 0.01 && (this.pdf.setFontSize(f3), this.lineWidth = d3);
      }
    else
      t3.scale >= 0.01 && (f3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f3 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale), this.pdf.text(t3.text, a3.x + this.posX, a3.y + this.posY, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode, maxWidth: t3.maxWidth }), t3.scale >= 0.01 && (this.pdf.setFontSize(f3), this.lineWidth = d3);
  }, j2 = function(t3, e3, r3, a3) {
    r3 = r3 || 0, a3 = a3 || 0, this.pdf.internal.out(n3(t3 + r3) + " " + i3(e3 + a3) + " l");
  }, O3 = function(t3, e3, r3) {
    return this.pdf.lines(t3, e3, r3, null, null);
  }, B2 = function(t3, e3, n4, i4, a3, c5, u4, h4) {
    this.pdf.internal.out([r2(o3(n4 + t3)), r2(s3(i4 + e3)), r2(o3(a3 + t3)), r2(s3(c5 + e3)), r2(o3(u4 + t3)), r2(s3(h4 + e3)), "c"].join(" "));
  }, M2 = function(t3, e3, r3, n4) {
    for (var i4 = 2 * Math.PI, a3 = Math.PI / 2; e3 > r3; )
      e3 -= i4;
    var o4 = Math.abs(r3 - e3);
    o4 < i4 && n4 && (o4 = i4 - o4);
    for (var s4 = [], c5 = n4 ? -1 : 1, u4 = e3; o4 > 1e-5; ) {
      var h4 = u4 + c5 * Math.min(o4, a3);
      s4.push(E2.call(this, t3, u4, h4)), o4 -= Math.abs(h4 - u4), u4 = h4;
    }
    return s4;
  }, E2 = function(t3, e3, r3) {
    var n4 = (r3 - e3) / 2, i4 = t3 * Math.cos(n4), a3 = t3 * Math.sin(n4), o4 = i4, s4 = -a3, c5 = o4 * o4 + s4 * s4, u4 = c5 + o4 * i4 + s4 * a3, h4 = 4 / 3 * (Math.sqrt(2 * c5 * u4) - u4) / (o4 * a3 - s4 * i4), l4 = o4 - h4 * s4, f3 = s4 + h4 * o4, d3 = l4, p4 = -f3, g3 = n4 + e3, m5 = Math.cos(g3), v4 = Math.sin(g3);
    return { x1: t3 * Math.cos(e3), y1: t3 * Math.sin(e3), x2: l4 * m5 - f3 * v4, y2: l4 * v4 + f3 * m5, x3: d3 * m5 - p4 * v4, y3: d3 * v4 + p4 * m5, x4: t3 * Math.cos(r3), y4: t3 * Math.sin(r3) };
  }, q2 = function(t3) {
    return 180 * t3 / Math.PI;
  }, D2 = function(t3, e3, r3, n4, i4, a3) {
    var o4 = t3 + 0.5 * (r3 - t3), s4 = e3 + 0.5 * (n4 - e3), c5 = i4 + 0.5 * (r3 - i4), h4 = a3 + 0.5 * (n4 - a3), l4 = Math.min(t3, i4, o4, c5), f3 = Math.max(t3, i4, o4, c5), d3 = Math.min(e3, a3, s4, h4), p4 = Math.max(e3, a3, s4, h4);
    return new u3(l4, d3, f3 - l4, p4 - d3);
  }, R2 = function(t3, e3, r3, n4, i4, a3, o4, s4) {
    var c5, h4, l4, f3, d3, p4, g3, m5, v4, b3, y4, w3, N4, L3, A3 = r3 - t3, x3 = n4 - e3, S3 = i4 - r3, _4 = a3 - n4, P3 = o4 - i4, k3 = s4 - a3;
    for (h4 = 0; h4 < 41; h4++)
      v4 = (g3 = (l4 = t3 + (c5 = h4 / 40) * A3) + c5 * ((d3 = r3 + c5 * S3) - l4)) + c5 * (d3 + c5 * (i4 + c5 * P3 - d3) - g3), b3 = (m5 = (f3 = e3 + c5 * x3) + c5 * ((p4 = n4 + c5 * _4) - f3)) + c5 * (p4 + c5 * (a3 + c5 * k3 - p4) - m5), 0 == h4 ? (y4 = v4, w3 = b3, N4 = v4, L3 = b3) : (y4 = Math.min(y4, v4), w3 = Math.min(w3, b3), N4 = Math.max(N4, v4), L3 = Math.max(L3, b3));
    return new u3(Math.round(y4), Math.round(w3), Math.round(N4 - y4), Math.round(L3 - w3));
  }, T3 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t3, e3, r3 = (t3 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t3, lineDashOffset: e3 }));
      this.prevLineDash !== r3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r3);
    }
  };
}(E.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var r2 = function(t4) {
    var e2, r3, n4, i4, a4, o3, s3, c4, u3, h3;
    for (/[^\x00-\xFF]/.test(t4), r3 = [], n4 = 0, i4 = (t4 += e2 = "\0\0\0\0".slice(t4.length % 4 || 4)).length; i4 > n4; n4 += 4)
      0 !== (a4 = (t4.charCodeAt(n4) << 24) + (t4.charCodeAt(n4 + 1) << 16) + (t4.charCodeAt(n4 + 2) << 8) + t4.charCodeAt(n4 + 3)) ? (o3 = (a4 = ((a4 = ((a4 = ((a4 = (a4 - (h3 = a4 % 85)) / 85) - (u3 = a4 % 85)) / 85) - (c4 = a4 % 85)) / 85) - (s3 = a4 % 85)) / 85) % 85, r3.push(o3 + 33, s3 + 33, c4 + 33, u3 + 33, h3 + 33)) : r3.push(122);
    return function(t5, e3) {
      for (var r4 = e3; r4 > 0; r4--)
        t5.pop();
    }(r3, e2.length), String.fromCharCode.apply(String, r3) + "~>";
  }, n3 = function(t4) {
    var e2, r3, n4, i4, a4, o3 = String, s3 = "length", c4 = 255, u3 = "charCodeAt", h3 = "slice", l3 = "replace";
    for (t4[h3](-2), t4 = t4[h3](0, -2)[l3](/\s/g, "")[l3]("z", "!!!!!"), n4 = [], i4 = 0, a4 = (t4 += e2 = "uuuuu"[h3](t4[s3] % 5 || 5))[s3]; a4 > i4; i4 += 5)
      r3 = 52200625 * (t4[u3](i4) - 33) + 614125 * (t4[u3](i4 + 1) - 33) + 7225 * (t4[u3](i4 + 2) - 33) + 85 * (t4[u3](i4 + 3) - 33) + (t4[u3](i4 + 4) - 33), n4.push(c4 & r3 >> 24, c4 & r3 >> 16, c4 & r3 >> 8, c4 & r3);
    return function(t5, e3) {
      for (var r4 = e3; r4 > 0; r4--)
        t5.pop();
    }(n4, e2[s3]), o3.fromCharCode.apply(o3, n4);
  }, i3 = function(t4) {
    var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t4 = t4.replace(/\s/g, "")).indexOf(">") && (t4 = t4.substr(0, t4.indexOf(">"))), t4.length % 2 && (t4 += "0"), false === e2.test(t4))
      return "";
    for (var r3 = "", n4 = 0; n4 < t4.length; n4 += 2)
      r3 += String.fromCharCode("0x" + (t4[n4] + t4[n4 + 1]));
    return r3;
  }, a3 = function(t4) {
    for (var r3 = new Uint8Array(t4.length), n4 = t4.length; n4--; )
      r3[n4] = t4.charCodeAt(n4);
    return t4 = (r3 = zlibSync(r3)).reduce(function(t5, e2) {
      return t5 + String.fromCharCode(e2);
    }, "");
  };
  t3.processDataByFilters = function(t4, e2) {
    var o3 = 0, s3 = t4 || "", c4 = [];
    for ("string" == typeof (e2 = e2 || []) && (e2 = [e2]), o3 = 0; o3 < e2.length; o3 += 1)
      switch (e2[o3]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          s3 = n3(s3), c4.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          s3 = r2(s3), c4.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          s3 = i3(s3), c4.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          s3 = s3.split("").map(function(t5) {
            return ("0" + t5.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", c4.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          s3 = a3(s3), c4.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e2[o3] + '" is not implemented');
      }
    return { data: s3, reverseChain: c4.reverse().join(" ") };
  };
}(E.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  t3.loadFile = function(t4, e2, r2) {
    return function(t5, e3, r3) {
      e3 = false !== e3, r3 = "function" == typeof r3 ? r3 : function() {
      };
      var n3 = void 0;
      try {
        n3 = function(t6, e4, r4) {
          var n4 = new XMLHttpRequest(), i3 = 0, a3 = function(t7) {
            var e5 = t7.length, r5 = [], n5 = String.fromCharCode;
            for (i3 = 0; i3 < e5; i3 += 1)
              r5.push(n5(255 & t7.charCodeAt(i3)));
            return r5.join("");
          };
          if (n4.open("GET", t6, !e4), n4.overrideMimeType("text/plain; charset=x-user-defined"), false === e4 && (n4.onload = function() {
            200 === n4.status ? r4(a3(this.responseText)) : r4(void 0);
          }), n4.send(null), e4 && 200 === n4.status)
            return a3(n4.responseText);
        }(t5, e3, r3);
      } catch (t6) {
      }
      return n3;
    }(t4, e2, r2);
  }, t3.loadImageFile = t3.loadFile;
}(E.API), function(e2) {
  function r2() {
    return (n2.html2canvas ? Promise.resolve(n2.html2canvas) : Promise.resolve().then(() => __toESM(require_html2canvas()))).catch(function(t3) {
      return Promise.reject(new Error("Could not load html2canvas: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  function i3() {
    return (n2.DOMPurify ? Promise.resolve(n2.DOMPurify) : Promise.resolve().then(() => __toESM(require_purify()))).catch(function(t3) {
      return Promise.reject(new Error("Could not load dompurify: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  var a3 = function(e3) {
    var r3 = _typeof(e3);
    return "undefined" === r3 ? "undefined" : "string" === r3 || e3 instanceof String ? "string" : "number" === r3 || e3 instanceof Number ? "number" : "function" === r3 || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && 1 === e3.nodeType ? "element" : "object" === r3 ? "object" : "unknown";
  }, o3 = function(t3, e3) {
    var r3 = document.createElement(t3);
    for (var n3 in e3.className && (r3.className = e3.className), e3.innerHTML && e3.dompurify && (r3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style)
      r3.style[n3] = e3.style[n3];
    return r3;
  }, s3 = function t3(e3) {
    var r3 = Object.assign(t3.convert(Promise.resolve()), JSON.parse(JSON.stringify(t3.template))), n3 = t3.convert(Promise.resolve(), r3);
    return n3 = (n3 = n3.setProgress(1, t3, 1, [t3])).set(e3);
  };
  (s3.prototype = Object.create(Promise.prototype)).constructor = s3, s3.convert = function(t3, e3) {
    return t3.__proto__ = e3 || s3.prototype, t3;
  }, s3.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s3.prototype.from = function(t3, e3) {
    return this.then(function() {
      switch (e3 = e3 || function(t4) {
        switch (a3(t4)) {
          case "string":
            return "string";
          case "element":
            return "canvas" === t4.nodeName.toLowerCase() ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t3)) {
        case "string":
          return this.then(i3).then(function(e4) {
            return this.set({ src: o3("div", { innerHTML: t3, dompurify: e4 }) });
          });
        case "element":
          return this.set({ src: t3 });
        case "canvas":
          return this.set({ canvas: t3 });
        case "img":
          return this.set({ img: t3 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s3.prototype.to = function(t3) {
    switch (t3) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s3.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t3 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = function t4(e4, r3) {
        for (var n3 = 3 === e4.nodeType ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i4 = e4.firstChild; i4; i4 = i4.nextSibling)
          true !== r3 && 1 === i4.nodeType && "SCRIPT" === i4.nodeName || n3.appendChild(t4(i4, r3));
        return 1 === e4.nodeType && ("CANVAS" === e4.nodeName ? (n3.width = e4.width, n3.height = e4.height, n3.getContext("2d").drawImage(e4, 0, 0)) : "TEXTAREA" !== e4.nodeName && "SELECT" !== e4.nodeName || (n3.value = e4.value), n3.addEventListener("load", function() {
          n3.scrollTop = e4.scrollTop, n3.scrollLeft = e4.scrollLeft;
        }, true)), n3;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      "BODY" === e3.tagName && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o3("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o3("div", { className: "html2pdf__container", style: t3 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o3("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s3.prototype.toCanvas = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(r2).then(function(t4) {
      var e3 = Object.assign({}, this.opt.html2canvas);
      return delete e3.onrendered, t4(this.prop.container, e3);
    }).then(function(t4) {
      (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, s3.prototype.toContext2d = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(r2).then(function(t4) {
      var e3 = this.opt.jsPDF, r3 = this.opt.fontFaces, n3 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i4 = Object.assign({ async: true, allowTaint: true, scale: n3, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i4.onrendered, e3.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r3, r3)
        for (var a4 = 0; a4 < r3.length; ++a4) {
          var o4 = r3[a4], s4 = o4.src.find(function(t5) {
            return "truetype" === t5.format;
          });
          s4 && e3.addFont(s4.url, o4.ref.name, o4.ref.style);
        }
      return i4.windowHeight = i4.windowHeight || 0, i4.windowHeight = 0 == i4.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i4.windowHeight, e3.context2d.save(true), t4(this.prop.container, i4);
    }).then(function(t4) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, s3.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t3 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t3;
    });
  }, s3.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s3.prototype.output = function(t3, e3, r3) {
    return "img" === (r3 = r3 || "pdf").toLowerCase() || "image" === r3.toLowerCase() ? this.outputImg(t3, e3) : this.outputPdf(t3, e3);
  }, s3.prototype.outputPdf = function(t3, e3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t3, e3);
    });
  }, s3.prototype.outputImg = function(t3) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t3) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t3 + '" is not supported.';
      }
    });
  }, s3.prototype.save = function(t3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t3 ? { filename: t3 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s3.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s3.prototype.set = function(t3) {
    if ("object" !== a3(t3))
      return this;
    var e3 = Object.keys(t3 || {}).map(function(e4) {
      if (e4 in s3.template.prop)
        return function() {
          this.prop[e4] = t3[e4];
        };
      switch (e4) {
        case "margin":
          return this.setMargin.bind(this, t3.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t3.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t3.pageSize);
        default:
          return function() {
            this.opt[e4] = t3[e4];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e3);
    });
  }, s3.prototype.get = function(t3, e3) {
    return this.then(function() {
      var r3 = t3 in s3.template.prop ? this.prop[t3] : this.opt[t3];
      return e3 ? e3(r3) : r3;
    });
  }, s3.prototype.setMargin = function(t3) {
    return this.then(function() {
      switch (a3(t3)) {
        case "number":
          t3 = [t3, t3, t3, t3];
        case "array":
          if (2 === t3.length && (t3 = [t3[0], t3[1], t3[0], t3[1]]), 4 === t3.length)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t3;
    }).then(this.setPageSize);
  }, s3.prototype.setPageSize = function(t3) {
    function e3(t4, e4) {
      return Math.floor(t4 * e4 / 72 * 96);
    }
    return this.then(function() {
      (t3 = t3 || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t3.inner = { width: t3.width - this.opt.margin[1] - this.opt.margin[3], height: t3.height - this.opt.margin[0] - this.opt.margin[2] }, t3.inner.px = { width: e3(t3.inner.width, t3.k), height: e3(t3.inner.height, t3.k) }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;
    });
  }, s3.prototype.setProgress = function(t3, e3, r3, n3) {
    return null != t3 && (this.progress.val = t3), null != e3 && (this.progress.state = e3), null != r3 && (this.progress.n = r3), null != n3 && (this.progress.stack = n3), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s3.prototype.updateProgress = function(t3, e3, r3, n3) {
    return this.setProgress(t3 ? this.progress.val + t3 : null, e3 || null, r3 ? this.progress.n + r3 : null, n3 ? this.progress.stack.concat(n3) : null);
  }, s3.prototype.then = function(t3, e3) {
    var r3 = this;
    return this.thenCore(t3, e3, function(t4, e4) {
      return r3.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e5) {
        return r3.updateProgress(null, t4), e5;
      }).then(t4, e4).then(function(t5) {
        return r3.updateProgress(1), t5;
      });
    });
  }, s3.prototype.thenCore = function(t3, e3, r3) {
    r3 = r3 || Promise.prototype.then;
    t3 && (t3 = t3.bind(this)), e3 && (e3 = e3.bind(this));
    var n3 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s3.convert(Object.assign({}, this), Promise.prototype), i4 = r3.call(n3, t3, e3);
    return s3.convert(i4, this.__proto__);
  }, s3.prototype.thenExternal = function(t3, e3) {
    return Promise.prototype.then.call(this, t3, e3);
  }, s3.prototype.thenList = function(t3) {
    var e3 = this;
    return t3.forEach(function(t4) {
      e3 = e3.thenCore(t4);
    }), e3;
  }, s3.prototype.catch = function(t3) {
    t3 && (t3 = t3.bind(this));
    var e3 = Promise.prototype.catch.call(this, t3);
    return s3.convert(e3, this);
  }, s3.prototype.catchExternal = function(t3) {
    return Promise.prototype.catch.call(this, t3);
  }, s3.prototype.error = function(t3) {
    return this.then(function() {
      throw new Error(t3);
    });
  }, s3.prototype.using = s3.prototype.set, s3.prototype.saveAs = s3.prototype.save, s3.prototype.export = s3.prototype.output, s3.prototype.run = s3.prototype.then, E.getPageSize = function(e3, r3, n3) {
    if ("object" === _typeof(e3)) {
      var i4 = e3;
      e3 = i4.orientation, r3 = i4.unit || r3, n3 = i4.format || n3;
    }
    r3 = r3 || "mm", n3 = n3 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
    var a4, o4 = ("" + n3).toLowerCase(), s4 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r3) {
      case "pt":
        a4 = 1;
        break;
      case "mm":
        a4 = 72 / 25.4;
        break;
      case "cm":
        a4 = 72 / 2.54;
        break;
      case "in":
        a4 = 72;
        break;
      case "px":
        a4 = 0.75;
        break;
      case "pc":
      case "em":
        a4 = 12;
        break;
      case "ex":
        a4 = 6;
        break;
      default:
        throw "Invalid unit: " + r3;
    }
    var c4, u3 = 0, h3 = 0;
    if (s4.hasOwnProperty(o4))
      u3 = s4[o4][1] / a4, h3 = s4[o4][0] / a4;
    else
      try {
        u3 = n3[1], h3 = n3[0];
      } catch (t3) {
        throw new Error("Invalid format: " + n3);
      }
    if ("p" === e3 || "portrait" === e3)
      e3 = "p", h3 > u3 && (c4 = h3, h3 = u3, u3 = c4);
    else {
      if ("l" !== e3 && "landscape" !== e3)
        throw "Invalid orientation: " + e3;
      e3 = "l", u3 > h3 && (c4 = h3, h3 = u3, u3 = c4);
    }
    return { width: h3, height: u3, unit: r3, k: a4, orientation: e3 };
  }, e2.html = function(t3, e3) {
    (e3 = e3 || {}).callback = e3.callback || function() {
    }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt) : null;
    var r3 = new s3(e3);
    return e3.worker ? r3 : r3.from(t3).doCallback();
  };
}(E.API), E.API.addJS = function(t3) {
  return Ht = t3, this.internal.events.subscribe("postPutResources", function() {
    Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    void 0 !== Ut && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2;
  t3.events.push(["postPutResources", function() {
    var t4 = this, r2 = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var n3 = t4.outline.render().split(/\r\n/), i3 = 0; i3 < n3.length; i3++) {
        var a3 = n3[i3], o3 = r2.exec(a3);
        if (null != o3) {
          var s3 = o3[1];
          t4.internal.newObjectDeferredBegin(s3, false);
        }
        t4.internal.write(a3);
      }
    if (this.outline.createNamedDestinations) {
      var c4 = this.internal.pages.length, u3 = [];
      for (i3 = 0; i3 < c4; i3++) {
        var h3 = t4.internal.newObject();
        u3.push(h3);
        var l3 = t4.internal.getPageInfo(i3 + 1);
        t4.internal.write("<< /D[" + l3.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f3 = t4.internal.newObject();
      t4.internal.write("<< /Names [ ");
      for (i3 = 0; i3 < u3.length; i3++)
        t4.internal.write("(page_" + (i3 + 1) + ")" + u3[i3] + " 0 R");
      t4.internal.write(" ] >>", "endobj"), e2 = t4.internal.newObject(), t4.internal.write("<< /Dests " + f3 + " 0 R"), t4.internal.write(">>", "endobj");
    }
  }]), t3.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e2 + " 0 R"));
  }]), t3.events.push(["initialized", function() {
    var t4 = this;
    t4.outline = { createNamedDestinations: false, root: { children: [] } }, t4.outline.add = function(t5, e3, r2) {
      var n3 = { title: e3, options: r2, children: [] };
      return null == t5 && (t5 = this.root), t5.children.push(n3), n3;
    }, t4.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t4, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t4.outline.genIds_r = function(e3) {
      e3.id = t4.internal.newObjectDeferred();
      for (var r2 = 0; r2 < e3.children.length; r2++)
        this.genIds_r(e3.children[r2]);
    }, t4.outline.renderRoot = function(t5) {
      this.objStart(t5), this.line("/Type /Outlines"), t5.children.length > 0 && (this.line("/First " + this.makeRef(t5.children[0])), this.line("/Last " + this.makeRef(t5.children[t5.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t5)), this.objEnd();
    }, t4.outline.renderItems = function(e3) {
      for (var r2 = this.ctx.pdf.internal.getVerticalCoordinateString, n3 = 0; n3 < e3.children.length; n3++) {
        var i3 = e3.children[n3];
        this.objStart(i3), this.line("/Title " + this.makeString(i3.title)), this.line("/Parent " + this.makeRef(e3)), n3 > 0 && this.line("/Prev " + this.makeRef(e3.children[n3 - 1])), n3 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[n3 + 1])), i3.children.length > 0 && (this.line("/First " + this.makeRef(i3.children[0])), this.line("/Last " + this.makeRef(i3.children[i3.children.length - 1])));
        var a3 = this.count = this.count_r({ count: 0 }, i3);
        if (a3 > 0 && this.line("/Count " + a3), i3.options && i3.options.pageNumber) {
          var o3 = t4.internal.getPageInfo(i3.options.pageNumber);
          this.line("/Dest [" + o3.objId + " 0 R /XYZ 0 " + r2(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s3 = 0; s3 < e3.children.length; s3++)
        this.renderItems(e3.children[s3]);
    }, t4.outline.line = function(t5) {
      this.ctx.val += t5 + "\r\n";
    }, t4.outline.makeRef = function(t5) {
      return t5.id + " 0 R";
    }, t4.outline.makeString = function(e3) {
      return "(" + t4.internal.pdfEscape(e3) + ")";
    }, t4.outline.objStart = function(t5) {
      this.ctx.val += "\r\n" + t5.id + " 0 obj\r\n<<\r\n";
    }, t4.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t4.outline.count_r = function(t5, e3) {
      for (var r2 = 0; r2 < e3.children.length; r2++)
        t5.count++, this.count_r(t5, e3.children[r2]);
      return t5.count;
    };
  }]);
}(E.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
  t3.processJPEG = function(t4, r2, n3, i3, a3, o3) {
    var s3, c4 = this.decode.DCT_DECODE, u3 = null;
    if ("string" == typeof t4 || this.__addimage__.isArrayBuffer(t4) || this.__addimage__.isArrayBufferView(t4)) {
      switch (t4 = a3 || t4, t4 = this.__addimage__.isArrayBuffer(t4) ? new Uint8Array(t4) : t4, (s3 = function(t5) {
        for (var r3, n4 = 256 * t5.charCodeAt(4) + t5.charCodeAt(5), i4 = t5.length, a4 = { width: 0, height: 0, numcomponents: 1 }, o4 = 4; o4 < i4; o4 += 2) {
          if (o4 += n4, -1 !== e2.indexOf(t5.charCodeAt(o4 + 1))) {
            r3 = 256 * t5.charCodeAt(o4 + 5) + t5.charCodeAt(o4 + 6), a4 = { width: 256 * t5.charCodeAt(o4 + 7) + t5.charCodeAt(o4 + 8), height: r3, numcomponents: t5.charCodeAt(o4 + 9) };
            break;
          }
          n4 = 256 * t5.charCodeAt(o4 + 2) + t5.charCodeAt(o4 + 3);
        }
        return a4;
      }(t4 = this.__addimage__.isArrayBufferView(t4) ? this.__addimage__.arrayBufferToBinaryString(t4) : t4)).numcomponents) {
        case 1:
          o3 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o3 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o3 = this.color_spaces.DEVICE_RGB;
      }
      u3 = { data: t4, width: s3.width, height: s3.height, colorSpace: o3, bitsPerComponent: 8, filter: c4, index: r2, alias: n3 };
    }
    return u3;
  };
}(E.API);
var Vt;
var Gt;
var Yt;
var Jt;
var Xt;
var Kt = function() {
  var t3, e2, i3;
  function a3(t4) {
    var e3, r2, n3, i4, a4, o4, s3, c4, u3, h3, l3, f3, d2, p3;
    for (this.data = t4, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o4 = null; ; ) {
      switch (e3 = this.readUInt32(), u3 = function() {
        var t5, e4;
        for (e4 = [], t5 = 0; t5 < 4; ++t5)
          e4.push(String.fromCharCode(this.data[this.pos++]));
        return e4;
      }.call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e3);
          break;
        case "fcTL":
          o4 && this.animation.frames.push(o4), this.pos += 4, o4 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a4 = this.readUInt16(), i4 = this.readUInt16() || 100, o4.delay = 1e3 * a4 / i4, o4.disposeOp = this.data[this.pos++], o4.blendOp = this.data[this.pos++], o4.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === u3 && (this.pos += 4, e3 -= 4), t4 = (null != o4 ? o4.data : void 0) || this.imgData, f3 = 0; 0 <= e3 ? f3 < e3 : f3 > e3; 0 <= e3 ? ++f3 : --f3)
            t4.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n3 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n3)
                throw new Error("More transparent colors than palette size");
              if ((h3 = n3 - this.transparency.indexed.length) > 0)
                for (d2 = 0; 0 <= h3 ? d2 < h3 : d2 > h3; 0 <= h3 ? ++d2 : --d2)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e3)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e3);
          }
          break;
        case "tEXt":
          s3 = (l3 = this.read(e3)).indexOf(0), c4 = String.fromCharCode.apply(String, l3.slice(0, s3)), this.text[c4] = String.fromCharCode.apply(String, l3.slice(s3 + 1));
          break;
        case "IEND":
          return o4 && this.animation.frames.push(o4), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = 4 === (p3 = this.colorType) || 6 === p3, r2 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r2, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e3;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  a3.prototype.read = function(t4) {
    var e3, r2;
    for (r2 = [], e3 = 0; 0 <= t4 ? e3 < t4 : e3 > t4; 0 <= t4 ? ++e3 : --e3)
      r2.push(this.data[this.pos++]);
    return r2;
  }, a3.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a3.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a3.prototype.decodePixels = function(t4) {
    var e3 = this.pixelBitlength / 8, n3 = new Uint8Array(this.width * this.height * e3), i4 = 0, a4 = this;
    if (null == t4 && (t4 = this.imgData), 0 === t4.length)
      return new Uint8Array(0);
    function o4(r2, o5, s3, c4) {
      var u3, h3, l3, f3, d2, p3, g2, m4, v3, b2, y3, w2, N3, L2, A2, x2, S2, _3, P2, k2, I2, F2 = Math.ceil((a4.width - r2) / s3), C2 = Math.ceil((a4.height - o5) / c4), j2 = a4.width == F2 && a4.height == C2;
      for (L2 = e3 * F2, w2 = j2 ? n3 : new Uint8Array(L2 * C2), p3 = t4.length, N3 = 0, h3 = 0; N3 < C2 && i4 < p3; ) {
        switch (t4[i4++]) {
          case 0:
            for (f3 = S2 = 0; S2 < L2; f3 = S2 += 1)
              w2[h3++] = t4[i4++];
            break;
          case 1:
            for (f3 = _3 = 0; _3 < L2; f3 = _3 += 1)
              u3 = t4[i4++], d2 = f3 < e3 ? 0 : w2[h3 - e3], w2[h3++] = (u3 + d2) % 256;
            break;
          case 2:
            for (f3 = P2 = 0; P2 < L2; f3 = P2 += 1)
              u3 = t4[i4++], l3 = (f3 - f3 % e3) / e3, A2 = N3 && w2[(N3 - 1) * L2 + l3 * e3 + f3 % e3], w2[h3++] = (A2 + u3) % 256;
            break;
          case 3:
            for (f3 = k2 = 0; k2 < L2; f3 = k2 += 1)
              u3 = t4[i4++], l3 = (f3 - f3 % e3) / e3, d2 = f3 < e3 ? 0 : w2[h3 - e3], A2 = N3 && w2[(N3 - 1) * L2 + l3 * e3 + f3 % e3], w2[h3++] = (u3 + Math.floor((d2 + A2) / 2)) % 256;
            break;
          case 4:
            for (f3 = I2 = 0; I2 < L2; f3 = I2 += 1)
              u3 = t4[i4++], l3 = (f3 - f3 % e3) / e3, d2 = f3 < e3 ? 0 : w2[h3 - e3], 0 === N3 ? A2 = x2 = 0 : (A2 = w2[(N3 - 1) * L2 + l3 * e3 + f3 % e3], x2 = l3 && w2[(N3 - 1) * L2 + (l3 - 1) * e3 + f3 % e3]), g2 = d2 + A2 - x2, m4 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y3 = Math.abs(g2 - x2), v3 = m4 <= b2 && m4 <= y3 ? d2 : b2 <= y3 ? A2 : x2, w2[h3++] = (u3 + v3) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t4[i4 - 1]);
        }
        if (!j2) {
          var O3 = ((o5 + N3 * c4) * a4.width + r2) * e3, B2 = N3 * L2;
          for (f3 = 0; f3 < F2; f3 += 1) {
            for (var M2 = 0; M2 < e3; M2 += 1)
              n3[O3++] = w2[B2++];
            O3 += (s3 - 1) * e3;
          }
        }
        N3++;
      }
    }
    return t4 = unzlibSync(t4), 1 == a4.interlaceMethod ? (o4(0, 0, 8, 8), o4(4, 0, 8, 8), o4(0, 4, 4, 8), o4(2, 0, 4, 4), o4(0, 2, 2, 4), o4(1, 0, 2, 2), o4(0, 1, 1, 2)) : o4(0, 0, 1, 1), n3;
  }, a3.prototype.decodePalette = function() {
    var t4, e3, r2, n3, i4, a4, o4, s3, c4;
    for (r2 = this.palette, a4 = this.transparency.indexed || [], i4 = new Uint8Array((a4.length || 0) + r2.length), n3 = 0, t4 = 0, e3 = o4 = 0, s3 = r2.length; o4 < s3; e3 = o4 += 3)
      i4[n3++] = r2[e3], i4[n3++] = r2[e3 + 1], i4[n3++] = r2[e3 + 2], i4[n3++] = null != (c4 = a4[t4++]) ? c4 : 255;
    return i4;
  }, a3.prototype.copyToImageData = function(t4, e3) {
    var r2, n3, i4, a4, o4, s3, c4, u3, h3, l3, f3;
    if (n3 = this.colors, h3 = null, r2 = this.hasAlphaChannel, this.palette.length && (h3 = null != (f3 = this._decodedPalette) ? f3 : this._decodedPalette = this.decodePalette(), n3 = 4, r2 = true), u3 = (i4 = t4.data || t4).length, o4 = h3 || e3, a4 = s3 = 0, 1 === n3)
      for (; a4 < u3; )
        c4 = h3 ? 4 * e3[a4 / 4] : s3, l3 = o4[c4++], i4[a4++] = l3, i4[a4++] = l3, i4[a4++] = l3, i4[a4++] = r2 ? o4[c4++] : 255, s3 = c4;
    else
      for (; a4 < u3; )
        c4 = h3 ? 4 * e3[a4 / 4] : s3, i4[a4++] = o4[c4++], i4[a4++] = o4[c4++], i4[a4++] = o4[c4++], i4[a4++] = r2 ? o4[c4++] : 255, s3 = c4;
  }, a3.prototype.decode = function() {
    var t4;
    return t4 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t4, this.decodePixels()), t4;
  };
  var o3 = function() {
    if ("[object Window]" === Object.prototype.toString.call(n2)) {
      try {
        e2 = n2.document.createElement("canvas"), i3 = e2.getContext("2d");
      } catch (t4) {
        return false;
      }
      return true;
    }
    return false;
  };
  return o3(), t3 = function(t4) {
    var r2;
    if (true === o3())
      return i3.width = t4.width, i3.height = t4.height, i3.clearRect(0, 0, t4.width, t4.height), i3.putImageData(t4, 0, 0), (r2 = new Image()).src = e2.toDataURL(), r2;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, a3.prototype.decodeFrames = function(e3) {
    var r2, n3, i4, a4, o4, s3, c4, u3;
    if (this.animation) {
      for (u3 = [], n3 = o4 = 0, s3 = (c4 = this.animation.frames).length; o4 < s3; n3 = ++o4)
        r2 = c4[n3], i4 = e3.createImageData(r2.width, r2.height), a4 = this.decodePixels(new Uint8Array(r2.data)), this.copyToImageData(i4, a4), r2.imageData = i4, u3.push(r2.image = t3(i4));
      return u3;
    }
  }, a3.prototype.renderFrame = function(t4, e3) {
    var r2, n3, i4;
    return r2 = (n3 = this.animation.frames)[e3], i4 = n3[e3 - 1], 0 === e3 && t4.clearRect(0, 0, this.width, this.height), 1 === (null != i4 ? i4.disposeOp : void 0) ? t4.clearRect(i4.xOffset, i4.yOffset, i4.width, i4.height) : 2 === (null != i4 ? i4.disposeOp : void 0) && t4.putImageData(i4.imageData, i4.xOffset, i4.yOffset), 0 === r2.blendOp && t4.clearRect(r2.xOffset, r2.yOffset, r2.width, r2.height), t4.drawImage(r2.image, r2.xOffset, r2.yOffset);
  }, a3.prototype.animate = function(t4) {
    var e3, r2, n3, i4, a4, o4, s3 = this;
    return r2 = 0, o4 = this.animation, i4 = o4.numFrames, n3 = o4.frames, a4 = o4.numPlays, (e3 = function() {
      var o5, c4;
      if (o5 = r2++ % i4, c4 = n3[o5], s3.renderFrame(t4, o5), i4 > 1 && r2 / i4 < a4)
        return s3.animation._timeout = setTimeout(e3, c4.delay);
    })();
  }, a3.prototype.stopAnimation = function() {
    var t4;
    return clearTimeout(null != (t4 = this.animation) ? t4._timeout : void 0);
  }, a3.prototype.render = function(t4) {
    var e3, r2;
    return t4._png && t4._png.stopAnimation(), t4._png = this, t4.width = this.width, t4.height = this.height, e3 = t4.getContext("2d"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r2 = e3.createImageData(this.width, this.height), this.copyToImageData(r2, this.decodePixels()), e3.putImageData(r2, 0, 0));
  }, a3;
}();
function Zt(t3) {
  var e2 = 0;
  if (71 !== t3[e2++] || 73 !== t3[e2++] || 70 !== t3[e2++] || 56 !== t3[e2++] || 56 != (t3[e2++] + 1 & 253) || 97 !== t3[e2++])
    throw new Error("Invalid GIF 87a/89a header.");
  var r2 = t3[e2++] | t3[e2++] << 8, n3 = t3[e2++] | t3[e2++] << 8, i3 = t3[e2++], a3 = i3 >> 7, o3 = 1 << (7 & i3) + 1;
  t3[e2++];
  t3[e2++];
  var s3 = null, c4 = null;
  a3 && (s3 = e2, c4 = o3, e2 += 3 * o3);
  var u3 = true, h3 = [], l3 = 0, f3 = null, d2 = 0, p3 = null;
  for (this.width = r2, this.height = n3; u3 && e2 < t3.length; )
    switch (t3[e2++]) {
      case 33:
        switch (t3[e2++]) {
          case 255:
            if (11 !== t3[e2] || 78 == t3[e2 + 1] && 69 == t3[e2 + 2] && 84 == t3[e2 + 3] && 83 == t3[e2 + 4] && 67 == t3[e2 + 5] && 65 == t3[e2 + 6] && 80 == t3[e2 + 7] && 69 == t3[e2 + 8] && 50 == t3[e2 + 9] && 46 == t3[e2 + 10] && 48 == t3[e2 + 11] && 3 == t3[e2 + 12] && 1 == t3[e2 + 13] && 0 == t3[e2 + 16])
              e2 += 14, p3 = t3[e2++] | t3[e2++] << 8, e2++;
            else
              for (e2 += 12; ; ) {
                if (!((P2 = t3[e2++]) >= 0))
                  throw Error("Invalid block size");
                if (0 === P2)
                  break;
                e2 += P2;
              }
            break;
          case 249:
            if (4 !== t3[e2++] || 0 !== t3[e2 + 4])
              throw new Error("Invalid graphics extension block.");
            var g2 = t3[e2++];
            l3 = t3[e2++] | t3[e2++] << 8, f3 = t3[e2++], 0 == (1 & g2) && (f3 = null), d2 = g2 >> 2 & 7, e2++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t3[e2++]) >= 0))
                throw Error("Invalid block size");
              if (0 === P2)
                break;
              e2 += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t3[e2 - 1].toString(16));
        }
        break;
      case 44:
        var m4 = t3[e2++] | t3[e2++] << 8, v3 = t3[e2++] | t3[e2++] << 8, b2 = t3[e2++] | t3[e2++] << 8, y3 = t3[e2++] | t3[e2++] << 8, w2 = t3[e2++], N3 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s3, x2 = c4, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e2, x2 = L2, e2 += 3 * L2;
        }
        var _3 = e2;
        for (e2++; ; ) {
          var P2;
          if (!((P2 = t3[e2++]) >= 0))
            throw Error("Invalid block size");
          if (0 === P2)
            break;
          e2 += P2;
        }
        h3.push({ x: m4, y: v3, width: b2, height: y3, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _3, data_length: e2 - _3, transparent_index: f3, interlaced: !!N3, delay: l3, disposal: d2 });
        break;
      case 59:
        u3 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t3[e2 - 1].toString(16));
    }
  this.numFrames = function() {
    return h3.length;
  }, this.loopCount = function() {
    return p3;
  }, this.frameInfo = function(t4) {
    if (t4 < 0 || t4 >= h3.length)
      throw new Error("Frame index out of range.");
    return h3[t4];
  }, this.decodeAndBlitFrameBGRA = function(e3, n4) {
    var i4 = this.frameInfo(e3), a4 = i4.width * i4.height, o4 = new Uint8Array(a4);
    $t(t3, i4.data_offset, o4, a4);
    var s4 = i4.palette_offset, c5 = i4.transparent_index;
    null === c5 && (c5 = 256);
    var u4 = i4.width, h4 = r2 - u4, l4 = u4, f4 = 4 * (i4.y * r2 + i4.x), d3 = 4 * ((i4.y + i4.height) * r2 + i4.x), p4 = f4, g3 = 4 * h4;
    true === i4.interlaced && (g3 += 4 * r2 * 7);
    for (var m5 = 8, v4 = 0, b3 = o4.length; v4 < b3; ++v4) {
      var y4 = o4[v4];
      if (0 === l4 && (l4 = u4, (p4 += g3) >= d3 && (g3 = 4 * h4 + 4 * r2 * (m5 - 1), p4 = f4 + (u4 + h4) * (m5 << 1), m5 >>= 1)), y4 === c5)
        p4 += 4;
      else {
        var w3 = t3[s4 + 3 * y4], N4 = t3[s4 + 3 * y4 + 1], L3 = t3[s4 + 3 * y4 + 2];
        n4[p4++] = L3, n4[p4++] = N4, n4[p4++] = w3, n4[p4++] = 255;
      }
      --l4;
    }
  }, this.decodeAndBlitFrameRGBA = function(e3, n4) {
    var i4 = this.frameInfo(e3), a4 = i4.width * i4.height, o4 = new Uint8Array(a4);
    $t(t3, i4.data_offset, o4, a4);
    var s4 = i4.palette_offset, c5 = i4.transparent_index;
    null === c5 && (c5 = 256);
    var u4 = i4.width, h4 = r2 - u4, l4 = u4, f4 = 4 * (i4.y * r2 + i4.x), d3 = 4 * ((i4.y + i4.height) * r2 + i4.x), p4 = f4, g3 = 4 * h4;
    true === i4.interlaced && (g3 += 4 * r2 * 7);
    for (var m5 = 8, v4 = 0, b3 = o4.length; v4 < b3; ++v4) {
      var y4 = o4[v4];
      if (0 === l4 && (l4 = u4, (p4 += g3) >= d3 && (g3 = 4 * h4 + 4 * r2 * (m5 - 1), p4 = f4 + (u4 + h4) * (m5 << 1), m5 >>= 1)), y4 === c5)
        p4 += 4;
      else {
        var w3 = t3[s4 + 3 * y4], N4 = t3[s4 + 3 * y4 + 1], L3 = t3[s4 + 3 * y4 + 2];
        n4[p4++] = w3, n4[p4++] = N4, n4[p4++] = L3, n4[p4++] = 255;
      }
      --l4;
    }
  };
}
function $t(t3, e2, r2, n3) {
  for (var i3 = t3[e2++], o3 = 1 << i3, s3 = o3 + 1, c4 = s3 + 1, u3 = i3 + 1, h3 = (1 << u3) - 1, l3 = 0, f3 = 0, d2 = 0, p3 = t3[e2++], g2 = new Int32Array(4096), m4 = null; ; ) {
    for (; l3 < 16 && 0 !== p3; )
      f3 |= t3[e2++] << l3, l3 += 8, 1 === p3 ? p3 = t3[e2++] : --p3;
    if (l3 < u3)
      break;
    var v3 = f3 & h3;
    if (f3 >>= u3, l3 -= u3, v3 !== o3) {
      if (v3 === s3)
        break;
      for (var b2 = v3 < c4 ? v3 : m4, y3 = 0, w2 = b2; w2 > o3; )
        w2 = g2[w2] >> 8, ++y3;
      var N3 = w2;
      if (d2 + y3 + (b2 !== v3 ? 1 : 0) > n3)
        return void a2.log("Warning, gif stream longer than expected.");
      r2[d2++] = N3;
      var L2 = d2 += y3;
      for (b2 !== v3 && (r2[d2++] = N3), w2 = b2; y3--; )
        w2 = g2[w2], r2[--L2] = 255 & w2, w2 >>= 8;
      null !== m4 && c4 < 4096 && (g2[c4++] = m4 << 8 | N3, c4 >= h3 + 1 && u3 < 12 && (++u3, h3 = h3 << 1 | 1)), m4 = v3;
    } else
      c4 = s3 + 1, h3 = (1 << (u3 = i3 + 1)) - 1, m4 = null;
  }
  return d2 !== n3 && a2.log("Warning, gif stream shorter than expected."), r2;
}
function Qt(t3) {
  var e2, r2, n3, i3, a3, o3 = Math.floor, s3 = new Array(64), c4 = new Array(64), u3 = new Array(64), h3 = new Array(64), l3 = new Array(65535), f3 = new Array(65535), d2 = new Array(64), p3 = new Array(64), g2 = [], m4 = 0, v3 = 7, b2 = new Array(64), y3 = new Array(64), w2 = new Array(64), N3 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _3 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t4, e3) {
    for (var r3 = 0, n4 = 0, i4 = new Array(), a4 = 1; a4 <= 16; a4++) {
      for (var o4 = 1; o4 <= t4[a4]; o4++)
        i4[e3[n4]] = [], i4[e3[n4]][0] = r3, i4[e3[n4]][1] = a4, n4++, r3++;
      r3 *= 2;
    }
    return i4;
  }
  function O3(t4) {
    for (var e3 = t4[0], r3 = t4[1] - 1; r3 >= 0; )
      e3 & 1 << r3 && (m4 |= 1 << v3), r3--, --v3 < 0 && (255 == m4 ? (B2(255), B2(0)) : B2(m4), v3 = 7, m4 = 0);
  }
  function B2(t4) {
    g2.push(t4);
  }
  function M2(t4) {
    B2(t4 >> 8 & 255), B2(255 & t4);
  }
  function E2(t4, e3, r3, n4, i4) {
    for (var a4, o4 = i4[0], s4 = i4[240], c5 = function(t5, e4) {
      var r4, n5, i5, a5, o5, s5, c6, u5, h5, l4, f4 = 0;
      for (h5 = 0; h5 < 8; ++h5) {
        r4 = t5[f4], n5 = t5[f4 + 1], i5 = t5[f4 + 2], a5 = t5[f4 + 3], o5 = t5[f4 + 4], s5 = t5[f4 + 5], c6 = t5[f4 + 6];
        var p4 = r4 + (u5 = t5[f4 + 7]), g4 = r4 - u5, m6 = n5 + c6, v5 = n5 - c6, b4 = i5 + s5, y5 = i5 - s5, w4 = a5 + o5, N4 = a5 - o5, L3 = p4 + w4, A3 = p4 - w4, x3 = m6 + b4, S3 = m6 - b4;
        t5[f4] = L3 + x3, t5[f4 + 4] = L3 - x3;
        var _4 = 0.707106781 * (S3 + A3);
        t5[f4 + 2] = A3 + _4, t5[f4 + 6] = A3 - _4;
        var P3 = 0.382683433 * ((L3 = N4 + y5) - (S3 = v5 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y5 + v5), C3 = g4 + F3, j3 = g4 - F3;
        t5[f4 + 5] = j3 + k3, t5[f4 + 3] = j3 - k3, t5[f4 + 1] = C3 + I3, t5[f4 + 7] = C3 - I3, f4 += 8;
      }
      for (f4 = 0, h5 = 0; h5 < 8; ++h5) {
        r4 = t5[f4], n5 = t5[f4 + 8], i5 = t5[f4 + 16], a5 = t5[f4 + 24], o5 = t5[f4 + 32], s5 = t5[f4 + 40], c6 = t5[f4 + 48];
        var O4 = r4 + (u5 = t5[f4 + 56]), B3 = r4 - u5, M3 = n5 + c6, E3 = n5 - c6, q3 = i5 + s5, D2 = i5 - s5, R2 = a5 + o5, T3 = a5 - o5, U2 = O4 + R2, z2 = O4 - R2, H2 = M3 + q3, W2 = M3 - q3;
        t5[f4] = U2 + H2, t5[f4 + 32] = U2 - H2;
        var V2 = 0.707106781 * (W2 + z2);
        t5[f4 + 16] = z2 + V2, t5[f4 + 48] = z2 - V2;
        var G2 = 0.382683433 * ((U2 = T3 + D2) - (W2 = E3 + B3)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H2 = D2 + E3), K2 = B3 + X2, Z2 = B3 - X2;
        t5[f4 + 40] = Z2 + Y2, t5[f4 + 24] = Z2 - Y2, t5[f4 + 8] = K2 + J2, t5[f4 + 56] = K2 - J2, f4++;
      }
      for (h5 = 0; h5 < 64; ++h5)
        l4 = t5[h5] * e4[h5], d2[h5] = l4 > 0 ? l4 + 0.5 | 0 : l4 - 0.5 | 0;
      return d2;
    }(t4, e3), u4 = 0; u4 < 64; ++u4)
      p3[A2[u4]] = c5[u4];
    var h4 = p3[0] - r3;
    r3 = p3[0], 0 == h4 ? O3(n4[0]) : (O3(n4[f3[a4 = 32767 + h4]]), O3(l3[a4]));
    for (var g3 = 63; g3 > 0 && 0 == p3[g3]; )
      g3--;
    if (0 == g3)
      return O3(o4), r3;
    for (var m5, v4 = 1; v4 <= g3; ) {
      for (var b3 = v4; 0 == p3[v4] && v4 <= g3; )
        ++v4;
      var y4 = v4 - b3;
      if (y4 >= 16) {
        m5 = y4 >> 4;
        for (var w3 = 1; w3 <= m5; ++w3)
          O3(s4);
        y4 &= 15;
      }
      a4 = 32767 + p3[v4], O3(i4[(y4 << 4) + f3[a4]]), O3(l3[a4]), v4++;
    }
    return 63 != g3 && O3(o4), r3;
  }
  function q2(t4) {
    (t4 = Math.min(Math.max(t4, 1), 100), a3 != t4) && (!function(t5) {
      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0; r3 < 64; r3++) {
        var n4 = o3((e3[r3] * t5 + 50) / 100);
        n4 = Math.min(Math.max(n4, 1), 255), s3[A2[r3]] = n4;
      }
      for (var i4 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a4 = 0; a4 < 64; a4++) {
        var l4 = o3((i4[a4] * t5 + 50) / 100);
        l4 = Math.min(Math.max(l4, 1), 255), c4[A2[a4]] = l4;
      }
      for (var f4 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p4 = 0; p4 < 8; p4++)
        for (var g3 = 0; g3 < 8; g3++)
          u3[d3] = 1 / (s3[A2[d3]] * f4[p4] * f4[g3] * 8), h3[d3] = 1 / (c4[A2[d3]] * f4[p4] * f4[g3] * 8), d3++;
    }(t4 < 50 ? Math.floor(5e3 / t4) : Math.floor(200 - 2 * t4)), a3 = t4);
  }
  this.encode = function(t4, a4) {
    a4 && q2(a4), g2 = new Array(), m4 = 0, v3 = 7, M2(65496), M2(65504), M2(16), B2(74), B2(70), B2(73), B2(70), B2(0), B2(1), B2(1), B2(0), M2(1), M2(1), B2(0), B2(0), function() {
      M2(65499), M2(132), B2(0);
      for (var t5 = 0; t5 < 64; t5++)
        B2(s3[t5]);
      B2(1);
      for (var e3 = 0; e3 < 64; e3++)
        B2(c4[e3]);
    }(), function(t5, e3) {
      M2(65472), M2(17), B2(8), M2(e3), M2(t5), B2(3), B2(1), B2(17), B2(0), B2(2), B2(17), B2(1), B2(3), B2(17), B2(1);
    }(t4.width, t4.height), function() {
      M2(65476), M2(418), B2(0);
      for (var t5 = 0; t5 < 16; t5++)
        B2(x2[t5 + 1]);
      for (var e3 = 0; e3 <= 11; e3++)
        B2(S2[e3]);
      B2(16);
      for (var r3 = 0; r3 < 16; r3++)
        B2(_3[r3 + 1]);
      for (var n4 = 0; n4 <= 161; n4++)
        B2(P2[n4]);
      B2(1);
      for (var i4 = 0; i4 < 16; i4++)
        B2(k2[i4 + 1]);
      for (var a5 = 0; a5 <= 11; a5++)
        B2(I2[a5]);
      B2(17);
      for (var o5 = 0; o5 < 16; o5++)
        B2(F2[o5 + 1]);
      for (var s4 = 0; s4 <= 161; s4++)
        B2(C2[s4]);
    }(), M2(65498), M2(12), B2(3), B2(1), B2(0), B2(2), B2(17), B2(3), B2(17), B2(0), B2(63), B2(0);
    var o4 = 0, l4 = 0, f4 = 0;
    m4 = 0, v3 = 7, this.encode.displayName = "_encode_";
    for (var d3, p4, N4, A3, j3, D2, R2, T3, U2, z2 = t4.data, H2 = t4.width, W2 = t4.height, V2 = 4 * H2, G2 = 0; G2 < W2; ) {
      for (d3 = 0; d3 < V2; ) {
        for (j3 = V2 * G2 + d3, R2 = -1, T3 = 0, U2 = 0; U2 < 64; U2++)
          D2 = j3 + (T3 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T3 >= W2 && (D2 -= V2 * (G2 + 1 + T3 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p4 = z2[D2++], N4 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p4] + L2[N4 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y3[U2] = (L2[p4 + 768 >> 0] + L2[N4 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p4 + 1280 >> 0] + L2[N4 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o4 = E2(b2, u3, o4, e2, n3), l4 = E2(y3, h3, l4, r2, i3), f4 = E2(w2, h3, f4, r2, i3), d3 += 32;
      }
      G2 += 8;
    }
    if (v3 >= 0) {
      var Y2 = [];
      Y2[1] = v3 + 1, Y2[0] = (1 << v3 + 1) - 1, O3(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t3 = t3 || 50, function() {
    for (var t4 = String.fromCharCode, e3 = 0; e3 < 256; e3++)
      N3[e3] = t4(e3);
  }(), e2 = j2(x2, S2), r2 = j2(k2, I2), n3 = j2(_3, P2), i3 = j2(F2, C2), function() {
    for (var t4 = 1, e3 = 2, r3 = 1; r3 <= 15; r3++) {
      for (var n4 = t4; n4 < e3; n4++)
        f3[32767 + n4] = r3, l3[32767 + n4] = [], l3[32767 + n4][1] = r3, l3[32767 + n4][0] = n4;
      for (var i4 = -(e3 - 1); i4 <= -t4; i4++)
        f3[32767 + i4] = r3, l3[32767 + i4] = [], l3[32767 + i4][1] = r3, l3[32767 + i4][0] = e3 - 1 + i4;
      t4 <<= 1, e3 <<= 1;
    }
  }(), function() {
    for (var t4 = 0; t4 < 256; t4++)
      L2[t4] = 19595 * t4, L2[t4 + 256 >> 0] = 38470 * t4, L2[t4 + 512 >> 0] = 7471 * t4 + 32768, L2[t4 + 768 >> 0] = -11059 * t4, L2[t4 + 1024 >> 0] = -21709 * t4, L2[t4 + 1280 >> 0] = 32768 * t4 + 8421375, L2[t4 + 1536 >> 0] = -27439 * t4, L2[t4 + 1792 >> 0] = -5329 * t4;
  }(), q2(t3);
}
function te(t3, e2) {
  if (this.pos = 0, this.buffer = t3, this.datav = new DataView(t3.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag))
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t3) {
  function e2(t4) {
    if (!t4)
      throw Error("assert :P");
  }
  function r2(t4, e3, r3) {
    for (var n4 = 0; 4 > n4; n4++)
      if (t4[e3 + n4] != r3.charCodeAt(n4))
        return true;
    return false;
  }
  function n3(t4, e3, r3, n4, i4) {
    for (var a4 = 0; a4 < i4; a4++)
      t4[e3 + a4] = r3[n4 + a4];
  }
  function i3(t4, e3, r3, n4) {
    for (var i4 = 0; i4 < n4; i4++)
      t4[e3 + i4] = r3;
  }
  function a3(t4) {
    return new Int32Array(t4);
  }
  function o3(t4, e3) {
    for (var r3 = [], n4 = 0; n4 < t4; n4++)
      r3.push(new e3());
    return r3;
  }
  function s3(t4, e3) {
    var r3 = [];
    return function t5(r4, n4, i4) {
      for (var a4 = i4[n4], o4 = 0; o4 < a4 && (r4.push(i4.length > n4 + 1 ? [] : new e3()), !(i4.length < n4 + 1)); o4++)
        t5(r4[o4], n4 + 1, i4);
    }(r3, 0, t4), r3;
  }
  var c4 = function() {
    var t4 = this;
    function c5(t5, e3) {
      for (var r3 = 1 << e3 - 1 >>> 0; t5 & r3; )
        r3 >>>= 1;
      return r3 ? (t5 & r3 - 1) + r3 : t5;
    }
    function u4(t5, r3, n4, i4, a4) {
      e2(!(i4 % n4));
      do {
        t5[r3 + (i4 -= n4)] = a4;
      } while (0 < i4);
    }
    function h4(t5, r3, n4, i4, o4) {
      if (e2(2328 >= o4), 512 >= o4)
        var s4 = a3(512);
      else if (null == (s4 = a3(o4)))
        return 0;
      return function(t6, r4, n5, i5, o5, s5) {
        var h5, f5, d4 = r4, p5 = 1 << n5, g4 = a3(16), m6 = a3(16);
        for (e2(0 != o5), e2(null != i5), e2(null != t6), e2(0 < n5), f5 = 0; f5 < o5; ++f5) {
          if (15 < i5[f5])
            return 0;
          ++g4[i5[f5]];
        }
        if (g4[0] == o5)
          return 0;
        for (m6[1] = 0, h5 = 1; 15 > h5; ++h5) {
          if (g4[h5] > 1 << h5)
            return 0;
          m6[h5 + 1] = m6[h5] + g4[h5];
        }
        for (f5 = 0; f5 < o5; ++f5)
          h5 = i5[f5], 0 < i5[f5] && (s5[m6[h5]++] = f5);
        if (1 == m6[15])
          return (i5 = new l4()).g = 0, i5.value = s5[0], u4(t6, d4, 1, p5, i5), p5;
        var v5, b4 = -1, y5 = p5 - 1, w4 = 0, N5 = 1, L4 = 1, A4 = 1 << n5;
        for (f5 = 0, h5 = 1, o5 = 2; h5 <= n5; ++h5, o5 <<= 1) {
          if (N5 += L4 <<= 1, 0 > (L4 -= g4[h5]))
            return 0;
          for (; 0 < g4[h5]; --g4[h5])
            (i5 = new l4()).g = h5, i5.value = s5[f5++], u4(t6, d4 + w4, o5, A4, i5), w4 = c5(w4, h5);
        }
        for (h5 = n5 + 1, o5 = 2; 15 >= h5; ++h5, o5 <<= 1) {
          if (N5 += L4 <<= 1, 0 > (L4 -= g4[h5]))
            return 0;
          for (; 0 < g4[h5]; --g4[h5]) {
            if (i5 = new l4(), (w4 & y5) != b4) {
              for (d4 += A4, v5 = 1 << (b4 = h5) - n5; 15 > b4 && !(0 >= (v5 -= g4[b4])); )
                ++b4, v5 <<= 1;
              p5 += A4 = 1 << (v5 = b4 - n5), t6[r4 + (b4 = w4 & y5)].g = v5 + n5, t6[r4 + b4].value = d4 - r4 - b4;
            }
            i5.g = h5 - n5, i5.value = s5[f5++], u4(t6, d4 + (w4 >> n5), o5, A4, i5), w4 = c5(w4, h5);
          }
        }
        return N5 != 2 * m6[15] - 1 ? 0 : p5;
      }(t5, r3, n4, i4, o4, s4);
    }
    function l4() {
      this.value = this.g = 0;
    }
    function f4() {
      this.value = this.g = 0;
    }
    function d3() {
      this.G = o3(5, l4), this.H = a3(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o3(Dr, f4);
    }
    function p4(t5, r3, n4, i4) {
      e2(null != t5), e2(null != r3), e2(2147483648 > i4), t5.Ca = 254, t5.I = 0, t5.b = -8, t5.Ka = 0, t5.oa = r3, t5.pa = n4, t5.Jd = r3, t5.Yc = n4 + i4, t5.Zc = 4 <= i4 ? n4 + i4 - 4 + 1 : n4, _3(t5);
    }
    function g3(t5, e3) {
      for (var r3 = 0; 0 < e3--; )
        r3 |= k2(t5, 128) << e3;
      return r3;
    }
    function m5(t5, e3) {
      var r3 = g3(t5, e3);
      return P2(t5) ? -r3 : r3;
    }
    function v4(t5, r3, n4, i4) {
      var a4, o4 = 0;
      for (e2(null != t5), e2(null != r3), e2(4294967288 > i4), t5.Sb = i4, t5.Ra = 0, t5.u = 0, t5.h = 0, 4 < i4 && (i4 = 4), a4 = 0; a4 < i4; ++a4)
        o4 += r3[n4 + a4] << 8 * a4;
      t5.Ra = o4, t5.bb = i4, t5.oa = r3, t5.pa = n4;
    }
    function b3(t5) {
      for (; 8 <= t5.u && t5.bb < t5.Sb; )
        t5.Ra >>>= 8, t5.Ra += t5.oa[t5.pa + t5.bb] << Ur - 8 >>> 0, ++t5.bb, t5.u -= 8;
      A3(t5) && (t5.h = 1, t5.u = 0);
    }
    function y4(t5, r3) {
      if (e2(0 <= r3), !t5.h && r3 <= Tr) {
        var n4 = L3(t5) & Rr[r3];
        return t5.u += r3, b3(t5), n4;
      }
      return t5.h = 1, t5.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N4() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t5) {
      return t5.Ra >>> (t5.u & Ur - 1) >>> 0;
    }
    function A3(t5) {
      return e2(t5.bb <= t5.Sb), t5.h || t5.bb == t5.Sb && t5.u > Ur;
    }
    function x2(t5, e3) {
      t5.u = e3, t5.h = A3(t5);
    }
    function S2(t5) {
      t5.u >= zr && (e2(t5.u >= zr), b3(t5));
    }
    function _3(t5) {
      e2(null != t5 && null != t5.oa), t5.pa < t5.Zc ? (t5.I = (t5.oa[t5.pa++] | t5.I << 8) >>> 0, t5.b += 8) : (e2(null != t5 && null != t5.oa), t5.pa < t5.Yc ? (t5.b += 8, t5.I = t5.oa[t5.pa++] | t5.I << 8) : t5.Ka ? t5.b = 0 : (t5.I <<= 8, t5.b += 8, t5.Ka = 1));
    }
    function P2(t5) {
      return g3(t5, 1);
    }
    function k2(t5, e3) {
      var r3 = t5.Ca;
      0 > t5.b && _3(t5);
      var n4 = t5.b, i4 = r3 * e3 >>> 8, a4 = (t5.I >>> n4 > i4) + 0;
      for (a4 ? (r3 -= i4, t5.I -= i4 + 1 << n4 >>> 0) : r3 = i4 + 1, n4 = r3, i4 = 0; 256 <= n4; )
        i4 += 8, n4 >>= 8;
      return n4 = 7 ^ i4 + Hr[n4], t5.b -= n4, t5.Ca = (r3 << n4) - 1, a4;
    }
    function I2(t5, e3, r3) {
      t5[e3 + 0] = r3 >> 24 & 255, t5[e3 + 1] = r3 >> 16 & 255, t5[e3 + 2] = r3 >> 8 & 255, t5[e3 + 3] = r3 >> 0 & 255;
    }
    function F2(t5, e3) {
      return t5[e3 + 0] << 0 | t5[e3 + 1] << 8;
    }
    function C2(t5, e3) {
      return F2(t5, e3) | t5[e3 + 2] << 16;
    }
    function j2(t5, e3) {
      return F2(t5, e3) | F2(t5, e3 + 2) << 16;
    }
    function O3(t5, r3) {
      var n4 = 1 << r3;
      return e2(null != t5), e2(0 < r3), t5.X = a3(n4), null == t5.X ? 0 : (t5.Mb = 32 - r3, t5.Xa = r3, 1);
    }
    function B2(t5, r3) {
      e2(null != t5), e2(null != r3), e2(t5.Xa == r3.Xa), n3(r3.X, 0, t5.X, 0, 1 << r3.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t5, r3, n4, i4) {
      e2(null != n4), e2(null != i4);
      var a4 = n4[0], o4 = i4[0];
      return 0 == a4 && (a4 = (t5 * o4 + r3 / 2) / r3), 0 == o4 && (o4 = (r3 * a4 + t5 / 2) / t5), 0 >= a4 || 0 >= o4 ? 0 : (n4[0] = a4, i4[0] = o4, 1);
    }
    function q2(t5, e3) {
      return t5 + (1 << e3) - 1 >>> e3;
    }
    function D2(t5, e3) {
      return ((4278255360 & t5) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t5) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
    }
    function R2(e3, r3) {
      t4[r3] = function(r4, n4, i4, a4, o4, s4, c6) {
        var u5;
        for (u5 = 0; u5 < o4; ++u5) {
          var h5 = t4[e3](s4[c6 + u5 - 1], i4, a4 + u5);
          s4[c6 + u5] = D2(r4[n4 + u5], h5);
        }
      };
    }
    function T3() {
      this.ud = this.hd = this.jd = 0;
    }
    function U2(t5, e3) {
      return ((4278124286 & (t5 ^ e3)) >>> 1) + (t5 & e3) >>> 0;
    }
    function z2(t5) {
      return 0 <= t5 && 256 > t5 ? t5 : 0 > t5 ? 0 : 255 < t5 ? 255 : void 0;
    }
    function H2(t5, e3) {
      return z2(t5 + (t5 - e3 + 0.5 >> 1));
    }
    function W2(t5, e3, r3) {
      return Math.abs(e3 - r3) - Math.abs(t5 - r3);
    }
    function V2(t5, e3, r3, n4, i4, a4, o4) {
      for (n4 = a4[o4 - 1], r3 = 0; r3 < i4; ++r3)
        a4[o4 + r3] = n4 = D2(t5[e3 + r3], n4);
    }
    function G2(t5, e3, r3, n4, i4) {
      var a4;
      for (a4 = 0; a4 < r3; ++a4) {
        var o4 = t5[e3 + a4], s4 = o4 >> 8 & 255, c6 = 16711935 & (c6 = (c6 = 16711935 & o4) + ((s4 << 16) + s4));
        n4[i4 + a4] = (4278255360 & o4) + c6 >>> 0;
      }
    }
    function Y2(t5, e3) {
      e3.jd = t5 >> 0 & 255, e3.hd = t5 >> 8 & 255, e3.ud = t5 >> 16 & 255;
    }
    function J2(t5, e3, r3, n4, i4, a4) {
      var o4;
      for (o4 = 0; o4 < n4; ++o4) {
        var s4 = e3[r3 + o4], c6 = s4 >>> 8, u5 = s4, h5 = 255 & (h5 = (h5 = s4 >>> 16) + ((t5.jd << 24 >> 24) * (c6 << 24 >> 24) >>> 5));
        u5 = 255 & (u5 = (u5 = u5 + ((t5.hd << 24 >> 24) * (c6 << 24 >> 24) >>> 5)) + ((t5.ud << 24 >> 24) * (h5 << 24 >> 24) >>> 5));
        i4[a4 + o4] = (4278255360 & s4) + (h5 << 16) + u5;
      }
    }
    function X2(e3, r3, n4, i4, a4) {
      t4[r3] = function(t5, e4, r4, n5, o4, s4, c6, u5, h5) {
        for (n5 = c6; n5 < u5; ++n5)
          for (c6 = 0; c6 < h5; ++c6)
            o4[s4++] = a4(r4[i4(t5[e4++])]);
      }, t4[e3] = function(e4, r4, o4, s4, c6, u5, h5) {
        var l5 = 8 >> e4.b, f5 = e4.Ea, d4 = e4.K[0], p5 = e4.w;
        if (8 > l5)
          for (e4 = (1 << e4.b) - 1, p5 = (1 << l5) - 1; r4 < o4; ++r4) {
            var g4, m6 = 0;
            for (g4 = 0; g4 < f5; ++g4)
              g4 & e4 || (m6 = i4(s4[c6++])), u5[h5++] = a4(d4[m6 & p5]), m6 >>= l5;
          }
        else
          t4["VP8LMapColor" + n4](s4, c6, d4, p5, u5, h5, r4, o4, f5);
      };
    }
    function K2(t5, e3, r3, n4, i4) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a4 = t5[e3++];
        n4[i4++] = a4 >> 16 & 255, n4[i4++] = a4 >> 8 & 255, n4[i4++] = a4 >> 0 & 255;
      }
    }
    function Z2(t5, e3, r3, n4, i4) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a4 = t5[e3++];
        n4[i4++] = a4 >> 16 & 255, n4[i4++] = a4 >> 8 & 255, n4[i4++] = a4 >> 0 & 255, n4[i4++] = a4 >> 24 & 255;
      }
    }
    function $2(t5, e3, r3, n4, i4) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a4 = (o4 = t5[e3++]) >> 16 & 240 | o4 >> 12 & 15, o4 = o4 >> 0 & 240 | o4 >> 28 & 15;
        n4[i4++] = a4, n4[i4++] = o4;
      }
    }
    function Q2(t5, e3, r3, n4, i4) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a4 = (o4 = t5[e3++]) >> 16 & 248 | o4 >> 13 & 7, o4 = o4 >> 5 & 224 | o4 >> 3 & 31;
        n4[i4++] = a4, n4[i4++] = o4;
      }
    }
    function tt2(t5, e3, r3, n4, i4) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a4 = t5[e3++];
        n4[i4++] = a4 >> 0 & 255, n4[i4++] = a4 >> 8 & 255, n4[i4++] = a4 >> 16 & 255;
      }
    }
    function et3(t5, e3, r3, i4, a4, o4) {
      if (0 == o4)
        for (r3 = e3 + r3; e3 < r3; )
          I2(i4, ((o4 = t5[e3++])[0] >> 24 | o4[1] >> 8 & 65280 | o4[2] << 8 & 16711680 | o4[3] << 24) >>> 0), a4 += 32;
      else
        n3(i4, a4, t5, e3, r3);
    }
    function rt2(e3, r3) {
      t4[r3][0] = t4[e3 + "0"], t4[r3][1] = t4[e3 + "1"], t4[r3][2] = t4[e3 + "2"], t4[r3][3] = t4[e3 + "3"], t4[r3][4] = t4[e3 + "4"], t4[r3][5] = t4[e3 + "5"], t4[r3][6] = t4[e3 + "6"], t4[r3][7] = t4[e3 + "7"], t4[r3][8] = t4[e3 + "8"], t4[r3][9] = t4[e3 + "9"], t4[r3][10] = t4[e3 + "10"], t4[r3][11] = t4[e3 + "11"], t4[r3][12] = t4[e3 + "12"], t4[r3][13] = t4[e3 + "13"], t4[r3][14] = t4[e3 + "0"], t4[r3][15] = t4[e3 + "0"];
    }
    function nt2(t5) {
      return t5 == Hn || t5 == Wn || t5 == Vn || t5 == Gn;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t5) {
      return alert("todo:WebPSamplerProcessPlane"), t5.T;
    }
    function ht2(t5, e3) {
      var r3 = t5.T, i4 = e3.ba.f.RGBA, a4 = i4.eb, o4 = i4.fb + t5.ka * i4.A, s4 = vi[e3.ba.S], c6 = t5.y, u5 = t5.O, h5 = t5.f, l5 = t5.N, f5 = t5.ea, d4 = t5.W, p5 = e3.cc, g4 = e3.dc, m6 = e3.Mc, v5 = e3.Nc, b4 = t5.ka, y5 = t5.ka + t5.T, w4 = t5.U, N5 = w4 + 1 >> 1;
      for (0 == b4 ? s4(c6, u5, null, null, h5, l5, f5, d4, h5, l5, f5, d4, a4, o4, null, null, w4) : (s4(e3.ec, e3.fc, c6, u5, p5, g4, m6, v5, h5, l5, f5, d4, a4, o4 - i4.A, a4, o4, w4), ++r3); b4 + 2 < y5; b4 += 2)
        p5 = h5, g4 = l5, m6 = f5, v5 = d4, l5 += t5.Rc, d4 += t5.Rc, o4 += 2 * i4.A, s4(c6, (u5 += 2 * t5.fa) - t5.fa, c6, u5, p5, g4, m6, v5, h5, l5, f5, d4, a4, o4 - i4.A, a4, o4, w4);
      return u5 += t5.fa, t5.j + y5 < t5.o ? (n3(e3.ec, e3.fc, c6, u5, w4), n3(e3.cc, e3.dc, h5, l5, N5), n3(e3.Mc, e3.Nc, f5, d4, N5), r3--) : 1 & y5 || s4(c6, u5, null, null, h5, l5, f5, d4, h5, l5, f5, d4, a4, o4 + i4.A, null, null, w4), r3;
    }
    function lt2(t5, r3, n4) {
      var i4 = t5.F, a4 = [t5.J];
      if (null != i4) {
        var o4 = t5.U, s4 = r3.ba.S, c6 = s4 == Tn || s4 == Vn;
        r3 = r3.ba.f.RGBA;
        var u5 = [0], h5 = t5.ka;
        u5[0] = t5.T, t5.Kb && (0 == h5 ? --u5[0] : (--h5, a4[0] -= t5.width), t5.j + t5.ka + t5.T == t5.o && (u5[0] = t5.o - t5.j - h5));
        var l5 = r3.eb;
        h5 = r3.fb + h5 * r3.A;
        t5 = Sn(i4, a4[0], t5.width, o4, u5, l5, h5 + (c6 ? 0 : 3), r3.A), e2(n4 == u5), t5 && nt2(s4) && An(l5, h5, c6, o4, u5, r3.A);
      }
      return 0;
    }
    function ft2(t5) {
      var e3 = t5.ma, r3 = e3.ba.S, n4 = 11 > r3, i4 = r3 == qn || r3 == Rn || r3 == Tn || r3 == Un || 12 == r3 || nt2(r3);
      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t5, i4 ? 11 : 12))
        return 0;
      if (i4 && nt2(r3) && br(), t5.da)
        alert("todo:use_scaling");
      else {
        if (n4) {
          if (e3.Ib = ut2, t5.Kb) {
            if (r3 = t5.U + 1 >> 1, e3.memory = a3(t5.U + 2 * r3), null == e3.memory)
              return 0;
            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t5.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r3, e3.Ib = ht2, br();
          }
        } else
          alert("todo:EmitYUV");
        i4 && (e3.Jb = lt2, n4 && mr());
      }
      if (n4 && !Ci) {
        for (t5 = 0; 256 > t5; ++t5)
          ji[t5] = 89858 * (t5 - 128) + _i >> Si, Mi[t5] = -22014 * (t5 - 128) + _i, Bi[t5] = -45773 * (t5 - 128), Oi[t5] = 113618 * (t5 - 128) + _i >> Si;
        for (t5 = Pi; t5 < ki; ++t5)
          e3 = 76283 * (t5 - 16) + _i >> Si, Ei[t5 - Pi] = Vt2(e3, 255), qi[t5 - Pi] = Vt2(e3 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    function dt2(t5) {
      var r3 = t5.ma, n4 = t5.U, i4 = t5.T;
      return e2(!(1 & t5.ka)), 0 >= n4 || 0 >= i4 ? 0 : (n4 = r3.Ib(t5, r3), null != r3.Jb && r3.Jb(t5, r3, n4), r3.Dc += n4, 1);
    }
    function pt2(t5) {
      t5.ma.memory = null;
    }
    function gt2(t5, e3, r3, n4) {
      return 47 != y4(t5, 8) ? 0 : (e3[0] = y4(t5, 14) + 1, r3[0] = y4(t5, 14) + 1, n4[0] = y4(t5, 1), 0 != y4(t5, 3) ? 0 : !t5.h);
    }
    function mt2(t5, e3) {
      if (4 > t5)
        return t5 + 1;
      var r3 = t5 - 2 >> 1;
      return (2 + (1 & t5) << r3) + y4(e3, r3) + 1;
    }
    function vt2(t5, e3) {
      return 120 < e3 ? e3 - 120 : 1 <= (r3 = ((r3 = $n[e3 - 1]) >> 4) * t5 + (8 - (15 & r3))) ? r3 : 1;
      var r3;
    }
    function bt2(t5, e3, r3) {
      var n4 = L3(r3), i4 = t5[e3 += 255 & n4].g - 8;
      return 0 < i4 && (x2(r3, r3.u + 8), n4 = L3(r3), e3 += t5[e3].value, e3 += n4 & (1 << i4) - 1), x2(r3, r3.u + t5[e3].g), t5[e3].value;
    }
    function yt2(t5, r3, n4) {
      return n4.g += t5.g, n4.value += t5.value << r3 >>> 0, e2(8 >= n4.g), t5.g;
    }
    function wt2(t5, r3, n4) {
      var i4 = t5.xc;
      return e2((r3 = 0 == i4 ? 0 : t5.vc[t5.md * (n4 >> i4) + (r3 >> i4)]) < t5.Wb), t5.Ya[r3];
    }
    function Nt2(t5, r3, i4, a4) {
      var o4 = t5.ab, s4 = t5.c * r3, c6 = t5.C;
      r3 = c6 + r3;
      var u5 = i4, h5 = a4;
      for (a4 = t5.Ta, i4 = t5.Ua; 0 < o4--; ) {
        var l5 = t5.gc[o4], f5 = c6, d4 = r3, p5 = u5, g4 = h5, m6 = (h5 = a4, u5 = i4, l5.Ea);
        switch (e2(f5 < d4), e2(d4 <= l5.nc), l5.hc) {
          case 2:
            Gr(p5, g4, (d4 - f5) * m6, h5, u5);
            break;
          case 0:
            var v5 = f5, b4 = d4, y5 = h5, w4 = u5, N5 = (_4 = l5).Ea;
            0 == v5 && (Wr(p5, g4, null, null, 1, y5, w4), V2(p5, g4 + 1, 0, 0, N5 - 1, y5, w4 + 1), g4 += N5, w4 += N5, ++v5);
            for (var L4 = 1 << _4.b, A4 = L4 - 1, x3 = q2(N5, _4.b), S3 = _4.K, _4 = _4.w + (v5 >> _4.b) * x3; v5 < b4; ) {
              var P3 = S3, k3 = _4, I3 = 1;
              for (Vr(p5, g4, y5, w4 - N5, 1, y5, w4); I3 < N5; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N5 && (F3 = N5), (0, Zr[P3[k3++] >> 8 & 15])(p5, g4 + +I3, y5, w4 + I3 - N5, F3 - I3, y5, w4 + I3), I3 = F3;
              }
              g4 += N5, w4 += N5, ++v5 & A4 || (_4 += x3);
            }
            d4 != l5.nc && n3(h5, u5 - m6, h5, u5 + (d4 - f5 - 1) * m6, m6);
            break;
          case 1:
            for (m6 = p5, b4 = g4, N5 = (p5 = l5.Ea) - (w4 = p5 & ~(y5 = (g4 = 1 << l5.b) - 1)), v5 = q2(p5, l5.b), L4 = l5.K, l5 = l5.w + (f5 >> l5.b) * v5; f5 < d4; ) {
              for (A4 = L4, x3 = l5, S3 = new T3(), _4 = b4 + w4, P3 = b4 + p5; b4 < _4; )
                Y2(A4[x3++], S3), $r(S3, m6, b4, g4, h5, u5), b4 += g4, u5 += g4;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m6, b4, N5, h5, u5), b4 += N5, u5 += N5), ++f5 & y5 || (l5 += v5);
            }
            break;
          case 3:
            if (p5 == h5 && g4 == u5 && 0 < l5.b) {
              for (b4 = h5, p5 = m6 = u5 + (d4 - f5) * m6 - (w4 = (d4 - f5) * q2(l5.Ea, l5.b)), g4 = h5, y5 = u5, v5 = [], w4 = (N5 = w4) - 1; 0 <= w4; --w4)
                v5[w4] = g4[y5 + w4];
              for (w4 = N5 - 1; 0 <= w4; --w4)
                b4[p5 + w4] = v5[w4];
              Yr(l5, f5, d4, h5, m6, h5, u5);
            } else
              Yr(l5, f5, d4, p5, g4, h5, u5);
        }
        u5 = a4, h5 = i4;
      }
      h5 != i4 && n3(a4, i4, u5, h5, s4);
    }
    function Lt2(t5, r3) {
      var n4 = t5.V, i4 = t5.Ba + t5.c * t5.C, a4 = r3 - t5.C;
      if (e2(r3 <= t5.l.o), e2(16 >= a4), 0 < a4) {
        var o4 = t5.l, s4 = t5.Ta, c6 = t5.Ua, u5 = o4.width;
        if (Nt2(t5, a4, n4, i4), a4 = c6 = [c6], e2((n4 = t5.C) < (i4 = r3)), e2(o4.v < o4.va), i4 > o4.o && (i4 = o4.o), n4 < o4.j) {
          var h5 = o4.j - n4;
          n4 = o4.j;
          a4[0] += h5 * u5;
        }
        if (n4 >= i4 ? n4 = 0 : (a4[0] += 4 * o4.v, o4.ka = n4 - o4.j, o4.U = o4.va - o4.v, o4.T = i4 - n4, n4 = 1), n4) {
          if (c6 = c6[0], 11 > (n4 = t5.ca).S) {
            var l5 = n4.f.RGBA, f5 = (i4 = n4.S, a4 = o4.U, o4 = o4.T, h5 = l5.eb, l5.A), d4 = o4;
            for (l5 = l5.fb + t5.Ma * l5.A; 0 < d4--; ) {
              var p5 = s4, g4 = c6, m6 = a4, v5 = h5, b4 = l5;
              switch (i4) {
                case En:
                  Qr(p5, g4, m6, v5, b4);
                  break;
                case qn:
                  tn(p5, g4, m6, v5, b4);
                  break;
                case Hn:
                  tn(p5, g4, m6, v5, b4), An(v5, b4, 0, m6, 1, 0);
                  break;
                case Dn:
                  nn(p5, g4, m6, v5, b4);
                  break;
                case Rn:
                  et3(p5, g4, m6, v5, b4, 1);
                  break;
                case Wn:
                  et3(p5, g4, m6, v5, b4, 1), An(v5, b4, 0, m6, 1, 0);
                  break;
                case Tn:
                  et3(p5, g4, m6, v5, b4, 0);
                  break;
                case Vn:
                  et3(p5, g4, m6, v5, b4, 0), An(v5, b4, 1, m6, 1, 0);
                  break;
                case Un:
                  en(p5, g4, m6, v5, b4);
                  break;
                case Gn:
                  en(p5, g4, m6, v5, b4), xn(v5, b4, m6, 1, 0);
                  break;
                case zn:
                  rn(p5, g4, m6, v5, b4);
                  break;
                default:
                  e2(0);
              }
              c6 += u5, l5 += f5;
            }
            t5.Ma += o4;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e2(t5.Ma <= n4.height);
        }
      }
      t5.C = r3, e2(t5.C <= t5.i);
    }
    function At2(t5) {
      var e3;
      if (0 < t5.ua)
        return 0;
      for (e3 = 0; e3 < t5.Wb; ++e3) {
        var r3 = t5.Ya[e3].G, n4 = t5.Ya[e3].H;
        if (0 < r3[1][n4[1] + 0].g || 0 < r3[2][n4[2] + 0].g || 0 < r3[3][n4[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function xt2(t5, r3, n4, i4, a4, o4) {
      if (0 != t5.Z) {
        var s4 = t5.qd, c6 = t5.rd;
        for (e2(null != mi[t5.Z]); r3 < n4; ++r3)
          mi[t5.Z](s4, c6, i4, a4, i4, a4, o4), s4 = i4, c6 = a4, a4 += o4;
        t5.qd = s4, t5.rd = c6;
      }
    }
    function St2(t5, r3) {
      var n4 = t5.l.ma, i4 = 0 == n4.Z || 1 == n4.Z ? t5.l.j : t5.C;
      i4 = t5.C < i4 ? i4 : t5.C;
      if (e2(r3 <= t5.l.o), r3 > i4) {
        var a4 = t5.l.width, o4 = n4.ca, s4 = n4.tb + a4 * i4, c6 = t5.V, u5 = t5.Ba + t5.c * i4, h5 = t5.gc;
        e2(1 == t5.ab), e2(3 == h5[0].hc), Xr(h5[0], i4, r3, c6, u5, o4, s4), xt2(n4, i4, r3, o4, s4, a4);
      }
      t5.C = t5.Ma = r3;
    }
    function _t2(t5, r3, n4, i4, a4, o4, s4) {
      var c6 = t5.$ / i4, u5 = t5.$ % i4, h5 = t5.m, l5 = t5.s, f5 = n4 + t5.$, d4 = f5;
      a4 = n4 + i4 * a4;
      var p5 = n4 + i4 * o4, g4 = 280 + l5.ua, m6 = t5.Pb ? c6 : 16777216, v5 = 0 < l5.ua ? l5.Wa : null, b4 = l5.wc, y5 = f5 < p5 ? wt2(l5, u5, c6) : null;
      e2(t5.C < o4), e2(p5 <= a4);
      var w4 = false;
      t:
        for (; ; ) {
          for (; w4 || f5 < p5; ) {
            var N5 = 0;
            if (c6 >= m6) {
              var _4 = f5 - n4;
              e2((m6 = t5).Pb), m6.wd = m6.m, m6.xd = _4, 0 < m6.s.ua && B2(m6.s.Wa, m6.s.vb), m6 = c6 + ti;
            }
            if (u5 & b4 || (y5 = wt2(l5, u5, c6)), e2(null != y5), y5.Qb && (r3[f5] = y5.qb, w4 = true), !w4)
              if (S2(h5), y5.jc) {
                N5 = h5, _4 = r3;
                var P3 = f5, k3 = y5.pd[L3(N5) & Dr - 1];
                e2(y5.jc), 256 > k3.g ? (x2(N5, N5.u + k3.g), _4[P3] = k3.value, N5 = 0) : (x2(N5, N5.u + k3.g - 256), e2(256 <= k3.value), N5 = k3.value), 0 == N5 && (w4 = true);
              } else
                N5 = bt2(y5.G[0], y5.H[0], h5);
            if (h5.h)
              break;
            if (w4 || 256 > N5) {
              if (!w4)
                if (y5.nd)
                  r3[f5] = (y5.qb | N5 << 8) >>> 0;
                else {
                  if (S2(h5), w4 = bt2(y5.G[1], y5.H[1], h5), S2(h5), _4 = bt2(y5.G[2], y5.H[2], h5), P3 = bt2(y5.G[3], y5.H[3], h5), h5.h)
                    break;
                  r3[f5] = (P3 << 24 | w4 << 16 | N5 << 8 | _4) >>> 0;
                }
              if (w4 = false, ++f5, ++u5 >= i4 && (u5 = 0, ++c6, null != s4 && c6 <= o4 && !(c6 % 16) && s4(t5, c6), null != v5))
                for (; d4 < f5; )
                  N5 = r3[d4++], v5.X[(506832829 * N5 & 4294967295) >>> v5.Mb] = N5;
            } else if (280 > N5) {
              if (N5 = mt2(N5 - 256, h5), _4 = bt2(y5.G[4], y5.H[4], h5), S2(h5), _4 = vt2(i4, _4 = mt2(_4, h5)), h5.h)
                break;
              if (f5 - n4 < _4 || a4 - f5 < N5)
                break t;
              for (P3 = 0; P3 < N5; ++P3)
                r3[f5 + P3] = r3[f5 + P3 - _4];
              for (f5 += N5, u5 += N5; u5 >= i4; )
                u5 -= i4, ++c6, null != s4 && c6 <= o4 && !(c6 % 16) && s4(t5, c6);
              if (e2(f5 <= a4), u5 & b4 && (y5 = wt2(l5, u5, c6)), null != v5)
                for (; d4 < f5; )
                  N5 = r3[d4++], v5.X[(506832829 * N5 & 4294967295) >>> v5.Mb] = N5;
            } else {
              if (!(N5 < g4))
                break t;
              for (w4 = N5 - 280, e2(null != v5); d4 < f5; )
                N5 = r3[d4++], v5.X[(506832829 * N5 & 4294967295) >>> v5.Mb] = N5;
              N5 = f5, e2(!(w4 >>> (_4 = v5).Xa)), r3[N5] = _4.X[w4], w4 = true;
            }
            w4 || e2(h5.h == A3(h5));
          }
          if (t5.Pb && h5.h && f5 < a4)
            e2(t5.m.h), t5.a = 5, t5.m = t5.wd, t5.$ = t5.xd, 0 < t5.s.ua && B2(t5.s.vb, t5.s.Wa);
          else {
            if (h5.h)
              break t;
            null != s4 && s4(t5, c6 > o4 ? o4 : c6), t5.a = 0, t5.$ = f5 - n4;
          }
          return 1;
        }
      return t5.a = 3, 0;
    }
    function Pt2(t5) {
      e2(null != t5), t5.vc = null, t5.yc = null, t5.Ya = null;
      var r3 = t5.Wa;
      null != r3 && (r3.X = null), t5.vb = null, e2(null != t5);
    }
    function kt2() {
      var e3 = new or();
      return null == e3 ? null : (e3.a = 0, e3.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t4.VP8LMapColor32b = Jr, t4.VP8LMapColor8b = Kr, e3);
    }
    function It2(t5, r3, n4, s4, c6) {
      var u5 = 1, f5 = [t5], p5 = [r3], g4 = s4.m, m6 = s4.s, v5 = null, b4 = 0;
      t:
        for (; ; ) {
          if (n4)
            for (; u5 && y4(g4, 1); ) {
              var w4 = f5, N5 = p5, A4 = s4, _4 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y4(P3, 2);
              if (A4.Oc & 1 << I3)
                u5 = 0;
              else {
                switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N5[0], k3.K = [null], ++A4.ab, e2(4 >= A4.ab), I3) {
                  case 0:
                  case 1:
                    k3.b = y4(P3, 3) + 2, _4 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                    break;
                  case 3:
                    var F3, C3 = y4(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                    if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _4 = It2(C3, 1, 0, A4, k3.K)) {
                      var B3, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T4 = a3(R3);
                      if (null == T4)
                        F3 = 0;
                      else {
                        var U3 = E3.K[0], z3 = E3.w;
                        for (T4[0] = E3.K[0][0], B3 = 1; B3 < 1 * M3; ++B3)
                          T4[B3] = D2(U3[z3 + B3], T4[B3 - 1]);
                        for (; B3 < 4 * R3; ++B3)
                          T4[B3] = 0;
                        E3.K[0] = null, E3.K[0] = T4, F3 = 1;
                      }
                    }
                    _4 = F3;
                    break;
                  case 2:
                    break;
                  default:
                    e2(0);
                }
                u5 = _4;
              }
            }
          if (f5 = f5[0], p5 = p5[0], u5 && y4(g4, 1) && !(u5 = 1 <= (b4 = y4(g4, 4)) && 11 >= b4)) {
            s4.a = 3;
            break t;
          }
          var H3;
          if (H3 = u5)
            e: {
              var W3, V3, G3, Y3 = s4, J3 = f5, X3 = p5, K3 = b4, Z3 = n4, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et4 = 1, rt3 = 0, nt3 = Qn[K3];
              r:
                for (; ; ) {
                  if (Z3 && y4($3, 1)) {
                    var it3 = y4($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                    if (!It2(at3, ot3, 0, Y3, tt3))
                      break r;
                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                      var ct3 = tt3[W3] >> 8 & 65535;
                      tt3[W3] = ct3, ct3 >= et4 && (et4 = ct3 + 1);
                    }
                  }
                  if ($3.h)
                    break r;
                  for (V3 = 0; 5 > V3; ++V3) {
                    var ut3 = Xn[V3];
                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                  }
                  var ht3 = o3(et4 * nt3, l4), lt3 = et4, ft3 = o3(lt3, d3);
                  if (null == ft3)
                    var dt3 = null;
                  else
                    e2(65536 >= lt3), dt3 = ft3;
                  var pt3 = a3(rt3);
                  if (null == dt3 || null == pt3 || null == ht3) {
                    Y3.a = 1;
                    break r;
                  }
                  var gt3 = ht3;
                  for (W3 = G3 = 0; W3 < et4; ++W3) {
                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                    for (V3 = 0; 5 > V3; ++V3) {
                      ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                      n: {
                        var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y4(Ot3, 1);
                        if (i3(kt3, 0, 0, xt3), Bt3) {
                          var Mt3 = y4(Ot3, 1) + 1, Et3 = y4(Ot3, 1), qt3 = y4(Ot3, 0 == Et3 ? 1 : 8);
                          kt3[qt3] = 1, 2 == Mt3 && (kt3[qt3 = y4(Ot3, 8)] = 1);
                          var Dt3 = 1;
                        } else {
                          var Rt3 = a3(19), Tt3 = y4(Ot3, 4) + 4;
                          if (19 < Tt3) {
                            St3.a = 3;
                            var Ut3 = 0;
                            break n;
                          }
                          for (At3 = 0; At3 < Tt3; ++At3)
                            Rt3[Zn[At3]] = y4(Ot3, 3);
                          var zt3 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o3(128, l4);
                          i:
                            for (; h4(Zt3, 0, 7, Vt3, 19); ) {
                              if (y4(Xt3, 1)) {
                                var $t3 = 2 + 2 * y4(Xt3, 3);
                                if ((zt3 = 2 + y4(Xt3, $t3)) > Gt3)
                                  break i;
                              } else
                                zt3 = Gt3;
                              for (Ht3 = 0; Ht3 < Gt3 && zt3--; ) {
                                S2(Xt3);
                                var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                                x2(Xt3, Xt3.u + Qt3.g);
                                var te3 = Qt3.value;
                                if (16 > te3)
                                  Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                                else {
                                  var ee3 = 16 == te3, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y4(Xt3, Yn[re3]) + ne3;
                                  if (Ht3 + ie3 > Gt3)
                                    break i;
                                  for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )
                                    Yt3[Ht3++] = ae3;
                                }
                              }
                              Jt3 = 1;
                              break i;
                            }
                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                        }
                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h4(Ft3, Ct3, 8, kt3, xt3)), Dt3 && 0 != jt3 ? Ut3 = jt3 : (St3.a = 3, Ut3 = 0);
                      }
                      if (0 == Ut3)
                        break r;
                      if (Nt3 && 1 == Kn[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                        var oe3, se3 = pt3[0];
                        for (oe3 = 1; oe3 < ut3; ++oe3)
                          pt3[oe3] > se3 && (se3 = pt3[oe3]);
                        Lt3 += se3;
                      }
                    }
                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                      var ce3, ue3 = mt3;
                      for (ce3 = 0; ce3 < Dr; ++ce3) {
                        var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                        256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                      }
                    }
                  }
                  Q3.vc = tt3, Q3.Wb = et4, Q3.Ya = dt3, Q3.yc = ht3, H3 = 1;
                  break e;
                }
              H3 = 0;
            }
          if (!(u5 = H3)) {
            s4.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m6.ua = 1 << b4, !O3(m6.Wa, b4)) {
              s4.a = 1, u5 = 0;
              break t;
            }
          } else
            m6.ua = 0;
          var de3 = s4, pe3 = f5, ge3 = p5, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n4) {
            s4.xb = pi;
            break t;
          }
          if (null == (v5 = a3(f5 * p5))) {
            s4.a = 1, u5 = 0;
            break t;
          }
          u5 = (u5 = _t2(s4, v5, 0, f5, p5, p5, null)) && !g4.h;
          break t;
        }
      return u5 ? (null != c6 ? c6[0] = v5 : (e2(null == v5), e2(n4)), s4.$ = 0, n4 || Pt2(m6)) : Pt2(m6), u5;
    }
    function Ft2(t5, r3) {
      var n4 = t5.c * t5.i, i4 = n4 + r3 + 16 * r3;
      return e2(t5.c <= r3), t5.V = a3(i4), null == t5.V ? (t5.Ta = null, t5.Ua = 0, t5.a = 1, 0) : (t5.Ta = t5.V, t5.Ua = t5.Ba + n4 + r3, 1);
    }
    function Ct2(t5, r3) {
      var n4 = t5.C, i4 = r3 - n4, a4 = t5.V, o4 = t5.Ba + t5.c * n4;
      for (e2(r3 <= t5.l.o); 0 < i4; ) {
        var s4 = 16 < i4 ? 16 : i4, c6 = t5.l.ma, u5 = t5.l.width, h5 = u5 * s4, l5 = c6.ca, f5 = c6.tb + u5 * n4, d4 = t5.Ta, p5 = t5.Ua;
        Nt2(t5, s4, a4, o4), _n(d4, p5, l5, f5, h5), xt2(c6, n4, n4 + s4, l5, f5, u5), i4 -= s4, a4 += s4 * t5.c, n4 += s4;
      }
      e2(n4 == r3), t5.C = t5.Ma = r3;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a3(4), this.Lb = a3(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t5 = [];
        return function t6(e3, r3, n4) {
          for (var i4 = n4[r3], a4 = 0; a4 < i4 && (e3.push(n4.length > r3 + 1 ? [] : 0), !(n4.length < r3 + 1)); a4++)
            t6(e3[a4], r3 + 1, n4);
        }(t5, 0, [3, 11]), t5;
      }();
    }
    function Et2() {
      this.jb = a3(3), this.Wc = s3([4, 8], Mt2), this.Xc = s3([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a3(4), this.od = new a3(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ut2() {
      this.ad = a3(384), this.Za = 0, this.Ob = a3(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function zt2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new Ut2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a3(16), this.f = a3(8), this.ea = a3(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new zt2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o3(8, w3), this.ia = 0, this.pb = o3(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2()), this.L = this.aa = 0, this.gd = s3([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t5 = new Wt2();
      return null != t5 && (t5.a = 0, t5.sc = "OK", t5.cb = 0, t5.Xb = 0, ni || (ni = Zt2)), t5;
    }
    function Jt2(t5, e3, r3) {
      return 0 == t5.a && (t5.a = e3, t5.sc = r3, t5.cb = 0), 0;
    }
    function Xt2(t5, e3, r3) {
      return 3 <= r3 && 157 == t5[e3 + 0] && 1 == t5[e3 + 1] && 42 == t5[e3 + 2];
    }
    function Kt2(t5, r3) {
      if (null == t5)
        return 0;
      if (t5.a = 0, t5.sc = "OK", null == r3)
        return Jt2(t5, 2, "null VP8Io passed to VP8GetHeaders()");
      var n4 = r3.data, a4 = r3.w, o4 = r3.ha;
      if (4 > o4)
        return Jt2(t5, 7, "Truncated header.");
      var s4 = n4[a4 + 0] | n4[a4 + 1] << 8 | n4[a4 + 2] << 16, c6 = t5.Od;
      if (c6.Rb = !(1 & s4), c6.td = s4 >> 1 & 7, c6.yd = s4 >> 4 & 1, c6.ub = s4 >> 5, 3 < c6.td)
        return Jt2(t5, 3, "Incorrect keyframe parameters.");
      if (!c6.yd)
        return Jt2(t5, 4, "Frame not displayable.");
      a4 += 3, o4 -= 3;
      var u5 = t5.Kc;
      if (c6.Rb) {
        if (7 > o4)
          return Jt2(t5, 7, "cannot parse picture header");
        if (!Xt2(n4, a4, o4))
          return Jt2(t5, 3, "Bad code word");
        u5.c = 16383 & (n4[a4 + 4] << 8 | n4[a4 + 3]), u5.Td = n4[a4 + 4] >> 6, u5.i = 16383 & (n4[a4 + 6] << 8 | n4[a4 + 5]), u5.Ud = n4[a4 + 6] >> 6, a4 += 7, o4 -= 7, t5.za = u5.c + 15 >> 4, t5.Ub = u5.i + 15 >> 4, r3.width = u5.c, r3.height = u5.i, r3.Da = 0, r3.j = 0, r3.v = 0, r3.va = r3.width, r3.o = r3.height, r3.da = 0, r3.ib = r3.width, r3.hb = r3.height, r3.U = r3.width, r3.T = r3.height, i3((s4 = t5.Pa).jb, 0, 255, s4.jb.length), e2(null != (s4 = t5.Qa)), s4.Cb = 0, s4.Bb = 0, s4.Fb = 1, i3(s4.Zb, 0, 0, s4.Zb.length), i3(s4.Lb, 0, 0, s4.Lb);
      }
      if (c6.ub > o4)
        return Jt2(t5, 7, "bad partition length");
      p4(s4 = t5.m, n4, a4, c6.ub), a4 += c6.ub, o4 -= c6.ub, c6.Rb && (u5.Ld = P2(s4), u5.Kd = P2(s4)), u5 = t5.Qa;
      var h5, l5 = t5.Pa;
      if (e2(null != s4), e2(null != u5), u5.Cb = P2(s4), u5.Cb) {
        if (u5.Bb = P2(s4), P2(s4)) {
          for (u5.Fb = P2(s4), h5 = 0; 4 > h5; ++h5)
            u5.Zb[h5] = P2(s4) ? m5(s4, 7) : 0;
          for (h5 = 0; 4 > h5; ++h5)
            u5.Lb[h5] = P2(s4) ? m5(s4, 6) : 0;
        }
        if (u5.Bb)
          for (h5 = 0; 3 > h5; ++h5)
            l5.jb[h5] = P2(s4) ? g3(s4, 8) : 255;
      } else
        u5.Bb = 0;
      if (s4.Ka)
        return Jt2(t5, 3, "cannot parse segment header");
      if ((u5 = t5.ed).zd = P2(s4), u5.Tb = g3(s4, 6), u5.wb = g3(s4, 3), u5.Pc = P2(s4), u5.Pc && P2(s4)) {
        for (l5 = 0; 4 > l5; ++l5)
          P2(s4) && (u5.vd[l5] = m5(s4, 6));
        for (l5 = 0; 4 > l5; ++l5)
          P2(s4) && (u5.od[l5] = m5(s4, 6));
      }
      if (t5.L = 0 == u5.Tb ? 0 : u5.zd ? 1 : 2, s4.Ka)
        return Jt2(t5, 3, "cannot parse filter header");
      var f5 = o4;
      if (o4 = h5 = a4, a4 = h5 + f5, u5 = f5, t5.Xb = (1 << g3(t5.m, 2)) - 1, f5 < 3 * (l5 = t5.Xb))
        n4 = 7;
      else {
        for (h5 += 3 * l5, u5 -= 3 * l5, f5 = 0; f5 < l5; ++f5) {
          var d4 = n4[o4 + 0] | n4[o4 + 1] << 8 | n4[o4 + 2] << 16;
          d4 > u5 && (d4 = u5), p4(t5.Jc[+f5], n4, h5, d4), h5 += d4, u5 -= d4, o4 += 3;
        }
        p4(t5.Jc[+l5], n4, h5, u5), n4 = h5 < a4 ? 0 : 5;
      }
      if (0 != n4)
        return Jt2(t5, n4, "cannot parse partitions");
      for (n4 = g3(h5 = t5.m, 7), o4 = P2(h5) ? m5(h5, 4) : 0, a4 = P2(h5) ? m5(h5, 4) : 0, u5 = P2(h5) ? m5(h5, 4) : 0, l5 = P2(h5) ? m5(h5, 4) : 0, h5 = P2(h5) ? m5(h5, 4) : 0, f5 = t5.Qa, d4 = 0; 4 > d4; ++d4) {
        if (f5.Cb) {
          var v5 = f5.Zb[d4];
          f5.Fb || (v5 += n4);
        } else {
          if (0 < d4) {
            t5.pb[d4] = t5.pb[0];
            continue;
          }
          v5 = n4;
        }
        var b4 = t5.pb[d4];
        b4.Sc[0] = ei[Vt2(v5 + o4, 127)], b4.Sc[1] = ri[Vt2(v5 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v5 + a4, 127)], b4.Eb[1] = 101581 * ri[Vt2(v5 + u5, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v5 + l5, 117)], b4.Qc[1] = ri[Vt2(v5 + h5, 127)], b4.lc = v5 + h5;
      }
      if (!c6.Rb)
        return Jt2(t5, 4, "Not a key frame.");
      for (P2(s4), c6 = t5.Pa, n4 = 0; 4 > n4; ++n4) {
        for (o4 = 0; 8 > o4; ++o4)
          for (a4 = 0; 3 > a4; ++a4)
            for (u5 = 0; 11 > u5; ++u5)
              l5 = k2(s4, ui[n4][o4][a4][u5]) ? g3(s4, 8) : si[n4][o4][a4][u5], c6.Wc[n4][o4].Yb[a4][u5] = l5;
        for (o4 = 0; 17 > o4; ++o4)
          c6.Xc[n4][o4] = c6.Wc[n4][hi[o4]];
      }
      return t5.kc = P2(s4), t5.kc && (t5.Bd = g3(s4, 8)), t5.cb = 1;
    }
    function Zt2(t5, e3, r3, n4, i4, a4, o4) {
      var s4 = e3[i4].Yb[r3];
      for (r3 = 0; 16 > i4; ++i4) {
        if (!k2(t5, s4[r3 + 0]))
          return i4;
        for (; !k2(t5, s4[r3 + 1]); )
          if (s4 = e3[++i4].Yb[0], r3 = 0, 16 == i4)
            return 16;
        var c6 = e3[i4 + 1].Yb;
        if (k2(t5, s4[r3 + 2])) {
          var u5 = t5, h5 = 0;
          if (k2(u5, (f5 = s4)[(l5 = r3) + 3]))
            if (k2(u5, f5[l5 + 6])) {
              for (s4 = 0, l5 = 2 * (h5 = k2(u5, f5[l5 + 8])) + (f5 = k2(u5, f5[l5 + 9 + h5])), h5 = 0, f5 = ii[l5]; f5[s4]; ++s4)
                h5 += h5 + k2(u5, f5[s4]);
              h5 += 3 + (8 << l5);
            } else
              k2(u5, f5[l5 + 7]) ? (h5 = 7 + 2 * k2(u5, 165), h5 += k2(u5, 145)) : h5 = 5 + k2(u5, 159);
          else
            h5 = k2(u5, f5[l5 + 4]) ? 3 + k2(u5, f5[l5 + 5]) : 2;
          s4 = c6[2];
        } else
          h5 = 1, s4 = c6[1];
        c6 = o4 + ai[i4], 0 > (u5 = t5).b && _3(u5);
        var l5, f5 = u5.b, d4 = (l5 = u5.Ca >> 1) - (u5.I >> f5) >> 31;
        --u5.b, u5.Ca += d4, u5.Ca |= 1, u5.I -= (l5 + 1 & d4) << f5, a4[c6] = ((h5 ^ d4) - d4) * n4[(0 < i4) + 0];
      }
      return 16;
    }
    function $t2(t5) {
      var e3 = t5.rb[t5.sb - 1];
      e3.la = 0, e3.Na = 0, i3(t5.zc, 0, 0, t5.zc.length), t5.ja = 0;
    }
    function Qt2(t5, r3) {
      if (null == t5)
        return 0;
      if (null == r3)
        return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t5.cb && !Kt2(t5, r3))
        return 0;
      if (e2(t5.cb), null == r3.ac || r3.ac(r3)) {
        r3.ob && (t5.L = 0);
        var s4 = Ri[t5.L];
        if (2 == t5.L ? (t5.yb = 0, t5.zb = 0) : (t5.yb = r3.v - s4 >> 4, t5.zb = r3.j - s4 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = r3.o + 15 + s4 >> 4, t5.Hb = r3.va + 15 + s4 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
          var c6 = t5.ed;
          for (s4 = 0; 4 > s4; ++s4) {
            var u5;
            if (t5.Qa.Cb) {
              var h5 = t5.Qa.Lb[s4];
              t5.Qa.Fb || (h5 += c6.Tb);
            } else
              h5 = c6.Tb;
            for (u5 = 0; 1 >= u5; ++u5) {
              var l5 = t5.gd[s4][u5], f5 = h5;
              if (c6.Pc && (f5 += c6.vd[0], u5 && (f5 += c6.od[0])), 0 < (f5 = 0 > f5 ? 0 : 63 < f5 ? 63 : f5)) {
                var d4 = f5;
                0 < c6.wb && ((d4 = 4 < c6.wb ? d4 >> 2 : d4 >> 1) > 9 - c6.wb && (d4 = 9 - c6.wb)), 1 > d4 && (d4 = 1), l5.dd = d4, l5.tc = 2 * f5 + d4, l5.ld = 40 <= f5 ? 2 : 15 <= f5 ? 1 : 0;
              } else
                l5.tc = 0;
              l5.La = u5;
            }
          }
        }
        s4 = 0;
      } else
        Jt2(t5, 6, "Frame setup failed"), s4 = t5.a;
      if (s4 = 0 == s4) {
        if (s4) {
          t5.$c = 0, 0 < t5.Aa || (t5.Ic = Ui);
          t: {
            s4 = t5.Ic;
            c6 = 4 * (d4 = t5.za);
            var p5 = 32 * d4, g4 = d4 + 1, m6 = 0 < t5.L ? d4 * (0 < t5.Aa ? 2 : 1) : 0, v5 = (2 == t5.Aa ? 2 : 1) * d4;
            if ((l5 = c6 + 832 + (u5 = 3 * (16 * s4 + Ri[t5.L]) / 2 * p5) + (h5 = null != t5.Fa && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != l5)
              s4 = 0;
            else {
              if (l5 > t5.Vb) {
                if (t5.Vb = 0, t5.Ec = a3(l5), t5.Fc = 0, null == t5.Ec) {
                  s4 = Jt2(t5, 1, "no memory during frame initialization.");
                  break t;
                }
                t5.Vb = l5;
              }
              l5 = t5.Ec, f5 = t5.Fc, t5.Ac = l5, t5.Bc = f5, f5 += c6, t5.Gd = o3(p5, Ht2), t5.Hd = 0, t5.rb = o3(g4 + 1, Rt2), t5.sb = 1, t5.wa = m6 ? o3(m6, Dt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d4), e2(true), t5.oc = l5, t5.pc = f5, f5 += 832, t5.ya = o3(v5, Ut2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, 2 == t5.Aa && (t5.D.aa += d4), t5.R = 16 * d4, t5.B = 8 * d4, d4 = (p5 = Ri[t5.L]) * t5.R, p5 = p5 / 2 * t5.B, t5.sa = l5, t5.ta = f5 + d4, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s4 * t5.R + p5, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s4 * t5.B + p5, t5.$c = 0, f5 += u5, t5.mb = h5 ? l5 : null, t5.nb = h5 ? f5 : null, e2(f5 + h5 <= t5.Fc + t5.Vb), $t2(t5), i3(t5.Ac, t5.Bc, 0, c6), s4 = 1;
            }
          }
          if (s4) {
            if (r3.ka = 0, r3.y = t5.sa, r3.O = t5.ta, r3.f = t5.qa, r3.N = t5.ra, r3.ea = t5.Ha, r3.Vd = t5.Ia, r3.fa = t5.R, r3.Rc = t5.B, r3.F = null, r3.J = 0, !Cn) {
              for (s4 = -255; 255 >= s4; ++s4)
                Pn[255 + s4] = 0 > s4 ? -s4 : s4;
              for (s4 = -1020; 1020 >= s4; ++s4)
                kn[1020 + s4] = -128 > s4 ? -128 : 127 < s4 ? 127 : s4;
              for (s4 = -112; 112 >= s4; ++s4)
                In[112 + s4] = -16 > s4 ? -16 : 15 < s4 ? 15 : s4;
              for (s4 = -255; 510 >= s4; ++s4)
                Fn[255 + s4] = 0 > s4 ? 0 : 255 < s4 ? 255 : s4;
              Cn = 1;
            }
            an = ue2, on = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li2[0] = ve2, li2[1] = de2, li2[2] = pe2, li2[3] = ge2, li2[4] = be2, li2[5] = ye2, li2[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s4 = 1;
          } else
            s4 = 0;
        }
        s4 && (s4 = function(t6, r4) {
          for (t6.M = 0; t6.M < t6.Va; ++t6.M) {
            var o4, s5 = t6.Jc[t6.M & t6.Xb], c7 = t6.m, u6 = t6;
            for (o4 = 0; o4 < u6.za; ++o4) {
              var h6 = c7, l6 = u6, f6 = l6.Ac, d5 = l6.Bc + 4 * o4, p6 = l6.zc, g5 = l6.ya[l6.aa + o4];
              if (l6.Qa.Bb ? g5.$b = k2(h6, l6.Pa.jb[0]) ? 2 + k2(h6, l6.Pa.jb[2]) : k2(h6, l6.Pa.jb[1]) : g5.$b = 0, l6.kc && (g5.Ad = k2(h6, l6.Bd)), g5.Za = !k2(h6, 145) + 0, g5.Za) {
                var m7 = g5.Ob, v6 = 0;
                for (l6 = 0; 4 > l6; ++l6) {
                  var b4, y5 = p6[0 + l6];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y5 = ci[f6[d5 + b4]][y5];
                    for (var w4 = oi[k2(h6, y5[0])]; 0 < w4; )
                      w4 = oi[2 * w4 + k2(h6, y5[w4])];
                    y5 = -w4, f6[d5 + b4] = y5;
                  }
                  n3(m7, v6, f6, d5, 4), v6 += 4, p6[0 + l6] = y5;
                }
              } else
                y5 = k2(h6, 156) ? k2(h6, 128) ? 1 : 3 : k2(h6, 163) ? 2 : 0, g5.Ob[0] = y5, i3(f6, d5, y5, 4), i3(p6, 0, y5, 4);
              g5.Dd = k2(h6, 142) ? k2(h6, 114) ? k2(h6, 183) ? 1 : 3 : 2 : 0;
            }
            if (u6.m.Ka)
              return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
            for (; t6.ja < t6.za; ++t6.ja) {
              if (u6 = s5, h6 = (c7 = t6).rb[c7.sb - 1], f6 = c7.rb[c7.sb + c7.ja], o4 = c7.ya[c7.aa + c7.ja], d5 = c7.kc ? o4.Ad : 0)
                h6.la = f6.la = 0, o4.Za || (h6.Na = f6.Na = 0), o4.Hc = 0, o4.Gc = 0, o4.ia = 0;
              else {
                var N5, L4;
                h6 = f6, f6 = u6, d5 = c7.Pa.Xc, p6 = c7.ya[c7.aa + c7.ja], g5 = c7.pb[p6.$b];
                if (l6 = p6.ad, m7 = 0, v6 = c7.rb[c7.sb - 1], y5 = b4 = 0, i3(l6, m7, 0, 384), p6.Za)
                  var A4 = 0, x3 = d5[3];
                else {
                  w4 = a3(16);
                  var S3 = h6.Na + v6.Na;
                  if (S3 = ni(f6, d5[1], S3, g5.Eb, 0, w4, 0), h6.Na = v6.Na = (0 < S3) + 0, 1 < S3)
                    an(w4, 0, l6, m7);
                  else {
                    var _4 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16)
                      l6[m7 + w4] = _4;
                  }
                  A4 = 1, x3 = d5[0];
                }
                var P3 = 15 & h6.la, I3 = 15 & v6.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_4 = L4 = 0; 4 > _4; ++_4)
                    P3 = P3 >> 1 | (F3 = (S3 = ni(f6, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l6, m7)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l6[m7 + 0]), m7 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N5 = 0; 4 > N5; N5 += 2) {
                  for (L4 = 0, P3 = h6.la >> 4 + N5, I3 = v6.la >> 4 + N5, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _4 = 0; 2 > _4; ++_4)
                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f6, d5[2], S3, g5.Qc, 0, l6, m7))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l6[m7 + 0]), m7 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y5 |= L4 << 4 * N5, x3 |= P3 << 4 << N5, A4 |= (240 & I3) << N5;
                }
                h6.la = x3, v6.la = A4, p6.Hc = b4, p6.Gc = y5, p6.ia = 43690 & y5 ? 0 : g5.ia, d5 = !(b4 | y5);
              }
              if (0 < c7.L && (c7.wa[c7.Y + c7.ja] = c7.gd[o4.$b][o4.Za], c7.wa[c7.Y + c7.ja].La |= !d5), u6.Ka)
                return Jt2(t6, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t6), c7 = r4, u6 = 1, o4 = (s5 = t6).D, h6 = 0 < s5.L && s5.M >= s5.zb && s5.M <= s5.Va, 0 == s5.Aa)
              t: {
                if (o4.M = s5.M, o4.uc = h6, Or(s5, o4), u6 = 1, o4 = (L4 = s5.D).Nb, h6 = (y5 = Ri[s5.L]) * s5.R, f6 = y5 / 2 * s5.B, w4 = 16 * o4 * s5.R, _4 = 8 * o4 * s5.B, d5 = s5.sa, p6 = s5.ta - h6 + w4, g5 = s5.qa, l6 = s5.ra - f6 + _4, m7 = s5.Ha, v6 = s5.Ia - f6 + _4, I3 = 0 == (P3 = L4.M), b4 = P3 >= s5.Va - 1, 2 == s5.Aa && Or(s5, L4), L4.uc)
                  for (F3 = (S3 = s5).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                    A4 = L4, x3 = F3;
                    var C3 = (j3 = (U3 = S3).D).Nb;
                    N5 = U3.R;
                    var j3 = j3.wa[j3.Y + A4], O4 = U3.sa, B3 = U3.ta + 16 * C3 * N5 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                    if (0 != E3)
                      if (e2(3 <= E3), 1 == U3.L)
                        0 < A4 && wn(O4, B3, N5, E3 + 4), j3.La && Ln(O4, B3, N5, E3), 0 < x3 && yn(O4, B3, N5, E3 + 4), j3.La && Nn(O4, B3, N5, E3);
                      else {
                        var q3 = U3.B, D3 = U3.qa, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T4 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                        C3 = j3.ld;
                        0 < A4 && (fn(O4, B3, N5, E3 + 4, M3, C3), pn(D3, R3, T4, U3, q3, E3 + 4, M3, C3)), j3.La && (mn(O4, B3, N5, E3, M3, C3), bn(D3, R3, T4, U3, q3, E3, M3, C3)), 0 < x3 && (ln2(O4, B3, N5, E3 + 4, M3, C3), dn(D3, R3, T4, U3, q3, E3 + 4, M3, C3)), j3.La && (gn(O4, B3, N5, E3, M3, C3), vn(D3, R3, T4, U3, q3, E3, M3, C3));
                      }
                  }
                if (s5.ia && alert("todo:DitherRow"), null != c7.put) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c7.y = s5.sa, c7.O = s5.ta + w4, c7.f = s5.qa, c7.N = s5.ra + _4, c7.ea = s5.Ha, c7.W = s5.Ia + _4) : (L4 -= y5, c7.y = d5, c7.O = p6, c7.f = g5, c7.N = l6, c7.ea = m7, c7.W = v6), b4 || (P3 -= y5), P3 > c7.o && (P3 = c7.o), c7.F = null, c7.J = null, null != s5.Fa && 0 < s5.Fa.length && L4 < P3 && (c7.J = lr(s5, c7, L4, P3 - L4), c7.F = s5.mb, null == c7.F && 0 == c7.F.length)) {
                    u6 = Jt2(s5, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c7.j && (y5 = c7.j - L4, L4 = c7.j, e2(!(1 & y5)), c7.O += s5.R * y5, c7.N += s5.B * (y5 >> 1), c7.W += s5.B * (y5 >> 1), null != c7.F && (c7.J += c7.width * y5)), L4 < P3 && (c7.O += c7.v, c7.N += c7.v >> 1, c7.W += c7.v >> 1, null != c7.F && (c7.J += c7.v), c7.ka = L4 - c7.j, c7.U = c7.va - c7.v, c7.T = P3 - L4, u6 = c7.put(c7));
                }
                o4 + 1 != s5.Ic || b4 || (n3(s5.sa, s5.ta - h6, d5, p6 + 16 * s5.R, h6), n3(s5.qa, s5.ra - f6, g5, l6 + 8 * s5.B, f6), n3(s5.Ha, s5.Ia - f6, m7, v6 + 8 * s5.B, f6));
              }
            if (!u6)
              return Jt2(t6, 6, "Output aborted.");
          }
          return 1;
        }(t5, r3)), null != r3.bc && r3.bc(r3), s4 &= 1;
      }
      return s4 ? (t5.cb = 0, s4) : 0;
    }
    function te2(t5, e3, r3, n4, i4) {
      i4 = t5[e3 + r3 + 32 * n4] + (i4 >> 3), t5[e3 + r3 + 32 * n4] = -256 & i4 ? 0 > i4 ? 0 : 255 : i4;
    }
    function ee2(t5, e3, r3, n4, i4, a4) {
      te2(t5, e3, 0, r3, n4 + i4), te2(t5, e3, 1, r3, n4 + a4), te2(t5, e3, 2, r3, n4 - a4), te2(t5, e3, 3, r3, n4 - i4);
    }
    function re2(t5) {
      return (20091 * t5 >> 16) + t5;
    }
    function ne2(t5, e3, r3, n4) {
      var i4, o4 = 0, s4 = a3(16);
      for (i4 = 0; 4 > i4; ++i4) {
        var c6 = t5[e3 + 0] + t5[e3 + 8], u5 = t5[e3 + 0] - t5[e3 + 8], h5 = (35468 * t5[e3 + 4] >> 16) - re2(t5[e3 + 12]), l5 = re2(t5[e3 + 4]) + (35468 * t5[e3 + 12] >> 16);
        s4[o4 + 0] = c6 + l5, s4[o4 + 1] = u5 + h5, s4[o4 + 2] = u5 - h5, s4[o4 + 3] = c6 - l5, o4 += 4, e3++;
      }
      for (i4 = o4 = 0; 4 > i4; ++i4)
        c6 = (t5 = s4[o4 + 0] + 4) + s4[o4 + 8], u5 = t5 - s4[o4 + 8], h5 = (35468 * s4[o4 + 4] >> 16) - re2(s4[o4 + 12]), te2(r3, n4, 0, 0, c6 + (l5 = re2(s4[o4 + 4]) + (35468 * s4[o4 + 12] >> 16))), te2(r3, n4, 1, 0, u5 + h5), te2(r3, n4, 2, 0, u5 - h5), te2(r3, n4, 3, 0, c6 - l5), o4++, n4 += 32;
    }
    function ie2(t5, e3, r3, n4) {
      var i4 = t5[e3 + 0] + 4, a4 = 35468 * t5[e3 + 4] >> 16, o4 = re2(t5[e3 + 4]), s4 = 35468 * t5[e3 + 1] >> 16;
      ee2(r3, n4, 0, i4 + o4, t5 = re2(t5[e3 + 1]), s4), ee2(r3, n4, 1, i4 + a4, t5, s4), ee2(r3, n4, 2, i4 - a4, t5, s4), ee2(r3, n4, 3, i4 - o4, t5, s4);
    }
    function ae2(t5, e3, r3, n4, i4) {
      ne2(t5, e3, r3, n4), i4 && ne2(t5, e3 + 16, r3, n4 + 4);
    }
    function oe2(t5, e3, r3, n4) {
      on(t5, e3 + 0, r3, n4, 1), on(t5, e3 + 32, r3, n4 + 128, 1);
    }
    function se2(t5, e3, r3, n4) {
      var i4;
      for (t5 = t5[e3 + 0] + 4, i4 = 0; 4 > i4; ++i4)
        for (e3 = 0; 4 > e3; ++e3)
          te2(r3, n4, e3, i4, t5);
    }
    function ce2(t5, e3, r3, n4) {
      t5[e3 + 0] && un(t5, e3 + 0, r3, n4), t5[e3 + 16] && un(t5, e3 + 16, r3, n4 + 4), t5[e3 + 32] && un(t5, e3 + 32, r3, n4 + 128), t5[e3 + 48] && un(t5, e3 + 48, r3, n4 + 128 + 4);
    }
    function ue2(t5, e3, r3, n4) {
      var i4, o4 = a3(16);
      for (i4 = 0; 4 > i4; ++i4) {
        var s4 = t5[e3 + 0 + i4] + t5[e3 + 12 + i4], c6 = t5[e3 + 4 + i4] + t5[e3 + 8 + i4], u5 = t5[e3 + 4 + i4] - t5[e3 + 8 + i4], h5 = t5[e3 + 0 + i4] - t5[e3 + 12 + i4];
        o4[0 + i4] = s4 + c6, o4[8 + i4] = s4 - c6, o4[4 + i4] = h5 + u5, o4[12 + i4] = h5 - u5;
      }
      for (i4 = 0; 4 > i4; ++i4)
        s4 = (t5 = o4[0 + 4 * i4] + 3) + o4[3 + 4 * i4], c6 = o4[1 + 4 * i4] + o4[2 + 4 * i4], u5 = o4[1 + 4 * i4] - o4[2 + 4 * i4], h5 = t5 - o4[3 + 4 * i4], r3[n4 + 0] = s4 + c6 >> 3, r3[n4 + 16] = h5 + u5 >> 3, r3[n4 + 32] = s4 - c6 >> 3, r3[n4 + 48] = h5 - u5 >> 3, n4 += 64;
    }
    function he2(t5, e3, r3) {
      var n4, i4 = e3 - 32, a4 = Bn, o4 = 255 - t5[i4 - 1];
      for (n4 = 0; n4 < r3; ++n4) {
        var s4, c6 = a4, u5 = o4 + t5[e3 - 1];
        for (s4 = 0; s4 < r3; ++s4)
          t5[e3 + s4] = c6[u5 + t5[i4 + s4]];
        e3 += 32;
      }
    }
    function le2(t5, e3) {
      he2(t5, e3, 4);
    }
    function fe2(t5, e3) {
      he2(t5, e3, 8);
    }
    function de2(t5, e3) {
      he2(t5, e3, 16);
    }
    function pe2(t5, e3) {
      var r3;
      for (r3 = 0; 16 > r3; ++r3)
        n3(t5, e3 + 32 * r3, t5, e3 - 32, 16);
    }
    function ge2(t5, e3) {
      var r3;
      for (r3 = 16; 0 < r3; --r3)
        i3(t5, e3, t5[e3 - 1], 16), e3 += 32;
    }
    function me2(t5, e3, r3) {
      var n4;
      for (n4 = 0; 16 > n4; ++n4)
        i3(e3, r3 + 32 * n4, t5, 16);
    }
    function ve2(t5, e3) {
      var r3, n4 = 16;
      for (r3 = 0; 16 > r3; ++r3)
        n4 += t5[e3 - 1 + 32 * r3] + t5[e3 + r3 - 32];
      me2(n4 >> 5, t5, e3);
    }
    function be2(t5, e3) {
      var r3, n4 = 8;
      for (r3 = 0; 16 > r3; ++r3)
        n4 += t5[e3 - 1 + 32 * r3];
      me2(n4 >> 4, t5, e3);
    }
    function ye2(t5, e3) {
      var r3, n4 = 8;
      for (r3 = 0; 16 > r3; ++r3)
        n4 += t5[e3 + r3 - 32];
      me2(n4 >> 4, t5, e3);
    }
    function we2(t5, e3) {
      me2(128, t5, e3);
    }
    function Ne2(t5, e3, r3) {
      return t5 + 2 * e3 + r3 + 2 >> 2;
    }
    function Le2(t5, e3) {
      var r3, i4 = e3 - 32;
      i4 = new Uint8Array([Ne2(t5[i4 - 1], t5[i4 + 0], t5[i4 + 1]), Ne2(t5[i4 + 0], t5[i4 + 1], t5[i4 + 2]), Ne2(t5[i4 + 1], t5[i4 + 2], t5[i4 + 3]), Ne2(t5[i4 + 2], t5[i4 + 3], t5[i4 + 4])]);
      for (r3 = 0; 4 > r3; ++r3)
        n3(t5, e3 + 32 * r3, i4, 0, i4.length);
    }
    function Ae(t5, e3) {
      var r3 = t5[e3 - 1], n4 = t5[e3 - 1 + 32], i4 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 + 96];
      I2(t5, e3 + 0, 16843009 * Ne2(t5[e3 - 1 - 32], r3, n4)), I2(t5, e3 + 32, 16843009 * Ne2(r3, n4, i4)), I2(t5, e3 + 64, 16843009 * Ne2(n4, i4, a4)), I2(t5, e3 + 96, 16843009 * Ne2(i4, a4, a4));
    }
    function xe(t5, e3) {
      var r3, n4 = 4;
      for (r3 = 0; 4 > r3; ++r3)
        n4 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      for (n4 >>= 3, r3 = 0; 4 > r3; ++r3)
        i3(t5, e3 + 32 * r3, n4, 4);
    }
    function Se(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n4 = t5[e3 - 1 + 32], i4 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 - 32], o4 = t5[e3 + 0 - 32], s4 = t5[e3 + 1 - 32], c6 = t5[e3 + 2 - 32], u5 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 96] = Ne2(n4, i4, t5[e3 - 1 + 96]), t5[e3 + 1 + 96] = t5[e3 + 0 + 64] = Ne2(r3, n4, i4), t5[e3 + 2 + 96] = t5[e3 + 1 + 64] = t5[e3 + 0 + 32] = Ne2(a4, r3, n4), t5[e3 + 3 + 96] = t5[e3 + 2 + 64] = t5[e3 + 1 + 32] = t5[e3 + 0 + 0] = Ne2(o4, a4, r3), t5[e3 + 3 + 64] = t5[e3 + 2 + 32] = t5[e3 + 1 + 0] = Ne2(s4, o4, a4), t5[e3 + 3 + 32] = t5[e3 + 2 + 0] = Ne2(c6, s4, o4), t5[e3 + 3 + 0] = Ne2(u5, c6, s4);
    }
    function _e(t5, e3) {
      var r3 = t5[e3 + 1 - 32], n4 = t5[e3 + 2 - 32], i4 = t5[e3 + 3 - 32], a4 = t5[e3 + 4 - 32], o4 = t5[e3 + 5 - 32], s4 = t5[e3 + 6 - 32], c6 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = Ne2(t5[e3 + 0 - 32], r3, n4), t5[e3 + 1 + 0] = t5[e3 + 0 + 32] = Ne2(r3, n4, i4), t5[e3 + 2 + 0] = t5[e3 + 1 + 32] = t5[e3 + 0 + 64] = Ne2(n4, i4, a4), t5[e3 + 3 + 0] = t5[e3 + 2 + 32] = t5[e3 + 1 + 64] = t5[e3 + 0 + 96] = Ne2(i4, a4, o4), t5[e3 + 3 + 32] = t5[e3 + 2 + 64] = t5[e3 + 1 + 96] = Ne2(a4, o4, s4), t5[e3 + 3 + 64] = t5[e3 + 2 + 96] = Ne2(o4, s4, c6), t5[e3 + 3 + 96] = Ne2(s4, c6, c6);
    }
    function Pe(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n4 = t5[e3 - 1 + 32], i4 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 - 32], o4 = t5[e3 + 0 - 32], s4 = t5[e3 + 1 - 32], c6 = t5[e3 + 2 - 32], u5 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 1 + 64] = a4 + o4 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 2 + 64] = o4 + s4 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 3 + 64] = s4 + c6 + 1 >> 1, t5[e3 + 3 + 0] = c6 + u5 + 1 >> 1, t5[e3 + 0 + 96] = Ne2(i4, n4, r3), t5[e3 + 0 + 64] = Ne2(n4, r3, a4), t5[e3 + 0 + 32] = t5[e3 + 1 + 96] = Ne2(r3, a4, o4), t5[e3 + 1 + 32] = t5[e3 + 2 + 96] = Ne2(a4, o4, s4), t5[e3 + 2 + 32] = t5[e3 + 3 + 96] = Ne2(o4, s4, c6), t5[e3 + 3 + 32] = Ne2(s4, c6, u5);
    }
    function ke(t5, e3) {
      var r3 = t5[e3 + 0 - 32], n4 = t5[e3 + 1 - 32], i4 = t5[e3 + 2 - 32], a4 = t5[e3 + 3 - 32], o4 = t5[e3 + 4 - 32], s4 = t5[e3 + 5 - 32], c6 = t5[e3 + 6 - 32], u5 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = r3 + n4 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 0 + 64] = n4 + i4 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 1 + 64] = i4 + a4 + 1 >> 1, t5[e3 + 3 + 0] = t5[e3 + 2 + 64] = a4 + o4 + 1 >> 1, t5[e3 + 0 + 32] = Ne2(r3, n4, i4), t5[e3 + 1 + 32] = t5[e3 + 0 + 96] = Ne2(n4, i4, a4), t5[e3 + 2 + 32] = t5[e3 + 1 + 96] = Ne2(i4, a4, o4), t5[e3 + 3 + 32] = t5[e3 + 2 + 96] = Ne2(a4, o4, s4), t5[e3 + 3 + 64] = Ne2(o4, s4, c6), t5[e3 + 3 + 96] = Ne2(s4, c6, u5);
    }
    function Ie(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n4 = t5[e3 - 1 + 32], i4 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 + 96];
      t5[e3 + 0 + 0] = r3 + n4 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 0 + 32] = n4 + i4 + 1 >> 1, t5[e3 + 2 + 32] = t5[e3 + 0 + 64] = i4 + a4 + 1 >> 1, t5[e3 + 1 + 0] = Ne2(r3, n4, i4), t5[e3 + 3 + 0] = t5[e3 + 1 + 32] = Ne2(n4, i4, a4), t5[e3 + 3 + 32] = t5[e3 + 1 + 64] = Ne2(i4, a4, a4), t5[e3 + 3 + 64] = t5[e3 + 2 + 64] = t5[e3 + 0 + 96] = t5[e3 + 1 + 96] = t5[e3 + 2 + 96] = t5[e3 + 3 + 96] = a4;
    }
    function Fe(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n4 = t5[e3 - 1 + 32], i4 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 + 96], o4 = t5[e3 - 1 - 32], s4 = t5[e3 + 0 - 32], c6 = t5[e3 + 1 - 32], u5 = t5[e3 + 2 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 2 + 32] = r3 + o4 + 1 >> 1, t5[e3 + 0 + 32] = t5[e3 + 2 + 64] = n4 + r3 + 1 >> 1, t5[e3 + 0 + 64] = t5[e3 + 2 + 96] = i4 + n4 + 1 >> 1, t5[e3 + 0 + 96] = a4 + i4 + 1 >> 1, t5[e3 + 3 + 0] = Ne2(s4, c6, u5), t5[e3 + 2 + 0] = Ne2(o4, s4, c6), t5[e3 + 1 + 0] = t5[e3 + 3 + 32] = Ne2(r3, o4, s4), t5[e3 + 1 + 32] = t5[e3 + 3 + 64] = Ne2(n4, r3, o4), t5[e3 + 1 + 64] = t5[e3 + 3 + 96] = Ne2(i4, n4, r3), t5[e3 + 1 + 96] = Ne2(a4, i4, n4);
    }
    function Ce(t5, e3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3)
        n3(t5, e3 + 32 * r3, t5, e3 - 32, 8);
    }
    function je(t5, e3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3)
        i3(t5, e3, t5[e3 - 1], 8), e3 += 32;
    }
    function Oe(t5, e3, r3) {
      var n4;
      for (n4 = 0; 8 > n4; ++n4)
        i3(e3, r3 + 32 * n4, t5, 8);
    }
    function Be(t5, e3) {
      var r3, n4 = 8;
      for (r3 = 0; 8 > r3; ++r3)
        n4 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      Oe(n4 >> 4, t5, e3);
    }
    function Me(t5, e3) {
      var r3, n4 = 4;
      for (r3 = 0; 8 > r3; ++r3)
        n4 += t5[e3 + r3 - 32];
      Oe(n4 >> 3, t5, e3);
    }
    function Ee(t5, e3) {
      var r3, n4 = 4;
      for (r3 = 0; 8 > r3; ++r3)
        n4 += t5[e3 - 1 + 32 * r3];
      Oe(n4 >> 3, t5, e3);
    }
    function qe(t5, e3) {
      Oe(128, t5, e3);
    }
    function De(t5, e3, r3) {
      var n4 = t5[e3 - r3], i4 = t5[e3 + 0], a4 = 3 * (i4 - n4) + jn[1020 + t5[e3 - 2 * r3] - t5[e3 + r3]], o4 = On[112 + (a4 + 4 >> 3)];
      t5[e3 - r3] = Bn[255 + n4 + On[112 + (a4 + 3 >> 3)]], t5[e3 + 0] = Bn[255 + i4 - o4];
    }
    function Re(t5, e3, r3, n4) {
      var i4 = t5[e3 + 0], a4 = t5[e3 + r3];
      return Mn[255 + t5[e3 - 2 * r3] - t5[e3 - r3]] > n4 || Mn[255 + a4 - i4] > n4;
    }
    function Te(t5, e3, r3, n4) {
      return 4 * Mn[255 + t5[e3 - r3] - t5[e3 + 0]] + Mn[255 + t5[e3 - 2 * r3] - t5[e3 + r3]] <= n4;
    }
    function Ue(t5, e3, r3, n4, i4) {
      var a4 = t5[e3 - 3 * r3], o4 = t5[e3 - 2 * r3], s4 = t5[e3 - r3], c6 = t5[e3 + 0], u5 = t5[e3 + r3], h5 = t5[e3 + 2 * r3], l5 = t5[e3 + 3 * r3];
      return 4 * Mn[255 + s4 - c6] + Mn[255 + o4 - u5] > n4 ? 0 : Mn[255 + t5[e3 - 4 * r3] - a4] <= i4 && Mn[255 + a4 - o4] <= i4 && Mn[255 + o4 - s4] <= i4 && Mn[255 + l5 - h5] <= i4 && Mn[255 + h5 - u5] <= i4 && Mn[255 + u5 - c6] <= i4;
    }
    function ze(t5, e3, r3, n4) {
      var i4 = 2 * n4 + 1;
      for (n4 = 0; 16 > n4; ++n4)
        Te(t5, e3 + n4, r3, i4) && De(t5, e3 + n4, r3);
    }
    function He(t5, e3, r3, n4) {
      var i4 = 2 * n4 + 1;
      for (n4 = 0; 16 > n4; ++n4)
        Te(t5, e3 + n4 * r3, 1, i4) && De(t5, e3 + n4 * r3, 1);
    }
    function We(t5, e3, r3, n4) {
      var i4;
      for (i4 = 3; 0 < i4; --i4)
        ze(t5, e3 += 4 * r3, r3, n4);
    }
    function Ve(t5, e3, r3, n4) {
      var i4;
      for (i4 = 3; 0 < i4; --i4)
        He(t5, e3 += 4, r3, n4);
    }
    function Ge(t5, e3, r3, n4, i4, a4, o4, s4) {
      for (a4 = 2 * a4 + 1; 0 < i4--; ) {
        if (Ue(t5, e3, r3, a4, o4))
          if (Re(t5, e3, r3, s4))
            De(t5, e3, r3);
          else {
            var c6 = t5, u5 = e3, h5 = r3, l5 = c6[u5 - 2 * h5], f5 = c6[u5 - h5], d4 = c6[u5 + 0], p5 = c6[u5 + h5], g4 = c6[u5 + 2 * h5], m6 = 27 * (b4 = jn[1020 + 3 * (d4 - f5) + jn[1020 + l5 - p5]]) + 63 >> 7, v5 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c6[u5 - 3 * h5] = Bn[255 + c6[u5 - 3 * h5] + b4], c6[u5 - 2 * h5] = Bn[255 + l5 + v5], c6[u5 - h5] = Bn[255 + f5 + m6], c6[u5 + 0] = Bn[255 + d4 - m6], c6[u5 + h5] = Bn[255 + p5 - v5], c6[u5 + 2 * h5] = Bn[255 + g4 - b4];
          }
        e3 += n4;
      }
    }
    function Ye(t5, e3, r3, n4, i4, a4, o4, s4) {
      for (a4 = 2 * a4 + 1; 0 < i4--; ) {
        if (Ue(t5, e3, r3, a4, o4))
          if (Re(t5, e3, r3, s4))
            De(t5, e3, r3);
          else {
            var c6 = t5, u5 = e3, h5 = r3, l5 = c6[u5 - h5], f5 = c6[u5 + 0], d4 = c6[u5 + h5], p5 = On[112 + ((g4 = 3 * (f5 - l5)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m6 = p5 + 1 >> 1;
            c6[u5 - 2 * h5] = Bn[255 + c6[u5 - 2 * h5] + m6], c6[u5 - h5] = Bn[255 + l5 + g4], c6[u5 + 0] = Bn[255 + f5 - p5], c6[u5 + h5] = Bn[255 + d4 - m6];
          }
        e3 += n4;
      }
    }
    function Je(t5, e3, r3, n4, i4, a4) {
      Ge(t5, e3, r3, 1, 16, n4, i4, a4);
    }
    function Xe(t5, e3, r3, n4, i4, a4) {
      Ge(t5, e3, 1, r3, 16, n4, i4, a4);
    }
    function Ke(t5, e3, r3, n4, i4, a4) {
      var o4;
      for (o4 = 3; 0 < o4; --o4)
        Ye(t5, e3 += 4 * r3, r3, 1, 16, n4, i4, a4);
    }
    function Ze(t5, e3, r3, n4, i4, a4) {
      var o4;
      for (o4 = 3; 0 < o4; --o4)
        Ye(t5, e3 += 4, 1, r3, 16, n4, i4, a4);
    }
    function $e(t5, e3, r3, n4, i4, a4, o4, s4) {
      Ge(t5, e3, i4, 1, 8, a4, o4, s4), Ge(r3, n4, i4, 1, 8, a4, o4, s4);
    }
    function Qe(t5, e3, r3, n4, i4, a4, o4, s4) {
      Ge(t5, e3, 1, i4, 8, a4, o4, s4), Ge(r3, n4, 1, i4, 8, a4, o4, s4);
    }
    function tr(t5, e3, r3, n4, i4, a4, o4, s4) {
      Ye(t5, e3 + 4 * i4, i4, 1, 8, a4, o4, s4), Ye(r3, n4 + 4 * i4, i4, 1, 8, a4, o4, s4);
    }
    function er(t5, e3, r3, n4, i4, a4, o4, s4) {
      Ye(t5, e3 + 4, 1, i4, 8, a4, o4, s4), Ye(r3, n4 + 4, 1, i4, 8, a4, o4, s4);
    }
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l4();
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N4(), this.Pb = 0, this.wd = new N4(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o3(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t5, e3, r3, n4, i4, a4, o4) {
      for (t5 = null == t5 ? 0 : t5[e3 + 0], e3 = 0; e3 < o4; ++e3)
        i4[a4 + e3] = t5 + r3[n4 + e3] & 255, t5 = i4[a4 + e3];
    }
    function ur(t5, e3, r3, n4, i4, a4, o4) {
      var s4;
      if (null == t5)
        cr(null, null, r3, n4, i4, a4, o4);
      else
        for (s4 = 0; s4 < o4; ++s4)
          i4[a4 + s4] = t5[e3 + s4] + r3[n4 + s4] & 255;
    }
    function hr(t5, e3, r3, n4, i4, a4, o4) {
      if (null == t5)
        cr(null, null, r3, n4, i4, a4, o4);
      else {
        var s4, c6 = t5[e3 + 0], u5 = c6, h5 = c6;
        for (s4 = 0; s4 < o4; ++s4)
          u5 = h5 + (c6 = t5[e3 + s4]) - u5, h5 = r3[n4 + s4] + (-256 & u5 ? 0 > u5 ? 0 : 255 : u5) & 255, u5 = c6, i4[a4 + s4] = h5;
      }
    }
    function lr(t5, r3, i4, o4) {
      var s4 = r3.width, c6 = r3.o;
      if (e2(null != t5 && null != r3), 0 > i4 || 0 >= o4 || i4 + o4 > c6)
        return null;
      if (!t5.Cc) {
        if (null == t5.ga) {
          var u5;
          if (t5.ga = new sr(), (u5 = null == t5.ga) || (u5 = r3.width * r3.o, e2(0 == t5.Gb.length), t5.Gb = a3(u5), t5.Uc = 0, null == t5.Gb ? u5 = 0 : (t5.mb = t5.Gb, t5.nb = t5.Uc, t5.rc = null, u5 = 1), u5 = !u5), !u5) {
            u5 = t5.ga;
            var h5 = t5.Fa, l5 = t5.P, f5 = t5.qc, d4 = t5.mb, p5 = t5.nb, g4 = l5 + 1, m6 = f5 - 1, b4 = u5.l;
            if (e2(null != h5 && null != d4 && null != r3), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u5.ca = d4, u5.tb = p5, u5.c = r3.width, u5.i = r3.height, e2(0 < u5.c && 0 < u5.i), 1 >= f5)
              r3 = 0;
            else if (u5.$a = h5[l5 + 0] >> 0 & 3, u5.Z = h5[l5 + 0] >> 2 & 3, u5.Lc = h5[l5 + 0] >> 4 & 3, l5 = h5[l5 + 0] >> 6 & 3, 0 > u5.$a || 1 < u5.$a || 4 <= u5.Z || 1 < u5.Lc || l5)
              r3 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u5, b4.width = r3.width, b4.height = r3.height, b4.Da = r3.Da, b4.v = r3.v, b4.va = r3.va, b4.j = r3.j, b4.o = r3.o, u5.$a)
              t: {
                e2(1 == u5.$a), r3 = kt2();
                e:
                  for (; ; ) {
                    if (null == r3) {
                      r3 = 0;
                      break t;
                    }
                    if (e2(null != u5), u5.mc = r3, r3.c = u5.c, r3.i = u5.i, r3.l = u5.l, r3.l.ma = u5, r3.l.width = u5.c, r3.l.height = u5.i, r3.a = 0, v4(r3.m, h5, g4, m6), !It2(u5.c, u5.i, 1, r3, null))
                      break e;
                    if (1 == r3.ab && 3 == r3.gc[0].hc && At2(r3.s) ? (u5.ic = 1, h5 = r3.c * r3.i, r3.Ta = null, r3.Ua = 0, r3.V = a3(h5), r3.Ba = 0, null == r3.V ? (r3.a = 1, r3 = 0) : r3 = 1) : (u5.ic = 0, r3 = Ft2(r3, u5.c)), !r3)
                      break e;
                    r3 = 1;
                    break t;
                  }
                u5.mc = null, r3 = 0;
              }
            else
              r3 = m6 >= u5.c * u5.i;
            u5 = !r3;
          }
          if (u5)
            return null;
          1 != t5.ga.Lc ? t5.Ga = 0 : o4 = c6 - i4;
        }
        e2(null != t5.ga), e2(i4 + o4 <= c6);
        t: {
          if (r3 = (h5 = t5.ga).c, c6 = h5.l.o, 0 == h5.$a) {
            if (g4 = t5.rc, m6 = t5.Vc, b4 = t5.Fa, l5 = t5.P + 1 + i4 * r3, f5 = t5.mb, d4 = t5.nb + i4 * r3, e2(l5 <= t5.P + t5.qc), 0 != h5.Z)
              for (e2(null != mi[h5.Z]), u5 = 0; u5 < o4; ++u5)
                mi[h5.Z](g4, m6, b4, l5, f5, d4, r3), g4 = f5, m6 = d4, d4 += r3, l5 += r3;
            else
              for (u5 = 0; u5 < o4; ++u5)
                n3(f5, d4, b4, l5, r3), g4 = f5, m6 = d4, d4 += r3, l5 += r3;
            t5.rc = g4, t5.Vc = m6;
          } else {
            if (e2(null != h5.mc), r3 = i4 + o4, e2(null != (u5 = h5.mc)), e2(r3 <= u5.i), u5.C >= r3)
              r3 = 1;
            else if (h5.ic || mr(), h5.ic) {
              h5 = u5.V, g4 = u5.Ba, m6 = u5.c;
              var y5 = u5.i, w4 = (b4 = 1, l5 = u5.$ / m6, f5 = u5.$ % m6, d4 = u5.m, p5 = u5.s, u5.$), N5 = m6 * y5, L4 = m6 * r3, x3 = p5.wc, _4 = w4 < L4 ? wt2(p5, f5, l5) : null;
              e2(w4 <= N5), e2(r3 <= y5), e2(At2(p5));
              e:
                for (; ; ) {
                  for (; !d4.h && w4 < L4; ) {
                    if (f5 & x3 || (_4 = wt2(p5, f5, l5)), e2(null != _4), S2(d4), 256 > (y5 = bt2(_4.G[0], _4.H[0], d4)))
                      h5[g4 + w4] = y5, ++w4, ++f5 >= m6 && (f5 = 0, ++l5 <= r3 && !(l5 % 16) && St2(u5, l5));
                    else {
                      if (!(280 > y5)) {
                        b4 = 0;
                        break e;
                      }
                      y5 = mt2(y5 - 256, d4);
                      var P3, k3 = bt2(_4.G[4], _4.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m6, k3 = mt2(k3, d4))) && N5 - w4 >= y5)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y5; ++P3)
                        h5[g4 + w4 + P3] = h5[g4 + w4 + P3 - k3];
                      for (w4 += y5, f5 += y5; f5 >= m6; )
                        f5 -= m6, ++l5 <= r3 && !(l5 % 16) && St2(u5, l5);
                      w4 < L4 && f5 & x3 && (_4 = wt2(p5, f5, l5));
                    }
                    e2(d4.h == A3(d4));
                  }
                  St2(u5, l5 > r3 ? r3 : l5);
                  break e;
                }
              !b4 || d4.h && w4 < N5 ? (b4 = 0, u5.a = d4.h ? 5 : 3) : u5.$ = w4, r3 = b4;
            } else
              r3 = _t2(u5, u5.V, u5.Ba, u5.c, u5.i, r3, Ct2);
            if (!r3) {
              o4 = 0;
              break t;
            }
          }
          i4 + o4 >= c6 && (t5.Cc = 1), o4 = 1;
        }
        if (!o4)
          return null;
        if (t5.Cc && (null != (o4 = t5.ga) && (o4.mc = null), t5.ga = null, 0 < t5.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return t5.nb + i4 * s4;
    }
    function fr(t5, e3, r3, n4, i4, a4) {
      for (; 0 < i4--; ) {
        var o4, s4 = t5, c6 = e3 + (r3 ? 1 : 0), u5 = t5, h5 = e3 + (r3 ? 0 : 3);
        for (o4 = 0; o4 < n4; ++o4) {
          var l5 = u5[h5 + 4 * o4];
          255 != l5 && (l5 *= 32897, s4[c6 + 4 * o4 + 0] = s4[c6 + 4 * o4 + 0] * l5 >> 23, s4[c6 + 4 * o4 + 1] = s4[c6 + 4 * o4 + 1] * l5 >> 23, s4[c6 + 4 * o4 + 2] = s4[c6 + 4 * o4 + 2] * l5 >> 23);
        }
        e3 += a4;
      }
    }
    function dr(t5, e3, r3, n4, i4) {
      for (; 0 < n4--; ) {
        var a4;
        for (a4 = 0; a4 < r3; ++a4) {
          var o4 = t5[e3 + 2 * a4 + 0], s4 = 15 & (u5 = t5[e3 + 2 * a4 + 1]), c6 = 4369 * s4, u5 = (240 & u5 | u5 >> 4) * c6 >> 16;
          t5[e3 + 2 * a4 + 0] = (240 & o4 | o4 >> 4) * c6 >> 16 & 240 | (15 & o4 | o4 << 4) * c6 >> 16 >> 4 & 15, t5[e3 + 2 * a4 + 1] = 240 & u5 | s4;
        }
        e3 += i4;
      }
    }
    function pr(t5, e3, r3, n4, i4, a4, o4, s4) {
      var c6, u5, h5 = 255;
      for (u5 = 0; u5 < i4; ++u5) {
        for (c6 = 0; c6 < n4; ++c6) {
          var l5 = t5[e3 + c6];
          a4[o4 + 4 * c6] = l5, h5 &= l5;
        }
        e3 += r3, o4 += s4;
      }
      return 255 != h5;
    }
    function gr(t5, e3, r3, n4, i4) {
      var a4;
      for (a4 = 0; a4 < i4; ++a4)
        r3[n4 + a4] = t5[e3 + a4] >> 8;
    }
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    function vr(r3, n4, i4) {
      t4[r3] = function(t5, r4, a4, o4, s4, c6, u5, h5, l5, f5, d4, p5, g4, m6, v5, b4, y5) {
        var w4, N5 = y5 - 1 >> 1, L4 = s4[c6 + 0] | u5[h5 + 0] << 16, A4 = l5[f5 + 0] | d4[p5 + 0] << 16;
        e2(null != t5);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n4(t5[r4 + 0], 255 & x3, x3 >> 16, g4, m6), null != a4 && (x3 = 3 * A4 + L4 + 131074 >> 2, n4(a4[o4 + 0], 255 & x3, x3 >> 16, v5, b4)), w4 = 1; w4 <= N5; ++w4) {
          var S3 = s4[c6 + w4] | u5[h5 + w4] << 16, _4 = l5[f5 + w4] | d4[p5 + w4] << 16, P3 = L4 + S3 + A4 + _4 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _4) >> 3) + S3 >> 1, n4(t5[r4 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m6 + (2 * w4 - 1) * i4), n4(t5[r4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m6 + (2 * w4 - 0) * i4), null != a4 && (x3 = P3 + A4 >> 1, L4 = k3 + _4 >> 1, n4(a4[o4 + 2 * w4 - 1], 255 & x3, x3 >> 16, v5, b4 + (2 * w4 - 1) * i4), n4(a4[o4 + 2 * w4 + 0], 255 & L4, L4 >> 16, v5, b4 + (2 * w4 + 0) * i4)), L4 = S3, A4 = _4;
        }
        1 & y5 || (x3 = 3 * L4 + A4 + 131074 >> 2, n4(t5[r4 + y5 - 1], 255 & x3, x3 >> 16, g4, m6 + (y5 - 1) * i4), null != a4 && (x3 = 3 * A4 + L4 + 131074 >> 2, n4(a4[o4 + y5 - 1], 255 & x3, x3 >> 16, v5, b4 + (y5 - 1) * i4)));
      };
    }
    function br() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    function yr(t5) {
      return t5 & ~Fi ? 0 > t5 ? 0 : 255 : t5 >> Ii;
    }
    function wr(t5, e3) {
      return yr((19077 * t5 >> 8) + (26149 * e3 >> 8) - 14234);
    }
    function Nr(t5, e3, r3) {
      return yr((19077 * t5 >> 8) - (6419 * e3 >> 8) - (13320 * r3 >> 8) + 8708);
    }
    function Lr(t5, e3) {
      return yr((19077 * t5 >> 8) + (33050 * e3 >> 8) - 17685);
    }
    function Ar(t5, e3, r3, n4, i4) {
      n4[i4 + 0] = wr(t5, r3), n4[i4 + 1] = Nr(t5, e3, r3), n4[i4 + 2] = Lr(t5, e3);
    }
    function xr(t5, e3, r3, n4, i4) {
      n4[i4 + 0] = Lr(t5, e3), n4[i4 + 1] = Nr(t5, e3, r3), n4[i4 + 2] = wr(t5, r3);
    }
    function Sr(t5, e3, r3, n4, i4) {
      var a4 = Nr(t5, e3, r3);
      e3 = a4 << 3 & 224 | Lr(t5, e3) >> 3, n4[i4 + 0] = 248 & wr(t5, r3) | a4 >> 5, n4[i4 + 1] = e3;
    }
    function _r(t5, e3, r3, n4, i4) {
      var a4 = 240 & Lr(t5, e3) | 15;
      n4[i4 + 0] = 240 & wr(t5, r3) | Nr(t5, e3, r3) >> 4, n4[i4 + 1] = a4;
    }
    function Pr(t5, e3, r3, n4, i4) {
      n4[i4 + 0] = 255, Ar(t5, e3, r3, n4, i4 + 1);
    }
    function kr(t5, e3, r3, n4, i4) {
      xr(t5, e3, r3, n4, i4), n4[i4 + 3] = 255;
    }
    function Ir(t5, e3, r3, n4, i4) {
      Ar(t5, e3, r3, n4, i4), n4[i4 + 3] = 255;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Fr(e3, r3, n4) {
      t4[e3] = function(t5, e4, i4, a4, o4, s4, c6, u5, h5) {
        for (var l5 = u5 + (-2 & h5) * n4; u5 != l5; )
          r3(t5[e4 + 0], i4[a4 + 0], o4[s4 + 0], c6, u5), r3(t5[e4 + 1], i4[a4 + 0], o4[s4 + 0], c6, u5 + n4), e4 += 2, ++a4, ++s4, u5 += 2 * n4;
        1 & h5 && r3(t5[e4 + 0], i4[a4 + 0], o4[s4 + 0], c6, u5);
      };
    }
    function Cr(t5, e3, r3) {
      return 0 == r3 ? 0 == t5 ? 0 == e3 ? 6 : 5 : 0 == e3 ? 4 : 0 : r3;
    }
    function jr(t5, e3, r3, n4, i4) {
      switch (t5 >>> 30) {
        case 3:
          on(e3, r3, n4, i4, 0);
          break;
        case 2:
          sn(e3, r3, n4, i4);
          break;
        case 1:
          un(e3, r3, n4, i4);
      }
    }
    function Or(t5, e3) {
      var r3, a4, o4 = e3.M, s4 = e3.Nb, c6 = t5.oc, u5 = t5.pc + 40, h5 = t5.oc, l5 = t5.pc + 584, f5 = t5.oc, d4 = t5.pc + 600;
      for (r3 = 0; 16 > r3; ++r3)
        c6[u5 + 32 * r3 - 1] = 129;
      for (r3 = 0; 8 > r3; ++r3)
        h5[l5 + 32 * r3 - 1] = 129, f5[d4 + 32 * r3 - 1] = 129;
      for (0 < o4 ? c6[u5 - 1 - 32] = h5[l5 - 1 - 32] = f5[d4 - 1 - 32] = 129 : (i3(c6, u5 - 32 - 1, 127, 21), i3(h5, l5 - 32 - 1, 127, 9), i3(f5, d4 - 32 - 1, 127, 9)), a4 = 0; a4 < t5.za; ++a4) {
        var p5 = e3.ya[e3.aa + a4];
        if (0 < a4) {
          for (r3 = -1; 16 > r3; ++r3)
            n3(c6, u5 + 32 * r3 - 4, c6, u5 + 32 * r3 + 12, 4);
          for (r3 = -1; 8 > r3; ++r3)
            n3(h5, l5 + 32 * r3 - 4, h5, l5 + 32 * r3 + 4, 4), n3(f5, d4 + 32 * r3 - 4, f5, d4 + 32 * r3 + 4, 4);
        }
        var g4 = t5.Gd, m6 = t5.Hd + a4, v5 = p5.ad, b4 = p5.Hc;
        if (0 < o4 && (n3(c6, u5 - 32, g4[m6].y, 0, 16), n3(h5, l5 - 32, g4[m6].f, 0, 8), n3(f5, d4 - 32, g4[m6].ea, 0, 8)), p5.Za) {
          var y5 = c6, w4 = u5 - 32 + 16;
          for (0 < o4 && (a4 >= t5.za - 1 ? i3(y5, w4, g4[m6].y[15], 4) : n3(y5, w4, g4[m6 + 1].y, 0, 4)), r3 = 0; 4 > r3; r3++)
            y5[w4 + 128 + r3] = y5[w4 + 256 + r3] = y5[w4 + 384 + r3] = y5[w4 + 0 + r3];
          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)
            y5 = c6, w4 = u5 + Di[r3], fi[p5.Ob[r3]](y5, w4), jr(b4, v5, 16 * +r3, y5, w4);
        } else if (y5 = Cr(a4, o4, p5.Ob[0]), li2[y5](c6, u5), 0 != b4)
          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)
            jr(b4, v5, 16 * +r3, c6, u5 + Di[r3]);
        for (r3 = p5.Gc, y5 = Cr(a4, o4, p5.Dd), di[y5](h5, l5), di[y5](f5, d4), b4 = v5, y5 = h5, w4 = l5, 255 & (p5 = r3 >> 0) && (170 & p5 ? cn(b4, 256, y5, w4) : hn(b4, 256, y5, w4)), p5 = f5, b4 = d4, 255 & (r3 >>= 8) && (170 & r3 ? cn(v5, 320, p5, b4) : hn(v5, 320, p5, b4)), o4 < t5.Ub - 1 && (n3(g4[m6].y, 0, c6, u5 + 480, 16), n3(g4[m6].f, 0, h5, l5 + 224, 8), n3(g4[m6].ea, 0, f5, d4 + 224, 8)), r3 = 8 * s4 * t5.B, g4 = t5.sa, m6 = t5.ta + 16 * a4 + 16 * s4 * t5.R, v5 = t5.qa, p5 = t5.ra + 8 * a4 + r3, b4 = t5.Ha, y5 = t5.Ia + 8 * a4 + r3, r3 = 0; 16 > r3; ++r3)
          n3(g4, m6 + r3 * t5.R, c6, u5 + 32 * r3, 16);
        for (r3 = 0; 8 > r3; ++r3)
          n3(v5, p5 + r3 * t5.B, h5, l5 + 32 * r3, 8), n3(b4, y5 + r3 * t5.B, f5, d4 + 32 * r3, 8);
      }
    }
    function Br(t5, n4, i4, a4, o4, s4, c6, u5, h5) {
      var l5 = [0], f5 = [0], d4 = 0, p5 = null != h5 ? h5.kd : 0, g4 = null != h5 ? h5 : new nr();
      if (null == t5 || 12 > i4)
        return 7;
      g4.data = t5, g4.w = n4, g4.ha = i4, n4 = [n4], i4 = [i4], g4.gb = [g4.gb];
      t: {
        var m6 = n4, b4 = i4, y5 = g4.gb;
        if (e2(null != t5), e2(null != b4), e2(null != y5), y5[0] = 0, 12 <= b4[0] && !r2(t5, m6[0], "RIFF")) {
          if (r2(t5, m6[0] + 8, "WEBP")) {
            y5 = 3;
            break t;
          }
          var w4 = j2(t5, m6[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y5 = 3;
            break t;
          }
          if (p5 && w4 > b4[0] - 8) {
            y5 = 7;
            break t;
          }
          y5[0] = w4, m6[0] += 12, b4[0] -= 12;
        }
        y5 = 0;
      }
      if (0 != y5)
        return y5;
      for (w4 = 0 < g4.gb[0], i4 = i4[0]; ; ) {
        t: {
          var L4 = t5;
          b4 = n4, y5 = i4;
          var A4 = l5, x3 = f5, S3 = m6 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y5[0])
            y5 = 7;
          else {
            if (!r2(L4, b4[0], "VP8X")) {
              if (10 != j2(L4, b4[0] + 4)) {
                y5 = 3;
                break t;
              }
              if (18 > y5[0]) {
                y5 = 7;
                break t;
              }
              var _4 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y5 = 3;
                break t;
              }
              null != S3 && (S3[0] = _4), null != A4 && (A4[0] = P3), null != x3 && (x3[0] = L4), b4[0] += 18, y5[0] -= 18, k3[0] = 1;
            }
            y5 = 0;
          }
        }
        if (d4 = d4[0], m6 = m6[0], 0 != y5)
          return y5;
        if (b4 = !!(2 & m6), !w4 && d4)
          return 3;
        if (null != s4 && (s4[0] = !!(16 & m6)), null != c6 && (c6[0] = b4), null != u5 && (u5[0] = 0), c6 = l5[0], m6 = f5[0], d4 && b4 && null == h5) {
          y5 = 0;
          break;
        }
        if (4 > i4) {
          y5 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !r2(t5, n4[0], "ALPH")) {
          i4 = [i4], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _4 = t5, y5 = n4, w4 = i4;
            var k3 = g4.gb;
            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
            P3 = 22, e2(null != _4), e2(null != w4), L4 = y5[0];
            var I3 = w4[0];
            for (e2(null != A4), e2(null != S3), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y5[0] = L4, w4[0] = I3, 8 > I3) {
                y5 = 7;
                break t;
              }
              var F3 = j2(_4, L4 + 4);
              if (4294967286 < F3) {
                y5 = 3;
                break t;
              }
              var O4 = 8 + F3 + 1 & -2;
              if (P3 += O4, 0 < k3 && P3 > k3) {
                y5 = 3;
                break t;
              }
              if (!r2(_4, L4, "VP8 ") || !r2(_4, L4, "VP8L")) {
                y5 = 0;
                break t;
              }
              if (I3[0] < O4) {
                y5 = 7;
                break t;
              }
              r2(_4, L4, "ALPH") || (A4[0] = _4, x3[0] = L4 + 8, S3[0] = F3), L4 += O4, I3 -= O4;
            }
          }
          if (i4 = i4[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y5)
            break;
        }
        i4 = [i4], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t:
          if (k3 = t5, y5 = n4, w4 = i4, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _4 = y5[0], L4 = !r2(k3, _4, "VP8 "), P3 = !r2(k3, _4, "VP8L"), e2(null != k3), e2(null != w4), e2(null != x3), e2(null != S3), 8 > w4[0])
            y5 = 7;
          else {
            if (L4 || P3) {
              if (k3 = j2(k3, _4 + 4), 12 <= A4 && k3 > A4 - 12) {
                y5 = 3;
                break t;
              }
              if (p5 && k3 > w4[0] - 8) {
                y5 = 7;
                break t;
              }
              x3[0] = k3, y5[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else
              S3[0] = 5 <= w4[0] && 47 == k3[_4 + 0] && !(k3[_4 + 4] >> 5), x3[0] = w4[0];
            y5 = 0;
          }
        if (i4 = i4[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n4 = n4[0], 0 != y5)
          break;
        if (4294967286 < g4.Ja)
          return 3;
        if (null == u5 || b4 || (u5[0] = g4.xa ? 2 : 1), c6 = [c6], m6 = [m6], g4.xa) {
          if (5 > i4) {
            y5 = 7;
            break;
          }
          u5 = c6, p5 = m6, b4 = s4, null == t5 || 5 > i4 ? t5 = 0 : 5 <= i4 && 47 == t5[n4 + 0] && !(t5[n4 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v4(x3 = new N4(), t5, n4, i4), gt2(x3, w4, k3, A4) ? (null != u5 && (u5[0] = w4[0]), null != p5 && (p5[0] = k3[0]), null != b4 && (b4[0] = A4[0]), t5 = 1) : t5 = 0) : t5 = 0;
        } else {
          if (10 > i4) {
            y5 = 7;
            break;
          }
          u5 = m6, null == t5 || 10 > i4 || !Xt2(t5, n4 + 3, i4 - 3) ? t5 = 0 : (p5 = t5[n4 + 0] | t5[n4 + 1] << 8 | t5[n4 + 2] << 16, b4 = 16383 & (t5[n4 + 7] << 8 | t5[n4 + 6]), t5 = 16383 & (t5[n4 + 9] << 8 | t5[n4 + 8]), 1 & p5 || 3 < (p5 >> 1 & 7) || !(p5 >> 4 & 1) || p5 >> 5 >= g4.Ja || !b4 || !t5 ? t5 = 0 : (c6 && (c6[0] = b4), u5 && (u5[0] = t5), t5 = 1));
        }
        if (!t5)
          return 3;
        if (c6 = c6[0], m6 = m6[0], d4 && (l5[0] != c6 || f5[0] != m6))
          return 3;
        null != h5 && (h5[0] = g4, h5.offset = n4 - h5.w, e2(4294967286 > n4 - h5.w), e2(h5.offset == h5.ha - i4));
        break;
      }
      return 0 == y5 || 7 == y5 && d4 && null == h5 ? (null != s4 && (s4[0] |= null != g4.na && 0 < g4.na.length), null != a4 && (a4[0] = c6), null != o4 && (o4[0] = m6), 0) : y5;
    }
    function Mr(t5, e3, r3) {
      var n4 = e3.width, i4 = e3.height, a4 = 0, o4 = 0, s4 = n4, c6 = i4;
      if (e3.Da = null != t5 && 0 < t5.Da, e3.Da && (s4 = t5.cd, c6 = t5.bd, a4 = t5.v, o4 = t5.j, 11 > r3 || (a4 &= -2, o4 &= -2), 0 > a4 || 0 > o4 || 0 >= s4 || 0 >= c6 || a4 + s4 > n4 || o4 + c6 > i4))
        return 0;
      if (e3.v = a4, e3.j = o4, e3.va = a4 + s4, e3.o = o4 + c6, e3.U = s4, e3.T = c6, e3.da = null != t5 && 0 < t5.da, e3.da) {
        if (!E2(s4, c6, r3 = [t5.ib], a4 = [t5.hb]))
          return 0;
        e3.ib = r3[0], e3.hb = a4[0];
      }
      return e3.ob = null != t5 && t5.ob, e3.Kb = null == t5 || !t5.Sd, e3.da && (e3.ob = e3.ib < 3 * n4 / 4 && e3.hb < 3 * i4 / 4, e3.Kb = 0), 1;
    }
    function Er(t5) {
      if (null == t5)
        return 2;
      if (11 > t5.S) {
        var e3 = t5.f.RGBA;
        e3.fb += (t5.height - 1) * e3.A, e3.A = -e3.A;
      } else
        e3 = t5.f.kb, t5 = t5.height, e3.O += (t5 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t5 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t5 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, null != e3.F && (e3.J += (t5 - 1) * e3.lb, e3.lb = -e3.lb);
      return 0;
    }
    function qr(t5, e3, r3, n4) {
      if (null == n4 || 0 >= t5 || 0 >= e3)
        return 2;
      if (null != r3) {
        if (r3.Da) {
          var i4 = r3.cd, o4 = r3.bd, s4 = -2 & r3.v, c6 = -2 & r3.j;
          if (0 > s4 || 0 > c6 || 0 >= i4 || 0 >= o4 || s4 + i4 > t5 || c6 + o4 > e3)
            return 2;
          t5 = i4, e3 = o4;
        }
        if (r3.da) {
          if (!E2(t5, e3, i4 = [r3.ib], o4 = [r3.hb]))
            return 2;
          t5 = i4[0], e3 = o4[0];
        }
      }
      n4.width = t5, n4.height = e3;
      t: {
        var u5 = n4.width, h5 = n4.height;
        if (t5 = n4.S, 0 >= u5 || 0 >= h5 || !(t5 >= En && 13 > t5))
          t5 = 2;
        else {
          if (0 >= n4.Rd && null == n4.sd) {
            s4 = o4 = i4 = e3 = 0;
            var l5 = (c6 = u5 * zi[t5]) * h5;
            if (11 > t5 || (o4 = (h5 + 1) / 2 * (e3 = (u5 + 1) / 2), 12 == t5 && (s4 = (i4 = u5) * h5)), null == (h5 = a3(l5 + 2 * o4 + s4))) {
              t5 = 1;
              break t;
            }
            n4.sd = h5, 11 > t5 ? ((u5 = n4.f.RGBA).eb = h5, u5.fb = 0, u5.A = c6, u5.size = l5) : ((u5 = n4.f.kb).y = h5, u5.O = 0, u5.fa = c6, u5.Fd = l5, u5.f = h5, u5.N = 0 + l5, u5.Ab = e3, u5.Cd = o4, u5.ea = h5, u5.W = 0 + l5 + o4, u5.Db = e3, u5.Ed = o4, 12 == t5 && (u5.F = h5, u5.J = 0 + l5 + 2 * o4), u5.Tc = s4, u5.lb = i4);
          }
          if (e3 = 1, i4 = n4.S, o4 = n4.width, s4 = n4.height, i4 >= En && 13 > i4)
            if (11 > i4)
              t5 = n4.f.RGBA, e3 &= (c6 = Math.abs(t5.A)) * (s4 - 1) + o4 <= t5.size, e3 &= c6 >= o4 * zi[i4], e3 &= null != t5.eb;
            else {
              t5 = n4.f.kb, c6 = (o4 + 1) / 2, l5 = (s4 + 1) / 2, u5 = Math.abs(t5.fa);
              h5 = Math.abs(t5.Ab);
              var f5 = Math.abs(t5.Db), d4 = Math.abs(t5.lb), p5 = d4 * (s4 - 1) + o4;
              e3 &= u5 * (s4 - 1) + o4 <= t5.Fd, e3 &= h5 * (l5 - 1) + c6 <= t5.Cd, e3 = (e3 &= f5 * (l5 - 1) + c6 <= t5.Ed) & u5 >= o4 & h5 >= c6 & f5 >= c6, e3 &= null != t5.y, e3 &= null != t5.f, e3 &= null != t5.ea, 12 == i4 && (e3 &= d4 >= o4, e3 &= p5 <= t5.Tc, e3 &= null != t5.F);
            }
          else
            e3 = 0;
          t5 = e3 ? 0 : 2;
        }
      }
      return 0 != t5 || null != r3 && r3.fd && (t5 = Er(n4)), t5;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t4.Predictor0 = function() {
      return 4278190080;
    }, t4.Predictor1 = function(t5) {
      return t5;
    }, t4.Predictor2 = function(t5, e3, r3) {
      return e3[r3 + 0];
    }, t4.Predictor3 = function(t5, e3, r3) {
      return e3[r3 + 1];
    }, t4.Predictor4 = function(t5, e3, r3) {
      return e3[r3 - 1];
    }, t4.Predictor5 = function(t5, e3, r3) {
      return U2(U2(t5, e3[r3 + 1]), e3[r3 + 0]);
    }, t4.Predictor6 = function(t5, e3, r3) {
      return U2(t5, e3[r3 - 1]);
    }, t4.Predictor7 = function(t5, e3, r3) {
      return U2(t5, e3[r3 + 0]);
    }, t4.Predictor8 = function(t5, e3, r3) {
      return U2(e3[r3 - 1], e3[r3 + 0]);
    }, t4.Predictor9 = function(t5, e3, r3) {
      return U2(e3[r3 + 0], e3[r3 + 1]);
    }, t4.Predictor10 = function(t5, e3, r3) {
      return U2(U2(t5, e3[r3 - 1]), U2(e3[r3 + 0], e3[r3 + 1]));
    }, t4.Predictor11 = function(t5, e3, r3) {
      var n4 = e3[r3 + 0];
      return 0 >= W2(n4 >> 24 & 255, t5 >> 24 & 255, (e3 = e3[r3 - 1]) >> 24 & 255) + W2(n4 >> 16 & 255, t5 >> 16 & 255, e3 >> 16 & 255) + W2(n4 >> 8 & 255, t5 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n4, 255 & t5, 255 & e3) ? n4 : t5;
    }, t4.Predictor12 = function(t5, e3, r3) {
      var n4 = e3[r3 + 0];
      return (z2((t5 >> 24 & 255) + (n4 >> 24 & 255) - ((e3 = e3[r3 - 1]) >> 24 & 255)) << 24 | z2((t5 >> 16 & 255) + (n4 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | z2((t5 >> 8 & 255) + (n4 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | z2((255 & t5) + (255 & n4) - (255 & e3))) >>> 0;
    }, t4.Predictor13 = function(t5, e3, r3) {
      var n4 = e3[r3 - 1];
      return (H2((t5 = U2(t5, e3[r3 + 0])) >> 24 & 255, n4 >> 24 & 255) << 24 | H2(t5 >> 16 & 255, n4 >> 16 & 255) << 16 | H2(t5 >> 8 & 255, n4 >> 8 & 255) << 8 | H2(t5 >> 0 & 255, n4 >> 0 & 255)) >>> 0;
    };
    var Wr = t4.PredictorAdd0;
    t4.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t4.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t5) {
      return t5 >> 8 & 255;
    }, function(t5) {
      return t5;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t5) {
      return t5;
    }, function(t5) {
      return t5 >> 8 & 255;
    });
    var Gr, Yr = t4.ColorIndexInverseTransform, Jr = t4.MapARGB, Xr = t4.VP8LColorIndexInverseTransformAlpha, Kr = t4.MapAlpha, Zr = t4.VP8LPredictorsAdd = [];
    Zr.length = 16, (t4.VP8LPredictors = []).length = 16, (t4.VP8LPredictorsAdd_C = []).length = 16, (t4.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a3(511), kn = a3(2041), In = a3(225), Fn = a3(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li2 = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi = t4.UpsampleRgbLinePair, yi = t4.UpsampleBgrLinePair, wi = t4.UpsampleRgbaLinePair, Ni = t4.UpsampleBgraLinePair, Li = t4.UpsampleArgbLinePair, Ai = t4.UpsampleRgba4444LinePair, xi = t4.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a3(256), Oi = a3(256), Bi = a3(256), Mi = a3(256), Ei = a3(ki - Pi), qi = a3(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui = 1;
    this.WebPDecodeRGBA = function(t5, r3, n4, i4, a4) {
      var o4 = qn, s4 = new rr(), c6 = new ot2();
      s4.ba = c6, c6.S = o4, c6.width = [c6.width], c6.height = [c6.height];
      var u5 = c6.width, h5 = c6.height, l5 = new st2();
      if (null == l5 || null == t5)
        var f5 = 2;
      else
        e2(null != l5), f5 = Br(t5, r3, n4, l5.width, l5.height, l5.Pd, l5.Qd, l5.format, null);
      if (0 != f5 ? u5 = 0 : (null != u5 && (u5[0] = l5.width[0]), null != h5 && (h5[0] = l5.height[0]), u5 = 1), u5) {
        c6.width = c6.width[0], c6.height = c6.height[0], null != i4 && (i4[0] = c6.width), null != a4 && (a4[0] = c6.height);
        t: {
          if (i4 = new Gt2(), (a4 = new nr()).data = t5, a4.w = r3, a4.ha = n4, a4.kd = 1, r3 = [0], e2(null != a4), (0 == (t5 = Br(a4.data, a4.w, a4.ha, null, null, null, r3, null, a4)) || 7 == t5) && r3[0] && (t5 = 4), 0 == (r3 = t5)) {
            if (e2(null != s4), i4.data = a4.data, i4.w = a4.w + a4.offset, i4.ha = a4.ha - a4.offset, i4.put = dt2, i4.ac = ft2, i4.bc = pt2, i4.ma = s4, a4.xa) {
              if (null == (t5 = kt2())) {
                s4 = 1;
                break t;
              }
              if (function(t6, r4) {
                var n5 = [0], i5 = [0], a5 = [0];
                e:
                  for (; ; ) {
                    if (null == t6)
                      return 0;
                    if (null == r4)
                      return t6.a = 2, 0;
                    if (t6.l = r4, t6.a = 0, v4(t6.m, r4.data, r4.w, r4.ha), !gt2(t6.m, n5, i5, a5)) {
                      t6.a = 3;
                      break e;
                    }
                    if (t6.xb = gi, r4.width = n5[0], r4.height = i5[0], !It2(n5[0], i5[0], 1, t6, null))
                      break e;
                    return 1;
                  }
                return e2(0 != t6.a), 0;
              }(t5, i4)) {
                if (i4 = 0 == (r3 = qr(i4.width, i4.height, s4.Oa, s4.ba))) {
                  e: {
                    i4 = t5;
                    r:
                      for (; ; ) {
                        if (null == i4) {
                          i4 = 0;
                          break e;
                        }
                        if (e2(null != i4.s.yc), e2(null != i4.s.Ya), e2(0 < i4.s.Wb), e2(null != (n4 = i4.l)), e2(null != (a4 = n4.ma)), 0 != i4.xb) {
                          if (i4.ca = a4.ba, i4.tb = a4.tb, e2(null != i4.ca), !Mr(a4.Oa, n4, Rn)) {
                            i4.a = 2;
                            break r;
                          }
                          if (!Ft2(i4, n4.width))
                            break r;
                          if (n4.da)
                            break r;
                          if ((n4.da || nt2(i4.ca.S)) && mr(), 11 > i4.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i4.ca.f.kb.F && mr()), i4.Pb && 0 < i4.s.ua && null == i4.s.vb.X && !O3(i4.s.vb, i4.s.Wa.Xa)) {
                            i4.a = 1;
                            break r;
                          }
                          i4.xb = 0;
                        }
                        if (!_t2(i4, i4.V, i4.Ba, i4.c, i4.i, n4.o, Lt2))
                          break r;
                        a4.Dc = i4.Ma, i4 = 1;
                        break e;
                      }
                    e2(0 != i4.a), i4 = 0;
                  }
                  i4 = !i4;
                }
                i4 && (r3 = t5.a);
              } else
                r3 = t5.a;
            } else {
              if (null == (t5 = new Yt2())) {
                s4 = 1;
                break t;
              }
              if (t5.Fa = a4.na, t5.P = a4.P, t5.qc = a4.Sa, Kt2(t5, i4)) {
                if (0 == (r3 = qr(i4.width, i4.height, s4.Oa, s4.ba))) {
                  if (t5.Aa = 0, n4 = s4.Oa, e2(null != (a4 = t5)), null != n4) {
                    if (0 < (u5 = 0 > (u5 = n4.Md) ? 0 : 100 < u5 ? 255 : 255 * u5 / 100)) {
                      for (h5 = l5 = 0; 4 > h5; ++h5)
                        12 > (f5 = a4.pb[h5]).lc && (f5.ia = u5 * Ti[0 > f5.lc ? 0 : f5.lc] >> 3), l5 |= f5.ia;
                      l5 && (alert("todo:VP8InitRandom"), a4.ia = 1);
                    }
                    a4.Ga = n4.Id, 100 < a4.Ga ? a4.Ga = 100 : 0 > a4.Ga && (a4.Ga = 0);
                  }
                  Qt2(t5, i4) || (r3 = t5.a);
                }
              } else
                r3 = t5.a;
            }
            0 == r3 && null != s4.Oa && s4.Oa.fd && (r3 = Er(s4.ba));
          }
          s4 = r3;
        }
        o4 = 0 != s4 ? null : 11 > o4 ? c6.f.RGBA.eb : c6.f.kb.y;
      } else
        o4 = null;
      return o4;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u3(t4, e3) {
    for (var r3 = "", n4 = 0; n4 < 4; n4++)
      r3 += String.fromCharCode(t4[e3++]);
    return r3;
  }
  function h3(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16) >>> 0;
  }
  function l3(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24) >>> 0;
  }
  new c4();
  var f3 = [0], d2 = [0], p3 = [], g2 = new c4(), m4 = t3, v3 = function(t4, e3) {
    var r3 = {}, n4 = 0, i4 = false, a4 = 0, o4 = 0;
    if (r3.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(t5, e4, r4, n5) {
      for (var i5 = 0; i5 < n5; i5++)
        if (t5[e4 + i5] != r4.charCodeAt(i5))
          return true;
      return false;
    }(t4, e3, "RIFF", 4)) {
      var s4, c5;
      l3(t4, e3 += 4);
      for (e3 += 8; e3 < t4.length; ) {
        var f4 = u3(t4, e3), d3 = l3(t4, e3 += 4);
        e3 += 4;
        var p4 = d3 + (1 & d3);
        switch (f4) {
          case "VP8 ":
          case "VP8L":
            void 0 === r3.frames[n4] && (r3.frames[n4] = {});
            (v4 = r3.frames[n4]).src_off = i4 ? o4 : e3 - 8, v4.src_size = a4 + d3 + 8, n4++, i4 && (i4 = false, a4 = 0, o4 = 0);
            break;
          case "VP8X":
            (v4 = r3.header = {}).feature_flags = t4[e3];
            var g3 = e3 + 4;
            v4.canvas_width = 1 + h3(t4, g3);
            g3 += 3;
            v4.canvas_height = 1 + h3(t4, g3);
            g3 += 3;
            break;
          case "ALPH":
            i4 = true, a4 = p4 + 8, o4 = e3 - 8;
            break;
          case "ANIM":
            (v4 = r3.header).bgcolor = l3(t4, e3);
            g3 = e3 + 4;
            v4.loop_count = (s4 = t4)[(c5 = g3) + 0] << 0 | s4[c5 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m5, v4;
            (v4 = r3.frames[n4] = {}).offset_x = 2 * h3(t4, e3), e3 += 3, v4.offset_y = 2 * h3(t4, e3), e3 += 3, v4.width = 1 + h3(t4, e3), e3 += 3, v4.height = 1 + h3(t4, e3), e3 += 3, v4.duration = h3(t4, e3), e3 += 3, m5 = t4[e3++], v4.dispose = 1 & m5, v4.blend = m5 >> 1 & 1;
        }
        "ANMF" != f4 && (e3 += p4);
      }
      return r3;
    }
  }(m4, 0);
  v3.response = m4, v3.rgbaoutput = true, v3.dataurl = false;
  var b2 = v3.header ? v3.header : null, y3 = v3.frames ? v3.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f3 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0; w2 < y3.length && 0 != y3[w2].blend; w2++)
      ;
  }
  var N3 = y3[0], L2 = g2.WebPDecodeRGBA(m4, N3.src_off, N3.src_size, d2, f3);
  N3.rgba = L2, N3.imgwidth = d2[0], N3.imgheight = f3[0];
  for (var A2 = 0; A2 < d2[0] * f3[0] * 4; A2++)
    p3[A2] = L2[A2];
  return this.width = d2, this.height = f3, this.data = p3, this;
}
!function(t3) {
  var r2 = function() {
    return "function" == typeof zlibSync;
  }, n3 = function(r3, n4, a4, h4) {
    var l4 = 4, f4 = s3;
    switch (h4) {
      case t3.image_compression.FAST:
        l4 = 1, f4 = o3;
        break;
      case t3.image_compression.MEDIUM:
        l4 = 6, f4 = c4;
        break;
      case t3.image_compression.SLOW:
        l4 = 9, f4 = u3;
    }
    r3 = i3(r3, n4, a4, f4);
    var d2 = zlibSync(r3, { level: l4 });
    return t3.__addimage__.arrayBufferToBinaryString(d2);
  }, i3 = function(t4, e2, r3, n4) {
    for (var i4, a4, o4, s4 = t4.length / e2, c5 = new Uint8Array(t4.length + s4), u4 = l3(), h4 = 0; h4 < s4; h4 += 1) {
      if (o4 = h4 * e2, i4 = t4.subarray(o4, o4 + e2), n4)
        c5.set(n4(i4, r3, a4), o4 + h4);
      else {
        for (var d2, p3 = u4.length, g2 = []; d2 < p3; d2 += 1)
          g2[d2] = u4[d2](i4, r3, a4);
        var m4 = f3(g2.concat());
        c5.set(g2[m4], o4 + h4);
      }
      a4 = i4;
    }
    return c5;
  }, a3 = function(t4) {
    var e2 = Array.apply([], t4);
    return e2.unshift(0), e2;
  }, o3 = function(t4, e2) {
    var r3, n4 = [], i4 = t4.length;
    n4[0] = 1;
    for (var a4 = 0; a4 < i4; a4 += 1)
      r3 = t4[a4 - e2] || 0, n4[a4 + 1] = t4[a4] - r3 + 256 & 255;
    return n4;
  }, s3 = function(t4, e2, r3) {
    var n4, i4 = [], a4 = t4.length;
    i4[0] = 2;
    for (var o4 = 0; o4 < a4; o4 += 1)
      n4 = r3 && r3[o4] || 0, i4[o4 + 1] = t4[o4] - n4 + 256 & 255;
    return i4;
  }, c4 = function(t4, e2, r3) {
    var n4, i4, a4 = [], o4 = t4.length;
    a4[0] = 3;
    for (var s4 = 0; s4 < o4; s4 += 1)
      n4 = t4[s4 - e2] || 0, i4 = r3 && r3[s4] || 0, a4[s4 + 1] = t4[s4] + 256 - (n4 + i4 >>> 1) & 255;
    return a4;
  }, u3 = function(t4, e2, r3) {
    var n4, i4, a4, o4, s4 = [], c5 = t4.length;
    s4[0] = 4;
    for (var u4 = 0; u4 < c5; u4 += 1)
      n4 = t4[u4 - e2] || 0, i4 = r3 && r3[u4] || 0, a4 = r3 && r3[u4 - e2] || 0, o4 = h3(n4, i4, a4), s4[u4 + 1] = t4[u4] - o4 + 256 & 255;
    return s4;
  }, h3 = function(t4, e2, r3) {
    if (t4 === e2 && e2 === r3)
      return t4;
    var n4 = Math.abs(e2 - r3), i4 = Math.abs(t4 - r3), a4 = Math.abs(t4 + e2 - r3 - r3);
    return n4 <= i4 && n4 <= a4 ? t4 : i4 <= a4 ? e2 : r3;
  }, l3 = function() {
    return [a3, o3, s3, c4, u3];
  }, f3 = function(t4) {
    var e2 = t4.map(function(t5) {
      return t5.reduce(function(t6, e3) {
        return t6 + Math.abs(e3);
      }, 0);
    });
    return e2.indexOf(Math.min.apply(null, e2));
  };
  t3.processPNG = function(e2, i4, a4, o4) {
    var s4, c5, u4, h4, l4, f4, d2, p3, g2, m4, v3, b2, y3, w2, N3, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e2) && (e2 = new Uint8Array(e2)), this.__addimage__.isArrayBufferView(e2)) {
      if (e2 = (u4 = new Kt(e2)).imgData, c5 = u4.bits, s4 = u4.colorSpace, l4 = u4.colors, -1 !== [4, 6].indexOf(u4.colorType)) {
        if (8 === u4.bits) {
          g2 = (p3 = 32 == u4.pixelBitlength ? new Uint32Array(u4.decodePixels().buffer) : 16 == u4.pixelBitlength ? new Uint16Array(u4.decodePixels().buffer) : new Uint8Array(u4.decodePixels().buffer)).length, v3 = new Uint8Array(g2 * u4.colors), m4 = new Uint8Array(g2);
          var x2, S2 = u4.pixelBitlength - u4.bits;
          for (w2 = 0, N3 = 0; w2 < g2; w2++) {
            for (y3 = p3[w2], x2 = 0; x2 < S2; )
              v3[N3++] = y3 >>> x2 & 255, x2 += u4.bits;
            m4[w2] = y3 >>> x2 & 255;
          }
        }
        if (16 === u4.bits) {
          g2 = (p3 = new Uint32Array(u4.decodePixels().buffer)).length, v3 = new Uint8Array(g2 * (32 / u4.pixelBitlength) * u4.colors), m4 = new Uint8Array(g2 * (32 / u4.pixelBitlength)), b2 = u4.colors > 1, w2 = 0, N3 = 0;
          for (var _3 = 0; w2 < g2; )
            y3 = p3[w2++], v3[N3++] = y3 >>> 0 & 255, b2 && (v3[N3++] = y3 >>> 16 & 255, y3 = p3[w2++], v3[N3++] = y3 >>> 0 & 255), m4[_3++] = y3 >>> 16 & 255;
          c5 = 8;
        }
        o4 !== t3.image_compression.NONE && r2() ? (e2 = n3(v3, u4.width * u4.colors, u4.colors, o4), d2 = n3(m4, u4.width, 1, o4)) : (e2 = v3, d2 = m4, L2 = void 0);
      }
      if (3 === u4.colorType && (s4 = this.color_spaces.INDEXED, f4 = u4.palette, u4.transparency.indexed)) {
        var P2 = u4.transparency.indexed, k2 = 0;
        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2)
          k2 += P2[w2];
        if ((k2 /= 255) === g2 - 1 && -1 !== P2.indexOf(0))
          h4 = [P2.indexOf(0)];
        else if (k2 !== g2) {
          for (p3 = u4.decodePixels(), m4 = new Uint8Array(p3.length), w2 = 0, g2 = p3.length; w2 < g2; w2++)
            m4[w2] = P2[p3[w2]];
          d2 = n3(m4, u4.width, 1);
        }
      }
      var I2 = function(e3) {
        var r3;
        switch (e3) {
          case t3.image_compression.FAST:
            r3 = 11;
            break;
          case t3.image_compression.MEDIUM:
            r3 = 13;
            break;
          case t3.image_compression.SLOW:
            r3 = 14;
            break;
          default:
            r3 = 12;
        }
        return r3;
      }(o4);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l4 + " /BitsPerComponent " + c5 + " /Columns " + u4.width, (this.__addimage__.isArrayBuffer(e2) || this.__addimage__.isArrayBufferView(e2)) && (e2 = this.__addimage__.arrayBufferToBinaryString(e2)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a4, data: e2, index: i4, filter: L2, decodeParameters: A2, transparency: h4, palette: f4, sMask: d2, predictor: I2, width: u4.width, height: u4.height, bitsPerComponent: c5, colorSpace: s4 };
    }
  };
}(E.API), function(t3) {
  t3.processGIF89A = function(e2, r2, n3, i3) {
    var a3 = new Zt(e2), o3 = a3.width, s3 = a3.height, c4 = [];
    a3.decodeAndBlitFrameRGBA(0, c4);
    var u3 = { data: c4, width: o3, height: s3 }, h3 = new Qt(100).encode(u3, 100);
    return t3.processJPEG.call(this, h3, r2, n3, i3);
  }, t3.processGIF87A = t3.processGIF89A;
}(E.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t3 = 0 === this.colors ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t3);
    for (var e2 = 0; e2 < t3; e2++) {
      var r2 = this.datav.getUint8(this.pos++, true), n3 = this.datav.getUint8(this.pos++, true), i3 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true);
      this.palette[e2] = { red: i3, green: n3, blue: r2, quad: a3 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t3 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
    this.data = new Uint8Array(e2), this[t3]();
  } catch (t4) {
    a2.log("bit decode error:" + t4);
  }
}, te.prototype.bit1 = function() {
  var t3, e2 = Math.ceil(this.width / 8), r2 = e2 % 4;
  for (t3 = this.height - 1; t3 >= 0; t3--) {
    for (var n3 = this.bottom_up ? t3 : this.height - 1 - t3, i3 = 0; i3 < e2; i3++)
      for (var a3 = this.datav.getUint8(this.pos++, true), o3 = n3 * this.width * 4 + 8 * i3 * 4, s3 = 0; s3 < 8 && 8 * i3 + s3 < this.width; s3++) {
        var c4 = this.palette[a3 >> 7 - s3 & 1];
        this.data[o3 + 4 * s3] = c4.blue, this.data[o3 + 4 * s3 + 1] = c4.green, this.data[o3 + 4 * s3 + 2] = c4.red, this.data[o3 + 4 * s3 + 3] = 255;
      }
    0 !== r2 && (this.pos += 4 - r2);
  }
}, te.prototype.bit4 = function() {
  for (var t3 = Math.ceil(this.width / 2), e2 = t3 % 4, r2 = this.height - 1; r2 >= 0; r2--) {
    for (var n3 = this.bottom_up ? r2 : this.height - 1 - r2, i3 = 0; i3 < t3; i3++) {
      var a3 = this.datav.getUint8(this.pos++, true), o3 = n3 * this.width * 4 + 2 * i3 * 4, s3 = a3 >> 4, c4 = 15 & a3, u3 = this.palette[s3];
      if (this.data[o3] = u3.blue, this.data[o3 + 1] = u3.green, this.data[o3 + 2] = u3.red, this.data[o3 + 3] = 255, 2 * i3 + 1 >= this.width)
        break;
      u3 = this.palette[c4], this.data[o3 + 4] = u3.blue, this.data[o3 + 4 + 1] = u3.green, this.data[o3 + 4 + 2] = u3.red, this.data[o3 + 4 + 3] = 255;
    }
    0 !== e2 && (this.pos += 4 - e2);
  }
}, te.prototype.bit8 = function() {
  for (var t3 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {
    for (var r2 = this.bottom_up ? e2 : this.height - 1 - e2, n3 = 0; n3 < this.width; n3++) {
      var i3 = this.datav.getUint8(this.pos++, true), a3 = r2 * this.width * 4 + 4 * n3;
      if (i3 < this.palette.length) {
        var o3 = this.palette[i3];
        this.data[a3] = o3.red, this.data[a3 + 1] = o3.green, this.data[a3 + 2] = o3.blue, this.data[a3 + 3] = 255;
      } else
        this.data[a3] = 255, this.data[a3 + 1] = 255, this.data[a3 + 2] = 255, this.data[a3 + 3] = 255;
    }
    0 !== t3 && (this.pos += 4 - t3);
  }
}, te.prototype.bit15 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
    for (var n3 = this.bottom_up ? r2 : this.height - 1 - r2, i3 = 0; i3 < this.width; i3++) {
      var a3 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o3 = (a3 & e2) / e2 * 255 | 0, s3 = (a3 >> 5 & e2) / e2 * 255 | 0, c4 = (a3 >> 10 & e2) / e2 * 255 | 0, u3 = a3 >> 15 ? 255 : 0, h3 = n3 * this.width * 4 + 4 * i3;
      this.data[h3] = c4, this.data[h3 + 1] = s3, this.data[h3 + 2] = o3, this.data[h3 + 3] = u3;
    }
    this.pos += t3;
  }
}, te.prototype.bit16 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = parseInt("111111", 2), n3 = this.height - 1; n3 >= 0; n3--) {
    for (var i3 = this.bottom_up ? n3 : this.height - 1 - n3, a3 = 0; a3 < this.width; a3++) {
      var o3 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s3 = (o3 & e2) / e2 * 255 | 0, c4 = (o3 >> 5 & r2) / r2 * 255 | 0, u3 = (o3 >> 11) / e2 * 255 | 0, h3 = i3 * this.width * 4 + 4 * a3;
      this.data[h3] = u3, this.data[h3 + 1] = c4, this.data[h3 + 2] = s3, this.data[h3 + 3] = 255;
    }
    this.pos += t3;
  }
}, te.prototype.bit24 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--) {
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n3 = this.datav.getUint8(this.pos++, true), i3 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true), o3 = e2 * this.width * 4 + 4 * r2;
      this.data[o3] = a3, this.data[o3 + 1] = i3, this.data[o3 + 2] = n3, this.data[o3 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--)
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n3 = this.datav.getUint8(this.pos++, true), i3 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true), o3 = this.datav.getUint8(this.pos++, true), s3 = e2 * this.width * 4 + 4 * r2;
      this.data[s3] = a3, this.data[s3 + 1] = i3, this.data[s3 + 2] = n3, this.data[s3 + 3] = o3;
    }
}, te.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  t3.processBMP = function(e2, r2, n3, i3) {
    var a3 = new te(e2, false), o3 = a3.width, s3 = a3.height, c4 = { data: a3.getData(), width: o3, height: s3 }, u3 = new Qt(100).encode(c4, 100);
    return t3.processJPEG.call(this, u3, r2, n3, i3);
  };
}(E.API), ee.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  t3.processWEBP = function(e2, r2, n3, i3) {
    var a3 = new ee(e2, false), o3 = a3.width, s3 = a3.height, c4 = { data: a3.getData(), width: o3, height: s3 }, u3 = new Qt(100).encode(c4, 100);
    return t3.processJPEG.call(this, u3, r2, n3, i3);
  };
}(E.API), E.API.processRGBA = function(t3, e2, r2) {
  for (var n3 = t3.data, i3 = n3.length, a3 = new Uint8Array(i3 / 4 * 3), o3 = new Uint8Array(i3 / 4), s3 = 0, c4 = 0, u3 = 0; u3 < i3; u3 += 4) {
    var h3 = n3[u3], l3 = n3[u3 + 1], f3 = n3[u3 + 2], d2 = n3[u3 + 3];
    a3[s3++] = h3, a3[s3++] = l3, a3[s3++] = f3, o3[c4++] = d2;
  }
  var p3 = this.__addimage__.arrayBufferToBinaryString(a3);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o3), data: p3, index: e2, alias: r2, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t3.width, height: t3.height };
}, E.API.setLanguage = function(t3) {
  return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t3] && (this.internal.languageSettings.languageCode = t3, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e2, r2) {
  var n3, i3, a3 = (r2 = r2 || {}).font || this.internal.getFont(), o3 = r2.fontSize || this.internal.getFontSize(), s3 = r2.charSpace || this.internal.getCharSpace(), c4 = r2.widths ? r2.widths : a3.metadata.Unicode.widths, u3 = c4.fof ? c4.fof : 1, h3 = r2.kerning ? r2.kerning : a3.metadata.Unicode.kerning, l3 = h3.fof ? h3.fof : 1, f3 = false !== r2.doKerning, d2 = 0, p3 = e2.length, g2 = 0, m4 = c4[0] || u3, v3 = [];
  for (n3 = 0; n3 < p3; n3++)
    i3 = e2.charCodeAt(n3), "function" == typeof a3.metadata.widthOfString ? v3.push((a3.metadata.widthOfGlyph(a3.metadata.characterToGlyph(i3)) + s3 * (1e3 / o3) || 0) / 1e3) : (d2 = f3 && "object" === _typeof(h3[i3]) && !isNaN(parseInt(h3[i3][g2], 10)) ? h3[i3][g2] / l3 : 0, v3.push((c4[i3] || m4) / u3 + d2)), g2 = i3;
  return v3;
}, Yt = Vt.getStringUnitWidth = function(t3, e2) {
  var r2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), n3 = e2.font || this.internal.getFont(), i3 = e2.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t3 = Vt.processArabic(t3)), "function" == typeof n3.metadata.widthOfString ? n3.metadata.widthOfString(t3, r2, i3) / r2 : Gt.apply(this, arguments).reduce(function(t4, e3) {
    return t4 + e3;
  }, 0);
}, Jt = function(t3, e2, r2, n3) {
  for (var i3 = [], a3 = 0, o3 = t3.length, s3 = 0; a3 !== o3 && s3 + e2[a3] < r2; )
    s3 += e2[a3], a3++;
  i3.push(t3.slice(0, a3));
  var c4 = a3;
  for (s3 = 0; a3 !== o3; )
    s3 + e2[a3] > n3 && (i3.push(t3.slice(c4, a3)), s3 = 0, c4 = a3), s3 += e2[a3], a3++;
  return c4 !== a3 && i3.push(t3.slice(c4, a3)), i3;
}, Xt = function(t3, e2, r2) {
  r2 || (r2 = {});
  var n3, i3, a3, o3, s3, c4, u3, h3 = [], l3 = [h3], f3 = r2.textIndent || 0, d2 = 0, p3 = 0, g2 = t3.split(" "), m4 = Gt.apply(this, [" ", r2])[0];
  if (c4 = -1 === r2.lineIndent ? g2[0].length + 2 : r2.lineIndent || 0) {
    var v3 = Array(c4).join(" "), b2 = [];
    g2.map(function(t4) {
      (t4 = t4.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t4.map(function(t5, e3) {
        return (e3 && t5.length ? "\n" : "") + t5;
      })) : b2.push(t4[0]);
    }), g2 = b2, c4 = Yt.apply(this, [v3, r2]);
  }
  for (a3 = 0, o3 = g2.length; a3 < o3; a3++) {
    var y3 = 0;
    if (n3 = g2[a3], c4 && "\n" == n3[0] && (n3 = n3.substr(1), y3 = 1), f3 + d2 + (p3 = (i3 = Gt.apply(this, [n3, r2])).reduce(function(t4, e3) {
      return t4 + e3;
    }, 0)) > e2 || y3) {
      if (p3 > e2) {
        for (s3 = Jt.apply(this, [n3, i3, e2 - (f3 + d2), e2]), h3.push(s3.shift()), h3 = [s3.pop()]; s3.length; )
          l3.push([s3.shift()]);
        p3 = i3.slice(n3.length - (h3[0] ? h3[0].length : 0)).reduce(function(t4, e3) {
          return t4 + e3;
        }, 0);
      } else
        h3 = [n3];
      l3.push(h3), f3 = p3 + c4, d2 = m4;
    } else
      h3.push(n3), f3 += d2 + p3, d2 = m4;
  }
  return u3 = c4 ? function(t4, e3) {
    return (e3 ? v3 : "") + t4.join(" ");
  } : function(t4) {
    return t4.join(" ");
  }, l3.map(u3);
}, Vt.splitTextToSize = function(t3, e2, r2) {
  var n3, i3 = (r2 = r2 || {}).fontSize || this.internal.getFontSize(), a3 = function(t4) {
    if (t4.widths && t4.kerning)
      return { widths: t4.widths, kerning: t4.kerning };
    var e3 = this.internal.getFont(t4.fontName, t4.fontStyle);
    return e3.metadata.Unicode ? { widths: e3.metadata.Unicode.widths || { 0: 1 }, kerning: e3.metadata.Unicode.kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }.call(this, r2);
  n3 = Array.isArray(t3) ? t3 : String(t3).split(/\r?\n/);
  var o3 = 1 * this.internal.scaleFactor * e2 / i3;
  a3.textIndent = r2.textIndent ? 1 * r2.textIndent * this.internal.scaleFactor / i3 : 0, a3.lineIndent = r2.lineIndent;
  var s3, c4, u3 = [];
  for (s3 = 0, c4 = n3.length; s3 < c4; s3++)
    u3 = u3.concat(Xt.apply(this, [n3[s3], o3, a3]));
  return u3;
}, function(e2) {
  e2.__fontmetrics__ = e2.__fontmetrics__ || {};
  for (var r2 = "klmnopqrstuvwxyz", n3 = {}, i3 = {}, a3 = 0; a3 < r2.length; a3++)
    n3[r2[a3]] = "0123456789abcdef"[a3], i3["0123456789abcdef"[a3]] = r2[a3];
  var o3 = function(t3) {
    return "0x" + parseInt(t3, 10).toString(16);
  }, s3 = e2.__fontmetrics__.compress = function(e3) {
    var r3, n4, a4, c5, u4 = ["{"];
    for (var h4 in e3) {
      if (r3 = e3[h4], isNaN(parseInt(h4, 10)) ? n4 = "'" + h4 + "'" : (h4 = parseInt(h4, 10), n4 = (n4 = o3(h4).slice(2)).slice(0, -1) + i3[n4.slice(-1)]), "number" == typeof r3)
        r3 < 0 ? (a4 = o3(r3).slice(3), c5 = "-") : (a4 = o3(r3).slice(2), c5 = ""), a4 = c5 + a4.slice(0, -1) + i3[a4.slice(-1)];
      else {
        if ("object" !== _typeof(r3))
          throw new Error("Don't know what to do with value type " + _typeof(r3) + ".");
        a4 = s3(r3);
      }
      u4.push(n4 + a4);
    }
    return u4.push("}"), u4.join("");
  }, c4 = e2.__fontmetrics__.uncompress = function(t3) {
    if ("string" != typeof t3)
      throw new Error("Invalid argument passed to uncompress.");
    for (var e3, r3, i4, a4, o4 = {}, s4 = 1, c5 = o4, u4 = [], h4 = "", l4 = "", f3 = t3.length - 1, d2 = 1; d2 < f3; d2 += 1)
      "'" == (a4 = t3[d2]) ? e3 ? (i4 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a4) : "{" == a4 ? (u4.push([c5, i4]), c5 = {}, i4 = void 0) : "}" == a4 ? ((r3 = u4.pop())[0][r3[1]] = c5, i4 = void 0, c5 = r3[0]) : "-" == a4 ? s4 = -1 : void 0 === i4 ? n3.hasOwnProperty(a4) ? (h4 += n3[a4], i4 = parseInt(h4, 16) * s4, s4 = 1, h4 = "") : h4 += a4 : n3.hasOwnProperty(a4) ? (l4 += n3[a4], c5[i4] = parseInt(l4, 16) * s4, s4 = 1, i4 = void 0, l4 = "") : l4 += a4;
    return o4;
  }, u3 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c4("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h3 = { Unicode: { Courier: u3, "Courier-Bold": u3, "Courier-BoldOblique": u3, "Courier-Oblique": u3, Helvetica: u3, "Helvetica-Bold": u3, "Helvetica-BoldOblique": u3, "Helvetica-Oblique": u3, "Times-Roman": u3, "Times-Bold": u3, "Times-BoldItalic": u3, "Times-Italic": u3 } }, l3 = { Unicode: { "Courier-Oblique": c4("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c4("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c4("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c4("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c4("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c4("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c4("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c4("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c4("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c4("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c4("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c4("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c4("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c4("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e2.events.push(["addFont", function(t3) {
    var e3 = t3.font, r3 = l3.Unicode[e3.postScriptName];
    r3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r3.widths, e3.metadata.Unicode.kerning = r3.kerning);
    var n4 = h3.Unicode[e3.postScriptName];
    n4 && (e3.metadata.Unicode.encoding = n4, e3.encoding = n4.codePages[0]);
  }]);
}(E.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = function(t4) {
    for (var e3 = t4.length, r2 = new Uint8Array(e3), n3 = 0; n3 < e3; n3++)
      r2[n3] = t4.charCodeAt(n3);
    return r2;
  };
  t3.API.events.push(["addFont", function(r2) {
    var n3 = void 0, i3 = r2.font, a3 = r2.instance;
    if (!i3.isStandardFont) {
      if (void 0 === a3)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i3.postScriptName + "').");
      if ("string" != typeof (n3 = false === a3.existsFileInVFS(i3.postScriptName) ? a3.loadFile(i3.postScriptName) : a3.getFileFromVFS(i3.postScriptName)))
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i3.postScriptName + "').");
      !function(r3, n4) {
        n4 = /^\x00\x01\x00\x00/.test(n4) ? e2(n4) : e2(u2(n4)), r3.metadata = t3.API.TTFFont.open(n4), r3.metadata.Unicode = r3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r3.metadata.glyIdsUsed = [0];
      }(i3, n3);
    }
  }]);
}(E), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t3) {
  function e2() {
    return (n2.canvg ? Promise.resolve(n2.canvg) : Promise.resolve().then(() => (init_index_es(), index_es_exports))).catch(function(t4) {
      return Promise.reject(new Error("Could not load canvg: " + t4));
    }).then(function(t4) {
      return t4.default ? t4.default : t4;
    });
  }
  E.API.addSvgAsImage = function(t4, r2, n3, i3, o3, s3, c4, u3) {
    if (isNaN(r2) || isNaN(n3))
      throw a2.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i3) || isNaN(o3))
      throw a2.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h3 = document.createElement("canvas");
    h3.width = i3, h3.height = o3;
    var l3 = h3.getContext("2d");
    l3.fillStyle = "#fff", l3.fillRect(0, 0, h3.width, h3.height);
    var f3 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return e2().then(function(e3) {
      return e3.fromString(l3, t4, f3);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t5) {
      return t5.render(f3);
    }).then(function() {
      d2.addImage(h3.toDataURL("image/jpeg", 1), r2, n3, i3, o3, c4, u3);
    });
  };
}(), E.API.putTotalPages = function(t3) {
  var e2, r2 = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t3, "g"), r2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t3, this.internal.getFont()), "g"), r2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n3 = 1; n3 <= this.internal.getNumberOfPages(); n3++)
    for (var i3 = 0; i3 < this.internal.pages[n3].length; i3++)
      this.internal.pages[n3][i3] = this.internal.pages[n3][i3].replace(e2, r2);
  return this;
}, E.API.viewerPreferences = function(e2, r2) {
  var n3;
  e2 = e2 || {}, r2 = r2 || false;
  var i3, a3, o3, s3 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c4 = Object.keys(s3), u3 = [], h3 = 0, l3 = 0, f3 = 0;
  function d2(t3, e3) {
    var r3, n4 = false;
    for (r3 = 0; r3 < t3.length; r3 += 1)
      t3[r3] === e3 && (n4 = true);
    return n4;
  }
  if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s3)), this.internal.viewerpreferences.isSubscribed = false), n3 = this.internal.viewerpreferences.configuration, "reset" === e2 || true === r2) {
    var p3 = c4.length;
    for (f3 = 0; f3 < p3; f3 += 1)
      n3[c4[f3]].value = n3[c4[f3]].defaultValue, n3[c4[f3]].explicitSet = false;
  }
  if ("object" === _typeof(e2)) {
    for (a3 in e2)
      if (o3 = e2[a3], d2(c4, a3) && void 0 !== o3) {
        if ("boolean" === n3[a3].type && "boolean" == typeof o3)
          n3[a3].value = o3;
        else if ("name" === n3[a3].type && d2(n3[a3].valueSet, o3))
          n3[a3].value = o3;
        else if ("integer" === n3[a3].type && Number.isInteger(o3))
          n3[a3].value = o3;
        else if ("array" === n3[a3].type) {
          for (h3 = 0; h3 < o3.length; h3 += 1)
            if (i3 = true, 1 === o3[h3].length && "number" == typeof o3[h3][0])
              u3.push(String(o3[h3] - 1));
            else if (o3[h3].length > 1) {
              for (l3 = 0; l3 < o3[h3].length; l3 += 1)
                "number" != typeof o3[h3][l3] && (i3 = false);
              true === i3 && u3.push([o3[h3][0] - 1, o3[h3][1] - 1].join(" "));
            }
          n3[a3].value = "[" + u3.join(" ") + "]";
        } else
          n3[a3].value = n3[a3].defaultValue;
        n3[a3].explicitSet = true;
      }
  }
  return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    var t3, e3 = [];
    for (t3 in n3)
      true === n3[t3].explicitSet && ("name" === n3[t3].type ? e3.push("/" + t3 + " /" + n3[t3].value) : e3.push("/" + t3 + " " + n3[t3].value));
    0 !== e3.length && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n3, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t3) {
  var e2 = function() {
    var t4 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r3 = unescape(encodeURIComponent(t4)), n3 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i3 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a3 = unescape(encodeURIComponent("</x:xmpmeta>")), o3 = r3.length + n3.length + i3.length + e3.length + a3.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o3 + " >>"), this.internal.write("stream"), this.internal.write(e3 + r3 + n3 + i3 + a3), this.internal.write("endstream"), this.internal.write("endobj");
  }, r2 = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t3.addMetadata = function(t4, n3) {
    return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t4, namespaceuri: n3 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r2), this.internal.events.subscribe("postPutResources", e2)), this;
  };
}(E.API), function(t3) {
  var e2 = t3.API, r2 = e2.pdfEscape16 = function(t4, e3) {
    for (var r3, n4 = e3.metadata.Unicode.widths, i4 = ["", "0", "00", "000", "0000"], a3 = [""], o3 = 0, s3 = t4.length; o3 < s3; ++o3) {
      if (r3 = e3.metadata.characterToGlyph(t4.charCodeAt(o3)), e3.metadata.glyIdsUsed.push(r3), e3.metadata.toUnicode[r3] = t4.charCodeAt(o3), -1 == n4.indexOf(r3) && (n4.push(r3), n4.push([parseInt(e3.metadata.widthOfGlyph(r3), 10)])), "0" == r3)
        return a3.join("");
      r3 = r3.toString(16), a3.push(i4[4 - r3.length], r3);
    }
    return a3.join("");
  }, n3 = function(t4) {
    var e3, r3, n4, i4, a3, o3, s3;
    for (a3 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n4 = [], o3 = 0, s3 = (r3 = Object.keys(t4).sort(function(t5, e4) {
      return t5 - e4;
    })).length; o3 < s3; o3++)
      e3 = r3[o3], n4.length >= 100 && (a3 += "\n" + n4.length + " beginbfchar\n" + n4.join("\n") + "\nendbfchar", n4 = []), void 0 !== t4[e3] && null !== t4[e3] && "function" == typeof t4[e3].toString && (i4 = ("0000" + t4[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), n4.push("<" + e3 + "><" + i4 + ">"));
    return n4.length && (a3 += "\n" + n4.length + " beginbfchar\n" + n4.join("\n") + "\nendbfchar\n"), a3 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r3 = e4.font, i4 = e4.out, a3 = e4.newObject, o3 = e4.putStream;
      if (r3.metadata instanceof t3.API.TTFFont && "Identity-H" === r3.encoding) {
        for (var s3 = r3.metadata.Unicode.widths, c4 = r3.metadata.subset.encode(r3.metadata.glyIdsUsed, 1), u3 = "", h3 = 0; h3 < c4.length; h3++)
          u3 += String.fromCharCode(c4[h3]);
        var l3 = a3();
        o3({ data: u3, addLength1: true, objectId: l3 }), i4("endobj");
        var f3 = a3();
        o3({ data: n3(r3.metadata.toUnicode), addLength1: true, objectId: f3 }), i4("endobj");
        var d2 = a3();
        i4("<<"), i4("/Type /FontDescriptor"), i4("/FontName /" + F(r3.fontName)), i4("/FontFile2 " + l3 + " 0 R"), i4("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i4("/Flags " + r3.metadata.flags), i4("/StemV " + r3.metadata.stemV), i4("/ItalicAngle " + r3.metadata.italicAngle), i4("/Ascent " + r3.metadata.ascender), i4("/Descent " + r3.metadata.decender), i4("/CapHeight " + r3.metadata.capHeight), i4(">>"), i4("endobj");
        var p3 = a3();
        i4("<<"), i4("/Type /Font"), i4("/BaseFont /" + F(r3.fontName)), i4("/FontDescriptor " + d2 + " 0 R"), i4("/W " + t3.API.PDFObject.convert(s3)), i4("/CIDToGIDMap /Identity"), i4("/DW 1000"), i4("/Subtype /CIDFontType2"), i4("/CIDSystemInfo"), i4("<<"), i4("/Supplement 0"), i4("/Registry (Adobe)"), i4("/Ordering (" + r3.encoding + ")"), i4(">>"), i4(">>"), i4("endobj"), r3.objectNumber = a3(), i4("<<"), i4("/Type /Font"), i4("/Subtype /Type0"), i4("/ToUnicode " + f3 + " 0 R"), i4("/BaseFont /" + F(r3.fontName)), i4("/Encoding /" + r3.encoding), i4("/DescendantFonts [" + p3 + " 0 R]"), i4(">>"), i4("endobj"), r3.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r3 = e4.font, i4 = e4.out, a3 = e4.newObject, o3 = e4.putStream;
      if (r3.metadata instanceof t3.API.TTFFont && "WinAnsiEncoding" === r3.encoding) {
        for (var s3 = r3.metadata.rawData, c4 = "", u3 = 0; u3 < s3.length; u3++)
          c4 += String.fromCharCode(s3[u3]);
        var h3 = a3();
        o3({ data: c4, addLength1: true, objectId: h3 }), i4("endobj");
        var l3 = a3();
        o3({ data: n3(r3.metadata.toUnicode), addLength1: true, objectId: l3 }), i4("endobj");
        var f3 = a3();
        i4("<<"), i4("/Descent " + r3.metadata.decender), i4("/CapHeight " + r3.metadata.capHeight), i4("/StemV " + r3.metadata.stemV), i4("/Type /FontDescriptor"), i4("/FontFile2 " + h3 + " 0 R"), i4("/Flags 96"), i4("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i4("/FontName /" + F(r3.fontName)), i4("/ItalicAngle " + r3.metadata.italicAngle), i4("/Ascent " + r3.metadata.ascender), i4(">>"), i4("endobj"), r3.objectNumber = a3();
        for (var d2 = 0; d2 < r3.metadata.hmtx.widths.length; d2++)
          r3.metadata.hmtx.widths[d2] = parseInt(r3.metadata.hmtx.widths[d2] * (1e3 / r3.metadata.head.unitsPerEm));
        i4("<</Subtype/TrueType/Type/Font/ToUnicode " + l3 + " 0 R/BaseFont/" + F(r3.fontName) + "/FontDescriptor " + f3 + " 0 R/Encoding/" + r3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t3.API.PDFObject.convert(r3.metadata.hmtx.widths) + ">>"), i4("endobj"), r3.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  var i3 = function(t4) {
    var e3, n4 = t4.text || "", i4 = t4.x, a3 = t4.y, o3 = t4.options || {}, s3 = t4.mutex || {}, c4 = s3.pdfEscape, u3 = s3.activeFontKey, h3 = s3.fonts, l3 = u3, f3 = "", d2 = 0, p3 = "", g2 = h3[l3].encoding;
    if ("Identity-H" !== h3[l3].encoding)
      return { text: n4, x: i4, y: a3, options: o3, mutex: s3 };
    for (p3 = n4, l3 = u3, Array.isArray(n4) && (p3 = n4[0]), d2 = 0; d2 < p3.length; d2 += 1)
      h3[l3].metadata.hasOwnProperty("cmap") && (e3 = h3[l3].metadata.cmap.unicode.codeMap[p3[d2].charCodeAt(0)]), e3 || p3[d2].charCodeAt(0) < 256 && h3[l3].metadata.hasOwnProperty("Unicode") ? f3 += p3[d2] : f3 += "";
    var m4 = "";
    return parseInt(l3.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m4 = c4(f3, l3).split("").map(function(t5) {
      return t5.charCodeAt(0).toString(16);
    }).join("") : "Identity-H" === g2 && (m4 = r2(f3, h3[l3])), s3.isHex = true, { text: m4, x: i4, y: a3, options: o3, mutex: s3 };
  };
  e2.events.push(["postProcessText", function(t4) {
    var e3 = t4.text || "", r3 = [], n4 = { text: e3, x: t4.x, y: t4.y, options: t4.options, mutex: t4.mutex };
    if (Array.isArray(e3)) {
      var a3 = 0;
      for (a3 = 0; a3 < e3.length; a3 += 1)
        Array.isArray(e3[a3]) && 3 === e3[a3].length ? r3.push([i3(Object.assign({}, n4, { text: e3[a3][0] })).text, e3[a3][1], e3[a3][2]]) : r3.push(i3(Object.assign({}, n4, { text: e3[a3] })).text);
      t4.text = r3;
    } else
      t4.text = i3(Object.assign({}, n4, { text: e3 })).text;
  }]);
}(E), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = function() {
    return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
  };
  t3.existsFileInVFS = function(t4) {
    return e2.call(this), void 0 !== this.internal.vFS[t4];
  }, t3.addFileToVFS = function(t4, r2) {
    return e2.call(this), this.internal.vFS[t4] = r2, this;
  }, t3.getFileFromVFS = function(t4) {
    return e2.call(this), void 0 !== this.internal.vFS[t4] ? this.internal.vFS[t4] : null;
  };
}(E.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(t3) {
  t3.__bidiEngine__ = t3.prototype.__bidiEngine__ = function(t4) {
    var r3, n3, i3, a3, o3, s3, c4, u3 = e2, h3 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l3 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f3 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p3 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m4 = false, v3 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t5) {
      var e3 = t5.charCodeAt(), r4 = e3 >> 8, n4 = d2[r4];
      return void 0 !== n4 ? u3[256 * n4 + (255 & e3)] : 252 === r4 || 253 === r4 ? "AL" : g2.test(r4) ? "L" : 8 === r4 ? "R" : "N";
    }, y3 = function(t5) {
      for (var e3, r4 = 0; r4 < t5.length; r4++) {
        if ("L" === (e3 = b2(t5.charAt(r4))))
          return false;
        if ("R" === e3)
          return true;
      }
      return false;
    }, w2 = function(t5, e3, o4, s4) {
      var c5, u4, h4, l4, f4 = e3[s4];
      switch (f4) {
        case "L":
        case "R":
          m4 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m4 && (f4 = "AN");
          break;
        case "AL":
          m4 = true, f4 = "R";
          break;
        case "WS":
          f4 = "N";
          break;
        case "CS":
          s4 < 1 || s4 + 1 >= e3.length || "EN" !== (c5 = o4[s4 - 1]) && "AN" !== c5 || "EN" !== (u4 = e3[s4 + 1]) && "AN" !== u4 ? f4 = "N" : m4 && (u4 = "AN"), f4 = u4 === c5 ? u4 : "N";
          break;
        case "ES":
          f4 = "EN" === (c5 = s4 > 0 ? o4[s4 - 1] : "B") && s4 + 1 < e3.length && "EN" === e3[s4 + 1] ? "EN" : "N";
          break;
        case "ET":
          if (s4 > 0 && "EN" === o4[s4 - 1]) {
            f4 = "EN";
            break;
          }
          if (m4) {
            f4 = "N";
            break;
          }
          for (h4 = s4 + 1, l4 = e3.length; h4 < l4 && "ET" === e3[h4]; )
            h4++;
          f4 = h4 < l4 && "EN" === e3[h4] ? "EN" : "N";
          break;
        case "NSM":
          if (i3 && !a3) {
            for (l4 = e3.length, h4 = s4 + 1; h4 < l4 && "NSM" === e3[h4]; )
              h4++;
            if (h4 < l4) {
              var d3 = t5[s4], p4 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
              if (c5 = e3[h4], p4 && ("R" === c5 || "AL" === c5)) {
                f4 = "R";
                break;
              }
            }
          }
          f4 = s4 < 1 || "B" === (c5 = e3[s4 - 1]) ? "N" : o4[s4 - 1];
          break;
        case "B":
          m4 = false, r3 = true, f4 = v3;
          break;
        case "S":
          n3 = true, f4 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m4 = false;
          break;
        case "BN":
          f4 = "N";
      }
      return f4;
    }, N3 = function(t5, e3, r4) {
      var n4 = t5.split("");
      return r4 && L2(n4, r4, { hiLevel: v3 }), n4.reverse(), e3 && e3.reverse(), n4.join("");
    }, L2 = function(t5, e3, i4) {
      var a4, o4, s4, c5, u4, d3 = -1, p4 = t5.length, g3 = 0, y4 = [], N4 = v3 ? l3 : h3, L3 = [];
      for (m4 = false, r3 = false, n3 = false, o4 = 0; o4 < p4; o4++)
        L3[o4] = b2(t5[o4]);
      for (s4 = 0; s4 < p4; s4++) {
        if (u4 = g3, y4[s4] = w2(t5, L3, y4, s4), a4 = 240 & (g3 = N4[u4][f3[y4[s4]]]), g3 &= 15, e3[s4] = c5 = N4[g3][5], a4 > 0)
          if (16 === a4) {
            for (o4 = d3; o4 < s4; o4++)
              e3[o4] = 1;
            d3 = -1;
          } else
            d3 = -1;
        if (N4[g3][6])
          -1 === d3 && (d3 = s4);
        else if (d3 > -1) {
          for (o4 = d3; o4 < s4; o4++)
            e3[o4] = c5;
          d3 = -1;
        }
        "B" === L3[s4] && (e3[s4] = 0), i4.hiLevel |= c5;
      }
      n3 && function(t6, e4, r4) {
        for (var n4 = 0; n4 < r4; n4++)
          if ("S" === t6[n4]) {
            e4[n4] = v3;
            for (var i5 = n4 - 1; i5 >= 0 && "WS" === t6[i5]; i5--)
              e4[i5] = v3;
          }
      }(L3, e3, p4);
    }, A2 = function(t5, e3, n4, i4, a4) {
      if (!(a4.hiLevel < t5)) {
        if (1 === t5 && 1 === v3 && !r3)
          return e3.reverse(), void (n4 && n4.reverse());
        for (var o4, s4, c5, u4, h4 = e3.length, l4 = 0; l4 < h4; ) {
          if (i4[l4] >= t5) {
            for (c5 = l4 + 1; c5 < h4 && i4[c5] >= t5; )
              c5++;
            for (u4 = l4, s4 = c5 - 1; u4 < s4; u4++, s4--)
              o4 = e3[u4], e3[u4] = e3[s4], e3[s4] = o4, n4 && (o4 = n4[u4], n4[u4] = n4[s4], n4[s4] = o4);
            l4 = c5;
          }
          l4++;
        }
      }
    }, x2 = function(t5, e3, r4) {
      var n4 = t5.split(""), i4 = { hiLevel: v3 };
      return r4 || (r4 = []), L2(n4, r4, i4), function(t6, e4, r5) {
        if (0 !== r5.hiLevel && c4)
          for (var n5, i5 = 0; i5 < t6.length; i5++)
            1 === e4[i5] && (n5 = p3.indexOf(t6[i5])) >= 0 && (t6[i5] = p3[n5 + 1]);
      }(n4, r4, i4), A2(2, n4, e3, r4, i4), A2(1, n4, e3, r4, i4), n4.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t5, e3, r4) {
      if (function(t6, e4) {
        if (e4)
          for (var r5 = 0; r5 < t6.length; r5++)
            e4[r5] = r5;
        void 0 === a3 && (a3 = y3(t6)), void 0 === s3 && (s3 = y3(t6));
      }(t5, e3), i3 || !o3 || s3)
        if (i3 && o3 && a3 ^ s3)
          v3 = a3 ? 1 : 0, t5 = N3(t5, e3, r4);
        else if (!i3 && o3 && s3)
          v3 = a3 ? 1 : 0, t5 = x2(t5, e3, r4), t5 = N3(t5, e3);
        else if (!i3 || a3 || o3 || s3) {
          if (i3 && !o3 && a3 ^ s3)
            t5 = N3(t5, e3), a3 ? (v3 = 0, t5 = x2(t5, e3, r4)) : (v3 = 1, t5 = x2(t5, e3, r4), t5 = N3(t5, e3));
          else if (i3 && a3 && !o3 && s3)
            v3 = 1, t5 = x2(t5, e3, r4), t5 = N3(t5, e3);
          else if (!i3 && !o3 && a3 ^ s3) {
            var n4 = c4;
            a3 ? (v3 = 1, t5 = x2(t5, e3, r4), v3 = 0, c4 = false, t5 = x2(t5, e3, r4), c4 = n4) : (v3 = 0, t5 = x2(t5, e3, r4), t5 = N3(t5, e3), v3 = 1, c4 = false, t5 = x2(t5, e3, r4), c4 = n4, t5 = N3(t5, e3));
          }
        } else
          v3 = 0, t5 = x2(t5, e3, r4);
      else
        v3 = a3 ? 1 : 0, t5 = x2(t5, e3, r4);
      return t5;
    }, this.__bidiEngine__.setOptions = function(t5) {
      t5 && (i3 = t5.isInputVisual, o3 = t5.isOutputVisual, a3 = t5.isInputRtl, s3 = t5.isOutputRtl, c4 = t5.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t4), this.__bidiEngine__;
  };
  var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r2 = new t3.__bidiEngine__({ isInputVisual: true });
  t3.API.events.push(["postProcessText", function(t4) {
    var e3 = t4.text, n3 = (t4.x, t4.y, t4.options || {}), i3 = (t4.mutex, n3.lang, []);
    if (n3.isInputVisual = "boolean" != typeof n3.isInputVisual || n3.isInputVisual, r2.setOptions(n3), "[object Array]" === Object.prototype.toString.call(e3)) {
      var a3 = 0;
      for (i3 = [], a3 = 0; a3 < e3.length; a3 += 1)
        "[object Array]" === Object.prototype.toString.call(e3[a3]) ? i3.push([r2.doBidiReorder(e3[a3][0]), e3[a3][1], e3[a3][2]]) : i3.push([r2.doBidiReorder(e3[a3])]);
      t4.text = i3;
    } else
      t4.text = r2.doBidiReorder(e3);
    r2.setOptions({ isInputVisual: true });
  }]);
}(E), E.API.TTFFont = function() {
  function t3(t4) {
    var e2;
    if (this.rawData = t4, e2 = this.contents = new ne(t4), this.contents.pos = 4, "ttcf" === e2.readString(4))
      throw new Error("TTCF not supported.");
    e2.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  return t3.open = function(e2) {
    return new t3(e2);
  }, t3.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t3.prototype.registerTTF = function() {
    var t4, e2, r2, n3, i3;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
      var e3, r3, n4, i4;
      for (i4 = [], e3 = 0, r3 = (n4 = this.bbox).length; e3 < r3; e3++)
        t4 = n4[e3], i4.push(Math.round(t4 * this.scaleFactor));
      return i4;
    }.call(this), this.stemV = 0, this.post.exists ? (r2 = 255 & (n3 = this.post.italic_angle), 0 != (32768 & (e2 = n3 >> 16)) && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + r2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i3 = this.familyClass) || 2 === i3 || 3 === i3 || 4 === i3 || 5 === i3 || 7 === i3, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, t3.prototype.characterToGlyph = function(t4) {
    var e2;
    return (null != (e2 = this.cmap.unicode) ? e2.codeMap[t4] : void 0) || 0;
  }, t3.prototype.widthOfGlyph = function(t4) {
    var e2;
    return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t4).advance * e2;
  }, t3.prototype.widthOfString = function(t4, e2, r2) {
    var n3, i3, a3, o3;
    for (a3 = 0, i3 = 0, o3 = (t4 = "" + t4).length; 0 <= o3 ? i3 < o3 : i3 > o3; i3 = 0 <= o3 ? ++i3 : --i3)
      n3 = t4.charCodeAt(i3), a3 += this.widthOfGlyph(this.characterToGlyph(n3)) + r2 * (1e3 / e2) || 0;
    return a3 * (e2 / 1e3);
  }, t3.prototype.lineHeight = function(t4, e2) {
    var r2;
    return null == e2 && (e2 = false), r2 = e2 ? this.lineGap : 0, (this.ascender + r2 - this.decender) / 1e3 * t4;
  }, t3;
}();
var re;
var ne = function() {
  function t3(t4) {
    this.data = null != t4 ? t4 : [], this.pos = 0, this.length = this.data.length;
  }
  return t3.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t3.prototype.writeByte = function(t4) {
    return this.data[this.pos++] = t4;
  }, t3.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t3.prototype.writeUInt32 = function(t4) {
    return this.writeByte(t4 >>> 24 & 255), this.writeByte(t4 >> 16 & 255), this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt32 = function() {
    var t4;
    return (t4 = this.readUInt32()) >= 2147483648 ? t4 - 4294967296 : t4;
  }, t3.prototype.writeInt32 = function(t4) {
    return t4 < 0 && (t4 += 4294967296), this.writeUInt32(t4);
  }, t3.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t3.prototype.writeUInt16 = function(t4) {
    return this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt16 = function() {
    var t4;
    return (t4 = this.readUInt16()) >= 32768 ? t4 - 65536 : t4;
  }, t3.prototype.writeInt16 = function(t4) {
    return t4 < 0 && (t4 += 65536), this.writeUInt16(t4);
  }, t3.prototype.readString = function(t4) {
    var e2, r2;
    for (r2 = [], e2 = 0; 0 <= t4 ? e2 < t4 : e2 > t4; e2 = 0 <= t4 ? ++e2 : --e2)
      r2[e2] = String.fromCharCode(this.readByte());
    return r2.join("");
  }, t3.prototype.writeString = function(t4) {
    var e2, r2, n3;
    for (n3 = [], e2 = 0, r2 = t4.length; 0 <= r2 ? e2 < r2 : e2 > r2; e2 = 0 <= r2 ? ++e2 : --e2)
      n3.push(this.writeByte(t4.charCodeAt(e2)));
    return n3;
  }, t3.prototype.readShort = function() {
    return this.readInt16();
  }, t3.prototype.writeShort = function(t4) {
    return this.writeInt16(t4);
  }, t3.prototype.readLongLong = function() {
    var t4, e2, r2, n3, i3, a3, o3, s3;
    return t4 = this.readByte(), e2 = this.readByte(), r2 = this.readByte(), n3 = this.readByte(), i3 = this.readByte(), a3 = this.readByte(), o3 = this.readByte(), s3 = this.readByte(), 128 & t4 ? -1 * (72057594037927940 * (255 ^ t4) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ r2) + 4294967296 * (255 ^ n3) + 16777216 * (255 ^ i3) + 65536 * (255 ^ a3) + 256 * (255 ^ o3) + (255 ^ s3) + 1) : 72057594037927940 * t4 + 281474976710656 * e2 + 1099511627776 * r2 + 4294967296 * n3 + 16777216 * i3 + 65536 * a3 + 256 * o3 + s3;
  }, t3.prototype.writeLongLong = function(t4) {
    var e2, r2;
    return e2 = Math.floor(t4 / 4294967296), r2 = 4294967295 & t4, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(r2 >> 24 & 255), this.writeByte(r2 >> 16 & 255), this.writeByte(r2 >> 8 & 255), this.writeByte(255 & r2);
  }, t3.prototype.readInt = function() {
    return this.readInt32();
  }, t3.prototype.writeInt = function(t4) {
    return this.writeInt32(t4);
  }, t3.prototype.read = function(t4) {
    var e2, r2;
    for (e2 = [], r2 = 0; 0 <= t4 ? r2 < t4 : r2 > t4; r2 = 0 <= t4 ? ++r2 : --r2)
      e2.push(this.readByte());
    return e2;
  }, t3.prototype.write = function(t4) {
    var e2, r2, n3, i3;
    for (i3 = [], r2 = 0, n3 = t4.length; r2 < n3; r2++)
      e2 = t4[r2], i3.push(this.writeByte(e2));
    return i3;
  }, t3;
}();
var ie = function() {
  var t3;
  function e2(t4) {
    var e3, r2, n3;
    for (this.scalarType = t4.readInt(), this.tableCount = t4.readShort(), this.searchRange = t4.readShort(), this.entrySelector = t4.readShort(), this.rangeShift = t4.readShort(), this.tables = {}, r2 = 0, n3 = this.tableCount; 0 <= n3 ? r2 < n3 : r2 > n3; r2 = 0 <= n3 ? ++r2 : --r2)
      e3 = { tag: t4.readString(4), checksum: t4.readInt(), offset: t4.readInt(), length: t4.readInt() }, this.tables[e3.tag] = e3;
  }
  return e2.prototype.encode = function(e3) {
    var r2, n3, i3, a3, o3, s3, c4, u3, h3, l3, f3, d2, p3;
    for (p3 in f3 = Object.keys(e3).length, s3 = Math.log(2), h3 = 16 * Math.floor(Math.log(f3) / s3), a3 = Math.floor(h3 / s3), u3 = 16 * f3 - h3, (n3 = new ne()).writeInt(this.scalarType), n3.writeShort(f3), n3.writeShort(h3), n3.writeShort(a3), n3.writeShort(u3), i3 = 16 * f3, c4 = n3.pos + i3, o3 = null, d2 = [], e3)
      for (l3 = e3[p3], n3.writeString(p3), n3.writeInt(t3(l3)), n3.writeInt(c4), n3.writeInt(l3.length), d2 = d2.concat(l3), "head" === p3 && (o3 = c4), c4 += l3.length; c4 % 4; )
        d2.push(0), c4++;
    return n3.write(d2), r2 = 2981146554 - t3(n3.data), n3.pos = o3 + 8, n3.writeUInt32(r2), n3.data;
  }, t3 = function(t4) {
    var e3, r2, n3, i3;
    for (t4 = ve.call(t4); t4.length % 4; )
      t4.push(0);
    for (n3 = new ne(t4), r2 = 0, e3 = 0, i3 = t4.length; e3 < i3; e3 = e3 += 4)
      r2 += n3.readUInt32();
    return 4294967295 & r2;
  }, e2;
}();
var ae = {}.hasOwnProperty;
var oe = function(t3, e2) {
  for (var r2 in e2)
    ae.call(e2, r2) && (t3[r2] = e2[r2]);
  function n3() {
    this.constructor = t3;
  }
  return n3.prototype = e2.prototype, t3.prototype = new n3(), t3.__super__ = e2.prototype, t3;
};
re = function() {
  function t3(t4) {
    var e2;
    this.file = t4, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
  }
  return t3.prototype.parse = function() {
  }, t3.prototype.encode = function() {
  }, t3.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t3;
}();
var se = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "head", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.revision = t4.readInt(), this.checkSumAdjustment = t4.readInt(), this.magicNumber = t4.readInt(), this.flags = t4.readShort(), this.unitsPerEm = t4.readShort(), this.created = t4.readLongLong(), this.modified = t4.readLongLong(), this.xMin = t4.readShort(), this.yMin = t4.readShort(), this.xMax = t4.readShort(), this.yMax = t4.readShort(), this.macStyle = t4.readShort(), this.lowestRecPPEM = t4.readShort(), this.fontDirectionHint = t4.readShort(), this.indexToLocFormat = t4.readShort(), this.glyphDataFormat = t4.readShort();
  }, e2.prototype.encode = function(t4) {
    var e3;
    return (e3 = new ne()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t4), e3.writeShort(this.glyphDataFormat), e3.data;
  }, e2;
}();
var ce = function() {
  function t3(t4, e2) {
    var r2, n3, i3, a3, o3, s3, c4, u3, h3, l3, f3, d2, p3, g2, m4, v3, b2;
    switch (this.platformID = t4.readUInt16(), this.encodingID = t4.readShort(), this.offset = e2 + t4.readInt(), h3 = t4.pos, t4.pos = this.offset, this.format = t4.readUInt16(), this.length = t4.readUInt16(), this.language = t4.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
      case 0:
        for (s3 = 0; s3 < 256; ++s3)
          this.codeMap[s3] = t4.readByte();
        break;
      case 4:
        for (f3 = t4.readUInt16(), l3 = f3 / 2, t4.pos += 6, i3 = function() {
          var e3, r3;
          for (r3 = [], s3 = e3 = 0; 0 <= l3 ? e3 < l3 : e3 > l3; s3 = 0 <= l3 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), t4.pos += 2, p3 = function() {
          var e3, r3;
          for (r3 = [], s3 = e3 = 0; 0 <= l3 ? e3 < l3 : e3 > l3; s3 = 0 <= l3 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), c4 = function() {
          var e3, r3;
          for (r3 = [], s3 = e3 = 0; 0 <= l3 ? e3 < l3 : e3 > l3; s3 = 0 <= l3 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), u3 = function() {
          var e3, r3;
          for (r3 = [], s3 = e3 = 0; 0 <= l3 ? e3 < l3 : e3 > l3; s3 = 0 <= l3 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), n3 = (this.length - t4.pos + this.offset) / 2, o3 = function() {
          var e3, r3;
          for (r3 = [], s3 = e3 = 0; 0 <= n3 ? e3 < n3 : e3 > n3; s3 = 0 <= n3 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), s3 = m4 = 0, b2 = i3.length; m4 < b2; s3 = ++m4)
          for (g2 = i3[s3], r2 = v3 = d2 = p3[s3]; d2 <= g2 ? v3 <= g2 : v3 >= g2; r2 = d2 <= g2 ? ++v3 : --v3)
            0 === u3[s3] ? a3 = r2 + c4[s3] : 0 !== (a3 = o3[u3[s3] / 2 + (r2 - d2) - (l3 - s3)] || 0) && (a3 += c4[s3]), this.codeMap[r2] = 65535 & a3;
    }
    t4.pos = h3;
  }
  return t3.encode = function(t4, e2) {
    var r2, n3, i3, a3, o3, s3, c4, u3, h3, l3, f3, d2, p3, g2, m4, v3, b2, y3, w2, N3, L2, A2, x2, S2, _3, P2, k2, I2, F2, C2, j2, O3, B2, M2, E2, q2, D2, R2, T3, U2, z2, H2, W2, V2, G2, Y2;
    switch (I2 = new ne(), a3 = Object.keys(t4).sort(function(t5, e3) {
      return t5 - e3;
    }), e2) {
      case "macroman":
        for (p3 = 0, g2 = function() {
          var t5 = [];
          for (d2 = 0; d2 < 256; ++d2)
            t5.push(0);
          return t5;
        }(), v3 = { 0: 0 }, i3 = {}, F2 = 0, B2 = a3.length; F2 < B2; F2++)
          null == v3[W2 = t4[n3 = a3[F2]]] && (v3[W2] = ++p3), i3[n3] = { old: t4[n3], new: v3[t4[n3]] }, g2[n3] = v3[t4[n3]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i3, subtable: I2.data, maxGlyphID: p3 + 1 };
      case "unicode":
        for (P2 = [], h3 = [], b2 = 0, v3 = {}, r2 = {}, m4 = c4 = null, C2 = 0, M2 = a3.length; C2 < M2; C2++)
          null == v3[w2 = t4[n3 = a3[C2]]] && (v3[w2] = ++b2), r2[n3] = { old: w2, new: v3[w2] }, o3 = v3[w2] - n3, null != m4 && o3 === c4 || (m4 && h3.push(m4), P2.push(n3), c4 = o3), m4 = n3;
        for (m4 && h3.push(m4), h3.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l3 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s3 = [], N3 = [], f3 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
          if (_3 = P2[d2], u3 = h3[d2], 65535 === _3) {
            s3.push(0), N3.push(0);
            break;
          }
          if (_3 - (k2 = r2[_3].new) >= 32768)
            for (s3.push(0), N3.push(2 * (f3.length + x2 - d2)), n3 = O3 = _3; _3 <= u3 ? O3 <= u3 : O3 >= u3; n3 = _3 <= u3 ? ++O3 : --O3)
              f3.push(r2[n3].new);
          else
            s3.push(k2 - _3), N3.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f3.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l3), I2.writeUInt16(L2), z2 = 0, q2 = h3.length; z2 < q2; z2++)
          n3 = h3[z2], I2.writeUInt16(n3);
        for (I2.writeUInt16(0), H2 = 0, D2 = P2.length; H2 < D2; H2++)
          n3 = P2[H2], I2.writeUInt16(n3);
        for (V2 = 0, R2 = s3.length; V2 < R2; V2++)
          o3 = s3[V2], I2.writeUInt16(o3);
        for (G2 = 0, T3 = N3.length; G2 < T3; G2++)
          y3 = N3[G2], I2.writeUInt16(y3);
        for (Y2 = 0, U2 = f3.length; Y2 < U2; Y2++)
          p3 = f3[Y2], I2.writeUInt16(p3);
        return { charMap: r2, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t3;
}();
var ue = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "cmap", e2.prototype.parse = function(t4) {
    var e3, r2, n3;
    for (t4.pos = this.offset, this.version = t4.readUInt16(), n3 = t4.readUInt16(), this.tables = [], this.unicode = null, r2 = 0; 0 <= n3 ? r2 < n3 : r2 > n3; r2 = 0 <= n3 ? ++r2 : --r2)
      e3 = new ce(t4, this.offset), this.tables.push(e3), e3.isUnicode && null == this.unicode && (this.unicode = e3);
    return true;
  }, e2.encode = function(t4, e3) {
    var r2, n3;
    return null == e3 && (e3 = "macroman"), r2 = ce.encode(t4, e3), (n3 = new ne()).writeUInt16(0), n3.writeUInt16(1), r2.table = n3.data.concat(r2.subtable), r2;
  }, e2;
}();
var he = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hhea", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.ascender = t4.readShort(), this.decender = t4.readShort(), this.lineGap = t4.readShort(), this.advanceWidthMax = t4.readShort(), this.minLeftSideBearing = t4.readShort(), this.minRightSideBearing = t4.readShort(), this.xMaxExtent = t4.readShort(), this.caretSlopeRise = t4.readShort(), this.caretSlopeRun = t4.readShort(), this.caretOffset = t4.readShort(), t4.pos += 8, this.metricDataFormat = t4.readShort(), this.numberOfMetrics = t4.readUInt16();
  }, e2;
}();
var le = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "OS/2", e2.prototype.parse = function(t4) {
    if (t4.pos = this.offset, this.version = t4.readUInt16(), this.averageCharWidth = t4.readShort(), this.weightClass = t4.readUInt16(), this.widthClass = t4.readUInt16(), this.type = t4.readShort(), this.ySubscriptXSize = t4.readShort(), this.ySubscriptYSize = t4.readShort(), this.ySubscriptXOffset = t4.readShort(), this.ySubscriptYOffset = t4.readShort(), this.ySuperscriptXSize = t4.readShort(), this.ySuperscriptYSize = t4.readShort(), this.ySuperscriptXOffset = t4.readShort(), this.ySuperscriptYOffset = t4.readShort(), this.yStrikeoutSize = t4.readShort(), this.yStrikeoutPosition = t4.readShort(), this.familyClass = t4.readShort(), this.panose = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 10; ++e3)
        r2.push(t4.readByte());
      return r2;
    }(), this.charRange = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 4; ++e3)
        r2.push(t4.readInt());
      return r2;
    }(), this.vendorID = t4.readString(4), this.selection = t4.readShort(), this.firstCharIndex = t4.readShort(), this.lastCharIndex = t4.readShort(), this.version > 0 && (this.ascent = t4.readShort(), this.descent = t4.readShort(), this.lineGap = t4.readShort(), this.winAscent = t4.readShort(), this.winDescent = t4.readShort(), this.codePageRange = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 2; e3 = ++e3)
        r2.push(t4.readInt());
      return r2;
    }(), this.version > 1))
      return this.xHeight = t4.readShort(), this.capHeight = t4.readShort(), this.defaultChar = t4.readShort(), this.breakChar = t4.readShort(), this.maxContext = t4.readShort();
  }, e2;
}();
var fe = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "post", e2.prototype.parse = function(t4) {
    var e3, r2, n3;
    switch (t4.pos = this.offset, this.format = t4.readInt(), this.italicAngle = t4.readInt(), this.underlinePosition = t4.readShort(), this.underlineThickness = t4.readShort(), this.isFixedPitch = t4.readInt(), this.minMemType42 = t4.readInt(), this.maxMemType42 = t4.readInt(), this.minMemType1 = t4.readInt(), this.maxMemType1 = t4.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i3;
        for (r2 = t4.readUInt16(), this.glyphNameIndex = [], i3 = 0; 0 <= r2 ? i3 < r2 : i3 > r2; i3 = 0 <= r2 ? ++i3 : --i3)
          this.glyphNameIndex.push(t4.readUInt16());
        for (this.names = [], n3 = []; t4.pos < this.offset + this.length; )
          e3 = t4.readByte(), n3.push(this.names.push(t4.readString(e3)));
        return n3;
      case 151552:
        return r2 = t4.readUInt16(), this.offsets = t4.read(r2);
      case 196608:
        break;
      case 262144:
        return this.map = function() {
          var e4, r3, n4;
          for (n4 = [], i3 = e4 = 0, r3 = this.file.maxp.numGlyphs; 0 <= r3 ? e4 < r3 : e4 > r3; i3 = 0 <= r3 ? ++e4 : --e4)
            n4.push(t4.readUInt32());
          return n4;
        }.call(this);
    }
  }, e2;
}();
var de = function(t3, e2) {
  this.raw = t3, this.length = t3.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
};
var pe = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "name", e2.prototype.parse = function(t4) {
    var e3, r2, n3, i3, a3, o3, s3, c4, u3, h3, l3;
    for (t4.pos = this.offset, t4.readShort(), e3 = t4.readShort(), o3 = t4.readShort(), r2 = [], i3 = 0; 0 <= e3 ? i3 < e3 : i3 > e3; i3 = 0 <= e3 ? ++i3 : --i3)
      r2.push({ platformID: t4.readShort(), encodingID: t4.readShort(), languageID: t4.readShort(), nameID: t4.readShort(), length: t4.readShort(), offset: this.offset + o3 + t4.readShort() });
    for (s3 = {}, i3 = u3 = 0, h3 = r2.length; u3 < h3; i3 = ++u3)
      n3 = r2[i3], t4.pos = n3.offset, c4 = t4.readString(n3.length), a3 = new de(c4, n3), null == s3[l3 = n3.nameID] && (s3[l3] = []), s3[n3.nameID].push(a3);
    this.strings = s3, this.copyright = s3[0], this.fontFamily = s3[1], this.fontSubfamily = s3[2], this.uniqueSubfamily = s3[3], this.fontName = s3[4], this.version = s3[5];
    try {
      this.postscriptName = s3[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t5) {
      this.postscriptName = s3[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s3[7], this.manufacturer = s3[8], this.designer = s3[9], this.description = s3[10], this.vendorUrl = s3[11], this.designerUrl = s3[12], this.license = s3[13], this.licenseUrl = s3[14], this.preferredFamily = s3[15], this.preferredSubfamily = s3[17], this.compatibleFull = s3[18], this.sampleText = s3[19];
  }, e2;
}();
var ge = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "maxp", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.numGlyphs = t4.readUInt16(), this.maxPoints = t4.readUInt16(), this.maxContours = t4.readUInt16(), this.maxCompositePoints = t4.readUInt16(), this.maxComponentContours = t4.readUInt16(), this.maxZones = t4.readUInt16(), this.maxTwilightPoints = t4.readUInt16(), this.maxStorage = t4.readUInt16(), this.maxFunctionDefs = t4.readUInt16(), this.maxInstructionDefs = t4.readUInt16(), this.maxStackElements = t4.readUInt16(), this.maxSizeOfInstructions = t4.readUInt16(), this.maxComponentElements = t4.readUInt16(), this.maxComponentDepth = t4.readUInt16();
  }, e2;
}();
var me = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hmtx", e2.prototype.parse = function(t4) {
    var e3, r2, n3, i3, a3, o3, s3;
    for (t4.pos = this.offset, this.metrics = [], e3 = 0, o3 = this.file.hhea.numberOfMetrics; 0 <= o3 ? e3 < o3 : e3 > o3; e3 = 0 <= o3 ? ++e3 : --e3)
      this.metrics.push({ advance: t4.readUInt16(), lsb: t4.readInt16() });
    for (n3 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r3, i4;
      for (i4 = [], e3 = r3 = 0; 0 <= n3 ? r3 < n3 : r3 > n3; e3 = 0 <= n3 ? ++r3 : --r3)
        i4.push(t4.readInt16());
      return i4;
    }(), this.widths = function() {
      var t5, e4, r3, n4;
      for (n4 = [], t5 = 0, e4 = (r3 = this.metrics).length; t5 < e4; t5++)
        i3 = r3[t5], n4.push(i3.advance);
      return n4;
    }.call(this), r2 = this.widths[this.widths.length - 1], s3 = [], e3 = a3 = 0; 0 <= n3 ? a3 < n3 : a3 > n3; e3 = 0 <= n3 ? ++a3 : --a3)
      s3.push(this.widths.push(r2));
    return s3;
  }, e2.prototype.forGlyph = function(t4) {
    return t4 in this.metrics ? this.metrics[t4] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t4 - this.metrics.length] };
  }, e2;
}();
var ve = [].slice;
var be = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "glyf", e2.prototype.parse = function() {
    return this.cache = {};
  }, e2.prototype.glyphFor = function(t4) {
    var e3, r2, n3, i3, a3, o3, s3, c4, u3, h3;
    return t4 in this.cache ? this.cache[t4] : (i3 = this.file.loca, e3 = this.file.contents, r2 = i3.indexOf(t4), 0 === (n3 = i3.lengthOf(t4)) ? this.cache[t4] = null : (e3.pos = this.offset + r2, a3 = (o3 = new ne(e3.read(n3))).readShort(), c4 = o3.readShort(), h3 = o3.readShort(), s3 = o3.readShort(), u3 = o3.readShort(), this.cache[t4] = -1 === a3 ? new we(o3, c4, h3, s3, u3) : new ye(o3, a3, c4, h3, s3, u3), this.cache[t4]));
  }, e2.prototype.encode = function(t4, e3, r2) {
    var n3, i3, a3, o3, s3;
    for (a3 = [], i3 = [], o3 = 0, s3 = e3.length; o3 < s3; o3++)
      n3 = t4[e3[o3]], i3.push(a3.length), n3 && (a3 = a3.concat(n3.encode(r2)));
    return i3.push(a3.length), { table: a3, offsets: i3 };
  }, e2;
}();
var ye = function() {
  function t3(t4, e2, r2, n3, i3, a3) {
    this.raw = t4, this.numberOfContours = e2, this.xMin = r2, this.yMin = n3, this.xMax = i3, this.yMax = a3, this.compound = false;
  }
  return t3.prototype.encode = function() {
    return this.raw.data;
  }, t3;
}();
var we = function() {
  function t3(t4, e2, r2, n3, i3) {
    var a3, o3;
    for (this.raw = t4, this.xMin = e2, this.yMin = r2, this.xMax = n3, this.yMax = i3, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a3 = this.raw; o3 = a3.readShort(), this.glyphOffsets.push(a3.pos), this.glyphIDs.push(a3.readUInt16()), 32 & o3; )
      a3.pos += 1 & o3 ? 4 : 2, 128 & o3 ? a3.pos += 8 : 64 & o3 ? a3.pos += 4 : 8 & o3 && (a3.pos += 2);
  }
  return 1, 8, 32, 64, 128, t3.prototype.encode = function() {
    var t4, e2, r2;
    for (e2 = new ne(ve.call(this.raw.data)), t4 = 0, r2 = this.glyphIDs.length; t4 < r2; ++t4)
      e2.pos = this.glyphOffsets[t4];
    return e2.data;
  }, t3;
}();
var Ne = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "loca", e2.prototype.parse = function(t4) {
    var e3, r2;
    return t4.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = 0 === e3 ? function() {
      var e4, n3;
      for (n3 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 2)
        n3.push(2 * t4.readUInt16());
      return n3;
    }.call(this) : function() {
      var e4, n3;
      for (n3 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 4)
        n3.push(t4.readUInt32());
      return n3;
    }.call(this);
  }, e2.prototype.indexOf = function(t4) {
    return this.offsets[t4];
  }, e2.prototype.lengthOf = function(t4) {
    return this.offsets[t4 + 1] - this.offsets[t4];
  }, e2.prototype.encode = function(t4, e3) {
    for (var r2 = new Uint32Array(this.offsets.length), n3 = 0, i3 = 0, a3 = 0; a3 < r2.length; ++a3)
      if (r2[a3] = n3, i3 < e3.length && e3[i3] == a3) {
        ++i3, r2[a3] = n3;
        var o3 = this.offsets[a3], s3 = this.offsets[a3 + 1] - o3;
        s3 > 0 && (n3 += s3);
      }
    for (var c4 = new Array(4 * r2.length), u3 = 0; u3 < r2.length; ++u3)
      c4[4 * u3 + 3] = 255 & r2[u3], c4[4 * u3 + 2] = (65280 & r2[u3]) >> 8, c4[4 * u3 + 1] = (16711680 & r2[u3]) >> 16, c4[4 * u3] = (4278190080 & r2[u3]) >> 24;
    return c4;
  }, e2;
}();
var Le = function() {
  function t3(t4) {
    this.font = t4, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t3.prototype.generateCmap = function() {
    var t4, e2, r2, n3, i3;
    for (e2 in n3 = this.font.cmap.tables[0].codeMap, t4 = {}, i3 = this.subset)
      r2 = i3[e2], t4[e2] = n3[r2];
    return t4;
  }, t3.prototype.glyphsFor = function(t4) {
    var e2, r2, n3, i3, a3, o3, s3;
    for (n3 = {}, a3 = 0, o3 = t4.length; a3 < o3; a3++)
      n3[i3 = t4[a3]] = this.font.glyf.glyphFor(i3);
    for (i3 in e2 = [], n3)
      (null != (r2 = n3[i3]) ? r2.compound : void 0) && e2.push.apply(e2, r2.glyphIDs);
    if (e2.length > 0)
      for (i3 in s3 = this.glyphsFor(e2))
        r2 = s3[i3], n3[i3] = r2;
    return n3;
  }, t3.prototype.encode = function(t4, e2) {
    var r2, n3, i3, a3, o3, s3, c4, u3, h3, l3, f3, d2, p3, g2, m4;
    for (n3 in r2 = ue.encode(this.generateCmap(), "unicode"), a3 = this.glyphsFor(t4), f3 = { 0: 0 }, m4 = r2.charMap)
      f3[(s3 = m4[n3]).old] = s3.new;
    for (d2 in l3 = r2.maxGlyphID, a3)
      d2 in f3 || (f3[d2] = l3++);
    return u3 = function(t5) {
      var e3, r3;
      for (e3 in r3 = {}, t5)
        r3[t5[e3]] = e3;
      return r3;
    }(f3), h3 = Object.keys(u3).sort(function(t5, e3) {
      return t5 - e3;
    }), p3 = function() {
      var t5, e3, r3;
      for (r3 = [], t5 = 0, e3 = h3.length; t5 < e3; t5++)
        o3 = h3[t5], r3.push(u3[o3]);
      return r3;
    }(), i3 = this.font.glyf.encode(a3, p3, f3), c4 = this.font.loca.encode(i3.offsets, p3), g2 = { cmap: this.font.cmap.raw(), glyf: i3.table, loca: c4, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t3;
}();
E.API.PDFObject = function() {
  var t3;
  function e2() {
  }
  return t3 = function(t4, e3) {
    return (Array(e3 + 1).join("0") + t4).slice(-e3);
  }, e2.convert = function(r2) {
    var n3, i3, a3, o3;
    if (Array.isArray(r2))
      return "[" + function() {
        var t4, i4, a4;
        for (a4 = [], t4 = 0, i4 = r2.length; t4 < i4; t4++)
          n3 = r2[t4], a4.push(e2.convert(n3));
        return a4;
      }().join(" ") + "]";
    if ("string" == typeof r2)
      return "/" + r2;
    if (null != r2 ? r2.isString : void 0)
      return "(" + r2 + ")";
    if (r2 instanceof Date)
      return "(D:" + t3(r2.getUTCFullYear(), 4) + t3(r2.getUTCMonth(), 2) + t3(r2.getUTCDate(), 2) + t3(r2.getUTCHours(), 2) + t3(r2.getUTCMinutes(), 2) + t3(r2.getUTCSeconds(), 2) + "Z)";
    if ("[object Object]" === {}.toString.call(r2)) {
      for (i3 in a3 = ["<<"], r2)
        o3 = r2[i3], a3.push("/" + i3 + " " + e2.convert(o3));
      return a3.push(">>"), a3.join("\n");
    }
    return "" + r2;
  }, e2;
}();

// inline-worker:__inline-worker
function inlineWorker(scriptText) {
  let blob = new Blob([scriptText], { type: "text/javascript" });
  let url = URL.createObjectURL(blob);
  let worker2 = new Worker(url);
  URL.revokeObjectURL(url);
  return worker2;
}

// src/myworker.worker.ts
function Worker3() {
  return inlineWorker('var up=Object.create;var qi=Object.defineProperty;var dp=Object.getOwnPropertyDescriptor;var pp=Object.getOwnPropertyNames,$h=Object.getOwnPropertySymbols,mp=Object.getPrototypeOf,qh=Object.prototype.hasOwnProperty,gp=Object.prototype.propertyIsEnumerable;var Wh=t=>{throw TypeError(t)};var fo=(t,r,e)=>r in t?qi(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e,lr=(t,r)=>{for(var e in r||(r={}))qh.call(r,e)&&fo(t,e,r[e]);if($h)for(var e of $h(r))gp.call(r,e)&&fo(t,e,r[e]);return t};var ri=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(r,e)=>(typeof require!="undefined"?require:r)[e]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw Error(\'Dynamic require of "\'+t+\'" is not supported\')});var W=(t,r)=>()=>(r||t((r={exports:{}}).exports,r),r.exports),Wi=(t,r)=>{for(var e in r)qi(t,e,{get:r[e],enumerable:!0})},xp=(t,r,e,i)=>{if(r&&typeof r=="object"||typeof r=="function")for(let n of pp(r))!qh.call(t,n)&&n!==e&&qi(t,n,{get:()=>r[n],enumerable:!(i=dp(r,n))||i.enumerable});return t};var vt=(t,r,e)=>(e=t!=null?up(mp(t)):{},xp(r||!t||!t.__esModule?qi(e,"default",{value:t,enumerable:!0}):e,t));var Kh=(t,r,e)=>fo(t,typeof r!="symbol"?r+"":r,e),co=(t,r,e)=>r.has(t)||Wh("Cannot "+e);var Me=(t,r,e)=>(co(t,r,"read from private field"),e?e.call(t):r.get(t)),uo=(t,r,e)=>r.has(t)?Wh("Cannot add the same private member more than once"):r instanceof WeakSet?r.add(t):r.set(t,e),Ki=(t,r,e,i)=>(co(t,r,"write to private field"),i?i.call(t,e):r.set(t,e),e),po=(t,r,e)=>(co(t,r,"access private method"),e);var Qh=W(Jh=>{"use strict";(function(t){"use strict";if(t.TextEncoder&&t.TextDecoder)return!1;function r(i="utf-8"){if(i!=="utf-8")throw new RangeError(`Failed to construct \'TextEncoder\': The encoding label provided (\'${i}\') is invalid.`)}Object.defineProperty(r.prototype,"encoding",{value:"utf-8"}),r.prototype.encode=function(i,n={stream:!1}){if(n.stream)throw new Error("Failed to encode: the \'stream\' option is unsupported.");let o=0,s=i.length,a=[],l=0,h=Math.max(32,s+(s>>1)+7),f=new Uint8Array(h>>3<<3);for(;o<s;){let c=i.charCodeAt(o++);if(c>=55296&&c<=56319){if(o<s){let u=i.charCodeAt(o);(u&64512)===56320&&(++o,c=((c&1023)<<10)+(u&1023)+65536)}if(c>=55296&&c<=56319)continue}if(l+4>f.length){h+=8,h*=1+o/i.length*2,h=h>>3<<3;let u=new Uint8Array(h);u.set(f),f=u}if(c&4294967168)if(!(c&4294965248))f[l++]=c>>6&31|192;else if(!(c&4294901760))f[l++]=c>>12&15|224,f[l++]=c>>6&63|128;else if(!(c&4292870144))f[l++]=c>>18&7|240,f[l++]=c>>12&63|128,f[l++]=c>>6&63|128;else continue;else{f[l++]=c;continue}f[l++]=c&63|128}return f.slice(0,l)};function e(i="utf-8",n={fatal:!1}){if(i!=="utf-8")throw new RangeError(`Failed to construct \'TextDecoder\': The encoding label provided (\'${i}\') is invalid.`);if(n.fatal)throw new Error("Failed to construct \'TextDecoder\': the \'fatal\' option is unsupported.")}Object.defineProperty(e.prototype,"encoding",{value:"utf-8"}),Object.defineProperty(e.prototype,"fatal",{value:!1}),Object.defineProperty(e.prototype,"ignoreBOM",{value:!1}),e.prototype.decode=function(i,n={stream:!1}){if(n.stream)throw new Error("Failed to decode: the \'stream\' option is unsupported.");let o=new Uint8Array(i),s=0,a=o.length,l=[];for(;s<a;){let h=o[s++];if(h===0)break;if(!(h&128))l.push(h);else if((h&224)===192){let f=o[s++]&63;l.push((h&31)<<6|f)}else if((h&240)===224){let f=o[s++]&63,c=o[s++]&63;l.push((h&31)<<12|f<<6|c)}else if((h&248)===240){let f=o[s++]&63,c=o[s++]&63,u=o[s++]&63,d=(h&7)<<18|f<<12|c<<6|u;d>65535&&(d-=65536,l.push(d>>>10&1023|55296),d=56320|d&1023),l.push(d)}}return String.fromCharCode.apply(null,l)},t.TextEncoder=r,t.TextDecoder=e})(typeof window!="undefined"?window:typeof self!="undefined"?self:Jh)});var tf=W(Dr=>{"use strict";Object.defineProperty(Dr,"__esModule",{value:!0});Dr.encode=Dr.decode=void 0;Qh();function vp(t,r="utf8"){return new TextDecoder(r).decode(t)}Dr.decode=vp;var _p=new TextEncoder;function Mp(t){return _p.encode(t)}Dr.encode=Mp});var Tr=W(Ji=>{"use strict";Object.defineProperty(Ji,"__esModule",{value:!0});Ji.IOBuffer=void 0;var xo=tf(),Ep=1024*8,kp=(()=>{let t=new Uint8Array(4),r=new Uint32Array(t.buffer);return!((r[0]=1)&t[0])})(),wo={int8:globalThis.Int8Array,uint8:globalThis.Uint8Array,int16:globalThis.Int16Array,uint16:globalThis.Uint16Array,int32:globalThis.Int32Array,uint32:globalThis.Uint32Array,uint64:globalThis.BigUint64Array,int64:globalThis.BigInt64Array,float32:globalThis.Float32Array,float64:globalThis.Float64Array},bo=class t{constructor(r=Ep,e={}){let i=!1;typeof r=="number"?r=new ArrayBuffer(r):(i=!0,this.lastWrittenByte=r.byteLength);let n=e.offset?e.offset>>>0:0,o=r.byteLength-n,s=n;(ArrayBuffer.isView(r)||r instanceof t)&&(r.byteLength!==r.buffer.byteLength&&(s=r.byteOffset+n),r=r.buffer),i?this.lastWrittenByte=o:this.lastWrittenByte=0,this.buffer=r,this.length=o,this.byteLength=o,this.byteOffset=s,this.offset=0,this.littleEndian=!0,this._data=new DataView(this.buffer,s,o),this._mark=0,this._marks=[]}available(r=1){return this.offset+r<=this.length}isLittleEndian(){return this.littleEndian}setLittleEndian(){return this.littleEndian=!0,this}isBigEndian(){return!this.littleEndian}setBigEndian(){return this.littleEndian=!1,this}skip(r=1){return this.offset+=r,this}back(r=1){return this.offset-=r,this}seek(r){return this.offset=r,this}mark(){return this._mark=this.offset,this}reset(){return this.offset=this._mark,this}pushMark(){return this._marks.push(this.offset),this}popMark(){let r=this._marks.pop();if(r===void 0)throw new Error("Mark stack empty");return this.seek(r),this}rewind(){return this.offset=0,this}ensureAvailable(r=1){if(!this.available(r)){let i=(this.offset+r)*2,n=new Uint8Array(i);n.set(new Uint8Array(this.buffer)),this.buffer=n.buffer,this.length=this.byteLength=i,this._data=new DataView(this.buffer)}return this}readBoolean(){return this.readUint8()!==0}readInt8(){return this._data.getInt8(this.offset++)}readUint8(){return this._data.getUint8(this.offset++)}readByte(){return this.readUint8()}readBytes(r=1){return this.readArray(r,"uint8")}readArray(r,e){let i=wo[e].BYTES_PER_ELEMENT*r,n=this.byteOffset+this.offset,o=this.buffer.slice(n,n+i);if(this.littleEndian===kp&&e!=="uint8"&&e!=="int8"){let a=new Uint8Array(this.buffer.slice(n,n+i));a.reverse();let l=new wo[e](a.buffer);return this.offset+=i,l.reverse(),l}let s=new wo[e](o);return this.offset+=i,s}readInt16(){let r=this._data.getInt16(this.offset,this.littleEndian);return this.offset+=2,r}readUint16(){let r=this._data.getUint16(this.offset,this.littleEndian);return this.offset+=2,r}readInt32(){let r=this._data.getInt32(this.offset,this.littleEndian);return this.offset+=4,r}readUint32(){let r=this._data.getUint32(this.offset,this.littleEndian);return this.offset+=4,r}readFloat32(){let r=this._data.getFloat32(this.offset,this.littleEndian);return this.offset+=4,r}readFloat64(){let r=this._data.getFloat64(this.offset,this.littleEndian);return this.offset+=8,r}readBigInt64(){let r=this._data.getBigInt64(this.offset,this.littleEndian);return this.offset+=8,r}readBigUint64(){let r=this._data.getBigUint64(this.offset,this.littleEndian);return this.offset+=8,r}readChar(){return String.fromCharCode(this.readInt8())}readChars(r=1){let e="";for(let i=0;i<r;i++)e+=this.readChar();return e}readUtf8(r=1){return(0,xo.decode)(this.readBytes(r))}decodeText(r=1,e="utf-8"){return(0,xo.decode)(this.readBytes(r),e)}writeBoolean(r){return this.writeUint8(r?255:0),this}writeInt8(r){return this.ensureAvailable(1),this._data.setInt8(this.offset++,r),this._updateLastWrittenByte(),this}writeUint8(r){return this.ensureAvailable(1),this._data.setUint8(this.offset++,r),this._updateLastWrittenByte(),this}writeByte(r){return this.writeUint8(r)}writeBytes(r){this.ensureAvailable(r.length);for(let e=0;e<r.length;e++)this._data.setUint8(this.offset++,r[e]);return this._updateLastWrittenByte(),this}writeInt16(r){return this.ensureAvailable(2),this._data.setInt16(this.offset,r,this.littleEndian),this.offset+=2,this._updateLastWrittenByte(),this}writeUint16(r){return this.ensureAvailable(2),this._data.setUint16(this.offset,r,this.littleEndian),this.offset+=2,this._updateLastWrittenByte(),this}writeInt32(r){return this.ensureAvailable(4),this._data.setInt32(this.offset,r,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeUint32(r){return this.ensureAvailable(4),this._data.setUint32(this.offset,r,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeFloat32(r){return this.ensureAvailable(4),this._data.setFloat32(this.offset,r,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeFloat64(r){return this.ensureAvailable(8),this._data.setFloat64(this.offset,r,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeBigInt64(r){return this.ensureAvailable(8),this._data.setBigInt64(this.offset,r,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeBigUint64(r){return this.ensureAvailable(8),this._data.setBigUint64(this.offset,r,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeChar(r){return this.writeUint8(r.charCodeAt(0))}writeChars(r){for(let e=0;e<r.length;e++)this.writeUint8(r.charCodeAt(e));return this}writeUtf8(r){return this.writeBytes((0,xo.encode)(r))}toArray(){return new Uint8Array(this.buffer,this.byteOffset,this.lastWrittenByte)}_updateLastWrittenByte(){this.offset>this.lastWrittenByte&&(this.lastWrittenByte=this.offset)}};Ji.IOBuffer=bo});var rf=W((i_,ef)=>{"use strict";ef.exports={BITMAPV5HEADER:{LogicalColorSpace:{LCS_CALIBRATED_RGB:0,LCS_sRGB:1934772034,LCS_WINDOWS_COLOR_SPACE:1466527264},Compression:{BI_RGB:0,BI_RLE8:1,BI_RLE4:2,BI_BITFIELDS:3,BI_JPEG:4,BI_PNG:5,BI_CMYK:11,BI_CMYKRLE8:12,BI_CMYKRLE4:13},GamutMappingIntent:{LCS_GM_ABS_COLORIMETRIC:8,LCS_GM_BUSINESS:1,LCS_GM_GRAPHICS:2,LCS_GM_IMAGES:4}}}});var af=W((n_,sf)=>{"use strict";var{IOBuffer:nf}=Tr(),yo=rf(),of=[];for(let t=0;t<=8;t++)of.push(255<<t);var vo=class extends nf{constructor(r){if(r.bitDepth!==1)throw new Error("Only bitDepth of 1 is supported");if(!r.height||!r.width)throw new Error("ImageData width and height are required");super(r.data),this.width=r.width,this.height=r.height,this.bitDepth=r.bitDepth,this.channels=r.channels,this.components=r.components}encode(){this.encoded=new nf,this.encoded.skip(14),this.writeBitmapV5Header(),this.writeColorTable();let r=this.encoded.offset;return this.writePixelArray(),this.encoded.rewind(),this.writeBitmapFileHeader(r),this.encoded.toArray()}writePixelArray(){let r=this.encoded,e=Math.floor((this.bitDepth*this.width+31)/32)*4,i=Math.ceil(this.bitDepth*this.width/8),n=e-i,o=this.bitDepth*this.width%8,s=o===0?0:8-o,a=e*this.height,l,h,f=0,c=0,u=8;r.mark(),h=this.readUint8();for(let d=this.height-1;d>=0;d--){let p=d===0;r.reset(),r.skip(d*e);for(let g=0;g<i;g++){let x=g===i-1;c<=s&&x?(r.writeByte(h<<c),(s===0||s===c)&&!p&&(l=h,h=this.readByte())):c===0?(l=h,h=this.readUint8(),r.writeByte(l)):(l=h,h=this.readUint8(),r.writeByte(l<<c&of[c]|h>>u)),x&&(f+=o||0,r.skip(n),c=f%8,u=8-c)}}e>i&&(r.reset(),r.skip(a-1),r.writeUint8(0))}writeColorTable(){this.encoded.writeUint32(0).writeUint32(16777215)}writeBitmapFileHeader(r){this.encoded.writeChars("BM").writeInt32(this.encoded.lastWrittenByte).writeUint16(0).writeUint16(0).writeUint32(r)}writeBitmapV5Header(){let e=Math.floor((this.bitDepth*this.width+31)/32)*4*this.height;this.encoded.writeUint32(124).writeInt32(this.width).writeInt32(this.height).writeUint16(1).writeUint16(this.bitDepth).writeUint32(yo.BITMAPV5HEADER.Compression.BI_RGB).writeUint32(e).writeInt32(0).writeInt32(0).writeUint32(Math.pow(2,this.bitDepth)).writeUint32(Math.pow(2,this.bitDepth)).writeUint32(4278190080).writeUint32(16711680).writeUint32(65280).writeUint32(255).writeUint32(yo.BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB).skip(36).skip(12).writeUint32(yo.BITMAPV5HEADER.GamutMappingIntent.LCS_GM_IMAGES).skip(12)}};sf.exports=vo});var hf=W(lf=>{"use strict";var Ap=af();lf.encode=function(r){return new Ap(r).encode()}});var z0=W((I_,pn)=>{var Y0=Y0||function(t){return Buffer.from(t).toString("base64")};function kx(t){var r=this,e=Math.round,i=Math.floor,n=new Array(64),o=new Array(64),s=new Array(64),a=new Array(64),l,h,f,c,u=new Array(65535),d=new Array(65535),p=new Array(64),g=new Array(64),x=[],m=0,w=7,y=new Array(64),M=new Array(64),_=new Array(64),T=new Array(256),E=new Array(2048),A,D=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],b=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],k=[0,1,2,3,4,5,6,7,8,9,10,11],C=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],S=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],X=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],B=[0,1,2,3,4,5,6,7,8,9,10,11],j=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],Z=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function tt(F){for(var et=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],it=0;it<64;it++){var U=i((et[it]*F+50)/100);U<1?U=1:U>255&&(U=255),n[D[it]]=U}for(var mt=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],gt=0;gt<64;gt++){var Mt=i((mt[gt]*F+50)/100);Mt<1?Mt=1:Mt>255&&(Mt=255),o[D[gt]]=Mt}for(var yt=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],Ct=0,Dt=0;Dt<8;Dt++)for(var N=0;N<8;N++)s[Ct]=1/(n[D[Ct]]*yt[Dt]*yt[N]*8),a[Ct]=1/(o[D[Ct]]*yt[Dt]*yt[N]*8),Ct++}function rt(F,et){for(var it=0,U=0,mt=new Array,gt=1;gt<=16;gt++){for(var Mt=1;Mt<=F[gt];Mt++)mt[et[U]]=[],mt[et[U]][0]=it,mt[et[U]][1]=gt,U++,it++;it*=2}return mt}function ht(){l=rt(b,k),h=rt(X,B),f=rt(C,S),c=rt(j,Z)}function at(){for(var F=1,et=2,it=1;it<=15;it++){for(var U=F;U<et;U++)d[32767+U]=it,u[32767+U]=[],u[32767+U][1]=it,u[32767+U][0]=U;for(var mt=-(et-1);mt<=-F;mt++)d[32767+mt]=it,u[32767+mt]=[],u[32767+mt][1]=it,u[32767+mt][0]=et-1+mt;F<<=1,et<<=1}}function nt(){for(var F=0;F<256;F++)E[F]=19595*F,E[F+256>>0]=38470*F,E[F+512>>0]=7471*F+32768,E[F+768>>0]=-11059*F,E[F+1024>>0]=-21709*F,E[F+1280>>0]=32768*F+8421375,E[F+1536>>0]=-27439*F,E[F+1792>>0]=-5329*F}function Y(F){for(var et=F[0],it=F[1]-1;it>=0;)et&1<<it&&(m|=1<<w),it--,w--,w<0&&(m==255?(P(255),P(0)):P(m),w=7,m=0)}function P(F){x.push(F)}function V(F){P(F>>8&255),P(F&255)}function st(F,et){var it,U,mt,gt,Mt,yt,Ct,Dt,N=0,H,ut=8,Tt=64;for(H=0;H<ut;++H){it=F[N],U=F[N+1],mt=F[N+2],gt=F[N+3],Mt=F[N+4],yt=F[N+5],Ct=F[N+6],Dt=F[N+7];var xt=it+Dt,bt=it-Dt,At=U+Ct,pt=U-Ct,St=mt+yt,Xt=mt-yt,Rt=gt+Mt,Jt=gt-Mt,we=xt+Rt,Ae=xt-Rt,Be=At+St,je=At-St;F[N]=we+Be,F[N+4]=we-Be;var ar=(je+Ae)*.707106781;F[N+2]=Ae+ar,F[N+6]=Ae-ar,we=Jt+Xt,Be=Xt+pt,je=pt+bt;var v=(we-je)*.382683433,I=.5411961*we+v,R=1.306562965*je+v,O=Be*.707106781,q=bt+O,K=bt-O;F[N+5]=K+I,F[N+3]=K-I,F[N+1]=q+R,F[N+7]=q-R,N+=8}for(N=0,H=0;H<ut;++H){it=F[N],U=F[N+8],mt=F[N+16],gt=F[N+24],Mt=F[N+32],yt=F[N+40],Ct=F[N+48],Dt=F[N+56];var Nt=it+Dt,Pt=it-Dt,jt=U+Ct,Qt=U-Ct,ei=mt+yt,Ht=mt-yt,Le=gt+Mt,ue=gt-Mt,de=Nt+Le,ee=Nt-Le,Oe=jt+ei,Ge=jt-ei;F[N]=de+Oe,F[N+32]=de-Oe;var Se=(Ge+ee)*.707106781;F[N+16]=ee+Se,F[N+48]=ee-Se,de=ue+Ht,Oe=Ht+Qt,Ge=Qt+Pt;var Vi=(de-Ge)*.382683433,zh=.5411961*de+Vi,Xh=1.306562965*Ge+Vi,jh=Oe*.707106781,Gh=Pt+jh,Vh=Pt-jh;F[N+40]=Vh+zh,F[N+24]=Vh-zh,F[N+8]=Gh+Xh,F[N+56]=Gh-Xh,N++}var $i;for(H=0;H<Tt;++H)$i=F[H]*et[H],p[H]=$i>0?$i+.5|0:$i-.5|0;return p}function J(){V(65504),V(16),P(74),P(70),P(73),P(70),P(0),P(1),P(1),P(0),V(1),V(1),P(0),P(0)}function ft(F){if(F){V(65505),F[0]===69&&F[1]===120&&F[2]===105&&F[3]===102?V(F.length+2):(V(F.length+5+2),P(69),P(120),P(105),P(102),P(0));for(var et=0;et<F.length;et++)P(F[et])}}function ct(F,et){V(65472),V(17),P(8),V(et),V(F),P(3),P(1),P(17),P(0),P(2),P(17),P(1),P(3),P(17),P(1)}function ot(){V(65499),V(132),P(0);for(var F=0;F<64;F++)P(n[F]);P(1);for(var et=0;et<64;et++)P(o[et])}function $(){V(65476),V(418),P(0);for(var F=0;F<16;F++)P(b[F+1]);for(var et=0;et<=11;et++)P(k[et]);P(16);for(var it=0;it<16;it++)P(C[it+1]);for(var U=0;U<=161;U++)P(S[U]);P(1);for(var mt=0;mt<16;mt++)P(X[mt+1]);for(var gt=0;gt<=11;gt++)P(B[gt]);P(17);for(var Mt=0;Mt<16;Mt++)P(j[Mt+1]);for(var yt=0;yt<=161;yt++)P(Z[yt])}function z(F){typeof F=="undefined"||F.constructor!==Array||F.forEach(et=>{if(typeof et=="string"){V(65534);var it=et.length;V(it+2);var U;for(U=0;U<it;U++)P(et.charCodeAt(U))}})}function Et(){V(65498),V(12),P(3),P(1),P(0),P(2),P(17),P(3),P(17),P(0),P(63),P(0)}function lt(F,et,it,U,mt){for(var gt=mt[0],Mt=mt[240],yt,Ct=16,Dt=63,N=64,H=st(F,et),ut=0;ut<N;++ut)g[D[ut]]=H[ut];var Tt=g[0]-it;it=g[0],Tt==0?Y(U[0]):(yt=32767+Tt,Y(U[d[yt]]),Y(u[yt]));for(var xt=63;xt>0&&g[xt]==0;xt--);if(xt==0)return Y(gt),it;for(var bt=1,At;bt<=xt;){for(var pt=bt;g[bt]==0&&bt<=xt;++bt);var St=bt-pt;if(St>=Ct){At=St>>4;for(var Xt=1;Xt<=At;++Xt)Y(Mt);St=St&15}yt=32767+g[bt],Y(mt[(St<<4)+d[yt]]),Y(u[yt]),bt++}return xt!=Dt&&Y(gt),it}function dt(){for(var F=String.fromCharCode,et=0;et<256;et++)T[et]=F(et)}this.encode=function(F,et){var it=new Date().getTime();et&&Yt(et),x=new Array,m=0,w=7,V(65496),J(),z(F.comments),ft(F.exifBuffer),ot(),ct(F.width,F.height),$(),Et();var U=0,mt=0,gt=0;m=0,w=7,this.encode.displayName="_encode_";for(var Mt=F.data,yt=F.width,Ct=F.height,Dt=yt*4,N=yt*3,H,ut=0,Tt,xt,bt,At,pt,St,Xt,Rt;ut<Ct;){for(H=0;H<Dt;){for(At=Dt*ut+H,pt=At,St=-1,Xt=0,Rt=0;Rt<64;Rt++)Xt=Rt>>3,St=(Rt&7)*4,pt=At+Xt*Dt+St,ut+Xt>=Ct&&(pt-=Dt*(ut+1+Xt-Ct)),H+St>=Dt&&(pt-=H+St-Dt+4),Tt=Mt[pt++],xt=Mt[pt++],bt=Mt[pt++],y[Rt]=(E[Tt]+E[xt+256>>0]+E[bt+512>>0]>>16)-128,M[Rt]=(E[Tt+768>>0]+E[xt+1024>>0]+E[bt+1280>>0]>>16)-128,_[Rt]=(E[Tt+1280>>0]+E[xt+1536>>0]+E[bt+1792>>0]>>16)-128;U=lt(y,s,U,l,f),mt=lt(M,a,mt,h,c),gt=lt(_,a,gt,h,c),H+=32}ut+=8}if(w>=0){var Jt=[];Jt[1]=w+1,Jt[0]=(1<<w+1)-1,Y(Jt)}if(V(65497),typeof pn=="undefined")return new Uint8Array(x);return Buffer.from(x);var we,Ae};function Yt(F){if(F<=0&&(F=1),F>100&&(F=100),A!=F){var et=0;F<50?et=Math.floor(5e3/F):et=Math.floor(200-F*2),tt(et),A=F}}function $t(){var F=new Date().getTime();t||(t=50),dt(),ht(),at(),nt(),Yt(t);var et=new Date().getTime()-F}$t()}typeof pn!="undefined"?pn.exports=N0:typeof window!="undefined"&&(window["jpeg-js"]=window["jpeg-js"]||{},window["jpeg-js"].encode=N0);function N0(t,r){typeof r=="undefined"&&(r=50);var e=new kx(r),i=e.encode(t,r);return{data:i,width:t.width,height:t.height}}});var j0=W((D_,ts)=>{var Qo=function(){"use strict";var r=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),e=4017,i=799,n=3406,o=2276,s=1567,a=3784,l=5793,h=2896;function f(){}function c(w,y){for(var M=0,_=[],T,E,A=16;A>0&&!w[A-1];)A--;_.push({children:[],index:0});var D=_[0],b;for(T=0;T<A;T++){for(E=0;E<w[T];E++){for(D=_.pop(),D.children[D.index]=y[M];D.index>0;){if(_.length===0)throw new Error("Could not recreate Huffman Table");D=_.pop()}for(D.index++,_.push(D);_.length<=T;)_.push(b={children:[],index:0}),D.children[D.index]=b.children,D=b;M++}T+1<A&&(_.push(b={children:[],index:0}),D.children[D.index]=b.children,D=b)}return _[0].children}function u(w,y,M,_,T,E,A,D,b,k){var C=M.precision,S=M.samplesPerLine,X=M.scanLines,B=M.mcusPerLine,j=M.progressive,Z=M.maxH,tt=M.maxV,rt=y,ht=0,at=0;function nt(){if(at>0)return at--,ht>>at&1;if(ht=w[y++],ht==255){var N=w[y++];if(N)throw new Error("unexpected marker: "+(ht<<8|N).toString(16))}return at=7,ht>>>7}function Y(N){for(var H=N,ut;(ut=nt())!==null;){if(H=H[ut],typeof H=="number")return H;if(typeof H!="object")throw new Error("invalid huffman sequence")}return null}function P(N){for(var H=0;N>0;){var ut=nt();if(ut===null)return;H=H<<1|ut,N--}return H}function V(N){var H=P(N);return H>=1<<N-1?H:H+(-1<<N)+1}function st(N,H){var ut=Y(N.huffmanTableDC),Tt=ut===0?0:V(ut);H[0]=N.pred+=Tt;for(var xt=1;xt<64;){var bt=Y(N.huffmanTableAC),At=bt&15,pt=bt>>4;if(At===0){if(pt<15)break;xt+=16;continue}xt+=pt;var St=r[xt];H[St]=V(At),xt++}}function J(N,H){var ut=Y(N.huffmanTableDC),Tt=ut===0?0:V(ut)<<b;H[0]=N.pred+=Tt}function ft(N,H){H[0]|=nt()<<b}var ct=0;function ot(N,H){if(ct>0){ct--;return}for(var ut=E,Tt=A;ut<=Tt;){var xt=Y(N.huffmanTableAC),bt=xt&15,At=xt>>4;if(bt===0){if(At<15){ct=P(At)+(1<<At)-1;break}ut+=16;continue}ut+=At;var pt=r[ut];H[pt]=V(bt)*(1<<b),ut++}}var $=0,z;function Et(N,H){for(var ut=E,Tt=A,xt=0;ut<=Tt;){var bt=r[ut],At=H[bt]<0?-1:1;switch($){case 0:var pt=Y(N.huffmanTableAC),St=pt&15,xt=pt>>4;if(St===0)xt<15?(ct=P(xt)+(1<<xt),$=4):(xt=16,$=1);else{if(St!==1)throw new Error("invalid ACn encoding");z=V(St),$=xt?2:3}continue;case 1:case 2:H[bt]?H[bt]+=(nt()<<b)*At:(xt--,xt===0&&($=$==2?3:0));break;case 3:H[bt]?H[bt]+=(nt()<<b)*At:(H[bt]=z<<b,$=0);break;case 4:H[bt]&&(H[bt]+=(nt()<<b)*At);break}ut++}$===4&&(ct--,ct===0&&($=0))}function lt(N,H,ut,Tt,xt){var bt=ut/B|0,At=ut%B,pt=bt*N.v+Tt,St=At*N.h+xt;N.blocks[pt]===void 0&&k.tolerantDecoding||H(N,N.blocks[pt][St])}function dt(N,H,ut){var Tt=ut/N.blocksPerLine|0,xt=ut%N.blocksPerLine;N.blocks[Tt]===void 0&&k.tolerantDecoding||H(N,N.blocks[Tt][xt])}var Yt=_.length,$t,F,et,it,U,mt;j?E===0?mt=D===0?J:ft:mt=D===0?ot:Et:mt=st;var gt=0,Mt,yt;Yt==1?yt=_[0].blocksPerLine*_[0].blocksPerColumn:yt=B*M.mcusPerColumn,T||(T=yt);for(var Ct,Dt;gt<yt;){for(F=0;F<Yt;F++)_[F].pred=0;if(ct=0,Yt==1)for($t=_[0],U=0;U<T;U++)dt($t,mt,gt),gt++;else for(U=0;U<T;U++){for(F=0;F<Yt;F++)for($t=_[F],Ct=$t.h,Dt=$t.v,et=0;et<Dt;et++)for(it=0;it<Ct;it++)lt($t,mt,gt,et,it);if(gt++,gt===yt)break}if(gt===yt)do{if(w[y]===255&&w[y+1]!==0)break;y+=1}while(y<w.length-2);if(at=0,Mt=w[y]<<8|w[y+1],Mt<65280)throw new Error("marker was not found");if(Mt>=65488&&Mt<=65495)y+=2;else break}return y-rt}function d(w,y){var M=[],_=y.blocksPerLine,T=y.blocksPerColumn,E=_<<3,A=new Int32Array(64),D=new Uint8Array(64);function b(rt,ht,at){var nt=y.quantizationTable,Y,P,V,st,J,ft,ct,ot,$,z=at,Et;for(Et=0;Et<64;Et++)z[Et]=rt[Et]*nt[Et];for(Et=0;Et<8;++Et){var lt=8*Et;if(z[1+lt]==0&&z[2+lt]==0&&z[3+lt]==0&&z[4+lt]==0&&z[5+lt]==0&&z[6+lt]==0&&z[7+lt]==0){$=l*z[0+lt]+512>>10,z[0+lt]=$,z[1+lt]=$,z[2+lt]=$,z[3+lt]=$,z[4+lt]=$,z[5+lt]=$,z[6+lt]=$,z[7+lt]=$;continue}Y=l*z[0+lt]+128>>8,P=l*z[4+lt]+128>>8,V=z[2+lt],st=z[6+lt],J=h*(z[1+lt]-z[7+lt])+128>>8,ot=h*(z[1+lt]+z[7+lt])+128>>8,ft=z[3+lt]<<4,ct=z[5+lt]<<4,$=Y-P+1>>1,Y=Y+P+1>>1,P=$,$=V*a+st*s+128>>8,V=V*s-st*a+128>>8,st=$,$=J-ct+1>>1,J=J+ct+1>>1,ct=$,$=ot+ft+1>>1,ft=ot-ft+1>>1,ot=$,$=Y-st+1>>1,Y=Y+st+1>>1,st=$,$=P-V+1>>1,P=P+V+1>>1,V=$,$=J*o+ot*n+2048>>12,J=J*n-ot*o+2048>>12,ot=$,$=ft*i+ct*e+2048>>12,ft=ft*e-ct*i+2048>>12,ct=$,z[0+lt]=Y+ot,z[7+lt]=Y-ot,z[1+lt]=P+ct,z[6+lt]=P-ct,z[2+lt]=V+ft,z[5+lt]=V-ft,z[3+lt]=st+J,z[4+lt]=st-J}for(Et=0;Et<8;++Et){var dt=Et;if(z[8+dt]==0&&z[16+dt]==0&&z[24+dt]==0&&z[32+dt]==0&&z[40+dt]==0&&z[48+dt]==0&&z[56+dt]==0){$=l*at[Et+0]+8192>>14,z[0+dt]=$,z[8+dt]=$,z[16+dt]=$,z[24+dt]=$,z[32+dt]=$,z[40+dt]=$,z[48+dt]=$,z[56+dt]=$;continue}Y=l*z[0+dt]+2048>>12,P=l*z[32+dt]+2048>>12,V=z[16+dt],st=z[48+dt],J=h*(z[8+dt]-z[56+dt])+2048>>12,ot=h*(z[8+dt]+z[56+dt])+2048>>12,ft=z[24+dt],ct=z[40+dt],$=Y-P+1>>1,Y=Y+P+1>>1,P=$,$=V*a+st*s+2048>>12,V=V*s-st*a+2048>>12,st=$,$=J-ct+1>>1,J=J+ct+1>>1,ct=$,$=ot+ft+1>>1,ft=ot-ft+1>>1,ot=$,$=Y-st+1>>1,Y=Y+st+1>>1,st=$,$=P-V+1>>1,P=P+V+1>>1,V=$,$=J*o+ot*n+2048>>12,J=J*n-ot*o+2048>>12,ot=$,$=ft*i+ct*e+2048>>12,ft=ft*e-ct*i+2048>>12,ct=$,z[0+dt]=Y+ot,z[56+dt]=Y-ot,z[8+dt]=P+ct,z[48+dt]=P-ct,z[16+dt]=V+ft,z[40+dt]=V-ft,z[24+dt]=st+J,z[32+dt]=st-J}for(Et=0;Et<64;++Et){var Yt=128+(z[Et]+8>>4);ht[Et]=Yt<0?0:Yt>255?255:Yt}}m(E*T*8);for(var k,C,S=0;S<T;S++){var X=S<<3;for(k=0;k<8;k++)M.push(new Uint8Array(E));for(var B=0;B<_;B++){b(y.blocks[S][B],D,A);var j=0,Z=B<<3;for(C=0;C<8;C++){var tt=M[X+C];for(k=0;k<8;k++)tt[Z+k]=D[j++]}}}return M}function p(w){return w<0?0:w>255?255:w}f.prototype={load:function(y){var M=new XMLHttpRequest;M.open("GET",y,!0),M.responseType="arraybuffer",M.onload=function(){var _=new Uint8Array(M.response||M.mozResponseArrayBuffer);this.parse(_),this.onload&&this.onload()}.bind(this),M.send(null)},parse:function(y){var M=this.opts.maxResolutionInMP*1e3*1e3,_=0,T=y.length;function E(){var pt=y[_]<<8|y[_+1];return _+=2,pt}function A(){var pt=E(),St=y.subarray(_,_+pt-2);return _+=St.length,St}function D(pt){var St=1,Xt=1,Rt,Jt;for(Jt in pt.components)pt.components.hasOwnProperty(Jt)&&(Rt=pt.components[Jt],St<Rt.h&&(St=Rt.h),Xt<Rt.v&&(Xt=Rt.v));var we=Math.ceil(pt.samplesPerLine/8/St),Ae=Math.ceil(pt.scanLines/8/Xt);for(Jt in pt.components)if(pt.components.hasOwnProperty(Jt)){Rt=pt.components[Jt];var Be=Math.ceil(Math.ceil(pt.samplesPerLine/8)*Rt.h/St),je=Math.ceil(Math.ceil(pt.scanLines/8)*Rt.v/Xt),ar=we*Rt.h,v=Ae*Rt.v,I=v*ar,R=[];m(I*256);for(var O=0;O<v;O++){for(var q=[],K=0;K<ar;K++)q.push(new Int32Array(64));R.push(q)}Rt.blocksPerLine=Be,Rt.blocksPerColumn=je,Rt.blocks=R}pt.maxH=St,pt.maxV=Xt,pt.mcusPerLine=we,pt.mcusPerColumn=Ae}var b=null,k=null,C=null,S,X,B=[],j=[],Z=[],tt=[],rt=E(),ht=-1;if(this.comments=[],rt!=65496)throw new Error("SOI not found");for(rt=E();rt!=65497;){var at,nt,Y;switch(rt){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var P=A();if(rt===65534){var V=String.fromCharCode.apply(null,P);this.comments.push(V)}rt===65504&&P[0]===74&&P[1]===70&&P[2]===73&&P[3]===70&&P[4]===0&&(b={version:{major:P[5],minor:P[6]},densityUnits:P[7],xDensity:P[8]<<8|P[9],yDensity:P[10]<<8|P[11],thumbWidth:P[12],thumbHeight:P[13],thumbData:P.subarray(14,14+3*P[12]*P[13])}),rt===65505&&P[0]===69&&P[1]===120&&P[2]===105&&P[3]===102&&P[4]===0&&(this.exifBuffer=P.subarray(5,P.length)),rt===65518&&P[0]===65&&P[1]===100&&P[2]===111&&P[3]===98&&P[4]===101&&P[5]===0&&(k={version:P[6],flags0:P[7]<<8|P[8],flags1:P[9]<<8|P[10],transformCode:P[11]});break;case 65499:for(var st=E(),J=st+_-2;_<J;){var ft=y[_++];m(256);var ct=new Int32Array(64);if(ft>>4)if(ft>>4===1)for(nt=0;nt<64;nt++){var ot=r[nt];ct[ot]=E()}else throw new Error("DQT: invalid table spec");else for(nt=0;nt<64;nt++){var ot=r[nt];ct[ot]=y[_++]}B[ft&15]=ct}break;case 65472:case 65473:case 65474:E(),S={},S.extended=rt===65473,S.progressive=rt===65474,S.precision=y[_++],S.scanLines=E(),S.samplesPerLine=E(),S.components={},S.componentsOrder=[];var $=S.scanLines*S.samplesPerLine;if($>M){var z=Math.ceil(($-M)/1e6);throw new Error(`maxResolutionInMP limit exceeded by ${z}MP`)}var Et=y[_++],lt,dt=0,Yt=0;for(at=0;at<Et;at++){lt=y[_];var $t=y[_+1]>>4,F=y[_+1]&15,et=y[_+2];if($t<=0||F<=0)throw new Error("Invalid sampling factor, expected values above 0");S.componentsOrder.push(lt),S.components[lt]={h:$t,v:F,quantizationIdx:et},_+=3}D(S),j.push(S);break;case 65476:var it=E();for(at=2;at<it;){var U=y[_++],mt=new Uint8Array(16),gt=0;for(nt=0;nt<16;nt++,_++)gt+=mt[nt]=y[_];m(16+gt);var Mt=new Uint8Array(gt);for(nt=0;nt<gt;nt++,_++)Mt[nt]=y[_];at+=17+gt,(U>>4?Z:tt)[U&15]=c(mt,Mt)}break;case 65501:E(),X=E();break;case 65500:E(),E();break;case 65498:var yt=E(),Ct=y[_++],Dt=[],N;for(at=0;at<Ct;at++){N=S.components[y[_++]];var H=y[_++];N.huffmanTableDC=tt[H>>4],N.huffmanTableAC=Z[H&15],Dt.push(N)}var ut=y[_++],Tt=y[_++],xt=y[_++],bt=u(y,_,S,Dt,X,ut,Tt,xt>>4,xt&15,this.opts);_+=bt;break;case 65535:y[_]!==255&&_--;break;default:if(y[_-3]==255&&y[_-2]>=192&&y[_-2]<=254){_-=3;break}else if(rt===224||rt==225){if(ht!==-1)throw new Error(`first unknown JPEG marker at offset ${ht.toString(16)}, second unknown JPEG marker ${rt.toString(16)} at offset ${(_-1).toString(16)}`);ht=_-1;let pt=E();if(y[_+pt-2]===255){_+=pt-2;break}}throw new Error("unknown JPEG marker "+rt.toString(16))}rt=E()}if(j.length!=1)throw new Error("only single frame JPEGs supported");for(var at=0;at<j.length;at++){var At=j[at].components;for(var nt in At)At[nt].quantizationTable=B[At[nt].quantizationIdx],delete At[nt].quantizationIdx}this.width=S.samplesPerLine,this.height=S.scanLines,this.jfif=b,this.adobe=k,this.components=[];for(var at=0;at<S.componentsOrder.length;at++){var N=S.components[S.componentsOrder[at]];this.components.push({lines:d(S,N),scaleX:N.h/S.maxH,scaleY:N.v/S.maxV})}},getData:function(y,M){var _=this.width/y,T=this.height/M,E,A,D,b,k,C,S,X,B,j,Z=0,tt,rt,ht,at,nt,Y,P,V,st,J,ft,ct=y*M*this.components.length;m(ct);var ot=new Uint8Array(ct);switch(this.components.length){case 1:for(E=this.components[0],j=0;j<M;j++)for(k=E.lines[0|j*E.scaleY*T],B=0;B<y;B++)tt=k[0|B*E.scaleX*_],ot[Z++]=tt;break;case 2:for(E=this.components[0],A=this.components[1],j=0;j<M;j++)for(k=E.lines[0|j*E.scaleY*T],C=A.lines[0|j*A.scaleY*T],B=0;B<y;B++)tt=k[0|B*E.scaleX*_],ot[Z++]=tt,tt=C[0|B*A.scaleX*_],ot[Z++]=tt;break;case 3:for(ft=!0,this.adobe&&this.adobe.transformCode?ft=!0:typeof this.opts.colorTransform!="undefined"&&(ft=!!this.opts.colorTransform),E=this.components[0],A=this.components[1],D=this.components[2],j=0;j<M;j++)for(k=E.lines[0|j*E.scaleY*T],C=A.lines[0|j*A.scaleY*T],S=D.lines[0|j*D.scaleY*T],B=0;B<y;B++)ft?(tt=k[0|B*E.scaleX*_],rt=C[0|B*A.scaleX*_],ht=S[0|B*D.scaleX*_],V=p(tt+1.402*(ht-128)),st=p(tt-.3441363*(rt-128)-.71413636*(ht-128)),J=p(tt+1.772*(rt-128))):(V=k[0|B*E.scaleX*_],st=C[0|B*A.scaleX*_],J=S[0|B*D.scaleX*_]),ot[Z++]=V,ot[Z++]=st,ot[Z++]=J;break;case 4:if(!this.adobe)throw new Error("Unsupported color mode (4 components)");for(ft=!1,this.adobe&&this.adobe.transformCode?ft=!0:typeof this.opts.colorTransform!="undefined"&&(ft=!!this.opts.colorTransform),E=this.components[0],A=this.components[1],D=this.components[2],b=this.components[3],j=0;j<M;j++)for(k=E.lines[0|j*E.scaleY*T],C=A.lines[0|j*A.scaleY*T],S=D.lines[0|j*D.scaleY*T],X=b.lines[0|j*b.scaleY*T],B=0;B<y;B++)ft?(tt=k[0|B*E.scaleX*_],rt=C[0|B*A.scaleX*_],ht=S[0|B*D.scaleX*_],at=X[0|B*b.scaleX*_],nt=255-p(tt+1.402*(ht-128)),Y=255-p(tt-.3441363*(rt-128)-.71413636*(ht-128)),P=255-p(tt+1.772*(rt-128))):(nt=k[0|B*E.scaleX*_],Y=C[0|B*A.scaleX*_],P=S[0|B*D.scaleX*_],at=X[0|B*b.scaleX*_]),ot[Z++]=255-nt,ot[Z++]=255-Y,ot[Z++]=255-P,ot[Z++]=255-at;break;default:throw new Error("Unsupported color mode")}return ot},copyToImageData:function(y,M){var _=y.width,T=y.height,E=y.data,A=this.getData(_,T),D=0,b=0,k,C,S,X,B,j,Z,tt,rt;switch(this.components.length){case 1:for(C=0;C<T;C++)for(k=0;k<_;k++)S=A[D++],E[b++]=S,E[b++]=S,E[b++]=S,M&&(E[b++]=255);break;case 3:for(C=0;C<T;C++)for(k=0;k<_;k++)Z=A[D++],tt=A[D++],rt=A[D++],E[b++]=Z,E[b++]=tt,E[b++]=rt,M&&(E[b++]=255);break;case 4:for(C=0;C<T;C++)for(k=0;k<_;k++)B=A[D++],j=A[D++],S=A[D++],X=A[D++],Z=255-p(B*(1-X/255)+X),tt=255-p(j*(1-X/255)+X),rt=255-p(S*(1-X/255)+X),E[b++]=Z,E[b++]=tt,E[b++]=rt,M&&(E[b++]=255);break;default:throw new Error("Unsupported color mode")}}};var g=0,x=0;function m(w=0){var y=g+w;if(y>x){var M=Math.ceil((y-x)/1024/1024);throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${M}MB`)}g=y}return f.resetMaxMemoryUsage=function(w){g=0,x=w},f.getBytesAllocated=function(){return g},f.requestMemoryAllocation=m,f}();typeof ts!="undefined"?ts.exports=X0:typeof window!="undefined"&&(window["jpeg-js"]=window["jpeg-js"]||{},window["jpeg-js"].decode=X0);function X0(t,r={}){var e={colorTransform:void 0,useTArray:!1,formatAsRGBA:!0,tolerantDecoding:!0,maxResolutionInMP:100,maxMemoryUsageInMB:512},i=lr(lr({},e),r),n=new Uint8Array(t),o=new Qo;o.opts=i,Qo.resetMaxMemoryUsage(i.maxMemoryUsageInMB*1024*1024),o.parse(n);var s=i.formatAsRGBA?4:3,a=o.width*o.height*s;try{Qo.requestMemoryAllocation(a);var l={width:o.width,height:o.height,exifBuffer:o.exifBuffer,data:i.useTArray?new Uint8Array(a):Buffer.alloc(a)};o.comments.length>0&&(l.comments=o.comments)}catch(h){throw h instanceof RangeError?new Error("Could not allocate enough memory for the image. Required: "+a):h instanceof ReferenceError&&h.message==="Buffer is not defined"?new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true"):h}return o.copyToImageData(l,i.formatAsRGBA),l}});var es=W((R_,G0)=>{var Ax=z0(),Sx=j0();G0.exports={encode:Ax,decode:Sx}});var tc=W((z_,Dx)=>{Dx.exports={name:"has-own",version:"1.0.1",description:"A safer .hasOwnProperty() - hasOwn(name, obj)",main:"index.js",scripts:{test:"make test"},author:"Aaron Heckmann <aaron.heckmann+github@gmail.com>",license:"MIT",repository:{type:"git",url:"git://github.com/aheckmann/has-own.git"},homepage:"https://github.com/aheckmann/has-own/",devDependencies:{mocha:"^6.2.2"}}});var ss=W((os,ec)=>{var Tx=Object.prototype.hasOwnProperty;ec.exports=os=function(r,e){return Tx.call(e,r)};os.version=tc().version});var fs=W((q_,xc)=>{"use strict";var ls=[],hs=class{constructor(r,e){e=e||{},r===void 0&&(r=8192),typeof r=="number"&&(r=new ArrayBuffer(r));let i=r.byteLength,n=e.offset?e.offset>>>0:0;r.buffer&&(i=r.byteLength-n,r.byteLength!==r.buffer.byteLength?r=r.buffer.slice(r.byteOffset+n,r.byteOffset+r.byteLength):n?r=r.buffer.slice(n):r=r.buffer),this.buffer=r,this.length=i,this.byteLength=i,this.byteOffset=0,this.offset=0,this.littleEndian=!0,this._data=new DataView(this.buffer),this._increment=i||8192,this._mark=0}available(r){return r===void 0&&(r=1),this.offset+r<=this.length}isLittleEndian(){return this.littleEndian}setLittleEndian(){this.littleEndian=!0}isBigEndian(){return!this.littleEndian}setBigEndian(){this.littleEndian=!1}skip(r){r===void 0&&(r=1),this.offset+=r}seek(r){this.offset=r}mark(){this._mark=this.offset}reset(){this.offset=this._mark}rewind(){this.offset=0}ensureAvailable(r){if(r===void 0&&(r=1),!this.available(r)){let e=this._increment+this._increment;this._increment=e;let i=this.length+e,n=new Uint8Array(i);n.set(new Uint8Array(this.buffer)),this.buffer=n.buffer,this.length=i,this._data=new DataView(this.buffer)}}readBoolean(){return this.readUint8()!==0}readInt8(){return this._data.getInt8(this.offset++)}readUint8(){return this._data.getUint8(this.offset++)}readByte(){return this.readUint8()}readBytes(r){r===void 0&&(r=1);for(var e=new Uint8Array(r),i=0;i<r;i++)e[i]=this.readByte();return e}readInt16(){var r=this._data.getInt16(this.offset,this.littleEndian);return this.offset+=2,r}readUint16(){var r=this._data.getUint16(this.offset,this.littleEndian);return this.offset+=2,r}readInt32(){var r=this._data.getInt32(this.offset,this.littleEndian);return this.offset+=4,r}readUint32(){var r=this._data.getUint32(this.offset,this.littleEndian);return this.offset+=4,r}readFloat32(){var r=this._data.getFloat32(this.offset,this.littleEndian);return this.offset+=4,r}readFloat64(){var r=this._data.getFloat64(this.offset,this.littleEndian);return this.offset+=8,r}readChar(){return String.fromCharCode(this.readInt8())}readChars(r){r===void 0&&(r=1),ls.length=r;for(var e=0;e<r;e++)ls[e]=this.readChar();return ls.join("")}writeBoolean(r){this.writeUint8(r?255:0)}writeInt8(r){this.ensureAvailable(1),this._data.setInt8(this.offset++,r)}writeUint8(r){this.ensureAvailable(1),this._data.setUint8(this.offset++,r)}writeByte(r){this.writeUint8(r)}writeBytes(r){this.ensureAvailable(r.length);for(var e=0;e<r.length;e++)this._data.setUint8(this.offset++,r[e])}writeInt16(r){this.ensureAvailable(2),this._data.setInt16(this.offset,r,this.littleEndian),this.offset+=2}writeUint16(r){this.ensureAvailable(2),this._data.setUint16(this.offset,r,this.littleEndian),this.offset+=2}writeInt32(r){this.ensureAvailable(4),this._data.setInt32(this.offset,r,this.littleEndian),this.offset+=4}writeUint32(r){this.ensureAvailable(4),this._data.setUint32(this.offset,r,this.littleEndian),this.offset+=4}writeFloat32(r){this.ensureAvailable(4),this._data.setFloat32(this.offset,r,this.littleEndian),this.offset+=4}writeFloat64(r){this.ensureAvailable(8),this._data.setFloat64(this.offset,r,this.littleEndian),this.offset+=8}writeChar(r){this.writeUint8(r.charCodeAt(0))}writeChars(r){for(var e=0;e<r.length;e++)this.writeUint8(r.charCodeAt(e))}toArray(){return new Uint8Array(this.buffer,0,this.offset)}};xc.exports=hs});var yc=W((W_,bc)=>{"use strict";var us={254:"NewSubfileType",255:"SubfileType",256:"ImageWidth",257:"ImageLength",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",263:"Threshholding",264:"CellWidth",265:"CellLength",266:"FillOrder",270:"ImageDescription",271:"Make",272:"Model",273:"StripOffsets",274:"Orientation",277:"SamplesPerPixel",278:"RowsPerStrip",279:"StripByteCounts",280:"MinSampleValue",281:"MaxSampleValue",282:"XResolution",283:"YResolution",284:"PlanarConfiguration",288:"FreeOffsets",289:"FreeByteCounts",290:"GrayResponseUnit",291:"GrayResponseCurve",296:"ResolutionUnit",305:"Software",306:"DateTime",315:"Artist",316:"HostComputer",320:"ColorMap",338:"ExtraSamples",33432:"Copyright",269:"DocumentName",285:"PageName",286:"XPosition",287:"YPosition",292:"T4Options",293:"T6Options",297:"PageNumber",301:"TransferFunction",317:"Predictor",318:"WhitePoint",319:"PrimaryChromaticities",321:"HalftoneHints",322:"TileWidth",323:"TileLength",324:"TileOffsets",325:"TileByteCounts",326:"BadFaxLines",327:"CleanFaxData",328:"ConsecutiveBadFaxLines",330:"SubIFDs",332:"InkSet",333:"InkNames",334:"NumberOfInks",336:"DotRange",337:"TargetPrinter",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",342:"TransferRange",343:"ClipPath",344:"XClipPathUnits",345:"YClipPathUnits",346:"Indexed",347:"JPEGTables",351:"OPIProxy",400:"GlobalParametersIFD",401:"ProfileType",402:"FaxProfile",403:"CodingMethods",404:"VersionYear",405:"ModeNumber",433:"Decode",434:"DefaultImageColor",512:"JPEGProc",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",515:"JPEGRestartInterval",517:"JPEGLosslessPredictors",518:"JPEGPointTransforms",519:"JPEGQTables",520:"JPEGDCTables",521:"JPEGACTables",529:"YCbCrCoefficients",530:"YCbCrSubSampling",531:"YCbCrPositioning",532:"ReferenceBlackWhite",559:"StripRowCounts",700:"XMP",32781:"ImageID",34732:"ImageLayer",32932:"WangAnnotatio",33445:"MDFileTag",33446:"MDScalePixel",33447:"MDColorTable",33448:"MDLabName",33449:"MDSampleInfo",33450:"MDPrepDate",33451:"MDPrepTime",33452:"MDFileUnits",33550:"ModelPixelScaleTag",33723:"IPTC",33918:"INGRPacketDataTag",33919:"INGRFlagRegisters",33920:"IrasBTransformationMatrix",33922:"ModelTiepointTag",34264:"ModelTransformationTag",34377:"Photoshop",34665:"ExifIFD",34675:"ICCProfile",34735:"GeoKeyDirectoryTag",34736:"GeoDoubleParamsTag",34737:"GeoAsciiParamsTag",34853:"GPSIFD",34908:"HylaFAXFaxRecvParams",34909:"HylaFAXFaxSubAddress",34910:"HylaFAXFaxRecvTime",37724:"ImageSourceData",40965:"InteroperabilityIFD",42112:"GDAL_METADATA",42113:"GDAL_NODATA",50215:"OceScanjobDescription",50216:"OceApplicationSelector",50217:"OceIdentificationNumber",50218:"OceImageLogicCharacteristics",50706:"DNGVersion",50707:"DNGBackwardVersion",50708:"UniqueCameraModel",50709:"LocalizedCameraModel",50710:"CFAPlaneColor",50711:"CFALayout",50712:"LinearizationTable",50713:"BlackLevelRepeatDim",50714:"BlackLevel",50715:"BlackLevelDeltaH",50716:"BlackLevelDeltaV",50717:"WhiteLevel",50718:"DefaultScale",50719:"DefaultCropOrigin",50720:"DefaultCropSize",50721:"ColorMatrix1",50722:"ColorMatrix2",50723:"CameraCalibration1",50724:"CameraCalibration2",50725:"ReductionMatrix1",50726:"ReductionMatrix2",50727:"AnalogBalance",50728:"AsShotNeutral",50729:"AsShotWhiteXY",50730:"BaselineExposure",50731:"BaselineNoise",50732:"BaselineSharpness",50733:"BayerGreenSplit",50734:"LinearResponseLimit",50735:"CameraSerialNumber",50736:"LensInfo",50737:"ChromaBlurRadius",50738:"AntiAliasStrength",50740:"DNGPrivateData",50741:"MakerNoteSafety",50778:"CalibrationIlluminant1",50779:"CalibrationIlluminant2",50780:"BestQualityScale",50784:"AliasLayerMetadata"},wc={};for(cs in us)wc[us[cs]]=cs;var cs;bc.exports={tagsById:us,tagsByName:wc}});var Mc=W((K_,_c)=>{"use strict";var ps={33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"ISOSpeedRatings",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",36864:"ExifVersion",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBiasValue",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37386:"FocalLength",37396:"SubjectArea",37500:"MakerNote",37510:"UserComment",37520:"SubsecTime",37521:"SubsecTimeOriginal",37522:"SubsecTimeDigitized",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",40964:"RelatedSoundFile",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber",42240:"Gamma"},vc={};for(ds in ps)vc[ps[ds]]=ds;var ds;_c.exports={tagsById:ps,tagsByName:vc}});var Ac=W((H_,kc)=>{"use strict";var gs={0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},Ec={};for(ms in gs)Ec[gs[ms]]=ms;var ms;kc.exports={tagsById:gs,tagsByName:Ec}});var ws=W((Z_,Ic)=>{"use strict";var Sc={standard:yc(),exif:Mc(),gps:Ac()},xs=class{constructor(r){if(!r)throw new Error("missing kind");this.data=null,this.fields=new Map,this.kind=r,this._map=null}get(r){if(typeof r=="number")return this.fields.get(r);if(typeof r=="string")return this.fields.get(Sc[this.kind].tagsByName[r]);throw new Error("expected a number or string")}get map(){if(!this._map){this._map={};let e=Sc[this.kind].tagsById;for(var r of this.fields.keys())e[r]&&(this._map[e[r]]=this.fields.get(r))}return this._map}};Ic.exports=xs});var Rc=W((J_,Tc)=>{"use strict";var Ux=ws(),Nx=/^(\\d{4}):(\\d{2}):(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})$/,bs=class extends Ux{constructor(){super("standard")}get size(){return this.width*this.height}get width(){return this.imageWidth}get height(){return this.imageLength}get components(){return this.samplesPerPixel}get date(){var r=new Date,e=Nx.exec(this.dateTime);return r.setFullYear(e[1],e[2]-1,e[3]),r.setHours(e[4],e[5],e[6]),r}get newSubfileType(){return this.get(254)}get imageWidth(){return this.get(256)}get imageLength(){return this.get(257)}get bitsPerSample(){return this.get(258)}get compression(){return this.get(259)||1}get type(){return this.get(262)}get fillOrder(){return this.get(266)||1}get documentName(){return this.get(269)}get imageDescription(){return this.get(270)}get stripOffsets(){return Dc(this.get(273))}get orientation(){return this.get(274)}get samplesPerPixel(){return this.get(277)}get rowsPerStrip(){return this.get(278)}get stripByteCounts(){return Dc(this.get(279))}get minSampleValue(){return this.get(280)||0}get maxSampleValue(){return this.get(281)||Math.pow(2,this.bitsPerSample)-1}get xResolution(){return this.get(282)}get yResolution(){return this.get(283)}get planarConfiguration(){return this.get(284)||1}get resolutionUnit(){return this.get(296)||2}get dateTime(){return this.get(306)}get predictor(){return this.get(317)||1}get sampleFormat(){return this.get(339)||1}get sMinSampleValue(){return this.get(340)||this.minSampleValue}get sMaxSampleValue(){return this.get(341)||this.maxSampleValue}};function Dc(t){return typeof t=="number"?[t]:t}Tc.exports=bs});var Fc=W(ys=>{"use strict";var Cc=new Map([[1,[1,Pc]],[2,[1,Yx]],[3,[2,zx]],[4,[4,Xx]],[5,[8,jx]],[6,[1,Gx]],[7,[1,Pc]],[8,[2,Vx]],[9,[4,$x]],[10,[8,qx]],[11,[4,Wx]],[12,[8,Kx]]]);ys.getByteLength=function(t,r){return Cc.get(t)[0]*r};ys.readData=function(t,r,e){return Cc.get(r)[1](t,e)};function Pc(t,r){if(r===1)return t.readUint8();for(var e=new Uint8Array(r),i=0;i<r;i++)e[i]=t.readUint8();return e}function Yx(t,r){for(var e=[],i="",n=0;n<r;n++){var o=String.fromCharCode(t.readUint8());o==="\\0"?(e.push(i),i=""):i+=o}return e.length===1?e[0]:e}function zx(t,r){if(r===1)return t.readUint16();for(var e=new Uint16Array(r),i=0;i<r;i++)e[i]=t.readUint16();return e}function Xx(t,r){if(r===1)return t.readUint32();for(var e=new Uint32Array(r),i=0;i<r;i++)e[i]=t.readUint32();return e}function jx(t,r){if(r===1)return t.readUint32()/t.readUint32();for(var e=new Array(r),i=0;i<r;i++)e[i]=t.readUint32()/t.readUint32();return e}function Gx(t,r){if(r===1)return t.readInt8();for(var e=new Int8Array(r),i=0;i<r;i++)e[i]=t.readInt8();return e}function Vx(t,r){if(r===1)return t.readInt16();for(var e=new Int16Array(r),i=0;i<r;i++)e[i]=t.readInt16();return e}function $x(t,r){if(r===1)return t.readInt32();for(var e=new Int32Array(r),i=0;i<r;i++)e[i]=t.readInt32();return e}function qx(t,r){if(r===1)return t.readInt32()/t.readInt32();for(var e=new Array(r),i=0;i<r;i++)e[i]=t.readInt32()/t.readInt32();return e}function Wx(t,r){if(r===1)return t.readFloat32();for(var e=new Float32Array(r),i=0;i<r;i++)e[i]=t.readFloat32();return e}function Kx(t,r){if(r===1)return t.readFloat64();for(var e=new Float64Array(r),i=0;i<r;i++)e[i]=t.readFloat64();return e}});var Oc=W((t5,Lc)=>{"use strict";var Hx=fs(),Zx=ws(),Jx=Rc(),Bc=Fc(),Qx={ignoreImageData:!1,onlyFirst:!1},vs=class extends Hx{constructor(r,e){super(r,e),this._nextIFD=0}decode(r){r=Object.assign({},Qx,r);let e=[];for(this.decodeHeader();this._nextIFD;)if(e.push(this.decodeIFD(r)),r.onlyFirst)return e[0];return e}decodeHeader(){let r=this.readUint16();if(r===18761)this.setLittleEndian();else if(r===19789)this.setBigEndian();else throw new Error("invalid byte order: 0x"+r.toString(16));if(r=this.readUint16(),r!==42)throw new Error("not a TIFF file");this._nextIFD=this.readUint32()}decodeIFD(r){this.seek(this._nextIFD);var e;r.kind?e=new Zx(r.kind):e=new Jx;let i=this.readUint16();for(var n=0;n<i;n++)this.decodeIFDEntry(e);return r.ignoreImageData||this.decodeImageData(e),this._nextIFD=this.readUint32(),e}decodeIFDEntry(r){let e=this.offset,i=this.readUint16(),n=this.readUint16(),o=this.readUint32();if(n<1||n>12){this.skip(4);return}Bc.getByteLength(n,o)>4&&this.seek(this.readUint32());let a=Bc.readData(this,n,o);if(r.fields.set(i,a),i===34665||i===34853){let l=this.offset,h;i===34665?h="exif":i===34853&&(h="gps"),this._nextIFD=a,r[h]=this.decodeIFD({kind:h,ignoreImageData:!0}),this.offset=l}this.seek(e),this.skip(12)}decodeImageData(r){let e=r.orientation;switch(e&&e!==1&&Xr("orientation",e),r.type){case 1:case 2:this.readStripData(r);break;default:Xr("image type",r.type);break}}readStripData(r){let e=r.width,i=r.height,n=nw(r.bitsPerSample),o=r.sampleFormat,s=e*i,a=tw(s,1,n,o),l=r.compression,f=r.rowsPerStrip*e,c=r.stripOffsets,u=r.stripByteCounts;for(var d=0,p=0;p<c.length;p++){var g=this.getStripData(l,c[p],u[p]),x=s>f?f:s;s-=x,n===8?d=ew(a,g,d,x):n===16?d=rw(a,g,d,x,this.isLittleEndian()):n===32&&o===3?d=iw(a,g,d,x,this.isLittleEndian()):Xr("bitDepth",n)}r.data=a}getStripData(r,e,i){switch(r){case 1:return new DataView(this.buffer,e,i);case 2:case 32773:return Xr("Compression",r);default:throw new Error("invalid compression: "+r)}}};Lc.exports=vs;function tw(t,r,e,i){return e===8?new Uint8Array(t*r):e===16?new Uint16Array(t*r):e===32&&i===3?new Float32Array(t*r):Xr("bit depth / sample format",e+" / "+i)}function ew(t,r,e,i){for(var n=0;n<i;n++)t[e++]=r.getUint8(n);return e}function rw(t,r,e,i,n){for(var o=0;o<i*2;o+=2)t[e++]=r.getUint16(o,n);return e}function iw(t,r,e,i,n){for(var o=0;o<i*4;o+=4)t[e++]=r.getFloat32(o,n);return e}function Xr(t,r){throw new Error("Unsupported "+t+": "+r)}function nw(t){if(t.length){let e=t;t=e[0];for(var r=0;r<e.length;r++)e[r]!==t&&Xr("bit depth",e)}return t}});var Nc=W((e5,Uc)=>{"use strict";var ow=Oc();Uc.exports=function(r,e){return new ow(r,e).decode(e)}});var zc=W(Yc=>{"use strict";Yc.decode=Nc()});var jc=W((i5,Xc)=>{"use strict";var sw=fs(),aw=zc();function lw(t){let r=new sw(t),e={};if(r.setBigEndian(),r.readUint16()!==65496)throw new Error("SOI marker not found. Not a valid JPEG file");if(r.readUint16()===65505){let o=r.readUint16(),s=r.readBytes(6);if(s[0]===69&&s[1]===120&&s[2]===105&&s[3]===102&&s[4]===0&&s[5]===0){let a=aw.decode(r,{onlyFirst:!0,ignoreImageData:!0,offset:r.offset});e.exif=a}}return e}Xc.exports=lw});var Vc=W(Gc=>{"use strict";Gc.decode=jc()});var $c=W((exports,module)=>{"use strict";var toBytes=t=>[...t].map(r=>r.charCodeAt(0)),xpiZipFilename=toBytes("META-INF/mozilla.rsa"),oxmlContentTypes=toBytes("[Content_Types].xml"),oxmlRels=toBytes("_rels/.rels");function readUInt64LE(t,r=0){let e=t[r],i=1,n=0;for(;++n<8;)i*=256,e+=t[r+n]*i;return e}var fileType=t=>{if(!(t instanceof Uint8Array||t instanceof ArrayBuffer||Buffer.isBuffer(t)))throw new TypeError(`Expected the \\`input\\` argument to be of type \\`Uint8Array\\` or \\`Buffer\\` or \\`ArrayBuffer\\`, got \\`${typeof t}\\``);let r=t instanceof Uint8Array?t:new Uint8Array(t);if(!(r&&r.length>1))return null;let e=(n,o)=>{o=Object.assign({offset:0},o);for(let s=0;s<n.length;s++)if(o.mask){if(n[s]!==(o.mask[s]&r[s+o.offset]))return!1}else if(n[s]!==r[s+o.offset])return!1;return!0},i=(n,o)=>e(toBytes(n),o);if(e([255,216,255]))return{ext:"jpg",mime:"image/jpeg"};if(e([137,80,78,71,13,10,26,10]))return{ext:"png",mime:"image/png"};if(e([71,73,70]))return{ext:"gif",mime:"image/gif"};if(e([87,69,66,80],{offset:8}))return{ext:"webp",mime:"image/webp"};if(e([70,76,73,70]))return{ext:"flif",mime:"image/flif"};if((e([73,73,42,0])||e([77,77,0,42]))&&e([67,82],{offset:8}))return{ext:"cr2",mime:"image/x-canon-cr2"};if(e([73,73,42,0])||e([77,77,0,42]))return{ext:"tif",mime:"image/tiff"};if(e([66,77]))return{ext:"bmp",mime:"image/bmp"};if(e([73,73,188]))return{ext:"jxr",mime:"image/vnd.ms-photo"};if(e([56,66,80,83]))return{ext:"psd",mime:"image/vnd.adobe.photoshop"};if(e([80,75,3,4])){if(e([109,105,109,101,116,121,112,101,97,112,112,108,105,99,97,116,105,111,110,47,101,112,117,98,43,122,105,112],{offset:30}))return{ext:"epub",mime:"application/epub+zip"};if(e(xpiZipFilename,{offset:30}))return{ext:"xpi",mime:"application/x-xpinstall"};if(i("mimetypeapplication/vnd.oasis.opendocument.text",{offset:30}))return{ext:"odt",mime:"application/vnd.oasis.opendocument.text"};if(i("mimetypeapplication/vnd.oasis.opendocument.spreadsheet",{offset:30}))return{ext:"ods",mime:"application/vnd.oasis.opendocument.spreadsheet"};if(i("mimetypeapplication/vnd.oasis.opendocument.presentation",{offset:30}))return{ext:"odp",mime:"application/vnd.oasis.opendocument.presentation"};let n=(l,h=0)=>l.findIndex((f,c,u)=>c>=h&&u[c]===80&&u[c+1]===75&&u[c+2]===3&&u[c+3]===4),o=0,s=!1,a=null;do{let l=o+30;if(s||(s=e(oxmlContentTypes,{offset:l})||e(oxmlRels,{offset:l})),a||(i("word/",{offset:l})?a={ext:"docx",mime:"application/vnd.openxmlformats-officedocument.wordprocessingml.document"}:i("ppt/",{offset:l})?a={ext:"pptx",mime:"application/vnd.openxmlformats-officedocument.presentationml.presentation"}:i("xl/",{offset:l})&&(a={ext:"xlsx",mime:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"})),s&&a)return a;o=n(r,l)}while(o>=0);if(a)return a}if(e([80,75])&&(r[2]===3||r[2]===5||r[2]===7)&&(r[3]===4||r[3]===6||r[3]===8))return{ext:"zip",mime:"application/zip"};if(e([117,115,116,97,114],{offset:257}))return{ext:"tar",mime:"application/x-tar"};if(e([82,97,114,33,26,7])&&(r[6]===0||r[6]===1))return{ext:"rar",mime:"application/x-rar-compressed"};if(e([31,139,8]))return{ext:"gz",mime:"application/gzip"};if(e([66,90,104]))return{ext:"bz2",mime:"application/x-bzip2"};if(e([55,122,188,175,39,28]))return{ext:"7z",mime:"application/x-7z-compressed"};if(e([120,1]))return{ext:"dmg",mime:"application/x-apple-diskimage"};if(e([51,103,112,53])||e([0,0,0])&&e([102,116,121,112],{offset:4})&&(e([109,112,52,49],{offset:8})||e([109,112,52,50],{offset:8})||e([105,115,111,109],{offset:8})||e([105,115,111,50],{offset:8})||e([109,109,112,52],{offset:8})||e([77,52,86],{offset:8})||e([100,97,115,104],{offset:8})))return{ext:"mp4",mime:"video/mp4"};if(e([77,84,104,100]))return{ext:"mid",mime:"audio/midi"};if(e([26,69,223,163])){let n=r.subarray(4,4100),o=n.findIndex((s,a,l)=>l[a]===66&&l[a+1]===130);if(o!==-1){let s=o+3,a=l=>[...l].every((h,f)=>n[s+f]===h.charCodeAt(0));if(a("matroska"))return{ext:"mkv",mime:"video/x-matroska"};if(a("webm"))return{ext:"webm",mime:"video/webm"}}}if(e([0,0,0,20,102,116,121,112,113,116,32,32])||e([102,114,101,101],{offset:4})||e([102,116,121,112,113,116,32,32],{offset:4})||e([109,100,97,116],{offset:4})||e([109,111,111,118],{offset:4})||e([119,105,100,101],{offset:4}))return{ext:"mov",mime:"video/quicktime"};if(e([82,73,70,70])){if(e([65,86,73],{offset:8}))return{ext:"avi",mime:"video/vnd.avi"};if(e([87,65,86,69],{offset:8}))return{ext:"wav",mime:"audio/vnd.wave"};if(e([81,76,67,77],{offset:8}))return{ext:"qcp",mime:"audio/qcelp"}}if(e([48,38,178,117,142,102,207,17,166,217])){let n=30;do{let o=readUInt64LE(r,n+16);if(e([145,7,220,183,183,169,207,17,142,230,0,192,12,32,83,101],{offset:n})){if(e([64,158,105,248,77,91,207,17,168,253,0,128,95,92,68,43],{offset:n+24}))return{ext:"wma",mime:"audio/x-ms-wma"};if(e([192,239,25,188,77,91,207,17,168,253,0,128,95,92,68,43],{offset:n+24}))return{ext:"wmv",mime:"video/x-ms-asf"};break}n+=o}while(n+24<=r.length);return{ext:"asf",mime:"application/vnd.ms-asf"}}if(e([0,0,1,186])||e([0,0,1,179]))return{ext:"mpg",mime:"video/mpeg"};if(e([102,116,121,112,51,103],{offset:4}))return{ext:"3gp",mime:"video/3gpp"};for(let n=0;n<2&&n<r.length-16;n++){if(e([73,68,51],{offset:n})||e([255,226],{offset:n,mask:[255,226]}))return{ext:"mp3",mime:"audio/mpeg"};if(e([255,228],{offset:n,mask:[255,228]}))return{ext:"mp2",mime:"audio/mpeg"};if(e([255,248],{offset:n,mask:[255,252]}))return{ext:"mp2",mime:"audio/mpeg"};if(e([255,240],{offset:n,mask:[255,252]}))return{ext:"mp4",mime:"audio/mpeg"}}if(e([102,116,121,112,77,52,65],{offset:4}))return{ext:"m4a",mime:"audio/mp4"};if(e([79,112,117,115,72,101,97,100],{offset:28}))return{ext:"opus",mime:"audio/opus"};if(e([79,103,103,83]))return e([128,116,104,101,111,114,97],{offset:28})?{ext:"ogv",mime:"video/ogg"}:e([1,118,105,100,101,111,0],{offset:28})?{ext:"ogm",mime:"video/ogg"}:e([127,70,76,65,67],{offset:28})?{ext:"oga",mime:"audio/ogg"}:e([83,112,101,101,120,32,32],{offset:28})?{ext:"spx",mime:"audio/ogg"}:e([1,118,111,114,98,105,115],{offset:28})?{ext:"ogg",mime:"audio/ogg"}:{ext:"ogx",mime:"application/ogg"};if(e([102,76,97,67]))return{ext:"flac",mime:"audio/x-flac"};if(e([77,65,67,32]))return{ext:"ape",mime:"audio/ape"};if(e([119,118,112,107]))return{ext:"wv",mime:"audio/wavpack"};if(e([35,33,65,77,82,10]))return{ext:"amr",mime:"audio/amr"};if(e([37,80,68,70]))return{ext:"pdf",mime:"application/pdf"};if(e([77,90]))return{ext:"exe",mime:"application/x-msdownload"};if((r[0]===67||r[0]===70)&&e([87,83],{offset:1}))return{ext:"swf",mime:"application/x-shockwave-flash"};if(e([123,92,114,116,102]))return{ext:"rtf",mime:"application/rtf"};if(e([0,97,115,109]))return{ext:"wasm",mime:"application/wasm"};if(e([119,79,70,70])&&(e([0,1,0,0],{offset:4})||e([79,84,84,79],{offset:4})))return{ext:"woff",mime:"font/woff"};if(e([119,79,70,50])&&(e([0,1,0,0],{offset:4})||e([79,84,84,79],{offset:4})))return{ext:"woff2",mime:"font/woff2"};if(e([76,80],{offset:34})&&(e([0,0,1],{offset:8})||e([1,0,2],{offset:8})||e([2,0,2],{offset:8})))return{ext:"eot",mime:"application/vnd.ms-fontobject"};if(e([0,1,0,0,0]))return{ext:"ttf",mime:"font/ttf"};if(e([79,84,84,79,0]))return{ext:"otf",mime:"font/otf"};if(e([0,0,1,0]))return{ext:"ico",mime:"image/x-icon"};if(e([0,0,2,0]))return{ext:"cur",mime:"image/x-icon"};if(e([70,76,86,1]))return{ext:"flv",mime:"video/x-flv"};if(e([37,33]))return{ext:"ps",mime:"application/postscript"};if(e([253,55,122,88,90,0]))return{ext:"xz",mime:"application/x-xz"};if(e([83,81,76,105]))return{ext:"sqlite",mime:"application/x-sqlite3"};if(e([78,69,83,26]))return{ext:"nes",mime:"application/x-nintendo-nes-rom"};if(e([67,114,50,52]))return{ext:"crx",mime:"application/x-google-chrome-extension"};if(e([77,83,67,70])||e([73,83,99,40]))return{ext:"cab",mime:"application/vnd.ms-cab-compressed"};if(e([33,60,97,114,99,104,62,10,100,101,98,105,97,110,45,98,105,110,97,114,121]))return{ext:"deb",mime:"application/x-deb"};if(e([33,60,97,114,99,104,62]))return{ext:"ar",mime:"application/x-unix-archive"};if(e([237,171,238,219]))return{ext:"rpm",mime:"application/x-rpm"};if(e([31,160])||e([31,157]))return{ext:"Z",mime:"application/x-compress"};if(e([76,90,73,80]))return{ext:"lz",mime:"application/x-lzip"};if(e([208,207,17,224,161,177,26,225]))return{ext:"msi",mime:"application/x-msi"};if(e([6,14,43,52,2,5,1,1,13,1,2,1,1,2]))return{ext:"mxf",mime:"application/mxf"};if(e([71],{offset:4})&&(e([71],{offset:192})||e([71],{offset:196})))return{ext:"mts",mime:"video/mp2t"};if(e([66,76,69,78,68,69,82]))return{ext:"blend",mime:"application/x-blender"};if(e([66,80,71,251]))return{ext:"bpg",mime:"image/bpg"};if(e([0,0,0,12,106,80,32,32,13,10,135,10])){if(e([106,112,50,32],{offset:20}))return{ext:"jp2",mime:"image/jp2"};if(e([106,112,120,32],{offset:20}))return{ext:"jpx",mime:"image/jpx"};if(e([106,112,109,32],{offset:20}))return{ext:"jpm",mime:"image/jpm"};if(e([109,106,112,50],{offset:20}))return{ext:"mj2",mime:"image/mj2"}}if(e([70,79,82,77]))return{ext:"aif",mime:"audio/aiff"};if(i("<?xml "))return{ext:"xml",mime:"application/xml"};if(e([66,79,79,75,77,79,66,73],{offset:60}))return{ext:"mobi",mime:"application/x-mobipocket-ebook"};if(e([102,116,121,112],{offset:4})){if(e([109,105,102,49],{offset:8}))return{ext:"heic",mime:"image/heif"};if(e([109,115,102,49],{offset:8}))return{ext:"heic",mime:"image/heif-sequence"};if(e([104,101,105,99],{offset:8})||e([104,101,105,120],{offset:8}))return{ext:"heic",mime:"image/heic"};if(e([104,101,118,99],{offset:8})||e([104,101,118,120],{offset:8}))return{ext:"heic",mime:"image/heic-sequence"}}return e([171,75,84,88,32,49,49,187,13,10,26,10])?{ext:"ktx",mime:"image/ktx"}:e([68,73,67,77],{offset:128})?{ext:"dcm",mime:"application/dicom"}:e([77,80,43])?{ext:"mpc",mime:"audio/x-musepack"}:e([77,80,67,75])?{ext:"mpc",mime:"audio/x-musepack"}:e([66,69,71,73,78,58])?{ext:"ics",mime:"text/calendar"}:e([103,108,84,70,2,0,0,0])?{ext:"glb",mime:"model/gltf-binary"}:e([212,195,178,161])||e([161,178,195,212])?{ext:"pcap",mime:"application/vnd.tcpdump.pcap"}:null};module.exports=fileType;module.exports.default=fileType;Object.defineProperty(fileType,"minimumBytes",{value:4100});module.exports.stream=readableStream=>new Promise((resolve,reject)=>{let stream=eval("require")("stream");readableStream.once("readable",()=>{let t=new stream.PassThrough,r=readableStream.read(module.exports.minimumBytes)||readableStream.read();try{t.fileType=fileType(r)}catch(e){reject(e)}readableStream.unshift(r),stream.pipeline?resolve(stream.pipeline(readableStream,t,()=>{})):resolve(readableStream.pipe(t))})})});var Wc=W((o5,Ms)=>{"use strict";var qc=$c(),hw=new Set(["jpg","png","gif","webp","flif","cr2","tif","bmp","jxr","psd","ico","bpg","jp2","jpm","jpx","heic","cur","dcm"]),_s=t=>{let r=qc(t);return hw.has(r&&r.ext)?r:null};Ms.exports=_s;Ms.exports.default=_s;Object.defineProperty(_s,"minimumBytes",{value:qc.minimumBytes})});var Js=W((vM,vn)=>{(function(){function t(i){for(var n=0,o=i.length-1,s=void 0,a=void 0,l=void 0,h=e(n,o);;){if(o<=n)return i[h];if(o==n+1)return i[n]>i[o]&&r(i,n,o),i[h];for(s=e(n,o),i[s]>i[o]&&r(i,s,o),i[n]>i[o]&&r(i,n,o),i[s]>i[n]&&r(i,s,n),r(i,s,n+1),a=n+1,l=o;;){do a++;while(i[n]>i[a]);do l--;while(i[l]>i[n]);if(l<a)break;r(i,a,l)}r(i,n,l),l<=h&&(n=a),l>=h&&(o=l-1)}}var r=function(n,o,s){var a;return a=[n[s],n[o]],n[o]=a[0],n[s]=a[1],a},e=function(n,o){return~~((n+o)/2)};typeof vn!="undefined"&&vn.exports?vn.exports=t:window.median=t})()});var ea=W(_n=>{var IM=function(){var t;typeof _n!="undefined"?t=_n:t={};var r={release:"0.3.0",date:"2013-03"};t.toString=function(){return"version "+r.release+", released "+r.date};for(var e=0,i=null,n=null,o={init:function(l){if(l!==0&&!(l&l-1))e=l,o._initArray(),o._makeBitReversalTable(),o._makeCosSinTable();else throw new Error("init: radix-2 required")},fft1d:function(l,h){o.fft(l,h,1)},ifft1d:function(l,h){var f=1/e;o.fft(l,h,-1);for(var c=0;c<e;c++)l[c]*=f,h[c]*=f},bt1d:function(l,h){o.fft(l,h,-1)},fft2d:function(l,h){for(var f=[],c=[],u=0,d=0;d<e;d++){u=d*e;for(var p=0;p<e;p++)f[p]=l[p+u],c[p]=h[p+u];o.fft1d(f,c);for(var g=0;g<e;g++)l[g+u]=f[g],h[g+u]=c[g]}for(var x=0;x<e;x++){for(var m=0;m<e;m++)u=x+m*e,f[m]=l[u],c[m]=h[u];o.fft1d(f,c);for(var w=0;w<e;w++)u=x+w*e,l[u]=f[w],h[u]=c[w]}},ifft2d:function(l,h){for(var f=[],c=[],u=0,d=0;d<e;d++){u=d*e;for(var p=0;p<e;p++)f[p]=l[p+u],c[p]=h[p+u];o.ifft1d(f,c);for(var g=0;g<e;g++)l[g+u]=f[g],h[g+u]=c[g]}for(var x=0;x<e;x++){for(var m=0;m<e;m++)u=x+m*e,f[m]=l[u],c[m]=h[u];o.ifft1d(f,c);for(var w=0;w<e;w++)u=x+w*e,l[u]=f[w],h[u]=c[w]}},fft:function(l,h,f){for(var c,u,d,p,g,x,m,w,y,M=e>>2,_=0;_<e;_++)p=i[_],_<p&&(g=l[_],l[_]=l[p],l[p]=g,g=h[_],h[_]=h[p],h[p]=g);for(var T=1;T<e;T<<=1){u=0,c=e/(T<<1);for(var E=0;E<T;E++){x=n[u+M],m=f*n[u];for(var A=E;A<e;A+=T<<1)d=A+T,w=x*l[d]+m*h[d],y=x*h[d]-m*l[d],l[d]=l[A]-w,l[A]+=w,h[d]=h[A]-y,h[A]+=y;u+=c}}},_initArray:function(){typeof Uint32Array!="undefined"?i=new Uint32Array(e):i=[],typeof Float64Array!="undefined"?n=new Float64Array(e*1.25):n=[]},_paddingZero:function(){},_makeBitReversalTable:function(){var l=0,h=0,f=0;for(i[0]=0;++l<e;){for(f=e>>1;f<=h;)h-=f,f>>=1;h+=f,i[l]=h}},_makeCosSinTable:function(){var l=e>>1,h=e>>2,f=e>>3,c=l+h,u=Math.sin(Math.PI/e),d=2*u*u,p=Math.sqrt(d*(2-d)),g=n[h]=1,x=n[0]=0;u=2*d;for(var m=1;m<f;m++)g-=d,d+=u*g,x+=p,p-=u*x,n[m]=x,n[h-m]=g;f!==0&&(n[f]=Math.sqrt(.5));for(var w=0;w<h;w++)n[l-w]=n[w];for(var y=0;y<c;y++)n[y+l]=-n[y]}},s=["init","fft1d","ifft1d","fft2d","ifft2d"],a=0;a<s.length;a++)t[s[a]]=o[s[a]];return t.bt=o.bt1d,t.fft=o.fft1d,t.ifft=o.ifft1d,t}.call(_n)});var Du=W((TM,Iu)=>{"use strict";var Qe=ea(),Xw={DEBUG:!1,ifft2DArray:function(t,r,e){var i=new Array(r*e),n=r/2,o=(e-1)*2;Qe.init(n);for(var s={re:new Array(n),im:new Array(n)},a=0;a<e;a++){for(var l=n-1;l>=0;l--)s.re[l]=t[l*2*e+a],s.im[l]=t[(l*2+1)*e+a];Qe.bt(s.re,s.im);for(var l=n-1;l>=0;l--)i[l*2*e+a]=s.re[l],i[(l*2+1)*e+a]=s.im[l]}var h=new Array(n*o);Qe.init(o);for(var f={re:new Array(o),im:new Array(o)},c=o*n,l=0;l<r;l+=2){f.re[0]=i[l*e],f.im[0]=i[(l+1)*e];for(var a=1;a<e;a++)f.re[a]=i[l*e+a],f.im[a]=i[(l+1)*e+a],f.re[o-a]=i[l*e+a],f.im[o-a]=-i[(l+1)*e+a];Qe.bt(f.re,f.im);for(var u=l/2*o,a=o-1;a>=0;a--)h[u+a]=f.re[a]/c}return h},fft2DArray:function(t,r,e,i){var n=Object.assign({},{inplace:!0}),o=e/2+1,s=r*2,a=new Array(s*o);Qe.init(e);for(var l={re:new Array(e),im:new Array(e)},h={re:new Array(e),im:new Array(e)},f={re:new Array(e),im:new Array(e)},c,u,d,p,g,x=0;x<r/2;x++){c=x*2*e,l.re=t.slice(c,c+e),c=(x*2+1)*e,l.im=t.slice(c,c+e),Qe.fft1d(l.re,l.im),this.reconstructTwoRealFFT(l,h,f),u=x*4*o,d=(x*4+1)*o,p=(x*4+2)*o,g=(x*4+3)*o;for(var m=o-1;m>=0;m--)a[u+m]=h.re[m],a[d+m]=h.im[m],a[p+m]=f.re[m],a[g+m]=f.im[m]}h=null,f=null;var w=new Array(s*o);Qe.init(r);for(var y={re:new Array(r),im:new Array(r)},M=o-1;M>=0;M--){for(var x=r-1;x>=0;x--)y.re[x]=a[x*2*o+M],y.im[x]=a[(x*2+1)*o+M],isNaN(y.re[x])&&(y.re[x]=0),isNaN(y.im[x])&&(y.im[x]=0);Qe.fft1d(y.re,y.im);for(var x=r-1;x>=0;x--)w[x*2*o+M]=y.re[x],w[(x*2+1)*o+M]=y.im[x]}return w},reconstructTwoRealFFT:function(t,r,e){var i=t.re.length;r.re[0]=t.re[0],r.im[0]=0,e.re[0]=t.im[0],e.im[0]=0;for(var n,o,s,a,l,h=i/2;h>0;h--)l=i-h,n=.5*(t.re[h]-t.re[l]),o=.5*(t.re[h]+t.re[l]),s=.5*(t.im[h]-t.im[l]),a=.5*(t.im[h]+t.im[l]),r.re[h]=o,r.im[h]=s,r.re[l]=o,r.im[l]=-s,e.re[h]=a,e.im[h]=-n,e.re[l]=a,e.im[l]=n},convolute2DI:function(t,r,e,i){for(var n,o,s=0;s<e/2;s++)for(var a=0;a<i;a++)n=t[s*2*i+a]*r[s*2*i+a]-t[(s*2+1)*i+a]*r[(s*2+1)*i+a],o=t[s*2*i+a]*r[(s*2+1)*i+a]+t[(s*2+1)*i+a]*r[s*2*i+a],t[s*2*i+a]=n,t[(s*2+1)*i+a]=o},convolute:function(t,r,e,i,n){for(var o=new Array(i*e),s=0;s<e*i;s++)o[s]=t[s];o=this.fft2DArray(o,e,i);for(var a=r.length,l=r[0].length,h=new Array(i*e),s=0;s<i*e;s++)h[s]=0;for(var f,c,u=Math.floor((a-1)/2),d=Math.floor((l-1)/2),p=0;p<a;p++){f=(p-u+e)%e;for(var g=0;g<l;g++)c=(g-d+i)%i,h[f*i+c]=r[p][g]}h=this.fft2DArray(h,e,i);var x=e*2,m=i/2+1;return this.convolute2DI(o,h,x,m),this.ifft2DArray(o,x,m)},toRadix2:function(t,r,e){var i,n,o,s,a=e,l=r,h=0,f=0;if(!(e!==0&&!(e&e-1))){for(a=0;e>>++a;);a=1<<a,f=a-e}if(!(r!==0&&!(r&r-1))){for(l=0;r>>++l;);l=1<<l,h=(l-r)*a}if(l==r&&a==e)return{data:t,rows:r,cols:e};var c=new Array(l*a),u=Math.floor((l-r)/2)-r,d=Math.floor((a-e)/2)-e;for(i=0;i<l;i++)for(o=i*a,s=(i-u)%r*e,n=0;n<a;n++)c[o+n]=t[s+(n-d)%e];return{data:c,rows:l,cols:a}},crop:function(t,r,e,i,n,o){if(r==i&&e==n)return t;var s=Object.assign({},o),a=new Array(n*i),l=Math.floor((r-i)/2),h=Math.floor((e-n)/2),f,c,u,d;for(u=0;u<i;u++)for(f=u*n,c=(u+l)*e,d=0;d<n;d++)a[f+d]=t[c+(d+h)];return a}};Iu.exports=Xw});var Tu=W(ra=>{"use strict";ra.FFTUtils=Du();ra.FFT=ea()});var Pu=W((PM,Ru)=>{"use strict;";var ia=Tu().FFTUtils;function jw(t,r,e){var i=na(t),n=i.data,o=Object.assign({normalize:!1,divisor:1,rows:i.rows,cols:i.cols},e),s,a;if(o.rows&&o.cols)s=o.rows,a=o.cols;else throw new Error("Invalid number of rows or columns "+s+" "+a);var l=o.divisor,h,f,c=r.length,u=r[0].length;if(o.normalize)for(l=0,h=0;h<c;h++)for(f=0;f<u;f++)l+=r[h][f];if(l===0)throw new RangeError("convolution: The divisor is equal to zero");var d=ia.toRadix2(n,s,a),p=ia.convolute(d.data,r,d.rows,d.cols);if(p=ia.crop(p,d.rows,d.cols,s,a),l!=0&&l!=1)for(h=0;h<p.length;h++)p[h]/=l;return p}function Gw(t,r,e){var i=na(t),n=i.data,o=Object.assign({normalize:!1,divisor:1,rows:i.rows,cols:i.cols},e),s,a;if(o.rows&&o.cols)s=o.rows,a=o.cols;else throw new Error("Invalid number of rows or columns "+s+" "+a);var l=o.divisor,h=r.length,f=r[0].length,c,u,d,p,g,x,m,w,y;if(o.normalize)for(l=0,c=0;c<h;c++)for(u=0;u<f;u++)l+=r[c][u];if(l===0)throw new RangeError("convolution: The divisor is equal to zero");var M=new Array(s*a),_=Math.floor(h/2),T=Math.floor(f/2);for(p=0;p<s;p++)for(d=0;d<a;d++){for(x=0,u=0;u<h;u++)for(c=0;c<f;c++)m=r[h-u-1][f-c-1],w=(p+u-_+s)%s,y=(d+c-T+a)%a,g=w*a+y,x+=n[g]*m;g=p*a+d,M[g]=x/l}return M}function Vw(t,r,e){var i=1e3;e&&e.factor&&(i=e.factor);var n=new Array(r),o,s,a,l,h;i*=-1;var f=(r-1)/2,c=2*t*t;for(o=0;o<r;o++)for(n[o]=new Array(r),l=(o-f)*(o-f),s=0;s<r;s++)a=-((s-f)*(s-f)+l)/c,n[o][s]=Math.round(i*(1+a)*Math.exp(a));return n}function na(t){var r=t,e,i;if(typeof t[0]!="number"){e=t.length,i=t[0].length,r=new Array(e*i);for(var n=0;n<e;n++)for(var o=0;o<i;o++)r[n*i+o]=t[n][o]}else{var s=Math.sqrt(t.length);Number.isInteger(s)&&(e=s,i=s)}return{data:r,rows:e,cols:i}}Ru.exports={fft:jw,direct:Gw,kernelFactory:{LoG:Vw},matrix2Array:na}});var Fu=W((CM,Cu)=>{"use strict";Cu.exports=Number.isFinite||function(t){return!(typeof t!="number"||t!==t||t===1/0||t===-1/0)}});var oa=W((FM,Bu)=>{var $w=Fu();Bu.exports=Number.isInteger||function(t){return typeof t=="number"&&$w(t)&&Math.floor(t)===t}});var Nu=W((UM,Uu)=>{"use strict";function le(t){if(this.size=t|0,this.size<=1||this.size&this.size-1)throw new Error("FFT size must be a power of two and bigger than 1");this._csize=t<<1;for(var r=new Array(this.size*2),e=0;e<r.length;e+=2){let l=Math.PI*e/this.size;r[e]=Math.cos(l),r[e+1]=-Math.sin(l)}this.table=r;for(var i=0,n=1;this.size>n;n<<=1)i++;this._width=i%2===0?i-1:i,this._bitrev=new Array(1<<this._width);for(var o=0;o<this._bitrev.length;o++){this._bitrev[o]=0;for(var s=0;s<this._width;s+=2){var a=this._width-s-2;this._bitrev[o]|=(o>>>s&3)<<a}}this._out=null,this._data=null,this._inv=0}Uu.exports=le;le.prototype.fromComplexArray=function(r,e){for(var i=e||new Array(r.length>>>1),n=0;n<r.length;n+=2)i[n>>>1]=r[n];return i};le.prototype.createComplexArray=function(){let r=new Array(this._csize);for(var e=0;e<r.length;e++)r[e]=0;return r};le.prototype.toComplexArray=function(r,e){for(var i=e||this.createComplexArray(),n=0;n<i.length;n+=2)i[n]=r[n>>>1],i[n+1]=0;return i};le.prototype.completeSpectrum=function(r){for(var e=this._csize,i=e>>>1,n=2;n<i;n+=2)r[e-n]=r[n],r[e-n+1]=-r[n+1]};le.prototype.transform=function(r,e){if(r===e)throw new Error("Input and output buffers must be different");this._out=r,this._data=e,this._inv=0,this._transform4(),this._out=null,this._data=null};le.prototype.realTransform=function(r,e){if(r===e)throw new Error("Input and output buffers must be different");this._out=r,this._data=e,this._inv=0,this._realTransform4(),this._out=null,this._data=null};le.prototype.inverseTransform=function(r,e){if(r===e)throw new Error("Input and output buffers must be different");this._out=r,this._data=e,this._inv=1,this._transform4();for(var i=0;i<r.length;i++)r[i]/=this.size;this._out=null,this._data=null};le.prototype._transform4=function(){var r=this._out,e=this._csize,i=this._width,n=1<<i,o=e/n<<1,s,a,l=this._bitrev;if(o===4)for(s=0,a=0;s<e;s+=o,a++){let g=l[a];this._singleTransform2(s,g,n)}else for(s=0,a=0;s<e;s+=o,a++){let g=l[a];this._singleTransform4(s,g,n)}var h=this._inv?-1:1,f=this.table;for(n>>=2;n>=2;n>>=2){o=e/n<<1;var c=o>>>2;for(s=0;s<e;s+=o)for(var u=s+c,d=s,p=0;d<u;d+=2,p+=n){let g=d,x=g+c,m=x+c,w=m+c,y=r[g],M=r[g+1],_=r[x],T=r[x+1],E=r[m],A=r[m+1],D=r[w],b=r[w+1],k=y,C=M,S=f[p],X=h*f[p+1],B=_*S-T*X,j=_*X+T*S,Z=f[2*p],tt=h*f[2*p+1],rt=E*Z-A*tt,ht=E*tt+A*Z,at=f[3*p],nt=h*f[3*p+1],Y=D*at-b*nt,P=D*nt+b*at,V=k+rt,st=C+ht,J=k-rt,ft=C-ht,ct=B+Y,ot=j+P,$=h*(B-Y),z=h*(j-P),Et=V+ct,lt=st+ot,dt=V-ct,Yt=st-ot,$t=J+z,F=ft-$,et=J-z,it=ft+$;r[g]=Et,r[g+1]=lt,r[x]=$t,r[x+1]=F,r[m]=dt,r[m+1]=Yt,r[w]=et,r[w+1]=it}}};le.prototype._singleTransform2=function(r,e,i){let n=this._out,o=this._data,s=o[e],a=o[e+1],l=o[e+i],h=o[e+i+1],f=s+l,c=a+h,u=s-l,d=a-h;n[r]=f,n[r+1]=c,n[r+2]=u,n[r+3]=d};le.prototype._singleTransform4=function(r,e,i){let n=this._out,o=this._data,s=this._inv?-1:1,a=i*2,l=i*3,h=o[e],f=o[e+1],c=o[e+i],u=o[e+i+1],d=o[e+a],p=o[e+a+1],g=o[e+l],x=o[e+l+1],m=h+d,w=f+p,y=h-d,M=f-p,_=c+g,T=u+x,E=s*(c-g),A=s*(u-x),D=m+_,b=w+T,k=y+A,C=M-E,S=m-_,X=w-T,B=y-A,j=M+E;n[r]=D,n[r+1]=b,n[r+2]=k,n[r+3]=C,n[r+4]=S,n[r+5]=X,n[r+6]=B,n[r+7]=j};le.prototype._realTransform4=function(){var r=this._out,e=this._csize,i=this._width,n=1<<i,o=e/n<<1,s,a,l=this._bitrev;if(o===4)for(s=0,a=0;s<e;s+=o,a++){let At=l[a];this._singleRealTransform2(s,At>>>1,n>>>1)}else for(s=0,a=0;s<e;s+=o,a++){let At=l[a];this._singleRealTransform4(s,At>>>1,n>>>1)}var h=this._inv?-1:1,f=this.table;for(n>>=2;n>=2;n>>=2){o=e/n<<1;var c=o>>>1,u=c>>>1,d=u>>>1;for(s=0;s<e;s+=o)for(var p=0,g=0;p<=d;p+=2,g+=n){var x=s+p,m=x+u,w=m+u,y=w+u,M=r[x],_=r[x+1],T=r[m],E=r[m+1],A=r[w],D=r[w+1],b=r[y],k=r[y+1],C=M,S=_,X=f[g],B=h*f[g+1],j=T*X-E*B,Z=T*B+E*X,tt=f[2*g],rt=h*f[2*g+1],ht=A*tt-D*rt,at=A*rt+D*tt,nt=f[3*g],Y=h*f[3*g+1],P=b*nt-k*Y,V=b*Y+k*nt,st=C+ht,J=S+at,ft=C-ht,ct=S-at,ot=j+P,$=Z+V,z=h*(j-P),Et=h*(Z-V),lt=st+ot,dt=J+$,Yt=ft+Et,$t=ct-z;if(r[x]=lt,r[x+1]=dt,r[m]=Yt,r[m+1]=$t,p===0){var F=st-ot,et=J-$;r[w]=F,r[w+1]=et;continue}if(p!==d){var it=ft,U=-ct,mt=st,gt=-J,Mt=-h*Et,yt=-h*z,Ct=-h*$,Dt=-h*ot,N=it+Mt,H=U+yt,ut=mt+Dt,Tt=gt-Ct,xt=s+u-p,bt=s+c-p;r[xt]=N,r[xt+1]=H,r[bt]=ut,r[bt+1]=Tt}}}};le.prototype._singleRealTransform2=function(r,e,i){let n=this._out,o=this._data,s=o[e],a=o[e+i],l=s+a,h=s-a;n[r]=l,n[r+1]=0,n[r+2]=h,n[r+3]=0};le.prototype._singleRealTransform4=function(r,e,i){let n=this._out,o=this._data,s=this._inv?-1:1,a=i*2,l=i*3,h=o[e],f=o[e+i],c=o[e+a],u=o[e+l],d=h+c,p=h-c,g=f+u,x=s*(f-u),m=d+g,w=p,y=-x,M=d-g,_=p,T=x;n[r]=m,n[r+1]=0,n[r+2]=w,n[r+3]=y,n[r+4]=M,n[r+5]=0,n[r+6]=_,n[r+7]=T}});var zu=W((NM,Yu)=>{Yu.exports=Ww;function Ww(t){return t===0?1:(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,t+1)}});var vr=W(Mn=>{"use strict";Object.defineProperty(Mn,"__esModule",{value:!0});Mn.isAnyArray=void 0;var Zw=Object.prototype.toString;function Jw(t){let r=Zw.call(t);return r.endsWith("Array]")&&!r.includes("Big")}Mn.isAnyArray=Jw});var ju=W((WM,Xu)=>{"use strict";var Qw=vr();function t2(t,r={}){if(!Qw.isAnyArray(t))throw new TypeError("input must be an array");if(t.length===0)throw new TypeError("input must not be empty");let{fromIndex:e=0,toIndex:i=t.length}=r;if(e<0||e>=t.length||!Number.isInteger(e))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=e||i>t.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");let n=t[e];for(let o=e+1;o<i;o++)t[o]>n&&(n=t[o]);return n}Xu.exports=t2});var Vu=W((KM,Gu)=>{"use strict";var e2=vr();function r2(t,r={}){if(!e2.isAnyArray(t))throw new TypeError("input must be an array");if(t.length===0)throw new TypeError("input must not be empty");let{fromIndex:e=0,toIndex:i=t.length}=r;if(e<0||e>=t.length||!Number.isInteger(e))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=e||i>t.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");let n=t[e];for(let o=e+1;o<i;o++)t[o]<n&&(n=t[o]);return n}Gu.exports=r2});var Ku=W((HM,Wu)=>{"use strict";var $u=vr(),i2=ju(),n2=Vu();function qu(t){return t&&typeof t=="object"&&"default"in t?t:{default:t}}var o2=qu(i2),s2=qu(n2);function a2(t,r={}){if($u.isAnyArray(t)){if(t.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");let e;if(r.output!==void 0){if(!$u.isAnyArray(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);let i=s2.default(t),n=o2.default(t);if(i===n)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");let{min:o=r.autoMinMax?i:0,max:s=r.autoMinMax?n:1}=r;if(o>=s)throw new RangeError("min option must be smaller than max option");let a=(s-o)/(n-i);for(let l=0;l<t.length;l++)e[l]=(t[l]-i)*a+o;return e}Wu.exports=a2});var ba=W(_t=>{"use strict";Object.defineProperty(_t,"__esModule",{value:!0});var he=vr(),Hu=Ku(),En=" ".repeat(2),Qu=" ".repeat(4);function l2(){return td(this)}function td(t,r={}){let{maxRows:e=15,maxColumns:i=10,maxNumSize:n=8,padMinus:o="auto"}=r;return`${t.constructor.name} {\n${En}[\n${Qu}${h2(t,e,i,n,o)}\n${En}]\n${En}rows: ${t.rows}\n${En}columns: ${t.columns}\n}`}function h2(t,r,e,i,n){let{rows:o,columns:s}=t,a=Math.min(o,r),l=Math.min(s,e),h=[];if(n==="auto"){n=!1;t:for(let f=0;f<a;f++)for(let c=0;c<l;c++)if(t.get(f,c)<0){n=!0;break t}}for(let f=0;f<a;f++){let c=[];for(let u=0;u<l;u++)c.push(f2(t.get(f,u),i,n));h.push(`${c.join(" ")}`)}return l!==s&&(h[h.length-1]+=` ... ${s-e} more columns`),a!==o&&h.push(`... ${o-r} more rows`),h.join(`\n${Qu}`)}function f2(t,r,e){return(t>=0&&e?` ${Zu(t,r-1)}`:Zu(t,r)).padEnd(r)}function Zu(t,r){let e=t.toString();if(e.length<=r)return e;let i=t.toFixed(r);if(i.length>r&&(i=t.toFixed(Math.max(0,r-(i.length-r)))),i.length<=r&&!i.startsWith("0.000")&&!i.startsWith("-0.000"))return i;let n=t.toExponential(r);return n.length>r&&(n=t.toExponential(Math.max(0,r-(n.length-r)))),n.slice(0)}function c2(t,r){t.prototype.add=function(i){return typeof i=="number"?this.addS(i):this.addM(i)},t.prototype.addS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)+i);return this},t.prototype.addM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)+i.get(n,o));return this},t.add=function(i,n){return new r(i).add(n)},t.prototype.sub=function(i){return typeof i=="number"?this.subS(i):this.subM(i)},t.prototype.subS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)-i);return this},t.prototype.subM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)-i.get(n,o));return this},t.sub=function(i,n){return new r(i).sub(n)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(i){return typeof i=="number"?this.mulS(i):this.mulM(i)},t.prototype.mulS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)*i);return this},t.prototype.mulM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)*i.get(n,o));return this},t.mul=function(i,n){return new r(i).mul(n)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(i){return typeof i=="number"?this.divS(i):this.divM(i)},t.prototype.divS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)/i);return this},t.prototype.divM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)/i.get(n,o));return this},t.div=function(i,n){return new r(i).div(n)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(i){return typeof i=="number"?this.modS(i):this.modM(i)},t.prototype.modS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)%i);return this},t.prototype.modM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)%i.get(n,o));return this},t.mod=function(i,n){return new r(i).mod(n)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(i){return typeof i=="number"?this.andS(i):this.andM(i)},t.prototype.andS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)&i);return this},t.prototype.andM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)&i.get(n,o));return this},t.and=function(i,n){return new r(i).and(n)},t.prototype.or=function(i){return typeof i=="number"?this.orS(i):this.orM(i)},t.prototype.orS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)|i);return this},t.prototype.orM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)|i.get(n,o));return this},t.or=function(i,n){return new r(i).or(n)},t.prototype.xor=function(i){return typeof i=="number"?this.xorS(i):this.xorM(i)},t.prototype.xorS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)^i);return this},t.prototype.xorM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)^i.get(n,o));return this},t.xor=function(i,n){return new r(i).xor(n)},t.prototype.leftShift=function(i){return typeof i=="number"?this.leftShiftS(i):this.leftShiftM(i)},t.prototype.leftShiftS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)<<i);return this},t.prototype.leftShiftM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)<<i.get(n,o));return this},t.leftShift=function(i,n){return new r(i).leftShift(n)},t.prototype.signPropagatingRightShift=function(i){return typeof i=="number"?this.signPropagatingRightShiftS(i):this.signPropagatingRightShiftM(i)},t.prototype.signPropagatingRightShiftS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)>>i);return this},t.prototype.signPropagatingRightShiftM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)>>i.get(n,o));return this},t.signPropagatingRightShift=function(i,n){return new r(i).signPropagatingRightShift(n)},t.prototype.rightShift=function(i){return typeof i=="number"?this.rightShiftS(i):this.rightShiftM(i)},t.prototype.rightShiftS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)>>>i);return this},t.prototype.rightShiftM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,this.get(n,o)>>>i.get(n,o));return this},t.rightShift=function(i,n){return new r(i).rightShift(n)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,~this.get(i,n));return this},t.not=function(i){return new r(i).not()},t.prototype.abs=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.abs(this.get(i,n)));return this},t.abs=function(i){return new r(i).abs()},t.prototype.acos=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.acos(this.get(i,n)));return this},t.acos=function(i){return new r(i).acos()},t.prototype.acosh=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.acosh(this.get(i,n)));return this},t.acosh=function(i){return new r(i).acosh()},t.prototype.asin=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.asin(this.get(i,n)));return this},t.asin=function(i){return new r(i).asin()},t.prototype.asinh=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.asinh(this.get(i,n)));return this},t.asinh=function(i){return new r(i).asinh()},t.prototype.atan=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.atan(this.get(i,n)));return this},t.atan=function(i){return new r(i).atan()},t.prototype.atanh=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.atanh(this.get(i,n)));return this},t.atanh=function(i){return new r(i).atanh()},t.prototype.cbrt=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.cbrt(this.get(i,n)));return this},t.cbrt=function(i){return new r(i).cbrt()},t.prototype.ceil=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.ceil(this.get(i,n)));return this},t.ceil=function(i){return new r(i).ceil()},t.prototype.clz32=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.clz32(this.get(i,n)));return this},t.clz32=function(i){return new r(i).clz32()},t.prototype.cos=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.cos(this.get(i,n)));return this},t.cos=function(i){return new r(i).cos()},t.prototype.cosh=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.cosh(this.get(i,n)));return this},t.cosh=function(i){return new r(i).cosh()},t.prototype.exp=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.exp(this.get(i,n)));return this},t.exp=function(i){return new r(i).exp()},t.prototype.expm1=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.expm1(this.get(i,n)));return this},t.expm1=function(i){return new r(i).expm1()},t.prototype.floor=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.floor(this.get(i,n)));return this},t.floor=function(i){return new r(i).floor()},t.prototype.fround=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.fround(this.get(i,n)));return this},t.fround=function(i){return new r(i).fround()},t.prototype.log=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.log(this.get(i,n)));return this},t.log=function(i){return new r(i).log()},t.prototype.log1p=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.log1p(this.get(i,n)));return this},t.log1p=function(i){return new r(i).log1p()},t.prototype.log10=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.log10(this.get(i,n)));return this},t.log10=function(i){return new r(i).log10()},t.prototype.log2=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.log2(this.get(i,n)));return this},t.log2=function(i){return new r(i).log2()},t.prototype.round=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.round(this.get(i,n)));return this},t.round=function(i){return new r(i).round()},t.prototype.sign=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.sign(this.get(i,n)));return this},t.sign=function(i){return new r(i).sign()},t.prototype.sin=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.sin(this.get(i,n)));return this},t.sin=function(i){return new r(i).sin()},t.prototype.sinh=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.sinh(this.get(i,n)));return this},t.sinh=function(i){return new r(i).sinh()},t.prototype.sqrt=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.sqrt(this.get(i,n)));return this},t.sqrt=function(i){return new r(i).sqrt()},t.prototype.tan=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.tan(this.get(i,n)));return this},t.tan=function(i){return new r(i).tan()},t.prototype.tanh=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.tanh(this.get(i,n)));return this},t.tanh=function(i){return new r(i).tanh()},t.prototype.trunc=function(){for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.set(i,n,Math.trunc(this.get(i,n)));return this},t.trunc=function(i){return new r(i).trunc()},t.pow=function(i,n){return new r(i).pow(n)},t.prototype.pow=function(i){return typeof i=="number"?this.powS(i):this.powM(i)},t.prototype.powS=function(i){for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,Math.pow(this.get(n,o),i));return this},t.prototype.powM=function(i){if(i=r.checkMatrix(i),this.rows!==i.rows||this.columns!==i.columns)throw new RangeError("Matrices dimensions must be equal");for(let n=0;n<this.rows;n++)for(let o=0;o<this.columns;o++)this.set(n,o,Math.pow(this.get(n,o),i.get(n,o)));return this}}function ve(t,r,e){let i=e?t.rows:t.rows-1;if(r<0||r>i)throw new RangeError("Row index out of range")}function _e(t,r,e){let i=e?t.columns:t.columns-1;if(r<0||r>i)throw new RangeError("Column index out of range")}function $r(t,r){if(r.to1DArray&&(r=r.to1DArray()),r.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return r}function qr(t,r){if(r.to1DArray&&(r=r.to1DArray()),r.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return r}function xa(t,r){if(!he.isAnyArray(r))throw new TypeError("row indices must be an array");for(let e=0;e<r.length;e++)if(r[e]<0||r[e]>=t.rows)throw new RangeError("row indices are out of range")}function wa(t,r){if(!he.isAnyArray(r))throw new TypeError("column indices must be an array");for(let e=0;e<r.length;e++)if(r[e]<0||r[e]>=t.columns)throw new RangeError("column indices are out of range")}function aa(t,r,e,i,n){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(kn("startRow",r),kn("endRow",e),kn("startColumn",i),kn("endColumn",n),r>e||i>n||r<0||r>=t.rows||e<0||e>=t.rows||i<0||i>=t.columns||n<0||n>=t.columns)throw new RangeError("Submatrix indices are out of range")}function Bn(t,r=0){let e=[];for(let i=0;i<t;i++)e.push(r);return e}function kn(t,r){if(typeof r!="number")throw new TypeError(`${t} must be a number`)}function Vr(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}function u2(t){let r=Bn(t.rows);for(let e=0;e<t.rows;++e)for(let i=0;i<t.columns;++i)r[e]+=t.get(e,i);return r}function d2(t){let r=Bn(t.columns);for(let e=0;e<t.rows;++e)for(let i=0;i<t.columns;++i)r[i]+=t.get(e,i);return r}function p2(t){let r=0;for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++)r+=t.get(e,i);return r}function m2(t){let r=Bn(t.rows,1);for(let e=0;e<t.rows;++e)for(let i=0;i<t.columns;++i)r[e]*=t.get(e,i);return r}function g2(t){let r=Bn(t.columns,1);for(let e=0;e<t.rows;++e)for(let i=0;i<t.columns;++i)r[i]*=t.get(e,i);return r}function x2(t){let r=1;for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++)r*=t.get(e,i);return r}function w2(t,r,e){let i=t.rows,n=t.columns,o=[];for(let s=0;s<i;s++){let a=0,l=0,h=0;for(let f=0;f<n;f++)h=t.get(s,f)-e[s],a+=h,l+=h*h;r?o.push((l-a*a/n)/(n-1)):o.push((l-a*a/n)/n)}return o}function b2(t,r,e){let i=t.rows,n=t.columns,o=[];for(let s=0;s<n;s++){let a=0,l=0,h=0;for(let f=0;f<i;f++)h=t.get(f,s)-e[s],a+=h,l+=h*h;r?o.push((l-a*a/i)/(i-1)):o.push((l-a*a/i)/i)}return o}function y2(t,r,e){let i=t.rows,n=t.columns,o=i*n,s=0,a=0,l=0;for(let h=0;h<i;h++)for(let f=0;f<n;f++)l=t.get(h,f)-e,s+=l,a+=l*l;return r?(a-s*s/o)/(o-1):(a-s*s/o)/o}function v2(t,r){for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++)t.set(e,i,t.get(e,i)-r[e])}function _2(t,r){for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++)t.set(e,i,t.get(e,i)-r[i])}function M2(t,r){for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++)t.set(e,i,t.get(e,i)-r)}function E2(t){let r=[];for(let e=0;e<t.rows;e++){let i=0;for(let n=0;n<t.columns;n++)i+=Math.pow(t.get(e,n),2)/(t.columns-1);r.push(Math.sqrt(i))}return r}function k2(t,r){for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++)t.set(e,i,t.get(e,i)/r[e])}function A2(t){let r=[];for(let e=0;e<t.columns;e++){let i=0;for(let n=0;n<t.rows;n++)i+=Math.pow(t.get(n,e),2)/(t.rows-1);r.push(Math.sqrt(i))}return r}function S2(t,r){for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++)t.set(e,i,t.get(e,i)/r[i])}function I2(t){let r=t.size-1,e=0;for(let i=0;i<t.columns;i++)for(let n=0;n<t.rows;n++)e+=Math.pow(t.get(n,i),2)/r;return Math.sqrt(e)}function D2(t,r){for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++)t.set(e,i,t.get(e,i)/r)}var Ft=class t{static from1DArray(r,e,i){if(r*e!==i.length)throw new RangeError("data length does not match given dimensions");let o=new G(r,e);for(let s=0;s<r;s++)for(let a=0;a<e;a++)o.set(s,a,i[s*e+a]);return o}static rowVector(r){let e=new G(1,r.length);for(let i=0;i<r.length;i++)e.set(0,i,r[i]);return e}static columnVector(r){let e=new G(r.length,1);for(let i=0;i<r.length;i++)e.set(i,0,r[i]);return e}static zeros(r,e){return new G(r,e)}static ones(r,e){return new G(r,e).fill(1)}static rand(r,e,i={}){if(typeof i!="object")throw new TypeError("options must be an object");let{random:n=Math.random}=i,o=new G(r,e);for(let s=0;s<r;s++)for(let a=0;a<e;a++)o.set(s,a,n());return o}static randInt(r,e,i={}){if(typeof i!="object")throw new TypeError("options must be an object");let{min:n=0,max:o=1e3,random:s=Math.random}=i;if(!Number.isInteger(n))throw new TypeError("min must be an integer");if(!Number.isInteger(o))throw new TypeError("max must be an integer");if(n>=o)throw new RangeError("min must be smaller than max");let a=o-n,l=new G(r,e);for(let h=0;h<r;h++)for(let f=0;f<e;f++){let c=n+Math.round(s()*a);l.set(h,f,c)}return l}static eye(r,e,i){e===void 0&&(e=r),i===void 0&&(i=1);let n=Math.min(r,e),o=this.zeros(r,e);for(let s=0;s<n;s++)o.set(s,s,i);return o}static diag(r,e,i){let n=r.length;e===void 0&&(e=n),i===void 0&&(i=e);let o=Math.min(n,e,i),s=this.zeros(e,i);for(let a=0;a<o;a++)s.set(a,a,r[a]);return s}static min(r,e){r=this.checkMatrix(r),e=this.checkMatrix(e);let i=r.rows,n=r.columns,o=new G(i,n);for(let s=0;s<i;s++)for(let a=0;a<n;a++)o.set(s,a,Math.min(r.get(s,a),e.get(s,a)));return o}static max(r,e){r=this.checkMatrix(r),e=this.checkMatrix(e);let i=r.rows,n=r.columns,o=new this(i,n);for(let s=0;s<i;s++)for(let a=0;a<n;a++)o.set(s,a,Math.max(r.get(s,a),e.get(s,a)));return o}static checkMatrix(r){return t.isMatrix(r)?r:new G(r)}static isMatrix(r){return r!=null&&r.klass==="Matrix"}get size(){return this.rows*this.columns}apply(r){if(typeof r!="function")throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)r.call(this,e,i);return this}to1DArray(){let r=[];for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)r.push(this.get(e,i));return r}to2DArray(){let r=[];for(let e=0;e<this.rows;e++){r.push([]);for(let i=0;i<this.columns;i++)r[e].push(this.get(e,i))}return r}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let r=0;r<this.rows;r++)for(let e=0;e<=r;e++)if(this.get(r,e)!==this.get(e,r))return!1;return!0}return!1}isDistance(){if(!this.isSymmetric())return!1;for(let r=0;r<this.rows;r++)if(this.get(r,r)!==0)return!1;return!0}isEchelonForm(){let r=0,e=0,i=-1,n=!0,o=!1;for(;r<this.rows&&n;){for(e=0,o=!1;e<this.columns&&o===!1;)this.get(r,e)===0?e++:this.get(r,e)===1&&e>i?(o=!0,i=e):(n=!1,o=!0);r++}return n}isReducedEchelonForm(){let r=0,e=0,i=-1,n=!0,o=!1;for(;r<this.rows&&n;){for(e=0,o=!1;e<this.columns&&o===!1;)this.get(r,e)===0?e++:this.get(r,e)===1&&e>i?(o=!0,i=e):(n=!1,o=!0);for(let s=e+1;s<this.rows;s++)this.get(r,s)!==0&&(n=!1);r++}return n}echelonForm(){let r=this.clone(),e=0,i=0;for(;e<r.rows&&i<r.columns;){let n=e;for(let o=e;o<r.rows;o++)r.get(o,i)>r.get(n,i)&&(n=o);if(r.get(n,i)===0)i++;else{r.swapRows(e,n);let o=r.get(e,i);for(let s=i;s<r.columns;s++)r.set(e,s,r.get(e,s)/o);for(let s=e+1;s<r.rows;s++){let a=r.get(s,i)/r.get(e,i);r.set(s,i,0);for(let l=i+1;l<r.columns;l++)r.set(s,l,r.get(s,l)-r.get(e,l)*a)}e++,i++}}return r}reducedEchelonForm(){let r=this.echelonForm(),e=r.columns,i=r.rows,n=i-1;for(;n>=0;)if(r.maxRow(n)===0)n--;else{let o=0,s=!1;for(;o<i&&s===!1;)r.get(n,o)===1?s=!0:o++;for(let a=0;a<n;a++){let l=r.get(a,o);for(let h=o;h<e;h++){let f=r.get(a,h)-l*r.get(n,h);r.set(a,h,f)}}n--}return r}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(r={}){if(typeof r!="object")throw new TypeError("options must be an object");let{rows:e=1,columns:i=1}=r;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(i)||i<=0)throw new TypeError("columns must be a positive integer");let n=new G(this.rows*e,this.columns*i);for(let o=0;o<e;o++)for(let s=0;s<i;s++)n.setSubMatrix(this,this.rows*o,this.columns*s);return n}fill(r){for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,r);return this}neg(){return this.mulS(-1)}getRow(r){ve(this,r);let e=[];for(let i=0;i<this.columns;i++)e.push(this.get(r,i));return e}getRowVector(r){return G.rowVector(this.getRow(r))}setRow(r,e){ve(this,r),e=$r(this,e);for(let i=0;i<this.columns;i++)this.set(r,i,e[i]);return this}swapRows(r,e){ve(this,r),ve(this,e);for(let i=0;i<this.columns;i++){let n=this.get(r,i);this.set(r,i,this.get(e,i)),this.set(e,i,n)}return this}getColumn(r){_e(this,r);let e=[];for(let i=0;i<this.rows;i++)e.push(this.get(i,r));return e}getColumnVector(r){return G.columnVector(this.getColumn(r))}setColumn(r,e){_e(this,r),e=qr(this,e);for(let i=0;i<this.rows;i++)this.set(i,r,e[i]);return this}swapColumns(r,e){_e(this,r),_e(this,e);for(let i=0;i<this.rows;i++){let n=this.get(i,r);this.set(i,r,this.get(i,e)),this.set(i,e,n)}return this}addRowVector(r){r=$r(this,r);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,this.get(e,i)+r[i]);return this}subRowVector(r){r=$r(this,r);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,this.get(e,i)-r[i]);return this}mulRowVector(r){r=$r(this,r);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,this.get(e,i)*r[i]);return this}divRowVector(r){r=$r(this,r);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,this.get(e,i)/r[i]);return this}addColumnVector(r){r=qr(this,r);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,this.get(e,i)+r[e]);return this}subColumnVector(r){r=qr(this,r);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,this.get(e,i)-r[e]);return this}mulColumnVector(r){r=qr(this,r);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,this.get(e,i)*r[e]);return this}divColumnVector(r){r=qr(this,r);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)this.set(e,i,this.get(e,i)/r[e]);return this}mulRow(r,e){ve(this,r);for(let i=0;i<this.columns;i++)this.set(r,i,this.get(r,i)*e);return this}mulColumn(r,e){_e(this,r);for(let i=0;i<this.rows;i++)this.set(i,r,this.get(i,r)*e);return this}max(r){if(this.isEmpty())return NaN;switch(r){case"row":{let e=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.get(i,n)>e[i]&&(e[i]=this.get(i,n));return e}case"column":{let e=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.get(i,n)>e[n]&&(e[n]=this.get(i,n));return e}case void 0:{let e=this.get(0,0);for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.get(i,n)>e&&(e=this.get(i,n));return e}default:throw new Error(`invalid option: ${r}`)}}maxIndex(){Vr(this);let r=this.get(0,0),e=[0,0];for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.get(i,n)>r&&(r=this.get(i,n),e[0]=i,e[1]=n);return e}min(r){if(this.isEmpty())return NaN;switch(r){case"row":{let e=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.get(i,n)<e[i]&&(e[i]=this.get(i,n));return e}case"column":{let e=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.get(i,n)<e[n]&&(e[n]=this.get(i,n));return e}case void 0:{let e=this.get(0,0);for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.get(i,n)<e&&(e=this.get(i,n));return e}default:throw new Error(`invalid option: ${r}`)}}minIndex(){Vr(this);let r=this.get(0,0),e=[0,0];for(let i=0;i<this.rows;i++)for(let n=0;n<this.columns;n++)this.get(i,n)<r&&(r=this.get(i,n),e[0]=i,e[1]=n);return e}maxRow(r){if(ve(this,r),this.isEmpty())return NaN;let e=this.get(r,0);for(let i=1;i<this.columns;i++)this.get(r,i)>e&&(e=this.get(r,i));return e}maxRowIndex(r){ve(this,r),Vr(this);let e=this.get(r,0),i=[r,0];for(let n=1;n<this.columns;n++)this.get(r,n)>e&&(e=this.get(r,n),i[1]=n);return i}minRow(r){if(ve(this,r),this.isEmpty())return NaN;let e=this.get(r,0);for(let i=1;i<this.columns;i++)this.get(r,i)<e&&(e=this.get(r,i));return e}minRowIndex(r){ve(this,r),Vr(this);let e=this.get(r,0),i=[r,0];for(let n=1;n<this.columns;n++)this.get(r,n)<e&&(e=this.get(r,n),i[1]=n);return i}maxColumn(r){if(_e(this,r),this.isEmpty())return NaN;let e=this.get(0,r);for(let i=1;i<this.rows;i++)this.get(i,r)>e&&(e=this.get(i,r));return e}maxColumnIndex(r){_e(this,r),Vr(this);let e=this.get(0,r),i=[0,r];for(let n=1;n<this.rows;n++)this.get(n,r)>e&&(e=this.get(n,r),i[0]=n);return i}minColumn(r){if(_e(this,r),this.isEmpty())return NaN;let e=this.get(0,r);for(let i=1;i<this.rows;i++)this.get(i,r)<e&&(e=this.get(i,r));return e}minColumnIndex(r){_e(this,r),Vr(this);let e=this.get(0,r),i=[0,r];for(let n=1;n<this.rows;n++)this.get(n,r)<e&&(e=this.get(n,r),i[0]=n);return i}diag(){let r=Math.min(this.rows,this.columns),e=[];for(let i=0;i<r;i++)e.push(this.get(i,i));return e}norm(r="frobenius"){switch(r){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${r}`)}}cumulativeSum(){let r=0;for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)r+=this.get(e,i),this.set(e,i,r);return this}dot(r){t.isMatrix(r)&&(r=r.to1DArray());let e=this.to1DArray();if(e.length!==r.length)throw new RangeError("vectors do not have the same size");let i=0;for(let n=0;n<e.length;n++)i+=e[n]*r[n];return i}mmul(r){r=G.checkMatrix(r);let e=this.rows,i=this.columns,n=r.columns,o=new G(e,n),s=new Float64Array(i);for(let a=0;a<n;a++){for(let l=0;l<i;l++)s[l]=r.get(l,a);for(let l=0;l<e;l++){let h=0;for(let f=0;f<i;f++)h+=this.get(l,f)*s[f];o.set(l,a,h)}}return o}strassen2x2(r){r=G.checkMatrix(r);let e=new G(2,2),i=this.get(0,0),n=r.get(0,0),o=this.get(0,1),s=r.get(0,1),a=this.get(1,0),l=r.get(1,0),h=this.get(1,1),f=r.get(1,1),c=(i+h)*(n+f),u=(a+h)*n,d=i*(s-f),p=h*(l-n),g=(i+o)*f,x=(a-i)*(n+s),m=(o-h)*(l+f),w=c+p-g+m,y=d+g,M=u+p,_=c-u+d+x;return e.set(0,0,w),e.set(0,1,y),e.set(1,0,M),e.set(1,1,_),e}strassen3x3(r){r=G.checkMatrix(r);let e=new G(3,3),i=this.get(0,0),n=this.get(0,1),o=this.get(0,2),s=this.get(1,0),a=this.get(1,1),l=this.get(1,2),h=this.get(2,0),f=this.get(2,1),c=this.get(2,2),u=r.get(0,0),d=r.get(0,1),p=r.get(0,2),g=r.get(1,0),x=r.get(1,1),m=r.get(1,2),w=r.get(2,0),y=r.get(2,1),M=r.get(2,2),_=(i+n+o-s-a-f-c)*x,T=(i-s)*(-d+x),E=a*(-u+d+g-x-m-w+M),A=(-i+s+a)*(u-d+x),D=(s+a)*(-u+d),b=i*u,k=(-i+h+f)*(u-p+m),C=(-i+h)*(p-m),S=(h+f)*(-u+p),X=(i+n+o-a-l-h-f)*m,B=f*(-u+p+g-x-m-w+y),j=(-o+f+c)*(x+w-y),Z=(o-c)*(x-y),tt=o*w,rt=(f+c)*(-w+y),ht=(-o+a+l)*(m+w-M),at=(o-l)*(m-M),nt=(a+l)*(-w+M),Y=n*g,P=l*y,V=s*p,st=h*d,J=c*M,ft=b+tt+Y,ct=_+A+D+b+j+tt+rt,ot=b+k+S+X+tt+ht+nt,$=T+E+A+b+tt+ht+at,z=T+A+D+b+P,Et=tt+ht+at+nt+V,lt=b+k+C+B+j+Z+tt,dt=j+Z+tt+rt+st,Yt=b+k+C+S+J;return e.set(0,0,ft),e.set(0,1,ct),e.set(0,2,ot),e.set(1,0,$),e.set(1,1,z),e.set(1,2,Et),e.set(2,0,lt),e.set(2,1,dt),e.set(2,2,Yt),e}mmulStrassen(r){r=G.checkMatrix(r);let e=this.clone(),i=e.rows,n=e.columns,o=r.rows,s=r.columns;n!==o&&console.warn(`Multiplying ${i} x ${n} and ${o} x ${s} matrix: dimensions do not match.`);function a(c,u,d){let p=c.rows,g=c.columns;if(p===u&&g===d)return c;{let x=t.zeros(u,d);return x=x.setSubMatrix(c,0,0),x}}let l=Math.max(i,o),h=Math.max(n,s);e=a(e,l,h),r=a(r,l,h);function f(c,u,d,p){if(d<=512||p<=512)return c.mmul(u);d%2===1&&p%2===1?(c=a(c,d+1,p+1),u=a(u,d+1,p+1)):d%2===1?(c=a(c,d+1,p),u=a(u,d+1,p)):p%2===1&&(c=a(c,d,p+1),u=a(u,d,p+1));let g=parseInt(c.rows/2,10),x=parseInt(c.columns/2,10),m=c.subMatrix(0,g-1,0,x-1),w=u.subMatrix(0,g-1,0,x-1),y=c.subMatrix(0,g-1,x,c.columns-1),M=u.subMatrix(0,g-1,x,u.columns-1),_=c.subMatrix(g,c.rows-1,0,x-1),T=u.subMatrix(g,u.rows-1,0,x-1),E=c.subMatrix(g,c.rows-1,x,c.columns-1),A=u.subMatrix(g,u.rows-1,x,u.columns-1),D=f(t.add(m,E),t.add(w,A),g,x),b=f(t.add(_,E),w,g,x),k=f(m,t.sub(M,A),g,x),C=f(E,t.sub(T,w),g,x),S=f(t.add(m,y),A,g,x),X=f(t.sub(_,m),t.add(w,M),g,x),B=f(t.sub(y,E),t.add(T,A),g,x),j=t.add(D,C);j.sub(S),j.add(B);let Z=t.add(k,S),tt=t.add(b,C),rt=t.sub(D,b);rt.add(k),rt.add(X);let ht=t.zeros(2*j.rows,2*j.columns);return ht=ht.setSubMatrix(j,0,0),ht=ht.setSubMatrix(Z,j.rows,0),ht=ht.setSubMatrix(tt,0,j.columns),ht=ht.setSubMatrix(rt,j.rows,j.columns),ht.subMatrix(0,d-1,0,p-1)}return f(e,r,l,h)}scaleRows(r={}){if(typeof r!="object")throw new TypeError("options must be an object");let{min:e=0,max:i=1}=r;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(i))throw new TypeError("max must be a number");if(e>=i)throw new RangeError("min must be smaller than max");let n=new G(this.rows,this.columns);for(let o=0;o<this.rows;o++){let s=this.getRow(o);s.length>0&&Hu(s,{min:e,max:i,output:s}),n.setRow(o,s)}return n}scaleColumns(r={}){if(typeof r!="object")throw new TypeError("options must be an object");let{min:e=0,max:i=1}=r;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(i))throw new TypeError("max must be a number");if(e>=i)throw new RangeError("min must be smaller than max");let n=new G(this.rows,this.columns);for(let o=0;o<this.columns;o++){let s=this.getColumn(o);s.length&&Hu(s,{min:e,max:i,output:s}),n.setColumn(o,s)}return n}flipRows(){let r=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let i=0;i<r;i++){let n=this.get(e,i),o=this.get(e,this.columns-1-i);this.set(e,i,o),this.set(e,this.columns-1-i,n)}return this}flipColumns(){let r=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let i=0;i<r;i++){let n=this.get(i,e),o=this.get(this.rows-1-i,e);this.set(i,e,o),this.set(this.rows-1-i,e,n)}return this}kroneckerProduct(r){r=G.checkMatrix(r);let e=this.rows,i=this.columns,n=r.rows,o=r.columns,s=new G(e*n,i*o);for(let a=0;a<e;a++)for(let l=0;l<i;l++)for(let h=0;h<n;h++)for(let f=0;f<o;f++)s.set(n*a+h,o*l+f,this.get(a,l)*r.get(h,f));return s}kroneckerSum(r){if(r=G.checkMatrix(r),!this.isSquare()||!r.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,i=r.rows,n=this.kroneckerProduct(G.eye(i,i)),o=G.eye(e,e).kroneckerProduct(r);return n.add(o)}transpose(){let r=new G(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let i=0;i<this.columns;i++)r.set(i,e,this.get(e,i));return r}sortRows(r=Ju){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(r));return this}sortColumns(r=Ju){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(r));return this}subMatrix(r,e,i,n){aa(this,r,e,i,n);let o=new G(e-r+1,n-i+1);for(let s=r;s<=e;s++)for(let a=i;a<=n;a++)o.set(s-r,a-i,this.get(s,a));return o}subMatrixRow(r,e,i){if(e===void 0&&(e=0),i===void 0&&(i=this.columns-1),e>i||e<0||e>=this.columns||i<0||i>=this.columns)throw new RangeError("Argument out of range");let n=new G(r.length,i-e+1);for(let o=0;o<r.length;o++)for(let s=e;s<=i;s++){if(r[o]<0||r[o]>=this.rows)throw new RangeError(`Row index out of range: ${r[o]}`);n.set(o,s-e,this.get(r[o],s))}return n}subMatrixColumn(r,e,i){if(e===void 0&&(e=0),i===void 0&&(i=this.rows-1),e>i||e<0||e>=this.rows||i<0||i>=this.rows)throw new RangeError("Argument out of range");let n=new G(i-e+1,r.length);for(let o=0;o<r.length;o++)for(let s=e;s<=i;s++){if(r[o]<0||r[o]>=this.columns)throw new RangeError(`Column index out of range: ${r[o]}`);n.set(s-e,o,this.get(s,r[o]))}return n}setSubMatrix(r,e,i){if(r=G.checkMatrix(r),r.isEmpty())return this;let n=e+r.rows-1,o=i+r.columns-1;aa(this,e,n,i,o);for(let s=0;s<r.rows;s++)for(let a=0;a<r.columns;a++)this.set(e+s,i+a,r.get(s,a));return this}selection(r,e){xa(this,r),wa(this,e);let i=new G(r.length,e.length);for(let n=0;n<r.length;n++){let o=r[n];for(let s=0;s<e.length;s++){let a=e[s];i.set(n,s,this.get(o,a))}}return i}trace(){let r=Math.min(this.rows,this.columns),e=0;for(let i=0;i<r;i++)e+=this.get(i,i);return e}clone(){return this.constructor.copy(this,new G(this.rows,this.columns))}static copy(r,e){for(let[i,n,o]of r.entries())e.set(i,n,o);return e}sum(r){switch(r){case"row":return u2(this);case"column":return d2(this);case void 0:return p2(this);default:throw new Error(`invalid option: ${r}`)}}product(r){switch(r){case"row":return m2(this);case"column":return g2(this);case void 0:return x2(this);default:throw new Error(`invalid option: ${r}`)}}mean(r){let e=this.sum(r);switch(r){case"row":{for(let i=0;i<this.rows;i++)e[i]/=this.columns;return e}case"column":{for(let i=0;i<this.columns;i++)e[i]/=this.rows;return e}case void 0:return e/this.size;default:throw new Error(`invalid option: ${r}`)}}variance(r,e={}){if(typeof r=="object"&&(e=r,r=void 0),typeof e!="object")throw new TypeError("options must be an object");let{unbiased:i=!0,mean:n=this.mean(r)}=e;if(typeof i!="boolean")throw new TypeError("unbiased must be a boolean");switch(r){case"row":{if(!he.isAnyArray(n))throw new TypeError("mean must be an array");return w2(this,i,n)}case"column":{if(!he.isAnyArray(n))throw new TypeError("mean must be an array");return b2(this,i,n)}case void 0:{if(typeof n!="number")throw new TypeError("mean must be a number");return y2(this,i,n)}default:throw new Error(`invalid option: ${r}`)}}standardDeviation(r,e){typeof r=="object"&&(e=r,r=void 0);let i=this.variance(r,e);if(r===void 0)return Math.sqrt(i);for(let n=0;n<i.length;n++)i[n]=Math.sqrt(i[n]);return i}center(r,e={}){if(typeof r=="object"&&(e=r,r=void 0),typeof e!="object")throw new TypeError("options must be an object");let{center:i=this.mean(r)}=e;switch(r){case"row":{if(!he.isAnyArray(i))throw new TypeError("center must be an array");return v2(this,i),this}case"column":{if(!he.isAnyArray(i))throw new TypeError("center must be an array");return _2(this,i),this}case void 0:{if(typeof i!="number")throw new TypeError("center must be a number");return M2(this,i),this}default:throw new Error(`invalid option: ${r}`)}}scale(r,e={}){if(typeof r=="object"&&(e=r,r=void 0),typeof e!="object")throw new TypeError("options must be an object");let i=e.scale;switch(r){case"row":{if(i===void 0)i=E2(this);else if(!he.isAnyArray(i))throw new TypeError("scale must be an array");return k2(this,i),this}case"column":{if(i===void 0)i=A2(this);else if(!he.isAnyArray(i))throw new TypeError("scale must be an array");return S2(this,i),this}case void 0:{if(i===void 0)i=I2(this);else if(typeof i!="number")throw new TypeError("scale must be a number");return D2(this,i),this}default:throw new Error(`invalid option: ${r}`)}}toString(r){return td(this,r)}[Symbol.iterator](){return this.entries()}*entries(){for(let r=0;r<this.rows;r++)for(let e=0;e<this.columns;e++)yield[r,e,this.get(r,e)]}*values(){for(let r=0;r<this.rows;r++)for(let e=0;e<this.columns;e++)yield this.get(r,e)}};Ft.prototype.klass="Matrix";typeof Symbol!="undefined"&&(Ft.prototype[Symbol.for("nodejs.util.inspect.custom")]=l2);function Ju(t,r){return t-r}function T2(t){return t.every(r=>typeof r=="number")}Ft.random=Ft.rand;Ft.randomInt=Ft.randInt;Ft.diagonal=Ft.diag;Ft.prototype.diagonal=Ft.prototype.diag;Ft.identity=Ft.eye;Ft.prototype.negate=Ft.prototype.neg;Ft.prototype.tensorProduct=Ft.prototype.kroneckerProduct;var Pi,la,Cn=class Cn extends Ft{constructor(e,i){super();uo(this,Pi);Kh(this,"data");if(Cn.isMatrix(e))po(this,Pi,la).call(this,e.rows,e.columns),Cn.copy(e,this);else if(Number.isInteger(e)&&e>=0)po(this,Pi,la).call(this,e,i);else if(he.isAnyArray(e)){let n=e;if(e=n.length,i=e?n[0].length:0,typeof i!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let o=0;o<e;o++){if(n[o].length!==i)throw new RangeError("Inconsistent array dimensions");if(!T2(n[o]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(n[o]))}this.rows=e,this.columns=i}else throw new TypeError("First argument must be a positive number or an array")}set(e,i,n){return this.data[e][i]=n,this}get(e,i){return this.data[e][i]}removeRow(e){return ve(this,e),this.data.splice(e,1),this.rows-=1,this}addRow(e,i){return i===void 0&&(i=e,e=this.rows),ve(this,e,!0),i=Float64Array.from($r(this,i)),this.data.splice(e,0,i),this.rows+=1,this}removeColumn(e){_e(this,e);for(let i=0;i<this.rows;i++){let n=new Float64Array(this.columns-1);for(let o=0;o<e;o++)n[o]=this.data[i][o];for(let o=e+1;o<this.columns;o++)n[o-1]=this.data[i][o];this.data[i]=n}return this.columns-=1,this}addColumn(e,i){typeof i=="undefined"&&(i=e,e=this.columns),_e(this,e,!0),i=qr(this,i);for(let n=0;n<this.rows;n++){let o=new Float64Array(this.columns+1),s=0;for(;s<e;s++)o[s]=this.data[n][s];for(o[s++]=i[n];s<this.columns+1;s++)o[s]=this.data[n][s-1];this.data[n]=o}return this.columns+=1,this}};Pi=new WeakSet,la=function(e,i){if(this.data=[],Number.isInteger(i)&&i>=0)for(let n=0;n<e;n++)this.data.push(new Float64Array(i));else throw new TypeError("nColumns must be a positive integer");this.rows=e,this.columns=i};var G=Cn;c2(Ft,G);var te,Fn=class Fn extends Ft{constructor(e){super();uo(this,te);if(G.isMatrix(e)){if(!e.isSymmetric())throw new TypeError("not symmetric data");Ki(this,te,G.copy(e,new G(e.rows,e.rows)))}else if(Number.isInteger(e)&&e>=0)Ki(this,te,new G(e,e));else if(Ki(this,te,new G(e)),!this.isSymmetric())throw new TypeError("not symmetric data")}get size(){return Me(this,te).size}get rows(){return Me(this,te).rows}get columns(){return Me(this,te).columns}get diagonalSize(){return this.rows}static isSymmetricMatrix(e){return G.isMatrix(e)&&e.klassType==="SymmetricMatrix"}static zeros(e){return new this(e)}static ones(e){return new this(e).fill(1)}clone(){let e=new Fn(this.diagonalSize);for(let[i,n,o]of this.upperRightEntries())e.set(i,n,o);return e}toMatrix(){return new G(this)}get(e,i){return Me(this,te).get(e,i)}set(e,i,n){return Me(this,te).set(e,i,n),Me(this,te).set(i,e,n),this}removeCross(e){return Me(this,te).removeRow(e),Me(this,te).removeColumn(e),this}addCross(e,i){i===void 0&&(i=e,e=this.diagonalSize);let n=i.slice();return n.splice(e,1),Me(this,te).addRow(e,n),Me(this,te).addColumn(e,i),this}applyMask(e){if(e.length!==this.diagonalSize)throw new RangeError("Mask size do not match with matrix size");let i=[];for(let[n,o]of e.entries())o||i.push(n);i.reverse();for(let n of i)this.removeCross(n);return this}toCompact(){let{diagonalSize:e}=this,i=new Array(e*(e+1)/2);for(let n=0,o=0,s=0;s<i.length;s++)i[s]=this.get(o,n),++n>=e&&(n=++o);return i}static fromCompact(e){let i=e.length,n=(Math.sqrt(8*i+1)-1)/2;if(!Number.isInteger(n))throw new TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(e)}`);let o=new Fn(n);for(let s=0,a=0,l=0;l<i;l++)o.set(s,a,e[l]),++s>=n&&(s=++a);return o}*upperRightEntries(){for(let e=0,i=0;e<this.diagonalSize;void 0){let n=this.get(e,i);yield[e,i,n],++i>=this.diagonalSize&&(i=++e)}}*upperRightValues(){for(let e=0,i=0;e<this.diagonalSize;void 0)yield this.get(e,i),++i>=this.diagonalSize&&(i=++e)}};te=new WeakMap;var _r=Fn;_r.prototype.klassType="SymmetricMatrix";var In=class t extends _r{static isDistanceMatrix(r){return _r.isSymmetricMatrix(r)&&r.klassSubType==="DistanceMatrix"}constructor(r){if(super(r),!this.isDistance())throw new TypeError("Provided arguments do no produce a distance matrix")}set(r,e,i){return r===e&&(i=0),super.set(r,e,i)}addCross(r,e){return e===void 0&&(e=r,r=this.diagonalSize),e=e.slice(),e[r]=0,super.addCross(r,e)}toSymmetricMatrix(){return new _r(this)}clone(){let r=new t(this.diagonalSize);for(let[e,i,n]of this.upperRightEntries())e!==i&&r.set(e,i,n);return r}toCompact(){let{diagonalSize:r}=this,e=(r-1)*r/2,i=new Array(e);for(let n=1,o=0,s=0;s<i.length;s++)i[s]=this.get(o,n),++n>=r&&(n=++o+1);return i}static fromCompact(r){let e=r.length,i=(Math.sqrt(8*e+1)+1)/2;if(!Number.isInteger(i))throw new TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(r)}`);let n=new this(i);for(let o=1,s=0,a=0;a<e;a++)n.set(o,s,r[a]),++o>=i&&(o=++s+1);return n}};In.prototype.klassSubType="DistanceMatrix";var Ee=class extends Ft{constructor(r,e,i){super(),this.matrix=r,this.rows=e,this.columns=i}},ha=class extends Ee{constructor(r,e){_e(r,e),super(r,r.rows,1),this.column=e}set(r,e,i){return this.matrix.set(r,this.column,i),this}get(r){return this.matrix.get(r,this.column)}},fa=class extends Ee{constructor(r,e){wa(r,e),super(r,r.rows,e.length),this.columnIndices=e}set(r,e,i){return this.matrix.set(r,this.columnIndices[e],i),this}get(r,e){return this.matrix.get(r,this.columnIndices[e])}},ca=class extends Ee{constructor(r){super(r,r.rows,r.columns)}set(r,e,i){return this.matrix.set(r,this.columns-e-1,i),this}get(r,e){return this.matrix.get(r,this.columns-e-1)}},ua=class extends Ee{constructor(r){super(r,r.rows,r.columns)}set(r,e,i){return this.matrix.set(this.rows-r-1,e,i),this}get(r,e){return this.matrix.get(this.rows-r-1,e)}},da=class extends Ee{constructor(r,e){ve(r,e),super(r,1,r.columns),this.row=e}set(r,e,i){return this.matrix.set(this.row,e,i),this}get(r,e){return this.matrix.get(this.row,e)}},pa=class extends Ee{constructor(r,e){xa(r,e),super(r,e.length,r.columns),this.rowIndices=e}set(r,e,i){return this.matrix.set(this.rowIndices[r],e,i),this}get(r,e){return this.matrix.get(this.rowIndices[r],e)}},Wr=class extends Ee{constructor(r,e,i){xa(r,e),wa(r,i),super(r,e.length,i.length),this.rowIndices=e,this.columnIndices=i}set(r,e,i){return this.matrix.set(this.rowIndices[r],this.columnIndices[e],i),this}get(r,e){return this.matrix.get(this.rowIndices[r],this.columnIndices[e])}},ma=class extends Ee{constructor(r,e,i,n,o){aa(r,e,i,n,o),super(r,i-e+1,o-n+1),this.startRow=e,this.startColumn=n}set(r,e,i){return this.matrix.set(this.startRow+r,this.startColumn+e,i),this}get(r,e){return this.matrix.get(this.startRow+r,this.startColumn+e)}},ga=class extends Ee{constructor(r){super(r,r.columns,r.rows)}set(r,e,i){return this.matrix.set(e,r,i),this}get(r,e){return this.matrix.get(e,r)}},Dn=class extends Ft{constructor(r,e={}){let{rows:i=1}=e;if(r.length%i!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=i,this.columns=r.length/i,this.data=r}set(r,e,i){let n=this._calculateIndex(r,e);return this.data[n]=i,this}get(r,e){let i=this._calculateIndex(r,e);return this.data[i]}_calculateIndex(r,e){return r*this.columns+e}},ne=class extends Ft{constructor(r){super(),this.data=r,this.rows=r.length,this.columns=r[0].length}set(r,e,i){return this.data[r][e]=i,this}get(r,e){return this.data[r][e]}};function R2(t,r){if(he.isAnyArray(t))return t[0]&&he.isAnyArray(t[0])?new ne(t):new Dn(t,r);throw new Error("the argument is not an array")}var Kr=class{constructor(r){r=ne.checkMatrix(r);let e=r.clone(),i=e.rows,n=e.columns,o=new Float64Array(i),s=1,a,l,h,f,c,u,d,p,g;for(a=0;a<i;a++)o[a]=a;for(p=new Float64Array(i),l=0;l<n;l++){for(a=0;a<i;a++)p[a]=e.get(a,l);for(a=0;a<i;a++){for(g=Math.min(a,l),c=0,h=0;h<g;h++)c+=e.get(a,h)*p[h];p[a]-=c,e.set(a,l,p[a])}for(f=l,a=l+1;a<i;a++)Math.abs(p[a])>Math.abs(p[f])&&(f=a);if(f!==l){for(h=0;h<n;h++)u=e.get(f,h),e.set(f,h,e.get(l,h)),e.set(l,h,u);d=o[f],o[f]=o[l],o[l]=d,s=-s}if(l<i&&e.get(l,l)!==0)for(a=l+1;a<i;a++)e.set(a,l,e.get(a,l)/e.get(l,l))}this.LU=e,this.pivotVector=o,this.pivotSign=s}isSingular(){let r=this.LU,e=r.columns;for(let i=0;i<e;i++)if(r.get(i,i)===0)return!0;return!1}solve(r){r=G.checkMatrix(r);let e=this.LU;if(e.rows!==r.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let n=r.columns,o=r.subMatrixRow(this.pivotVector,0,n-1),s=e.columns,a,l,h;for(h=0;h<s;h++)for(a=h+1;a<s;a++)for(l=0;l<n;l++)o.set(a,l,o.get(a,l)-o.get(h,l)*e.get(a,h));for(h=s-1;h>=0;h--){for(l=0;l<n;l++)o.set(h,l,o.get(h,l)/e.get(h,h));for(a=0;a<h;a++)for(l=0;l<n;l++)o.set(a,l,o.get(a,l)-o.get(h,l)*e.get(a,h))}return o}get determinant(){let r=this.LU;if(!r.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,i=r.columns;for(let n=0;n<i;n++)e*=r.get(n,n);return e}get lowerTriangularMatrix(){let r=this.LU,e=r.rows,i=r.columns,n=new G(e,i);for(let o=0;o<e;o++)for(let s=0;s<i;s++)o>s?n.set(o,s,r.get(o,s)):o===s?n.set(o,s,1):n.set(o,s,0);return n}get upperTriangularMatrix(){let r=this.LU,e=r.rows,i=r.columns,n=new G(e,i);for(let o=0;o<e;o++)for(let s=0;s<i;s++)o<=s?n.set(o,s,r.get(o,s)):n.set(o,s,0);return n}get pivotPermutationVector(){return Array.from(this.pivotVector)}};function Xe(t,r){let e=0;return Math.abs(t)>Math.abs(r)?(e=r/t,Math.abs(t)*Math.sqrt(1+e*e)):r!==0?(e=t/r,Math.abs(r)*Math.sqrt(1+e*e)):0}var Ri=class{constructor(r){r=ne.checkMatrix(r);let e=r.clone(),i=r.rows,n=r.columns,o=new Float64Array(n),s,a,l,h;for(l=0;l<n;l++){let f=0;for(s=l;s<i;s++)f=Xe(f,e.get(s,l));if(f!==0){for(e.get(l,l)<0&&(f=-f),s=l;s<i;s++)e.set(s,l,e.get(s,l)/f);for(e.set(l,l,e.get(l,l)+1),a=l+1;a<n;a++){for(h=0,s=l;s<i;s++)h+=e.get(s,l)*e.get(s,a);for(h=-h/e.get(l,l),s=l;s<i;s++)e.set(s,a,e.get(s,a)+h*e.get(s,l))}}o[l]=-f}this.QR=e,this.Rdiag=o}solve(r){r=G.checkMatrix(r);let e=this.QR,i=e.rows;if(r.rows!==i)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let n=r.columns,o=r.clone(),s=e.columns,a,l,h,f;for(h=0;h<s;h++)for(l=0;l<n;l++){for(f=0,a=h;a<i;a++)f+=e.get(a,h)*o.get(a,l);for(f=-f/e.get(h,h),a=h;a<i;a++)o.set(a,l,o.get(a,l)+f*e.get(a,h))}for(h=s-1;h>=0;h--){for(l=0;l<n;l++)o.set(h,l,o.get(h,l)/this.Rdiag[h]);for(a=0;a<h;a++)for(l=0;l<n;l++)o.set(a,l,o.get(a,l)-o.get(h,l)*e.get(a,h))}return o.subMatrix(0,s-1,0,n-1)}isFullRank(){let r=this.QR.columns;for(let e=0;e<r;e++)if(this.Rdiag[e]===0)return!1;return!0}get upperTriangularMatrix(){let r=this.QR,e=r.columns,i=new G(e,e),n,o;for(n=0;n<e;n++)for(o=0;o<e;o++)n<o?i.set(n,o,r.get(n,o)):n===o?i.set(n,o,this.Rdiag[n]):i.set(n,o,0);return i}get orthogonalMatrix(){let r=this.QR,e=r.rows,i=r.columns,n=new G(e,i),o,s,a,l;for(a=i-1;a>=0;a--){for(o=0;o<e;o++)n.set(o,a,0);for(n.set(a,a,1),s=a;s<i;s++)if(r.get(a,a)!==0){for(l=0,o=a;o<e;o++)l+=r.get(o,a)*n.get(o,s);for(l=-l/r.get(a,a),o=a;o<e;o++)n.set(o,s,n.get(o,s)+l*r.get(o,a))}}return n}},tr=class{constructor(r,e={}){if(r=ne.checkMatrix(r),r.isEmpty())throw new Error("Matrix must be non-empty");let i=r.rows,n=r.columns,{computeLeftSingularVectors:o=!0,computeRightSingularVectors:s=!0,autoTranspose:a=!1}=e,l=!!o,h=!!s,f=!1,c;if(i<n)if(!a)c=r.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{c=r.transpose(),i=c.rows,n=c.columns,f=!0;let b=l;l=h,h=b}else c=r.clone();let u=Math.min(i,n),d=Math.min(i+1,n),p=new Float64Array(d),g=new G(i,u),x=new G(n,n),m=new Float64Array(n),w=new Float64Array(i),y=new Float64Array(d);for(let b=0;b<d;b++)y[b]=b;let M=Math.min(i-1,n),_=Math.max(0,Math.min(n-2,i)),T=Math.max(M,_);for(let b=0;b<T;b++){if(b<M){p[b]=0;for(let k=b;k<i;k++)p[b]=Xe(p[b],c.get(k,b));if(p[b]!==0){c.get(b,b)<0&&(p[b]=-p[b]);for(let k=b;k<i;k++)c.set(k,b,c.get(k,b)/p[b]);c.set(b,b,c.get(b,b)+1)}p[b]=-p[b]}for(let k=b+1;k<n;k++){if(b<M&&p[b]!==0){let C=0;for(let S=b;S<i;S++)C+=c.get(S,b)*c.get(S,k);C=-C/c.get(b,b);for(let S=b;S<i;S++)c.set(S,k,c.get(S,k)+C*c.get(S,b))}m[k]=c.get(b,k)}if(l&&b<M)for(let k=b;k<i;k++)g.set(k,b,c.get(k,b));if(b<_){m[b]=0;for(let k=b+1;k<n;k++)m[b]=Xe(m[b],m[k]);if(m[b]!==0){m[b+1]<0&&(m[b]=0-m[b]);for(let k=b+1;k<n;k++)m[k]/=m[b];m[b+1]+=1}if(m[b]=-m[b],b+1<i&&m[b]!==0){for(let k=b+1;k<i;k++)w[k]=0;for(let k=b+1;k<i;k++)for(let C=b+1;C<n;C++)w[k]+=m[C]*c.get(k,C);for(let k=b+1;k<n;k++){let C=-m[k]/m[b+1];for(let S=b+1;S<i;S++)c.set(S,k,c.get(S,k)+C*w[S])}}if(h)for(let k=b+1;k<n;k++)x.set(k,b,m[k])}}let E=Math.min(n,i+1);if(M<n&&(p[M]=c.get(M,M)),i<E&&(p[E-1]=0),_+1<E&&(m[_]=c.get(_,E-1)),m[E-1]=0,l){for(let b=M;b<u;b++){for(let k=0;k<i;k++)g.set(k,b,0);g.set(b,b,1)}for(let b=M-1;b>=0;b--)if(p[b]!==0){for(let k=b+1;k<u;k++){let C=0;for(let S=b;S<i;S++)C+=g.get(S,b)*g.get(S,k);C=-C/g.get(b,b);for(let S=b;S<i;S++)g.set(S,k,g.get(S,k)+C*g.get(S,b))}for(let k=b;k<i;k++)g.set(k,b,-g.get(k,b));g.set(b,b,1+g.get(b,b));for(let k=0;k<b-1;k++)g.set(k,b,0)}else{for(let k=0;k<i;k++)g.set(k,b,0);g.set(b,b,1)}}if(h)for(let b=n-1;b>=0;b--){if(b<_&&m[b]!==0)for(let k=b+1;k<n;k++){let C=0;for(let S=b+1;S<n;S++)C+=x.get(S,b)*x.get(S,k);C=-C/x.get(b+1,b);for(let S=b+1;S<n;S++)x.set(S,k,x.get(S,k)+C*x.get(S,b))}for(let k=0;k<n;k++)x.set(k,b,0);x.set(b,b,1)}let A=E-1,D=Number.EPSILON;for(;E>0;){let b,k;for(b=E-2;b>=-1&&b!==-1;b--){let C=Number.MIN_VALUE+D*Math.abs(p[b]+Math.abs(p[b+1]));if(Math.abs(m[b])<=C||Number.isNaN(m[b])){m[b]=0;break}}if(b===E-2)k=4;else{let C;for(C=E-1;C>=b&&C!==b;C--){let S=(C!==E?Math.abs(m[C]):0)+(C!==b+1?Math.abs(m[C-1]):0);if(Math.abs(p[C])<=D*S){p[C]=0;break}}C===b?k=3:C===E-1?k=1:(k=2,b=C)}switch(b++,k){case 1:{let C=m[E-2];m[E-2]=0;for(let S=E-2;S>=b;S--){let X=Xe(p[S],C),B=p[S]/X,j=C/X;if(p[S]=X,S!==b&&(C=-j*m[S-1],m[S-1]=B*m[S-1]),h)for(let Z=0;Z<n;Z++)X=B*x.get(Z,S)+j*x.get(Z,E-1),x.set(Z,E-1,-j*x.get(Z,S)+B*x.get(Z,E-1)),x.set(Z,S,X)}break}case 2:{let C=m[b-1];m[b-1]=0;for(let S=b;S<E;S++){let X=Xe(p[S],C),B=p[S]/X,j=C/X;if(p[S]=X,C=-j*m[S],m[S]=B*m[S],l)for(let Z=0;Z<i;Z++)X=B*g.get(Z,S)+j*g.get(Z,b-1),g.set(Z,b-1,-j*g.get(Z,S)+B*g.get(Z,b-1)),g.set(Z,S,X)}break}case 3:{let C=Math.max(Math.abs(p[E-1]),Math.abs(p[E-2]),Math.abs(m[E-2]),Math.abs(p[b]),Math.abs(m[b])),S=p[E-1]/C,X=p[E-2]/C,B=m[E-2]/C,j=p[b]/C,Z=m[b]/C,tt=((X+S)*(X-S)+B*B)/2,rt=S*B*(S*B),ht=0;(tt!==0||rt!==0)&&(tt<0?ht=0-Math.sqrt(tt*tt+rt):ht=Math.sqrt(tt*tt+rt),ht=rt/(tt+ht));let at=(j+S)*(j-S)+ht,nt=j*Z;for(let Y=b;Y<E-1;Y++){let P=Xe(at,nt);P===0&&(P=Number.MIN_VALUE);let V=at/P,st=nt/P;if(Y!==b&&(m[Y-1]=P),at=V*p[Y]+st*m[Y],m[Y]=V*m[Y]-st*p[Y],nt=st*p[Y+1],p[Y+1]=V*p[Y+1],h)for(let J=0;J<n;J++)P=V*x.get(J,Y)+st*x.get(J,Y+1),x.set(J,Y+1,-st*x.get(J,Y)+V*x.get(J,Y+1)),x.set(J,Y,P);if(P=Xe(at,nt),P===0&&(P=Number.MIN_VALUE),V=at/P,st=nt/P,p[Y]=P,at=V*m[Y]+st*p[Y+1],p[Y+1]=-st*m[Y]+V*p[Y+1],nt=st*m[Y+1],m[Y+1]=V*m[Y+1],l&&Y<i-1)for(let J=0;J<i;J++)P=V*g.get(J,Y)+st*g.get(J,Y+1),g.set(J,Y+1,-st*g.get(J,Y)+V*g.get(J,Y+1)),g.set(J,Y,P)}m[E-2]=at;break}case 4:{if(p[b]<=0&&(p[b]=p[b]<0?-p[b]:0,h))for(let C=0;C<=A;C++)x.set(C,b,-x.get(C,b));for(;b<A&&!(p[b]>=p[b+1]);){let C=p[b];if(p[b]=p[b+1],p[b+1]=C,h&&b<n-1)for(let S=0;S<n;S++)C=x.get(S,b+1),x.set(S,b+1,x.get(S,b)),x.set(S,b,C);if(l&&b<i-1)for(let S=0;S<i;S++)C=g.get(S,b+1),g.set(S,b+1,g.get(S,b)),g.set(S,b,C);b++}E--;break}}}if(f){let b=x;x=g,g=b}this.m=i,this.n=n,this.s=p,this.U=g,this.V=x}solve(r){let e=r,i=this.threshold,n=this.s.length,o=G.zeros(n,n);for(let u=0;u<n;u++)Math.abs(this.s[u])<=i?o.set(u,u,0):o.set(u,u,1/this.s[u]);let s=this.U,a=this.rightSingularVectors,l=a.mmul(o),h=a.rows,f=s.rows,c=G.zeros(h,f);for(let u=0;u<h;u++)for(let d=0;d<f;d++){let p=0;for(let g=0;g<n;g++)p+=l.get(u,g)*s.get(d,g);c.set(u,d,p)}return c.mmul(e)}solveForDiagonal(r){return this.solve(G.diag(r))}inverse(){let r=this.V,e=this.threshold,i=r.rows,n=r.columns,o=new G(i,this.s.length);for(let f=0;f<i;f++)for(let c=0;c<n;c++)Math.abs(this.s[c])>e&&o.set(f,c,r.get(f,c)/this.s[c]);let s=this.U,a=s.rows,l=s.columns,h=new G(i,a);for(let f=0;f<i;f++)for(let c=0;c<a;c++){let u=0;for(let d=0;d<l;d++)u+=o.get(f,d)*s.get(c,d);h.set(f,c,u)}return h}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let r=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,i=this.s;for(let n=0,o=i.length;n<o;n++)i[n]>r&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return G.diag(this.s)}};function P2(t,r=!1){return t=ne.checkMatrix(t),r?new tr(t).inverse():ed(t,G.eye(t.rows))}function ed(t,r,e=!1){return t=ne.checkMatrix(t),r=ne.checkMatrix(r),e?new tr(t).solve(r):t.isSquare()?new Kr(t).solve(r):new Ri(t).solve(r)}function Sn(t){if(t=G.checkMatrix(t),t.isSquare()){if(t.columns===0)return 1;let r,e,i,n;if(t.columns===2)return r=t.get(0,0),e=t.get(0,1),i=t.get(1,0),n=t.get(1,1),r*n-e*i;if(t.columns===3){let o,s,a;return o=new Wr(t,[1,2],[1,2]),s=new Wr(t,[1,2],[0,2]),a=new Wr(t,[1,2],[0,1]),r=t.get(0,0),e=t.get(0,1),i=t.get(0,2),r*Sn(o)-e*Sn(s)+i*Sn(a)}else return new Kr(t).determinant}else throw Error("determinant can only be calculated for a square matrix")}function C2(t,r){let e=[];for(let i=0;i<t;i++)i!==r&&e.push(i);return e}function F2(t,r,e,i=1e-9,n=1e-9){if(t>n)return new Array(r.rows+1).fill(0);{let o=r.addRow(e,[0]);for(let s=0;s<o.rows;s++)Math.abs(o.get(s,0))<i&&o.set(s,0,0);return o.to1DArray()}}function B2(t,r={}){let{thresholdValue:e=1e-9,thresholdError:i=1e-9}=r;t=G.checkMatrix(t);let n=t.rows,o=new G(n,n);for(let s=0;s<n;s++){let a=G.columnVector(t.getRow(s)),l=t.subMatrixRow(C2(n,s)).transpose(),f=new tr(l).solve(a),c=G.sub(a,l.mmul(f)).abs().max();o.setRow(s,F2(c,f,s,e,i))}return o}function L2(t,r=Number.EPSILON){if(t=G.checkMatrix(t),t.isEmpty())return t.transpose();let e=new tr(t,{autoTranspose:!0}),i=e.leftSingularVectors,n=e.rightSingularVectors,o=e.diagonal;for(let s=0;s<o.length;s++)Math.abs(o[s])>r?o[s]=1/o[s]:o[s]=0;return n.mmul(G.diag(o).mmul(i.transpose()))}function O2(t,r=t,e={}){t=new G(t);let i=!1;if(typeof r=="object"&&!G.isMatrix(r)&&!he.isAnyArray(r)?(e=r,r=t,i=!0):r=new G(r),t.rows!==r.rows)throw new TypeError("Both matrices must have the same number of rows");let{center:n=!0}=e;n&&(t=t.center("column"),i||(r=r.center("column")));let o=t.transpose().mmul(r);for(let s=0;s<o.rows;s++)for(let a=0;a<o.columns;a++)o.set(s,a,o.get(s,a)*(1/(t.rows-1)));return o}function U2(t,r=t,e={}){t=new G(t);let i=!1;if(typeof r=="object"&&!G.isMatrix(r)&&!he.isAnyArray(r)?(e=r,r=t,i=!0):r=new G(r),t.rows!==r.rows)throw new TypeError("Both matrices must have the same number of rows");let{center:n=!0,scale:o=!0}=e;n&&(t.center("column"),i||r.center("column")),o&&(t.scale("column"),i||r.scale("column"));let s=t.standardDeviation("column",{unbiased:!0}),a=i?s:r.standardDeviation("column",{unbiased:!0}),l=t.transpose().mmul(r);for(let h=0;h<l.rows;h++)for(let f=0;f<l.columns;f++)l.set(h,f,l.get(h,f)*(1/(s[h]*a[f]))*(1/(t.rows-1)));return l}var Tn=class{constructor(r,e={}){let{assumeSymmetric:i=!1}=e;if(r=ne.checkMatrix(r),!r.isSquare())throw new Error("Matrix is not a square matrix");if(r.isEmpty())throw new Error("Matrix must be non-empty");let n=r.columns,o=new G(n,n),s=new Float64Array(n),a=new Float64Array(n),l=r,h,f,c=!1;if(i?c=!0:c=r.isSymmetric(),c){for(h=0;h<n;h++)for(f=0;f<n;f++)o.set(h,f,l.get(h,f));N2(n,a,s,o),Y2(n,a,s,o)}else{let u=new G(n,n),d=new Float64Array(n);for(f=0;f<n;f++)for(h=0;h<n;h++)u.set(h,f,l.get(h,f));z2(n,u,d,o),X2(n,a,s,o,u)}this.n=n,this.e=a,this.d=s,this.V=o}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let r=this.n,e=this.e,i=this.d,n=new G(r,r),o,s;for(o=0;o<r;o++){for(s=0;s<r;s++)n.set(o,s,0);n.set(o,o,i[o]),e[o]>0?n.set(o,o+1,e[o]):e[o]<0&&n.set(o,o-1,e[o])}return n}};function N2(t,r,e,i){let n,o,s,a,l,h,f,c;for(l=0;l<t;l++)e[l]=i.get(t-1,l);for(a=t-1;a>0;a--){for(c=0,s=0,h=0;h<a;h++)c=c+Math.abs(e[h]);if(c===0)for(r[a]=e[a-1],l=0;l<a;l++)e[l]=i.get(a-1,l),i.set(a,l,0),i.set(l,a,0);else{for(h=0;h<a;h++)e[h]/=c,s+=e[h]*e[h];for(n=e[a-1],o=Math.sqrt(s),n>0&&(o=-o),r[a]=c*o,s=s-n*o,e[a-1]=n-o,l=0;l<a;l++)r[l]=0;for(l=0;l<a;l++){for(n=e[l],i.set(l,a,n),o=r[l]+i.get(l,l)*n,h=l+1;h<=a-1;h++)o+=i.get(h,l)*e[h],r[h]+=i.get(h,l)*n;r[l]=o}for(n=0,l=0;l<a;l++)r[l]/=s,n+=r[l]*e[l];for(f=n/(s+s),l=0;l<a;l++)r[l]-=f*e[l];for(l=0;l<a;l++){for(n=e[l],o=r[l],h=l;h<=a-1;h++)i.set(h,l,i.get(h,l)-(n*r[h]+o*e[h]));e[l]=i.get(a-1,l),i.set(a,l,0)}}e[a]=s}for(a=0;a<t-1;a++){if(i.set(t-1,a,i.get(a,a)),i.set(a,a,1),s=e[a+1],s!==0){for(h=0;h<=a;h++)e[h]=i.get(h,a+1)/s;for(l=0;l<=a;l++){for(o=0,h=0;h<=a;h++)o+=i.get(h,a+1)*i.get(h,l);for(h=0;h<=a;h++)i.set(h,l,i.get(h,l)-o*e[h])}}for(h=0;h<=a;h++)i.set(h,a+1,0)}for(l=0;l<t;l++)e[l]=i.get(t-1,l),i.set(t-1,l,0);i.set(t-1,t-1,1),r[0]=0}function Y2(t,r,e,i){let n,o,s,a,l,h,f,c,u,d,p,g,x,m,w,y;for(s=1;s<t;s++)r[s-1]=r[s];r[t-1]=0;let M=0,_=0,T=Number.EPSILON;for(h=0;h<t;h++){for(_=Math.max(_,Math.abs(e[h])+Math.abs(r[h])),f=h;f<t&&!(Math.abs(r[f])<=T*_);)f++;if(f>h)do{for(n=e[h],c=(e[h+1]-n)/(2*r[h]),u=Xe(c,1),c<0&&(u=-u),e[h]=r[h]/(c+u),e[h+1]=r[h]*(c+u),d=e[h+1],o=n-e[h],s=h+2;s<t;s++)e[s]-=o;for(M=M+o,c=e[f],p=1,g=p,x=p,m=r[h+1],w=0,y=0,s=f-1;s>=h;s--)for(x=g,g=p,y=w,n=p*r[s],o=p*c,u=Xe(c,r[s]),r[s+1]=w*u,w=r[s]/u,p=c/u,c=p*e[s]-w*n,e[s+1]=o+w*(p*n+w*e[s]),l=0;l<t;l++)o=i.get(l,s+1),i.set(l,s+1,w*i.get(l,s)+p*o),i.set(l,s,p*i.get(l,s)-w*o);c=-w*y*x*m*r[h]/d,r[h]=w*c,e[h]=p*c}while(Math.abs(r[h])>T*_);e[h]=e[h]+M,r[h]=0}for(s=0;s<t-1;s++){for(l=s,c=e[s],a=s+1;a<t;a++)e[a]<c&&(l=a,c=e[a]);if(l!==s)for(e[l]=e[s],e[s]=c,a=0;a<t;a++)c=i.get(a,s),i.set(a,s,i.get(a,l)),i.set(a,l,c)}}function z2(t,r,e,i){let n=0,o=t-1,s,a,l,h,f,c,u;for(c=n+1;c<=o-1;c++){for(u=0,h=c;h<=o;h++)u=u+Math.abs(r.get(h,c-1));if(u!==0){for(l=0,h=o;h>=c;h--)e[h]=r.get(h,c-1)/u,l+=e[h]*e[h];for(a=Math.sqrt(l),e[c]>0&&(a=-a),l=l-e[c]*a,e[c]=e[c]-a,f=c;f<t;f++){for(s=0,h=o;h>=c;h--)s+=e[h]*r.get(h,f);for(s=s/l,h=c;h<=o;h++)r.set(h,f,r.get(h,f)-s*e[h])}for(h=0;h<=o;h++){for(s=0,f=o;f>=c;f--)s+=e[f]*r.get(h,f);for(s=s/l,f=c;f<=o;f++)r.set(h,f,r.get(h,f)-s*e[f])}e[c]=u*e[c],r.set(c,c-1,u*a)}}for(h=0;h<t;h++)for(f=0;f<t;f++)i.set(h,f,h===f?1:0);for(c=o-1;c>=n+1;c--)if(r.get(c,c-1)!==0){for(h=c+1;h<=o;h++)e[h]=r.get(h,c-1);for(f=c;f<=o;f++){for(a=0,h=c;h<=o;h++)a+=e[h]*i.get(h,f);for(a=a/e[c]/r.get(c,c-1),h=c;h<=o;h++)i.set(h,f,i.get(h,f)+a*e[h])}}}function X2(t,r,e,i,n){let o=t-1,s=0,a=t-1,l=Number.EPSILON,h=0,f=0,c=0,u=0,d=0,p=0,g=0,x=0,m,w,y,M,_,T,E,A,D,b,k,C,S,X,B;for(m=0;m<t;m++)for((m<s||m>a)&&(e[m]=n.get(m,m),r[m]=0),w=Math.max(m-1,0);w<t;w++)f=f+Math.abs(n.get(m,w));for(;o>=s;){for(M=o;M>s&&(p=Math.abs(n.get(M-1,M-1))+Math.abs(n.get(M,M)),p===0&&(p=f),!(Math.abs(n.get(M,M-1))<l*p));)M--;if(M===o)n.set(o,o,n.get(o,o)+h),e[o]=n.get(o,o),r[o]=0,o--,x=0;else if(M===o-1){if(E=n.get(o,o-1)*n.get(o-1,o),c=(n.get(o-1,o-1)-n.get(o,o))/2,u=c*c+E,g=Math.sqrt(Math.abs(u)),n.set(o,o,n.get(o,o)+h),n.set(o-1,o-1,n.get(o-1,o-1)+h),A=n.get(o,o),u>=0){for(g=c>=0?c+g:c-g,e[o-1]=A+g,e[o]=e[o-1],g!==0&&(e[o]=A-E/g),r[o-1]=0,r[o]=0,A=n.get(o,o-1),p=Math.abs(A)+Math.abs(g),c=A/p,u=g/p,d=Math.sqrt(c*c+u*u),c=c/d,u=u/d,w=o-1;w<t;w++)g=n.get(o-1,w),n.set(o-1,w,u*g+c*n.get(o,w)),n.set(o,w,u*n.get(o,w)-c*g);for(m=0;m<=o;m++)g=n.get(m,o-1),n.set(m,o-1,u*g+c*n.get(m,o)),n.set(m,o,u*n.get(m,o)-c*g);for(m=s;m<=a;m++)g=i.get(m,o-1),i.set(m,o-1,u*g+c*i.get(m,o)),i.set(m,o,u*i.get(m,o)-c*g)}else e[o-1]=A+c,e[o]=A+c,r[o-1]=g,r[o]=-g;o=o-2,x=0}else{if(A=n.get(o,o),D=0,E=0,M<o&&(D=n.get(o-1,o-1),E=n.get(o,o-1)*n.get(o-1,o)),x===10){for(h+=A,m=s;m<=o;m++)n.set(m,m,n.get(m,m)-A);p=Math.abs(n.get(o,o-1))+Math.abs(n.get(o-1,o-2)),A=D=.75*p,E=-.4375*p*p}if(x===30&&(p=(D-A)/2,p=p*p+E,p>0)){for(p=Math.sqrt(p),D<A&&(p=-p),p=A-E/((D-A)/2+p),m=s;m<=o;m++)n.set(m,m,n.get(m,m)-p);h+=p,A=D=E=.964}for(x=x+1,_=o-2;_>=M&&(g=n.get(_,_),d=A-g,p=D-g,c=(d*p-E)/n.get(_+1,_)+n.get(_,_+1),u=n.get(_+1,_+1)-g-d-p,d=n.get(_+2,_+1),p=Math.abs(c)+Math.abs(u)+Math.abs(d),c=c/p,u=u/p,d=d/p,!(_===M||Math.abs(n.get(_,_-1))*(Math.abs(u)+Math.abs(d))<l*(Math.abs(c)*(Math.abs(n.get(_-1,_-1))+Math.abs(g)+Math.abs(n.get(_+1,_+1))))));)_--;for(m=_+2;m<=o;m++)n.set(m,m-2,0),m>_+2&&n.set(m,m-3,0);for(y=_;y<=o-1&&(X=y!==o-1,y!==_&&(c=n.get(y,y-1),u=n.get(y+1,y-1),d=X?n.get(y+2,y-1):0,A=Math.abs(c)+Math.abs(u)+Math.abs(d),A!==0&&(c=c/A,u=u/A,d=d/A)),A!==0);y++)if(p=Math.sqrt(c*c+u*u+d*d),c<0&&(p=-p),p!==0){for(y!==_?n.set(y,y-1,-p*A):M!==_&&n.set(y,y-1,-n.get(y,y-1)),c=c+p,A=c/p,D=u/p,g=d/p,u=u/c,d=d/c,w=y;w<t;w++)c=n.get(y,w)+u*n.get(y+1,w),X&&(c=c+d*n.get(y+2,w),n.set(y+2,w,n.get(y+2,w)-c*g)),n.set(y,w,n.get(y,w)-c*A),n.set(y+1,w,n.get(y+1,w)-c*D);for(m=0;m<=Math.min(o,y+3);m++)c=A*n.get(m,y)+D*n.get(m,y+1),X&&(c=c+g*n.get(m,y+2),n.set(m,y+2,n.get(m,y+2)-c*d)),n.set(m,y,n.get(m,y)-c),n.set(m,y+1,n.get(m,y+1)-c*u);for(m=s;m<=a;m++)c=A*i.get(m,y)+D*i.get(m,y+1),X&&(c=c+g*i.get(m,y+2),i.set(m,y+2,i.get(m,y+2)-c*d)),i.set(m,y,i.get(m,y)-c),i.set(m,y+1,i.get(m,y+1)-c*u)}}}if(f!==0){for(o=t-1;o>=0;o--)if(c=e[o],u=r[o],u===0)for(M=o,n.set(o,o,1),m=o-1;m>=0;m--){for(E=n.get(m,m)-c,d=0,w=M;w<=o;w++)d=d+n.get(m,w)*n.get(w,o);if(r[m]<0)g=E,p=d;else if(M=m,r[m]===0?n.set(m,o,E!==0?-d/E:-d/(l*f)):(A=n.get(m,m+1),D=n.get(m+1,m),u=(e[m]-c)*(e[m]-c)+r[m]*r[m],T=(A*p-g*d)/u,n.set(m,o,T),n.set(m+1,o,Math.abs(A)>Math.abs(g)?(-d-E*T)/A:(-p-D*T)/g)),T=Math.abs(n.get(m,o)),l*T*T>1)for(w=m;w<=o;w++)n.set(w,o,n.get(w,o)/T)}else if(u<0)for(M=o-1,Math.abs(n.get(o,o-1))>Math.abs(n.get(o-1,o))?(n.set(o-1,o-1,u/n.get(o,o-1)),n.set(o-1,o,-(n.get(o,o)-c)/n.get(o,o-1))):(B=An(0,-n.get(o-1,o),n.get(o-1,o-1)-c,u),n.set(o-1,o-1,B[0]),n.set(o-1,o,B[1])),n.set(o,o-1,0),n.set(o,o,1),m=o-2;m>=0;m--){for(b=0,k=0,w=M;w<=o;w++)b=b+n.get(m,w)*n.get(w,o-1),k=k+n.get(m,w)*n.get(w,o);if(E=n.get(m,m)-c,r[m]<0)g=E,d=b,p=k;else if(M=m,r[m]===0?(B=An(-b,-k,E,u),n.set(m,o-1,B[0]),n.set(m,o,B[1])):(A=n.get(m,m+1),D=n.get(m+1,m),C=(e[m]-c)*(e[m]-c)+r[m]*r[m]-u*u,S=(e[m]-c)*2*u,C===0&&S===0&&(C=l*f*(Math.abs(E)+Math.abs(u)+Math.abs(A)+Math.abs(D)+Math.abs(g))),B=An(A*d-g*b+u*k,A*p-g*k-u*b,C,S),n.set(m,o-1,B[0]),n.set(m,o,B[1]),Math.abs(A)>Math.abs(g)+Math.abs(u)?(n.set(m+1,o-1,(-b-E*n.get(m,o-1)+u*n.get(m,o))/A),n.set(m+1,o,(-k-E*n.get(m,o)-u*n.get(m,o-1))/A)):(B=An(-d-D*n.get(m,o-1),-p-D*n.get(m,o),g,u),n.set(m+1,o-1,B[0]),n.set(m+1,o,B[1]))),T=Math.max(Math.abs(n.get(m,o-1)),Math.abs(n.get(m,o))),l*T*T>1)for(w=m;w<=o;w++)n.set(w,o-1,n.get(w,o-1)/T),n.set(w,o,n.get(w,o)/T)}for(m=0;m<t;m++)if(m<s||m>a)for(w=m;w<t;w++)i.set(m,w,n.get(m,w));for(w=t-1;w>=s;w--)for(m=s;m<=a;m++){for(g=0,y=s;y<=Math.min(w,a);y++)g=g+i.get(m,y)*n.get(y,w);i.set(m,w,g)}}}function An(t,r,e,i){let n,o;return Math.abs(e)>Math.abs(i)?(n=i/e,o=e+n*i,[(t+n*r)/o,(r-n*t)/o]):(n=e/i,o=i+n*e,[(n*t+r)/o,(n*r-t)/o])}var Rn=class{constructor(r){if(r=ne.checkMatrix(r),!r.isSymmetric())throw new Error("Matrix is not symmetric");let e=r,i=e.rows,n=new G(i,i),o=!0,s,a,l;for(a=0;a<i;a++){let h=0;for(l=0;l<a;l++){let f=0;for(s=0;s<l;s++)f+=n.get(l,s)*n.get(a,s);f=(e.get(a,l)-f)/n.get(l,l),n.set(a,l,f),h=h+f*f}for(h=e.get(a,a)-h,o&=h>0,n.set(a,a,Math.sqrt(Math.max(h,0))),l=a+1;l<i;l++)n.set(a,l,0)}this.L=n,this.positiveDefinite=!!o}isPositiveDefinite(){return this.positiveDefinite}solve(r){r=ne.checkMatrix(r);let e=this.L,i=e.rows;if(r.rows!==i)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let n=r.columns,o=r.clone(),s,a,l;for(l=0;l<i;l++)for(a=0;a<n;a++){for(s=0;s<l;s++)o.set(l,a,o.get(l,a)-o.get(s,a)*e.get(l,s));o.set(l,a,o.get(l,a)/e.get(l,l))}for(l=i-1;l>=0;l--)for(a=0;a<n;a++){for(s=l+1;s<i;s++)o.set(l,a,o.get(l,a)-o.get(s,a)*e.get(s,l));o.set(l,a,o.get(l,a)/e.get(l,l))}return o}get lowerTriangularMatrix(){return this.L}},Pn=class{constructor(r,e={}){r=ne.checkMatrix(r);let{Y:i}=e,{scaleScores:n=!1,maxIterations:o=1e3,terminationCriteria:s=1e-10}=e,a;if(i){if(he.isAnyArray(i)&&typeof i[0]=="number"?i=G.columnVector(i):i=ne.checkMatrix(i),i.rows!==r.rows)throw new Error("Y should have the same number of rows as X");a=i.getColumnVector(0)}else a=r.getColumnVector(0);let l=1,h,f,c,u;for(let d=0;d<o&&l>s;d++)c=r.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),c=c.div(c.norm()),h=r.mmul(c).div(c.transpose().mmul(c).get(0,0)),d>0&&(l=h.clone().sub(u).pow(2).sum()),u=h.clone(),i?(f=i.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),f=f.div(f.norm()),a=i.mmul(f).div(f.transpose().mmul(f).get(0,0))):a=h;if(i){let d=r.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0));d=d.div(d.norm());let p=r.clone().sub(h.clone().mmul(d.transpose())),g=a.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),x=i.clone().sub(h.clone().mulS(g.get(0,0)).mmul(f.transpose()));this.t=h,this.p=d.transpose(),this.w=c.transpose(),this.q=f,this.u=a,this.s=h.transpose().mmul(h),this.xResidual=p,this.yResidual=x,this.betas=g}else this.w=c.transpose(),this.s=h.transpose().mmul(h).sqrt(),n?this.t=h.clone().div(this.s.get(0,0)):this.t=h,this.xResidual=r.sub(h.mmul(c.transpose()))}};_t.AbstractMatrix=Ft;_t.CHO=Rn;_t.CholeskyDecomposition=Rn;_t.DistanceMatrix=In;_t.EVD=Tn;_t.EigenvalueDecomposition=Tn;_t.LU=Kr;_t.LuDecomposition=Kr;_t.Matrix=G;_t.MatrixColumnSelectionView=fa;_t.MatrixColumnView=ha;_t.MatrixFlipColumnView=ca;_t.MatrixFlipRowView=ua;_t.MatrixRowSelectionView=pa;_t.MatrixRowView=da;_t.MatrixSelectionView=Wr;_t.MatrixSubView=ma;_t.MatrixTransposeView=ga;_t.NIPALS=Pn;_t.Nipals=Pn;_t.QR=Ri;_t.QrDecomposition=Ri;_t.SVD=tr;_t.SingularValueDecomposition=tr;_t.SymmetricMatrix=_r;_t.WrapperMatrix1D=Dn;_t.WrapperMatrix2D=ne;_t.correlation=U2;_t.covariance=O2;_t.default=G;_t.determinant=Sn;_t.inverse=P2;_t.linearDependencies=B2;_t.pseudoInverse=L2;_t.solve=ed;_t.wrap=R2});var Pe=W((wE,od)=>{od.exports=j2;function j2(t,r){t=t||0;for(var e=new Array(t),i=0;i<t;i++)e[i]=r;return e}});var ad=W((vE,sd)=>{"use strict";var V2=Object.prototype.toString;sd.exports=function(r){return V2.call(r).substr(-6,5)==="Array"}});var Er=W(Un=>{"use strict";Object.defineProperty(Un,"__esModule",{value:!0});function hd(t,r){let e=0;for(let i=0;i<t.length;i++)e+=(t[i]-r[i])*(t[i]-r[i]);return e}Un.squaredEuclidean=hd;function q2(t,r){return Math.sqrt(hd(t,r))}Un.euclidean=q2});var cd=W((WE,fd)=>{"use strict";var{squaredEuclidean:W2}=Er(),K2={sigma:1},Pa=class{constructor(r){r=Object.assign({},K2,r),this.sigma=r.sigma,this.divisor=2*r.sigma*r.sigma}compute(r,e){let i=W2(r,e);return Math.exp(-i/this.divisor)}};fd.exports=Pa});var dd=W((KE,ud)=>{"use strict";var H2={degree:1,constant:1,scale:1},Ca=class{constructor(r){r=Object.assign({},H2,r),this.degree=r.degree,this.constant=r.constant,this.scale=r.scale}compute(r,e){for(var i=0,n=0;n<r.length;n++)i+=r[n]*e[n];return Math.pow(this.scale*i+this.constant,this.degree)}};ud.exports=Ca});var md=W((HE,pd)=>{"use strict";var Z2={alpha:.01,constant:-Math.E},Fa=class{constructor(r){r=Object.assign({},Z2,r),this.alpha=r.alpha,this.constant=r.constant}compute(r,e){for(var i=0,n=0;n<r.length;n++)i+=r[n]*e[n];return Math.tanh(this.alpha*i+this.constant)}};pd.exports=Fa});var xd=W((ZE,gd)=>{"use strict";var J2={sigma:1,degree:1},Ba=class{constructor(r){r=Object.assign({},J2,r),this.sigma=r.sigma,this.degree=r.degree}compute(r,e){for(var i=0,n=Math.min(r.length,e.length),o=1;o<=n;++o)i+=Math.pow(Math.exp(-this.sigma*Math.pow(Math.pow(r[o-1],o)-Math.pow(e[o-1],o),2)),this.degree);return i}};gd.exports=Ba});var bd=W((JE,wd)=>{"use strict";var{squaredEuclidean:Q2}=Er(),tb={sigma:1},La=class{constructor(r){r=Object.assign({},tb,r),this.sigma=r.sigma}compute(r,e){return 1/(1+Q2(r,e)/(this.sigma*this.sigma))}};wd.exports=La});var vd=W((QE,yd)=>{"use strict";var{euclidean:eb}=Er(),rb={sigma:1},Oa=class{constructor(r){r=Object.assign({},rb,r),this.sigma=r.sigma,this.divisor=2*r.sigma*r.sigma}compute(r,e){let i=eb(r,e);return Math.exp(-i/this.divisor)}};yd.exports=Oa});var Md=W((tk,_d)=>{"use strict";var Ua=class{compute(r,e){for(var i=Math.min(r.length,e.length),n=0,o=0;o<i;++o)n+=Math.min(r[o],e[o]);return n}};_d.exports=Ua});var kd=W((ek,Ed)=>{"use strict";var{euclidean:ib}=Er(),nb={sigma:1},Na=class{constructor(r){r=Object.assign({},nb,r),this.sigma=r.sigma}compute(r,e){let i=ib(r,e);return Math.exp(-i/this.sigma)}};Ed.exports=Na});var Sd=W((rk,Ad)=>{"use strict";var{squaredEuclidean:ob}=Er(),sb={constant:1},Ya=class{constructor(r){r=Object.assign({},sb,r),this.constant=r.constant}compute(r,e){return Math.sqrt(ob(r,e)+this.constant*this.constant)}};Ad.exports=Ya});var Dd=W((ik,Id)=>{"use strict";var{squaredEuclidean:ab}=Er(),lb={constant:1},za=class{constructor(r){r=Object.assign({},lb,r),this.constant=r.constant}compute(r,e){let i=ab(r,e);return 1-i/(i+this.constant)}};Id.exports=za});var Bd=W((nk,Fd)=>{"use strict";var{Matrix:Xa,MatrixTransposeView:hb}=ba(),Td=cd(),Rd=dd(),Pd=md(),fb=xd(),cb=bd(),ub=vd(),Cd=Md(),db=kd(),pb=Sd(),mb=Dd(),gb={gaussian:Td,rbf:Td,polynomial:Rd,poly:Rd,anova:fb,cauchy:cb,exponential:ub,histogram:Cd,min:Cd,laplacian:db,multiquadratic:pb,rational:mb,sigmoid:Pd,mlp:Pd},ja=class{constructor(r,e){if(this.kernelType=r,r!=="linear")if(typeof r=="string"){r=r.toLowerCase();var i=gb[r];if(i)this.kernelFunction=new i(e);else throw new Error(`unsupported kernel type: ${r}`)}else if(typeof r=="object"&&typeof r.compute=="function")this.kernelFunction=r;else throw new TypeError("first argument must be a valid kernel type or instance")}compute(r,e){if(r=Xa.checkMatrix(r),e===void 0?e=r:e=Xa.checkMatrix(e),this.kernelType==="linear")return r.mmul(new hb(e));let i=new Xa(r.rows,e.rows);if(r===e)for(let n=0;n<r.rows;n++)for(let o=n;o<r.rows;o++){let s=this.kernelFunction.compute(r.getRow(n),r.getRow(o));i.set(n,o,s),i.set(o,n,s)}else for(let n=0;n<r.rows;n++)for(let o=0;o<e.rows;o++)i.set(n,o,this.kernelFunction.compute(r.getRow(n),e.getRow(o)));return i}};Fd.exports=ja});var r1=W((t1,e1)=>{(function(){function t(e,i,n){this.next=n,n&&(n.prev=this),this.prev=i,i&&(i.next=this),this.data=e}function r(){if(!(this instanceof r))return new r;this._head=null,this._tail=null,this.length=0}r.prototype={push:function(e){this._tail=new t(e,this._tail,null),this._head||(this._head=this._tail),this.length++},pop:function(){if(this.length!==0){var e=this._tail;return this._tail=e.prev,e.prev&&(e.prev=this._tail.next=null),this.length--,this.length===1?this._head=this._tail:this.length===0&&(this._head=this._tail=null),e.data}},unshift:function(e){this._head=new t(e,null,this._head),this._tail||(this._tail=this._head),this.length++},shift:function(){if(this.length!==0){var e=this._head;return this._head=e.next,e.next&&(e.next=this._head.prev=null),this.length--,this.length===1?this._tail=this._head:this.length===0&&(this._head=this._tail=null),e.data}},item:function(e){e<0&&(e=this.length+e);for(var i=this._head;e-- >0&&i;)i=i.next;return i?i.data:void 0},slice:function(e,i){if(e||(e=0),i||(i=this.length),i<0&&(i=this.length+i),e<0&&(e=this.length+e),i===e)return[];if(i<e)throw new Error("invalid offset: "+e+","+i+" (length="+this.length+")");for(var n=i-e,o=new Array(n),s=0,a=this._head;e-- >0&&a;)a=a.next;for(;s<n&&a;)o[s++]=a.data,a=a.next;return o},drop:function(){r.call(this)},forEach:function(e,i){for(var n=this._head,o=0,s=this.length;o<s&&n;)e.call(i||this,n.data,o,this),n=n.next,o++},map:function(e,i){var n=new r;return this.forEach(function(o,s,a){n.push(e.call(i||a,o,s,a))}),n},filter:function(e,i){var n=new r;return this.forEach(function(o,s,a){e.call(i||a,o,s,a)&&n.push(o)}),n},reduce:function(e,i,n){var o=0,s=this._head,a=this.length;for(i||(o=1,i=s&&s.data,s=s&&s.next);o<a&&s;)i=e.call(n||this,i,s.data,this),o++,s=s.next;return i}},typeof t1!="undefined"?e1.exports=r:typeof define=="function"&&define.amd?define("FastList",function(){return r}):function(){return this}().FastList=r})()});var w1=W((ch,uh)=>{(function(t,r){typeof ch=="object"&&typeof uh!="undefined"?uh.exports=r():typeof define=="function"&&define.amd?define(r):(t=typeof globalThis!="undefined"?globalThis:t||self,t.Qty=r())})(ch,function(){"use strict";function t(v){return typeof v=="string"||v instanceof String}var r=Number.isFinite||window.isFinite;function e(v){return r(v)}function i(v){return v}function n(v){var I={};return v.filter(function(R){return I.hasOwnProperty(R)?!1:I[R]=!0})}function o(v,I){if(I.length!==v.length)return!1;for(var R=0;R<v.length;R++)if(I[R].compareArray&&!I[R].compareArray(v[R])||I[R]!==v[R])return!1;return!0}function s(v,I){Object.keys(I).forEach(function(R){v[R]=I[R]})}function a(){for(var v=1,I=0,R=0;R<arguments.length;R++){var O=arguments[R];I=I+f(O),v*=O}return I!==0?h(v,I):v}function l(v,I){if(I===0)throw new Error("Divide by zero");var R=Math.pow(10,f(I)),O=R/(R*I);return a(v,O)}function h(v,I){return Math.round(v*Math.pow(10,I))/Math.pow(10,I)}function f(v){if(!isFinite(v))return 0;for(var I=0;v%1!==0;)v*=10,I++;return I}function c(){var v;if(!this)return v=Object.create(c.prototype),c.apply(v,arguments),v;v=Error.apply(this,arguments),this.name="QtyError",this.message=v.message,this.stack=v.stack}c.prototype=Object.create(Error.prototype,{constructor:{value:c}});function u(v,I){throw new c("Incompatible units: "+v+" and "+I)}var d={"<googol>":[["googol"],1e100,"prefix"],"<kibi>":[["Ki","Kibi","kibi"],Math.pow(2,10),"prefix"],"<mebi>":[["Mi","Mebi","mebi"],Math.pow(2,20),"prefix"],"<gibi>":[["Gi","Gibi","gibi"],Math.pow(2,30),"prefix"],"<tebi>":[["Ti","Tebi","tebi"],Math.pow(2,40),"prefix"],"<pebi>":[["Pi","Pebi","pebi"],Math.pow(2,50),"prefix"],"<exi>":[["Ei","Exi","exi"],Math.pow(2,60),"prefix"],"<zebi>":[["Zi","Zebi","zebi"],Math.pow(2,70),"prefix"],"<yebi>":[["Yi","Yebi","yebi"],Math.pow(2,80),"prefix"],"<yotta>":[["Y","Yotta","yotta"],1e24,"prefix"],"<zetta>":[["Z","Zetta","zetta"],1e21,"prefix"],"<exa>":[["E","Exa","exa"],1e18,"prefix"],"<peta>":[["P","Peta","peta"],1e15,"prefix"],"<tera>":[["T","Tera","tera"],1e12,"prefix"],"<giga>":[["G","Giga","giga"],1e9,"prefix"],"<mega>":[["M","Mega","mega"],1e6,"prefix"],"<kilo>":[["k","kilo"],1e3,"prefix"],"<hecto>":[["h","Hecto","hecto"],100,"prefix"],"<deca>":[["da","Deca","deca","deka"],10,"prefix"],"<deci>":[["d","Deci","deci"],.1,"prefix"],"<centi>":[["c","Centi","centi"],.01,"prefix"],"<milli>":[["m","Milli","milli"],.001,"prefix"],"<micro>":[["u","\\u03BC","\\xB5","Micro","mc","micro"],1e-6,"prefix"],"<nano>":[["n","Nano","nano"],1e-9,"prefix"],"<pico>":[["p","Pico","pico"],1e-12,"prefix"],"<femto>":[["f","Femto","femto"],1e-15,"prefix"],"<atto>":[["a","Atto","atto"],1e-18,"prefix"],"<zepto>":[["z","Zepto","zepto"],1e-21,"prefix"],"<yocto>":[["y","Yocto","yocto"],1e-24,"prefix"],"<1>":[["1","<1>"],1,""],"<meter>":[["m","meter","meters","metre","metres"],1,"length",["<meter>"]],"<inch>":[["in","inch","inches",\'"\'],.0254,"length",["<meter>"]],"<foot>":[["ft","foot","feet","\'"],.3048,"length",["<meter>"]],"<yard>":[["yd","yard","yards"],.9144,"length",["<meter>"]],"<mile>":[["mi","mile","miles"],1609.344,"length",["<meter>"]],"<naut-mile>":[["nmi","naut-mile"],1852,"length",["<meter>"]],"<league>":[["league","leagues"],4828,"length",["<meter>"]],"<furlong>":[["furlong","furlongs"],201.2,"length",["<meter>"]],"<rod>":[["rd","rod","rods"],5.029,"length",["<meter>"]],"<mil>":[["mil","mils"],254e-7,"length",["<meter>"]],"<angstrom>":[["ang","angstrom","angstroms"],1e-10,"length",["<meter>"]],"<fathom>":[["fathom","fathoms"],1.829,"length",["<meter>"]],"<pica>":[["pica","picas"],.00423333333,"length",["<meter>"]],"<point>":[["pt","point","points"],.000352777778,"length",["<meter>"]],"<redshift>":[["z","red-shift","redshift"],1302773e20,"length",["<meter>"]],"<AU>":[["AU","astronomical-unit"],1495979e5,"length",["<meter>"]],"<light-second>":[["ls","light-second"],299792500,"length",["<meter>"]],"<light-minute>":[["lmin","light-minute"],1798755e4,"length",["<meter>"]],"<light-year>":[["ly","light-year"],9460528e9,"length",["<meter>"]],"<parsec>":[["pc","parsec","parsecs"],3085678e10,"length",["<meter>"]],"<datamile>":[["DM","datamile"],1828.8,"length",["<meter>"]],"<kilogram>":[["kg","kilogram","kilograms"],1,"mass",["<kilogram>"]],"<AMU>":[["u","AMU","amu"],1660538921e-36,"mass",["<kilogram>"]],"<dalton>":[["Da","Dalton","Daltons","dalton","daltons"],1660538921e-36,"mass",["<kilogram>"]],"<slug>":[["slug","slugs"],14.5939029,"mass",["<kilogram>"]],"<short-ton>":[["tn","ton","short-ton"],907.18474,"mass",["<kilogram>"]],"<metric-ton>":[["t","tonne","metric-ton"],1e3,"mass",["<kilogram>"]],"<carat>":[["ct","carat","carats"],2e-4,"mass",["<kilogram>"]],"<pound>":[["lbs","lb","pound","pounds","#"],.45359237,"mass",["<kilogram>"]],"<ounce>":[["oz","ounce","ounces"],.0283495231,"mass",["<kilogram>"]],"<gram>":[["g","gram","grams","gramme","grammes"],.001,"mass",["<kilogram>"]],"<grain>":[["grain","grains","gr"],6479891e-11,"mass",["<kilogram>"]],"<dram>":[["dram","drams","dr"],.0017718452,"mass",["<kilogram>"]],"<stone>":[["stone","stones","st"],6.35029318,"mass",["<kilogram>"]],"<hectare>":[["hectare"],1e4,"area",["<meter>","<meter>"]],"<acre>":[["acre","acres"],4046.85642,"area",["<meter>","<meter>"]],"<sqft>":[["sqft"],1,"area",["<foot>","<foot>"]],"<liter>":[["l","L","liter","liters","litre","litres"],.001,"volume",["<meter>","<meter>","<meter>"]],"<gallon>":[["gal","gallon","gallons"],.0037854118,"volume",["<meter>","<meter>","<meter>"]],"<gallon-imp>":[["galimp","gallon-imp","gallons-imp"],.00454609,"volume",["<meter>","<meter>","<meter>"]],"<quart>":[["qt","quart","quarts"],.00094635295,"volume",["<meter>","<meter>","<meter>"]],"<pint>":[["pt","pint","pints"],.000473176475,"volume",["<meter>","<meter>","<meter>"]],"<pint-imp>":[["ptimp","pint-imp","pints-imp"],.00056826125,"volume",["<meter>","<meter>","<meter>"]],"<cup>":[["cu","cup","cups"],.000236588238,"volume",["<meter>","<meter>","<meter>"]],"<fluid-ounce>":[["floz","fluid-ounce","fluid-ounces"],295735297e-13,"volume",["<meter>","<meter>","<meter>"]],"<fluid-ounce-imp>":[["flozimp","floz-imp","fluid-ounce-imp","fluid-ounces-imp"],284130625e-13,"volume",["<meter>","<meter>","<meter>"]],"<tablespoon>":[["tb","tbsp","tbs","tablespoon","tablespoons"],147867648e-13,"volume",["<meter>","<meter>","<meter>"]],"<teaspoon>":[["tsp","teaspoon","teaspoons"],492892161e-14,"volume",["<meter>","<meter>","<meter>"]],"<bushel>":[["bu","bsh","bushel","bushels"],.035239072,"volume",["<meter>","<meter>","<meter>"]],"<oilbarrel>":[["bbl","oilbarrel","oilbarrels","oil-barrel","oil-barrels"],.158987294928,"volume",["<meter>","<meter>","<meter>"]],"<beerbarrel>":[["bl","bl-us","beerbarrel","beerbarrels","beer-barrel","beer-barrels"],.1173477658,"volume",["<meter>","<meter>","<meter>"]],"<beerbarrel-imp>":[["blimp","bl-imp","beerbarrel-imp","beerbarrels-imp","beer-barrel-imp","beer-barrels-imp"],.16365924,"volume",["<meter>","<meter>","<meter>"]],"<kph>":[["kph"],.277777778,"speed",["<meter>"],["<second>"]],"<mph>":[["mph"],.44704,"speed",["<meter>"],["<second>"]],"<knot>":[["kt","kn","kts","knot","knots"],.514444444,"speed",["<meter>"],["<second>"]],"<fps>":[["fps"],.3048,"speed",["<meter>"],["<second>"]],"<gee>":[["gee"],9.80665,"acceleration",["<meter>"],["<second>","<second>"]],"<Gal>":[["Gal"],.01,"acceleration",["<meter>"],["<second>","<second>"]],"<kelvin>":[["degK","kelvin"],1,"temperature",["<kelvin>"]],"<celsius>":[["degC","celsius","celsius","centigrade"],1,"temperature",["<kelvin>"]],"<fahrenheit>":[["degF","fahrenheit"],5/9,"temperature",["<kelvin>"]],"<rankine>":[["degR","rankine"],5/9,"temperature",["<kelvin>"]],"<temp-K>":[["tempK","temp-K"],1,"temperature",["<temp-K>"]],"<temp-C>":[["tempC","temp-C"],1,"temperature",["<temp-K>"]],"<temp-F>":[["tempF","temp-F"],5/9,"temperature",["<temp-K>"]],"<temp-R>":[["tempR","temp-R"],5/9,"temperature",["<temp-K>"]],"<second>":[["s","sec","secs","second","seconds"],1,"time",["<second>"]],"<minute>":[["min","mins","minute","minutes"],60,"time",["<second>"]],"<hour>":[["h","hr","hrs","hour","hours"],3600,"time",["<second>"]],"<day>":[["d","day","days"],3600*24,"time",["<second>"]],"<week>":[["wk","week","weeks"],7*3600*24,"time",["<second>"]],"<fortnight>":[["fortnight","fortnights"],1209600,"time",["<second>"]],"<year>":[["y","yr","year","years","annum"],31556926,"time",["<second>"]],"<decade>":[["decade","decades"],315569260,"time",["<second>"]],"<century>":[["century","centuries"],3155692600,"time",["<second>"]],"<pascal>":[["Pa","pascal","Pascal"],1,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<bar>":[["bar","bars"],1e5,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<mmHg>":[["mmHg"],133.322368,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<inHg>":[["inHg"],3386.3881472,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<torr>":[["torr"],133.322368,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<atm>":[["atm","ATM","atmosphere","atmospheres"],101325,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<psi>":[["psi"],6894.76,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<cmh2o>":[["cmH2O","cmh2o"],98.0638,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<inh2o>":[["inH2O","inh2o"],249.082052,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<poise>":[["P","poise"],.1,"viscosity",["<kilogram>"],["<meter>","<second>"]],"<stokes>":[["St","stokes"],1e-4,"viscosity",["<meter>","<meter>"],["<second>"]],"<mole>":[["mol","mole"],1,"substance",["<mole>"]],"<molar>":[["M","molar"],1e3,"molar_concentration",["<mole>"],["<meter>","<meter>","<meter>"]],"<wtpercent>":[["wt%","wtpercent"],10,"molar_concentration",["<kilogram>"],["<meter>","<meter>","<meter>"]],"<katal>":[["kat","katal","Katal"],1,"activity",["<mole>"],["<second>"]],"<unit>":[["U","enzUnit","unit"],16667e-19,"activity",["<mole>"],["<second>"]],"<farad>":[["F","farad","Farad"],1,"capacitance",["<second>","<second>","<second>","<second>","<ampere>","<ampere>"],["<meter>","<meter>","<kilogram>"]],"<coulomb>":[["C","coulomb","Coulomb"],1,"charge",["<ampere>","<second>"]],"<Ah>":[["Ah"],3600,"charge",["<ampere>","<second>"]],"<ampere>":[["A","Ampere","ampere","amp","amps"],1,"current",["<ampere>"]],"<siemens>":[["S","Siemens","siemens"],1,"conductance",["<second>","<second>","<second>","<ampere>","<ampere>"],["<kilogram>","<meter>","<meter>"]],"<henry>":[["H","Henry","henry"],1,"inductance",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<ampere>","<ampere>"]],"<volt>":[["V","Volt","volt","volts"],1,"potential",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<second>","<ampere>"]],"<ohm>":[["Ohm","ohm","\\u03A9","\\u2126"],1,"resistance",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<second>","<ampere>","<ampere>"]],"<weber>":[["Wb","weber","webers"],1,"magnetism",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<ampere>"]],"<tesla>":[["T","tesla","teslas"],1,"magnetism",["<kilogram>"],["<second>","<second>","<ampere>"]],"<gauss>":[["G","gauss"],1e-4,"magnetism",["<kilogram>"],["<second>","<second>","<ampere>"]],"<maxwell>":[["Mx","maxwell","maxwells"],1e-8,"magnetism",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<ampere>"]],"<oersted>":[["Oe","oersted","oersteds"],250/Math.PI,"magnetism",["<ampere>"],["<meter>"]],"<joule>":[["J","joule","Joule","joules","Joules"],1,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<erg>":[["erg","ergs"],1e-7,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<btu>":[["BTU","btu","BTUs"],1055.056,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<calorie>":[["cal","calorie","calories"],4.184,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<Calorie>":[["Cal","Calorie","Calories"],4184,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<therm-US>":[["th","therm","therms","Therm","therm-US"],105480400,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<Wh>":[["Wh"],3600,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<electronvolt>":[["eV","electronvolt","electronvolts"],1602176634e-28,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<newton>":[["N","Newton","newton"],1,"force",["<kilogram>","<meter>"],["<second>","<second>"]],"<dyne>":[["dyn","dyne"],1e-5,"force",["<kilogram>","<meter>"],["<second>","<second>"]],"<pound-force>":[["lbf","pound-force"],4.448222,"force",["<kilogram>","<meter>"],["<second>","<second>"]],"<hertz>":[["Hz","hertz","Hertz"],1,"frequency",["<1>"],["<second>"]],"<radian>":[["rad","radian","radians"],1,"angle",["<radian>"]],"<degree>":[["deg","degree","degrees"],Math.PI/180,"angle",["<radian>"]],"<arcminute>":[["arcmin","arcminute","arcminutes"],Math.PI/10800,"angle",["<radian>"]],"<arcsecond>":[["arcsec","arcsecond","arcseconds"],Math.PI/648e3,"angle",["<radian>"]],"<gradian>":[["gon","grad","gradian","grads"],Math.PI/200,"angle",["<radian>"]],"<steradian>":[["sr","steradian","steradians"],1,"solid_angle",["<steradian>"]],"<rotation>":[["rotation"],2*Math.PI,"angle",["<radian>"]],"<rpm>":[["rpm"],2*Math.PI/60,"angular_velocity",["<radian>"],["<second>"]],"<byte>":[["B","byte","bytes"],1,"information",["<byte>"]],"<bit>":[["b","bit","bits"],.125,"information",["<byte>"]],"<Bps>":[["Bps"],1,"information_rate",["<byte>"],["<second>"]],"<bps>":[["bps"],.125,"information_rate",["<byte>"],["<second>"]],"<dollar>":[["USD","dollar"],1,"currency",["<dollar>"]],"<cents>":[["cents"],.01,"currency",["<dollar>"]],"<candela>":[["cd","candela"],1,"luminosity",["<candela>"]],"<lumen>":[["lm","lumen"],1,"luminous_power",["<candela>","<steradian>"]],"<lux>":[["lux"],1,"illuminance",["<candela>","<steradian>"],["<meter>","<meter>"]],"<watt>":[["W","watt","watts"],1,"power",["<kilogram>","<meter>","<meter>"],["<second>","<second>","<second>"]],"<volt-ampere>":[["VA","volt-ampere"],1,"power",["<kilogram>","<meter>","<meter>"],["<second>","<second>","<second>"]],"<volt-ampere-reactive>":[["var","Var","VAr","VAR","volt-ampere-reactive"],1,"power",["<kilogram>","<meter>","<meter>"],["<second>","<second>","<second>"]],"<horsepower>":[["hp","horsepower"],745.699872,"power",["<kilogram>","<meter>","<meter>"],["<second>","<second>","<second>"]],"<gray>":[["Gy","gray","grays"],1,"radiation",["<meter>","<meter>"],["<second>","<second>"]],"<roentgen>":[["R","roentgen"],.00933,"radiation",["<meter>","<meter>"],["<second>","<second>"]],"<sievert>":[["Sv","sievert","sieverts"],1,"radiation",["<meter>","<meter>"],["<second>","<second>"]],"<becquerel>":[["Bq","becquerel","becquerels"],1,"radiation",["<1>"],["<second>"]],"<curie>":[["Ci","curie","curies"],37e9,"radiation",["<1>"],["<second>"]],"<cpm>":[["cpm"],1/60,"rate",["<count>"],["<second>"]],"<dpm>":[["dpm"],1/60,"rate",["<count>"],["<second>"]],"<bpm>":[["bpm"],1/60,"rate",["<count>"],["<second>"]],"<dot>":[["dot","dots"],1,"resolution",["<each>"]],"<pixel>":[["pixel","px"],1,"resolution",["<each>"]],"<ppi>":[["ppi"],1,"resolution",["<pixel>"],["<inch>"]],"<dpi>":[["dpi"],1,"typography",["<dot>"],["<inch>"]],"<cell>":[["cells","cell"],1,"counting",["<each>"]],"<each>":[["each"],1,"counting",["<each>"]],"<count>":[["count"],1,"counting",["<each>"]],"<base-pair>":[["bp","base-pair"],1,"counting",["<each>"]],"<nucleotide>":[["nt","nucleotide"],1,"counting",["<each>"]],"<molecule>":[["molecule","molecules"],1,"counting",["<1>"]],"<dozen>":[["doz","dz","dozen"],12,"prefix_only",["<each>"]],"<percent>":[["%","percent"],.01,"prefix_only",["<1>"]],"<ppm>":[["ppm"],1e-6,"prefix_only",["<1>"]],"<ppb>":[["ppb"],1e-9,"prefix_only",["<1>"]],"<ppt>":[["ppt"],1e-12,"prefix_only",["<1>"]],"<ppq>":[["ppq"],1e-15,"prefix_only",["<1>"]],"<gross>":[["gr","gross"],144,"prefix_only",["<dozen>","<dozen>"]],"<decibel>":[["dB","decibel","decibels"],1,"logarithmic",["<decibel>"]]},p=["<meter>","<kilogram>","<second>","<mole>","<ampere>","<radian>","<kelvin>","<temp-K>","<byte>","<dollar>","<candela>","<each>","<steradian>","<decibel>"],g="<1>",x=[g];function m(v,I){var R=I[1],O=I[3]||[],q=I[4]||[];if(!e(R))throw new c(v+": Invalid unit definition. \'scalar\' must be a number");O.forEach(function(K){if(d[K]===void 0)throw new c(v+": Invalid unit definition. Unit "+K+" in \'numerator\' is not recognized")}),q.forEach(function(K){if(d[K]===void 0)throw new c(v+": Invalid unit definition. Unit "+K+" in \'denominator\' is not recognized")})}var w={},y={},M={},_={},T={};for(var E in d)if(d.hasOwnProperty(E)){var A=d[E];if(A[2]==="prefix"){w[E]=A[1];for(var D=0;D<A[0].length;D++)y[A[0][D]]=E}else{m(E,A),M[E]={scalar:A[1],numerator:A[3],denominator:A[4]};for(var b=0;b<A[0].length;b++)_[A[0][b]]=E}T[E]=A[0][0]}function k(v){var I,R=[],O=Object.keys(d);if(typeof v=="undefined")for(I=0;I<O.length;I++)["","prefix"].indexOf(d[O[I]][2])===-1&&R.push(O[I].substr(1,O[I].length-2));else{if(this.getKinds().indexOf(v)===-1)throw new c("Kind not recognized");for(I=0;I<O.length;I++)d[O[I]][2]===v&&R.push(O[I].substr(1,O[I].length-2))}return R.sort(function(q,K){return q.toLowerCase()<K.toLowerCase()?-1:q.toLowerCase()>K.toLowerCase()?1:0})}function C(v){if(!_[v])throw new c("Unit not recognized");return d[_[v]][0]}var S=["length","time","temperature","mass","current","substance","luminosity","currency","information","angle"];function X(){if(this.signature)return this.signature;for(var v=B.call(this),I=0;I<v.length;I++)v[I]*=Math.pow(20,I);return v.reduce(function(R,O){return R+O},0)}function B(){if(!this.isBase())return B.call(this.toBase());for(var v=new Array(S.length),I=0;I<v.length;I++)v[I]=0;for(var R,O,q=0;q<this.numerator.length;q++)(R=d[this.numerator[q]])&&(O=S.indexOf(R[2]),O>=0&&(v[O]=v[O]+1));for(var K=0;K<this.denominator.length;K++)(R=d[this.denominator[K]])&&(O=S.indexOf(R[2]),O>=0&&(v[O]=v[O]-1));return v}var j="[+-]",Z="\\\\d+",tt=j+"?"+Z,rt="\\\\."+Z,ht="(?:"+Z+"(?:"+rt+")?)|(?:"+rt+")",at="[Ee]"+tt,nt="(?:"+ht+")(?:"+at+")?",Y=j+"?\\\\s*"+nt,P="("+Y+")?\\\\s*([^/]*)(?:/(.+))?",V=new RegExp("^"+P+"$"),st="\\\\^|\\\\*{2}",J="[01234]",ft=new RegExp("([^ \\\\*\\\\d]+?)(?:"+st+")?(-?"+J+"(?![a-zA-Z]))"),ct=new RegExp("([^ \\\\*\\\\d]+?)(?:"+st+")?("+J+"(?![a-zA-Z]))");function ot(v){t(v)||(v=v.toString()),v=v.trim();var I=V.exec(v);if(!I)throw new c(v+": Quantity not recognized");var R=I[1];R?(R=R.replace(/\\s/g,""),this.scalar=parseFloat(R)):this.scalar=1;for(var O=I[2],q=I[3],K,Nt,Pt;I=ft.exec(O);){if(K=parseFloat(I[2]),isNaN(K))throw new c("Unit exponent is not a number");if(K===0&&!dt.test(I[1]))throw new c("Unit not recognized");Nt=I[1]+" ",Pt="";for(var jt=0;jt<Math.abs(K);jt++)Pt+=Nt;K>=0?O=O.replace(I[0],Pt):(q=q?q+Pt:Pt,O=O.replace(I[0],""))}for(;I=ct.exec(q);){if(K=parseFloat(I[2]),isNaN(K))throw new c("Unit exponent is not a number");if(K===0&&!dt.test(I[1]))throw new c("Unit not recognized");Nt=I[1]+" ",Pt="";for(var Qt=0;Qt<K;Qt++)Pt+=Nt;q=q.replace(I[0],Pt)}O&&(this.numerator=F(O.trim())),q&&(this.denominator=F(q.trim()))}var $=Object.keys(y).sort(function(v,I){return I.length-v.length}).join("|"),z=Object.keys(_).sort(function(v,I){return I.length-v.length}).join("|"),Et="\\\\b|$",lt="("+$+")??("+z+")(?:"+Et+")",dt=new RegExp("^\\\\s*("+lt+"[\\\\s\\\\*]*)+$"),Yt=new RegExp(lt,"g"),$t={};function F(v){var I=$t[v];if(I)return I;var R,O=[];if(!dt.test(v))throw new c("Unit not recognized");for(;R=Yt.exec(v);)O.push(R.slice(1));return O=O.map(function(q){return y[q[0]]?[y[q[0]],_[q[1]]]:[_[q[1]]]}),O=O.reduce(function(q,K){return q.concat(K)},[]),O=O.filter(function(q){return q}),$t[v]=O,O}function et(v){if(!t(v))throw new c("Argument should be a string");try{return this(v)}catch(I){return null}}function it(v){return v instanceof U}function U(v,I){if(mt.apply(null,arguments),!it(this))return new U(v,I);if(this.scalar=null,this.baseScalar=null,this.signature=null,this._conversionCache={},this.numerator=x,this.denominator=x,gt(v)?(this.scalar=v.scalar,this.numerator=v.numerator&&v.numerator.length!==0?v.numerator:x,this.denominator=v.denominator&&v.denominator.length!==0?v.denominator:x):I?(ot.call(this,I),this.scalar=v):ot.call(this,v),this.denominator.join("*").indexOf("temp")>=0)throw new c("Cannot divide with temperatures");if(this.numerator.join("*").indexOf("temp")>=0){if(this.numerator.length>1)throw new c("Cannot multiply by temperatures");if(!o(this.denominator,x))throw new c("Cannot divide with temperatures")}if(this.initValue=v,Mt.call(this),this.isTemperature()&&this.baseScalar<0)throw new c("Temperatures must not be less than absolute zero")}U.prototype={constructor:U};function mt(v,I){if(I){if(!(e(v)&&t(I)))throw new c("Only number accepted as initialization value when units are explicitly provided")}else if(!(t(v)||e(v)||it(v)||gt(v)))throw new c("Only string, number or quantity accepted as single initialization value")}function gt(v){return v&&typeof v=="object"&&v.hasOwnProperty("scalar")}function Mt(){if(this.baseScalar)return this.baseScalar;if(this.isBase())this.baseScalar=this.scalar,this.signature=X.call(this);else{var v=this.toBase();this.baseScalar=v.scalar,this.signature=v.signature}}var yt={"-312078":"elastance","-312058":"resistance","-312038":"inductance","-152058":"potential","-152040":"magnetism","-152038":"magnetism","-7997":"specific_volume","-79":"snap","-59":"jolt","-39":"acceleration","-38":"radiation","-20":"frequency","-19":"speed","-18":"viscosity","-17":"volumetric_flow","-1":"wavenumber",0:"unitless",1:"length",2:"area",3:"volume",20:"time",400:"temperature",7941:"yank",7942:"power",7959:"pressure",7961:"force",7962:"energy",7979:"viscosity",7981:"momentum",7982:"angular_momentum",7997:"density",7998:"area_density",8e3:"mass",152020:"radiation_exposure",159999:"magnetism",16e4:"current",160020:"charge",312058:"conductance",312078:"capacitance",3199980:"activity",3199997:"molar_concentration",32e5:"substance",63999998:"illuminance",64e6:"luminous_power",128e7:"currency","25599999980":"information_rate","25600000000":"information","511999999980":"angular_velocity","512000000000":"angle"};function Ct(){return n(Object.keys(yt).map(function(v){return yt[v]}))}U.prototype.kind=function(){return yt[this.signature.toString()]},s(U.prototype,{isDegrees:function(){return(this.signature===null||this.signature===400)&&this.numerator.length===1&&o(this.denominator,x)&&(this.numerator[0].match(/<temp-[CFRK]>/)||this.numerator[0].match(/<(kelvin|celsius|rankine|fahrenheit)>/))},isTemperature:function(){return this.isDegrees()&&this.numerator[0].match(/<temp-[CFRK]>/)}});function Dt(v,I){var R=v.units(),O=I.to(R),q=U(ut(R));return U({scalar:v.scalar-O.scalar,numerator:q.numerator,denominator:q.denominator})}function N(v,I){var R=I.to(ut(v.units()));return U({scalar:v.scalar-R.scalar,numerator:v.numerator,denominator:v.denominator})}function H(v,I){var R=I.to(ut(v.units()));return U({scalar:v.scalar+R.scalar,numerator:v.numerator,denominator:v.denominator})}function ut(v){if(v==="tempK")return"degK";if(v==="tempC")return"degC";if(v==="tempF")return"degF";if(v==="tempR")return"degR";throw new c("Unknown type for temp conversion from: "+v)}function Tt(v,I){var R=xt(v),O=I.units(),q;if(O==="degK")q=R.scalar;else if(O==="degC")q=R.scalar;else if(O==="degF")q=R.scalar*9/5;else if(O==="degR")q=R.scalar*9/5;else throw new c("Unknown type for degree conversion to: "+O);return U({scalar:q,numerator:I.numerator,denominator:I.denominator})}function xt(v){var I=v.units(),R;if(I.match(/(deg)[CFRK]/))R=v.baseScalar;else if(I==="tempK")R=v.scalar;else if(I==="tempC")R=v.scalar;else if(I==="tempF")R=v.scalar*5/9;else if(I==="tempR")R=v.scalar*5/9;else throw new c("Unknown type for temp conversion from: "+I);return U({scalar:R,numerator:["<kelvin>"],denominator:x})}function bt(v,I){var R=I.units(),O;if(R==="tempK")O=v.baseScalar;else if(R==="tempC")O=v.baseScalar-273.15;else if(R==="tempF")O=v.baseScalar*9/5-459.67;else if(R==="tempR")O=v.baseScalar*9/5;else throw new c("Unknown type for temp conversion to: "+R);return U({scalar:O,numerator:I.numerator,denominator:I.denominator})}function At(v){var I=v.units(),R;if(I.match(/(deg)[CFRK]/))R=v.baseScalar;else if(I==="tempK")R=v.scalar;else if(I==="tempC")R=v.scalar+273.15;else if(I==="tempF")R=(v.scalar+459.67)*5/9;else if(I==="tempR")R=v.scalar*5/9;else throw new c("Unknown type for temp conversion from: "+I);return U({scalar:R,numerator:["<temp-K>"],denominator:x})}s(U.prototype,{to:function(v){var I,R;if(v==null)return this;if(!t(v))return this.to(v.units());if(I=this._conversionCache[v],I)return I;if(R=U(v),R.units()===this.units())return this;if(!this.isCompatible(R))this.isInverse(R)?R=this.inverse().to(v):u(this.units(),R.units());else if(R.isTemperature())R=bt(this,R);else if(R.isDegrees())R=Tt(this,R);else{var O=l(this.baseScalar,R.baseScalar);R=U({scalar:O,numerator:R.numerator,denominator:R.denominator})}return this._conversionCache[v]=R,R},toBase:function(){if(this.isBase())return this;if(this.isTemperature())return At(this);var v=St[this.units()];return v||(v=Xt(this.numerator,this.denominator),St[this.units()]=v),v.mul(this.scalar)},toFloat:function(){if(this.isUnitless())return this.scalar;throw new c("Can\'t convert to Float unless unitless.  Use Unit#scalar")},toPrec:function(v){if(t(v)&&(v=U(v)),e(v)&&(v=U(v+" "+this.units())),this.isUnitless()?v.isUnitless()||u(this.units(),v.units()):v=v.to(this.units()),v.scalar===0)throw new c("Divide by zero");var I=a(Math.round(this.scalar/v.scalar),v.scalar);return U(I+this.units())}});function pt(v,I){var R=U(v),O=U(I);if(R.eq(O))return i;var q;return R.isTemperature()?q=function(K){return R.mul(K).to(O).scalar}:q=function(K){return K*R.baseScalar/O.baseScalar},function(Nt){var Pt,jt,Qt;if(Array.isArray(Nt)){for(jt=Nt.length,Qt=[],Pt=0;Pt<jt;Pt++)Qt.push(q(Nt[Pt]));return Qt}else return q(Nt)}}var St={};function Xt(v,I){for(var R=[],O=[],q=1,K,Nt=0;Nt<v.length;Nt++)K=v[Nt],w[K]?q=a(q,w[K]):M[K]&&(q*=M[K].scalar,M[K].numerator&&R.push(M[K].numerator),M[K].denominator&&O.push(M[K].denominator));for(var Pt=0;Pt<I.length;Pt++)K=I[Pt],w[K]?q/=w[K]:M[K]&&(q/=M[K].scalar,M[K].numerator&&O.push(M[K].numerator),M[K].denominator&&R.push(M[K].denominator));return R=R.reduce(function(jt,Qt){return jt.concat(Qt)},[]),O=O.reduce(function(jt,Qt){return jt.concat(Qt)},[]),U({scalar:q,numerator:R,denominator:O})}U.parse=et,U.getUnits=k,U.getAliases=C,U.mulSafe=a,U.divSafe=l,U.getKinds=Ct,U.swiftConverter=pt,U.Error=c,s(U.prototype,{add:function(v){if(t(v)&&(v=U(v)),this.isCompatible(v)||u(this.units(),v.units()),this.isTemperature()&&v.isTemperature())throw new c("Cannot add two temperatures");return this.isTemperature()?H(this,v):v.isTemperature()?H(v,this):U({scalar:this.scalar+v.to(this).scalar,numerator:this.numerator,denominator:this.denominator})},sub:function(v){if(t(v)&&(v=U(v)),this.isCompatible(v)||u(this.units(),v.units()),this.isTemperature()&&v.isTemperature())return Dt(this,v);if(this.isTemperature())return N(this,v);if(v.isTemperature())throw new c("Cannot subtract a temperature from a differential degree unit");return U({scalar:this.scalar-v.to(this).scalar,numerator:this.numerator,denominator:this.denominator})},mul:function(v){if(e(v))return U({scalar:a(this.scalar,v),numerator:this.numerator,denominator:this.denominator});if(t(v)&&(v=U(v)),(this.isTemperature()||v.isTemperature())&&!(this.isUnitless()||v.isUnitless()))throw new c("Cannot multiply by temperatures");var I=this,R=v;I.isCompatible(R)&&I.signature!==400&&(R=R.to(I));var O=Rt(I.numerator,I.denominator,R.numerator,R.denominator);return U({scalar:a(I.scalar,R.scalar,O[2]),numerator:O[0],denominator:O[1]})},div:function(v){if(e(v)){if(v===0)throw new c("Divide by zero");return U({scalar:this.scalar/v,numerator:this.numerator,denominator:this.denominator})}else t(v)&&(v=U(v));if(v.scalar===0)throw new c("Divide by zero");if(v.isTemperature())throw new c("Cannot divide with temperatures");if(this.isTemperature()&&!v.isUnitless())throw new c("Cannot divide with temperatures");var I=this,R=v;I.isCompatible(R)&&I.signature!==400&&(R=R.to(I));var O=Rt(I.numerator,I.denominator,R.denominator,R.numerator);return U({scalar:a(I.scalar,O[2])/R.scalar,numerator:O[0],denominator:O[1]})},inverse:function(){if(this.isTemperature())throw new c("Cannot divide with temperatures");if(this.scalar===0)throw new c("Divide by zero");return U({scalar:1/this.scalar,numerator:this.denominator,denominator:this.numerator})}});function Rt(v,I,R,O){function q(ue){return ue!==g}v=v.filter(q),R=R.filter(q),I=I.filter(q),O=O.filter(q);var K={};function Nt(ue,de){for(var ee,Oe,Ge,Se=0;Se<ue.length;Se++)if(w[ue[Se]]?(ee=ue[Se+1],Oe=ue[Se],Ge=w[Oe],Se++):(ee=ue[Se],Oe=null,Ge=1),ee&&ee!==g)if(K[ee]){K[ee][0]+=de;var Vi=K[ee][2]?w[K[ee][2]]:1;K[ee][de===1?3:4]*=l(Ge,Vi)}else K[ee]=[de,ee,Oe,1,1]}Nt(v,1),Nt(I,-1),Nt(R,1),Nt(O,-1);var Pt=[],jt=[],Qt=1;for(var ei in K)if(K.hasOwnProperty(ei)){var Ht=K[ei],Le;if(Ht[0]>0)for(Le=0;Le<Ht[0];Le++)Pt.push(Ht[2]===null?Ht[1]:[Ht[2],Ht[1]]);else if(Ht[0]<0)for(Le=0;Le<-Ht[0];Le++)jt.push(Ht[2]===null?Ht[1]:[Ht[2],Ht[1]]);Qt*=l(Ht[3],Ht[4])}return Pt.length===0&&(Pt=x),jt.length===0&&(jt=x),Pt=Pt.reduce(function(ue,de){return ue.concat(de)},[]),jt=jt.reduce(function(ue,de){return ue.concat(de)},[]),[Pt,jt,Qt]}s(U.prototype,{eq:function(v){return this.compareTo(v)===0},lt:function(v){return this.compareTo(v)===-1},lte:function(v){return this.eq(v)||this.lt(v)},gt:function(v){return this.compareTo(v)===1},gte:function(v){return this.eq(v)||this.gt(v)},compareTo:function(v){if(t(v))return this.compareTo(U(v));if(this.isCompatible(v)||u(this.units(),v.units()),this.baseScalar<v.baseScalar)return-1;if(this.baseScalar===v.baseScalar)return 0;if(this.baseScalar>v.baseScalar)return 1},same:function(v){return this.scalar===v.scalar&&this.units()===v.units()}}),s(U.prototype,{isUnitless:function(){return[this.numerator,this.denominator].every(function(v){return o(v,x)})},isCompatible:function(v){return t(v)?this.isCompatible(U(v)):it(v)&&v.signature!==void 0?this.signature===v.signature:!1},isInverse:function(v){return this.inverse().isCompatible(v)},isBase:function(){return this._isBase!==void 0?this._isBase:this.isDegrees()&&this.numerator[0].match(/<(kelvin|temp-K)>/)?(this._isBase=!0,this._isBase):(this.numerator.concat(this.denominator).forEach(function(v){v!==g&&p.indexOf(v)===-1&&(this._isBase=!1)},this),this._isBase===!1?this._isBase:(this._isBase=!0,this._isBase))}});function Jt(){}Jt.prototype.get=function(v){return arguments.length>1&&(v=Array.apply(null,arguments)),v.reduce(function(I,R,O){if(I){var q=I[R];return O===v.length-1?q?q.data:void 0:q}},this)},Jt.prototype.set=function(v,I){return arguments.length>2&&(v=Array.prototype.slice.call(arguments,0,-1),I=arguments[arguments.length-1]),v.reduce(function(R,O,q){var K=R[O];return K===void 0&&(K=R[O]={}),q===v.length-1?(K.data=I,I):K},this)};function we(v,I){return(v+" "+I).trim()}U.formatter=we,s(U.prototype,{units:function(){if(this._units!==void 0)return this._units;var v=o(this.numerator,x),I=o(this.denominator,x);if(v&&I)return this._units="",this._units;var R=Be(this.numerator),O=Be(this.denominator);return this._units=R+(I?"":"/"+O),this._units},toString:function(v,I){var R;if(e(v))R=this.units(),I=v;else if(t(v))R=v;else if(it(v))return this.toPrec(v).toString(I);var O=this.to(R),q=I!==void 0?h(O.scalar,I):O.scalar;return O=(q+" "+O.units()).trim(),O},format:function(v,I){arguments.length===1&&typeof v=="function"&&(I=v,v=void 0),I=I||U.formatter;var R=this.to(v);return I.call(this,R.scalar,R.units())}});var Ae=new Jt;function Be(v){var I=Ae.get(v);if(I)return I;var R=o(v,x);return R?I="1":I=ar(je(v)).join("*"),Ae.set(v,I),I}function je(v){for(var I=[],R,O,q=0;q<v.length;q++)R=v[q],O=v[q+1],w[R]?(I.push(T[R]+T[O]),q++):I.push(T[R]);return I}function ar(v){var I=v.reduce(function(R,O){var q=R[O];return q||R.push(q=R[O]=[O,0]),q[1]++,R},[]);return I.map(function(R){return R[0]+(R[1]>1?R[1]:"")})}return U.version="1.8.0",U})});var ph=W((_4,y1)=>{"use strict";y1.exports=vy;var b1=+(Math.pow(2,27)+1);function vy(t,r,e){var i=t*r,n=b1*t,o=n-t,s=n-o,a=t-s,l=b1*r,h=l-r,f=l-h,c=r-f,u=i-s*f,d=u-a*f,p=d-s*c,g=a*c-p;return e?(e[0]=g,e[1]=i,e):[g,i]}});var _1=W((M4,v1)=>{"use strict";v1.exports=My;function _y(t,r){var e=t+r,i=e-t,n=e-i,o=r-i,s=t-n,a=s+o;return a?[a,e]:[e]}function My(t,r){var e=t.length|0,i=r.length|0;if(e===1&&i===1)return _y(t[0],r[0]);var n=e+i,o=new Array(n),s=0,a=0,l=0,h=Math.abs,f=t[a],c=h(f),u=r[l],d=h(u),p,g;c<d?(g=f,a+=1,a<e&&(f=t[a],c=h(f))):(g=u,l+=1,l<i&&(u=r[l],d=h(u))),a<e&&c<d||l>=i?(p=f,a+=1,a<e&&(f=t[a],c=h(f))):(p=u,l+=1,l<i&&(u=r[l],d=h(u)));for(var x=p+g,m=x-p,w=g-m,y=w,M=x,_,T,E,A,D;a<e&&l<i;)c<d?(p=f,a+=1,a<e&&(f=t[a],c=h(f))):(p=u,l+=1,l<i&&(u=r[l],d=h(u))),g=y,x=p+g,m=x-p,w=g-m,w&&(o[s++]=w),_=M+x,T=_-M,E=_-T,A=x-T,D=M-E,y=D+A,M=_;for(;a<e;)p=f,g=y,x=p+g,m=x-p,w=g-m,w&&(o[s++]=w),_=M+x,T=_-M,E=_-T,A=x-T,D=M-E,y=D+A,M=_,a+=1,a<e&&(f=t[a]);for(;l<i;)p=u,g=y,x=p+g,m=x-p,w=g-m,w&&(o[s++]=w),_=M+x,T=_-M,E=_-T,A=x-T,D=M-E,y=D+A,M=_,l+=1,l<i&&(u=r[l]);return y&&(o[s++]=y),M&&(o[s++]=M),s||(o[s++]=0),o.length=s,o}});var E1=W((E4,M1)=>{"use strict";M1.exports=Ey;function Ey(t,r,e){var i=t+r,n=i-t,o=i-n,s=r-n,a=t-o;return e?(e[0]=a+s,e[1]=i,e):[a+s,i]}});var A1=W((k4,k1)=>{"use strict";var mh=ph(),ky=E1();k1.exports=Ay;function Ay(t,r){var e=t.length;if(e===1){var i=mh(t[0],r);return i[0]?i:[i[1]]}var n=new Array(2*e),o=[.1,.1],s=[.1,.1],a=0;mh(t[0],r,o),o[0]&&(n[a++]=o[0]);for(var l=1;l<e;++l){mh(t[l],r,s);var h=o[1];ky(h,s[0],o),o[0]&&(n[a++]=o[0]);var f=s[1],c=o[1],u=f+c,d=u-f,p=c-d;o[1]=u,p&&(n[a++]=p)}return o[1]&&(n[a++]=o[1]),a===0&&(n[a++]=0),n.length=a,n}});var I1=W((A4,S1)=>{"use strict";S1.exports=Iy;function Sy(t,r){var e=t+r,i=e-t,n=e-i,o=r-i,s=t-n,a=s+o;return a?[a,e]:[e]}function Iy(t,r){var e=t.length|0,i=r.length|0;if(e===1&&i===1)return Sy(t[0],-r[0]);var n=e+i,o=new Array(n),s=0,a=0,l=0,h=Math.abs,f=t[a],c=h(f),u=-r[l],d=h(u),p,g;c<d?(g=f,a+=1,a<e&&(f=t[a],c=h(f))):(g=u,l+=1,l<i&&(u=-r[l],d=h(u))),a<e&&c<d||l>=i?(p=f,a+=1,a<e&&(f=t[a],c=h(f))):(p=u,l+=1,l<i&&(u=-r[l],d=h(u)));for(var x=p+g,m=x-p,w=g-m,y=w,M=x,_,T,E,A,D;a<e&&l<i;)c<d?(p=f,a+=1,a<e&&(f=t[a],c=h(f))):(p=u,l+=1,l<i&&(u=-r[l],d=h(u))),g=y,x=p+g,m=x-p,w=g-m,w&&(o[s++]=w),_=M+x,T=_-M,E=_-T,A=x-T,D=M-E,y=D+A,M=_;for(;a<e;)p=f,g=y,x=p+g,m=x-p,w=g-m,w&&(o[s++]=w),_=M+x,T=_-M,E=_-T,A=x-T,D=M-E,y=D+A,M=_,a+=1,a<e&&(f=t[a]);for(;l<i;)p=u,g=y,x=p+g,m=x-p,w=g-m,w&&(o[s++]=w),_=M+x,T=_-M,E=_-T,A=x-T,D=M-E,y=D+A,M=_,l+=1,l<i&&(u=-r[l]);return y&&(o[s++]=y),M&&(o[s++]=M),s||(o[s++]=0),o.length=s,o}});var T1=W((S4,gh)=>{"use strict";var Dy=ph(),Ty=_1(),Ry=A1(),Py=I1(),D1=5,ro=11102230246251565e-32,Cy=(3+16*ro)*ro,Fy=(7+56*ro)*ro;function By(t,r,e,i){return function(o,s,a){var l=t(t(r(s[1],a[0]),r(-a[1],s[0])),t(r(o[1],s[0]),r(-s[1],o[0]))),h=t(r(o[1],a[0]),r(-a[1],o[0])),f=i(l,h);return f[f.length-1]}}function Ly(t,r,e,i){return function(o,s,a,l){var h=t(t(e(t(r(a[1],l[0]),r(-l[1],a[0])),s[2]),t(e(t(r(s[1],l[0]),r(-l[1],s[0])),-a[2]),e(t(r(s[1],a[0]),r(-a[1],s[0])),l[2]))),t(e(t(r(s[1],l[0]),r(-l[1],s[0])),o[2]),t(e(t(r(o[1],l[0]),r(-l[1],o[0])),-s[2]),e(t(r(o[1],s[0]),r(-s[1],o[0])),l[2])))),f=t(t(e(t(r(a[1],l[0]),r(-l[1],a[0])),o[2]),t(e(t(r(o[1],l[0]),r(-l[1],o[0])),-a[2]),e(t(r(o[1],a[0]),r(-a[1],o[0])),l[2]))),t(e(t(r(s[1],a[0]),r(-a[1],s[0])),o[2]),t(e(t(r(o[1],a[0]),r(-a[1],o[0])),-s[2]),e(t(r(o[1],s[0]),r(-s[1],o[0])),a[2])))),c=i(h,f);return c[c.length-1]}}function Oy(t,r,e,i){return function(o,s,a,l,h){var f=t(t(t(e(t(e(t(r(l[1],h[0]),r(-h[1],l[0])),a[2]),t(e(t(r(a[1],h[0]),r(-h[1],a[0])),-l[2]),e(t(r(a[1],l[0]),r(-l[1],a[0])),h[2]))),s[3]),t(e(t(e(t(r(l[1],h[0]),r(-h[1],l[0])),s[2]),t(e(t(r(s[1],h[0]),r(-h[1],s[0])),-l[2]),e(t(r(s[1],l[0]),r(-l[1],s[0])),h[2]))),-a[3]),e(t(e(t(r(a[1],h[0]),r(-h[1],a[0])),s[2]),t(e(t(r(s[1],h[0]),r(-h[1],s[0])),-a[2]),e(t(r(s[1],a[0]),r(-a[1],s[0])),h[2]))),l[3]))),t(e(t(e(t(r(a[1],l[0]),r(-l[1],a[0])),s[2]),t(e(t(r(s[1],l[0]),r(-l[1],s[0])),-a[2]),e(t(r(s[1],a[0]),r(-a[1],s[0])),l[2]))),-h[3]),t(e(t(e(t(r(l[1],h[0]),r(-h[1],l[0])),s[2]),t(e(t(r(s[1],h[0]),r(-h[1],s[0])),-l[2]),e(t(r(s[1],l[0]),r(-l[1],s[0])),h[2]))),o[3]),e(t(e(t(r(l[1],h[0]),r(-h[1],l[0])),o[2]),t(e(t(r(o[1],h[0]),r(-h[1],o[0])),-l[2]),e(t(r(o[1],l[0]),r(-l[1],o[0])),h[2]))),-s[3])))),t(t(e(t(e(t(r(s[1],h[0]),r(-h[1],s[0])),o[2]),t(e(t(r(o[1],h[0]),r(-h[1],o[0])),-s[2]),e(t(r(o[1],s[0]),r(-s[1],o[0])),h[2]))),l[3]),t(e(t(e(t(r(s[1],l[0]),r(-l[1],s[0])),o[2]),t(e(t(r(o[1],l[0]),r(-l[1],o[0])),-s[2]),e(t(r(o[1],s[0]),r(-s[1],o[0])),l[2]))),-h[3]),e(t(e(t(r(a[1],l[0]),r(-l[1],a[0])),s[2]),t(e(t(r(s[1],l[0]),r(-l[1],s[0])),-a[2]),e(t(r(s[1],a[0]),r(-a[1],s[0])),l[2]))),o[3]))),t(e(t(e(t(r(a[1],l[0]),r(-l[1],a[0])),o[2]),t(e(t(r(o[1],l[0]),r(-l[1],o[0])),-a[2]),e(t(r(o[1],a[0]),r(-a[1],o[0])),l[2]))),-s[3]),t(e(t(e(t(r(s[1],l[0]),r(-l[1],s[0])),o[2]),t(e(t(r(o[1],l[0]),r(-l[1],o[0])),-s[2]),e(t(r(o[1],s[0]),r(-s[1],o[0])),l[2]))),a[3]),e(t(e(t(r(s[1],a[0]),r(-a[1],s[0])),o[2]),t(e(t(r(o[1],a[0]),r(-a[1],o[0])),-s[2]),e(t(r(o[1],s[0]),r(-s[1],o[0])),a[2]))),-l[3]))))),c=t(t(t(e(t(e(t(r(l[1],h[0]),r(-h[1],l[0])),a[2]),t(e(t(r(a[1],h[0]),r(-h[1],a[0])),-l[2]),e(t(r(a[1],l[0]),r(-l[1],a[0])),h[2]))),o[3]),e(t(e(t(r(l[1],h[0]),r(-h[1],l[0])),o[2]),t(e(t(r(o[1],h[0]),r(-h[1],o[0])),-l[2]),e(t(r(o[1],l[0]),r(-l[1],o[0])),h[2]))),-a[3])),t(e(t(e(t(r(a[1],h[0]),r(-h[1],a[0])),o[2]),t(e(t(r(o[1],h[0]),r(-h[1],o[0])),-a[2]),e(t(r(o[1],a[0]),r(-a[1],o[0])),h[2]))),l[3]),e(t(e(t(r(a[1],l[0]),r(-l[1],a[0])),o[2]),t(e(t(r(o[1],l[0]),r(-l[1],o[0])),-a[2]),e(t(r(o[1],a[0]),r(-a[1],o[0])),l[2]))),-h[3]))),t(t(e(t(e(t(r(a[1],h[0]),r(-h[1],a[0])),s[2]),t(e(t(r(s[1],h[0]),r(-h[1],s[0])),-a[2]),e(t(r(s[1],a[0]),r(-a[1],s[0])),h[2]))),o[3]),e(t(e(t(r(a[1],h[0]),r(-h[1],a[0])),o[2]),t(e(t(r(o[1],h[0]),r(-h[1],o[0])),-a[2]),e(t(r(o[1],a[0]),r(-a[1],o[0])),h[2]))),-s[3])),t(e(t(e(t(r(s[1],h[0]),r(-h[1],s[0])),o[2]),t(e(t(r(o[1],h[0]),r(-h[1],o[0])),-s[2]),e(t(r(o[1],s[0]),r(-s[1],o[0])),h[2]))),a[3]),e(t(e(t(r(s[1],a[0]),r(-a[1],s[0])),o[2]),t(e(t(r(o[1],a[0]),r(-a[1],o[0])),-s[2]),e(t(r(o[1],s[0]),r(-s[1],o[0])),a[2]))),-h[3])))),u=i(f,c);return u[u.length-1]}}function io(t){var r=t===3?By:t===4?Ly:Oy;return r(Ty,Dy,Ry,Py)}var Uy=io(3),Ny=io(4),Ir=[function(){return 0},function(){return 0},function(r,e){return e[0]-r[0]},function(r,e,i){var n=(r[1]-i[1])*(e[0]-i[0]),o=(r[0]-i[0])*(e[1]-i[1]),s=n-o,a;if(n>0){if(o<=0)return s;a=n+o}else if(n<0){if(o>=0)return s;a=-(n+o)}else return s;var l=Cy*a;return s>=l||s<=-l?s:Uy(r,e,i)},function(r,e,i,n){var o=r[0]-n[0],s=e[0]-n[0],a=i[0]-n[0],l=r[1]-n[1],h=e[1]-n[1],f=i[1]-n[1],c=r[2]-n[2],u=e[2]-n[2],d=i[2]-n[2],p=s*f,g=a*h,x=a*l,m=o*f,w=o*h,y=s*l,M=c*(p-g)+u*(x-m)+d*(w-y),_=(Math.abs(p)+Math.abs(g))*Math.abs(c)+(Math.abs(x)+Math.abs(m))*Math.abs(u)+(Math.abs(w)+Math.abs(y))*Math.abs(d),T=Fy*_;return M>T||-M>T?M:Ny(r,e,i,n)}];function Yy(t){var r=Ir[t.length];return r||(r=Ir[t.length]=io(t.length)),r.apply(void 0,t)}function zy(t,r,e,i,n,o,s){return function(l,h,f,c,u){switch(arguments.length){case 0:case 1:return 0;case 2:return i(l,h);case 3:return n(l,h,f);case 4:return o(l,h,f,c);case 5:return s(l,h,f,c,u)}for(var d=new Array(arguments.length),p=0;p<arguments.length;++p)d[p]=arguments[p];return t(d)}}function Xy(){for(;Ir.length<=D1;)Ir.push(io(Ir.length));gh.exports=zy.apply(void 0,[Yy].concat(Ir));for(var t=0;t<=D1;++t)gh.exports[t]=Ir[t]}Xy()});var P1=W((I4,R1)=>{R1.exports=jy;var no=T1();function jy(t,r){for(var e=r[0],i=r[1],n=t.length,o=1,s=n,a=0,l=n-1;a<s;l=a++){var h=t[a],f=t[l],c=h[1],u=f[1];if(u<c){if(u<i&&i<c){var d=no(h,f,r);if(d===0)return 0;o^=0<d|0}else if(i===c){var p=t[(a+1)%n],g=p[1];if(c<g){var d=no(h,f,r);if(d===0)return 0;o^=0<d|0}}}else if(c<u){if(c<i&&i<u){var d=no(h,f,r);if(d===0)return 0;o^=d<0|0}else if(i===c){var p=t[(a+1)%n],g=p[1];if(g<c){var d=no(h,f,r);if(d===0)return 0;o^=d<0|0}}}else if(i===c){var x=Math.min(h[0],f[0]),m=Math.max(h[0],f[0]);if(a===0){for(;l>0;){var w=(l+n-1)%n,y=t[w];if(y[1]!==i)break;var M=y[0];x=Math.min(x,M),m=Math.max(m,M),l=w}if(l===0)return x<=e&&e<=m?0:1;s=l+1}for(var _=t[(l+n-1)%n][1];a+1<s;){var y=t[a+1];if(y[1]!==i)break;var M=y[0];x=Math.min(x,M),m=Math.max(m,M),a+=1}if(x<=e&&e<=m)return 0;var T=t[(a+1)%n][1];e<x&&_<i!=T<i&&(o^=1)}}return 2*o-1}});var F1=W((W4,C1)=>{"use strict";var _h=class{constructor(){this.nodes=new Map}add(r){var e=this.nodes.get(r);return e||(e=new Qy(r),this.nodes.set(r,e)),e}union(r,e){let i=this.find(r),n=this.find(e);i!==n&&(i.rank<n.rank?i.parent=n:i.rank>n.rank?n.parent=i:(n.parent=i,i.rank++))}find(r){for(var e=r;e.parent!==null;)e=e.parent;for(var i=r;i.parent!==null;){var n=i;i=i.parent,n.parent=e}return e}connected(r,e){return this.find(r)===this.find(e)}};C1.exports=_h;function Qy(t){this.value=t,this.parent=null,this.rank=0}});var O1=W((L1,Ah)=>{(function(t){if(typeof L1=="object"&&typeof Ah!="undefined")Ah.exports=t();else if(typeof define=="function"&&define.amd)define([],t);else{var r;typeof window!="undefined"?r=window:typeof global!="undefined"?r=global:typeof self!="undefined"?r=self:r=this,r.PriorityQueue=t()}})(function(){var t,r,e;return function i(n,o,s){function a(f,c){if(!o[f]){if(!n[f]){var u=typeof ri=="function"&&ri;if(!c&&u)return u(f,!0);if(l)return l(f,!0);var d=new Error("Cannot find module \'"+f+"\'");throw d.code="MODULE_NOT_FOUND",d}var p=o[f]={exports:{}};n[f][0].call(p.exports,function(g){var x=n[f][1][g];return a(x||g)},p,p.exports,i,n,o,s)}return o[f].exports}for(var l=typeof ri=="function"&&ri,h=0;h<s.length;h++)a(s[h]);return a}({1:[function(i,n,o){var s,a,l,h,f,c=function(d,p){for(var g in p)u.call(p,g)&&(d[g]=p[g]);function x(){this.constructor=d}return x.prototype=p.prototype,d.prototype=new x,d.__super__=p.prototype,d},u={}.hasOwnProperty;s=i("./PriorityQueue/AbstractPriorityQueue"),a=i("./PriorityQueue/ArrayStrategy"),h=i("./PriorityQueue/BinaryHeapStrategy"),l=i("./PriorityQueue/BHeapStrategy"),f=function(d){c(p,d);function p(g){g||(g={}),g.strategy||(g.strategy=h),g.comparator||(g.comparator=function(x,m){return(x||0)-(m||0)}),p.__super__.constructor.call(this,g)}return p}(s),f.ArrayStrategy=a,f.BinaryHeapStrategy=h,f.BHeapStrategy=l,n.exports=f},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(i,n,o){var s;n.exports=s=function(){function a(l){var h;if((l!=null?l.strategy:void 0)==null)throw"Must pass options.strategy, a strategy";if((l!=null?l.comparator:void 0)==null)throw"Must pass options.comparator, a comparator";this.priv=new l.strategy(l),this.length=(l!=null&&(h=l.initialValues)!=null?h.length:void 0)||0}return a.prototype.queue=function(l){this.length++,this.priv.queue(l)},a.prototype.dequeue=function(l){if(!this.length)throw"Empty queue";return this.length--,this.priv.dequeue()},a.prototype.peek=function(l){if(!this.length)throw"Empty queue";return this.priv.peek()},a.prototype.clear=function(){return this.length=0,this.priv.clear()},a}()},{}],3:[function(i,n,o){var s,a;a=function(l,h,f){var c,u,d;for(u=0,c=l.length;u<c;)d=u+c>>>1,f(l[d],h)>=0?u=d+1:c=d;return u},n.exports=s=function(){function l(h){var f;this.options=h,this.comparator=this.options.comparator,this.data=((f=this.options.initialValues)!=null?f.slice(0):void 0)||[],this.data.sort(this.comparator).reverse()}return l.prototype.queue=function(h){var f;f=a(this.data,h,this.comparator),this.data.splice(f,0,h)},l.prototype.dequeue=function(){return this.data.pop()},l.prototype.peek=function(){return this.data[this.data.length-1]},l.prototype.clear=function(){this.data.length=0},l}()},{}],4:[function(i,n,o){var s;n.exports=s=function(){function a(l){var h,f,c,u,d,p,g,x,m;for(this.comparator=(l!=null?l.comparator:void 0)||function(w,y){return w-y},this.pageSize=(l!=null?l.pageSize:void 0)||512,this.length=0,x=0;1<<x<this.pageSize;)x+=1;if(1<<x!==this.pageSize)throw"pageSize must be a power of two";for(this._shift=x,this._emptyMemoryPageTemplate=h=[],f=c=0,p=this.pageSize;0<=p?c<p:c>p;f=0<=p?++c:--c)h.push(null);if(this._memory=[],this._mask=this.pageSize-1,l.initialValues)for(g=l.initialValues,u=0,d=g.length;u<d;u++)m=g[u],this.queue(m)}return a.prototype.queue=function(l){this.length+=1,this._write(this.length,l),this._bubbleUp(this.length,l)},a.prototype.dequeue=function(){var l,h;return l=this._read(1),h=this._read(this.length),this.length-=1,this.length>0&&(this._write(1,h),this._bubbleDown(1,h)),l},a.prototype.peek=function(){return this._read(1)},a.prototype.clear=function(){this.length=0,this._memory.length=0},a.prototype._write=function(l,h){var f;for(f=l>>this._shift;f>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[f][l&this._mask]=h},a.prototype._read=function(l){return this._memory[l>>this._shift][l&this._mask]},a.prototype._bubbleUp=function(l,h){var f,c,u,d;for(f=this.comparator;l>1&&(c=l&this._mask,l<this.pageSize||c>3?u=l&~this._mask|c>>1:c<2?(u=l-this.pageSize>>this._shift,u+=u&~(this._mask>>1),u|=this.pageSize>>1):u=l-2,d=this._read(u),!(f(d,h)<0));)this._write(u,h),this._write(l,d),l=u},a.prototype._bubbleDown=function(l,h){var f,c,u,d,p;for(p=this.comparator;l<this.length;)if(l>this._mask&&!(l&this._mask-1)?f=c=l+2:l&this.pageSize>>1?(f=(l&~this._mask)>>1,f|=l&this._mask>>1,f=f+1<<this._shift,c=f+1):(f=l+(l&this._mask),c=f+1),f!==c&&c<=this.length)if(u=this._read(f),d=this._read(c),p(u,h)<0&&p(u,d)<=0)this._write(f,h),this._write(l,u),l=f;else if(p(d,h)<0)this._write(c,h),this._write(l,d),l=c;else break;else if(f<=this.length)if(u=this._read(f),p(u,h)<0)this._write(f,h),this._write(l,u),l=f;else break;else break},a}()},{}],5:[function(i,n,o){var s;n.exports=s=function(){function a(l){var h;this.comparator=(l!=null?l.comparator:void 0)||function(f,c){return f-c},this.length=0,this.data=((h=l.initialValues)!=null?h.slice(0):void 0)||[],this._heapify()}return a.prototype._heapify=function(){var l,h,f;if(this.data.length>0)for(l=h=1,f=this.data.length;1<=f?h<f:h>f;l=1<=f?++h:--h)this._bubbleUp(l)},a.prototype.queue=function(l){this.data.push(l),this._bubbleUp(this.data.length-1)},a.prototype.dequeue=function(){var l,h;return h=this.data[0],l=this.data.pop(),this.data.length>0&&(this.data[0]=l,this._bubbleDown(0)),h},a.prototype.peek=function(){return this.data[0]},a.prototype.clear=function(){this.length=0,this.data.length=0},a.prototype._bubbleUp=function(l){for(var h,f;l>0&&(h=l-1>>>1,this.comparator(this.data[l],this.data[h])<0);)f=this.data[h],this.data[h]=this.data[l],this.data[l]=f,l=h},a.prototype._bubbleDown=function(l){var h,f,c,u,d;for(h=this.data.length-1;f=(l<<1)+1,u=f+1,c=l,f<=h&&this.comparator(this.data[f],this.data[c])<0&&(c=f),u<=h&&this.comparator(this.data[u],this.data[c])<0&&(c=u),c!==l;)d=this.data[c],this.data[c]=this.data[l],this.data[l]=d,l=c},a}()},{}]},{},[1])(1)})});var z1=W(Y1=>{"use strict";var hv=function(){var t=self.window=self;function r(){this._listeners={}}r.prototype.on=function(i,n){if(this._listeners[i])throw new RangeError("there is already a listener for "+i);if(typeof n!="function")throw new TypeError("callback argument must be a function");this._listeners[i]=n},r.prototype._send=function(i,n,o){o===void 0?o=[]:Array.isArray(o)||(o=[o]),self.postMessage({id:i,data:n},o)},r.prototype._trigger=function(i,n){if(!this._listeners[i])throw new Error("event "+i+" is not defined");this._listeners[i].apply(null,n)};var e=new r;self.onmessage=function(i){switch(i.data.action){case"exec":i.data.args.unshift(function(n,o){e._send(i.data.id,n,o)}),e._trigger(i.data.event,i.data.args);break;case"ping":e._send(i.data.id,"pong");break;default:throw new Error("unexpected action: "+i.data.action)}}},N1=hv.toString().split(\'"CODE";\');Y1.newWorkerURL=function(r,e){var i=new Blob(["(",N1[0],"importScripts.apply(self, "+JSON.stringify(e)+`);\n`,"(",r,")();",N1[1],")();"],{type:"application/javascript"});return URL.createObjectURL(i)}});var j1=W((LS,X1)=>{"use strict";var fv=z1(),Rh=navigator.hardwareConcurrency||1,BS=Function.prototype;function or(t,r){if(typeof t!="string"&&typeof t!="function")throw new TypeError("func argument must be a function");if(r===void 0&&(r={}),typeof r!="object"||r===null)throw new TypeError("options argument must be an object");this._workerCode=t.toString(),r.maxWorkers===void 0||r.maxWorkers==="auto"?this._numWorkers=Math.min(Rh-1,1):r.maxWorkers>0?this._numWorkers=Math.min(r.maxWorkers,Rh):this._numWorkers=Rh,this._workers=new Map,this._timeout=r.timeout||0,this._terminateOnError=!!r.terminateOnError;var e=r.deps;typeof e=="string"&&(e=[e]),Array.isArray(e)||(e=void 0),this._id=0,this._terminated=!1,this._working=0,this._waiting=[],this._init(e)}or.prototype._init=function(t){for(var r=fv.newWorkerURL(this._workerCode,t),e=0;e<this._numWorkers;e++){var i=new Worker(r);i.onmessage=this._onmessage.bind(this,i),i.onerror=this._onerror.bind(this,i),i.running=!1,i.id=e,this._workers.set(i,null)}URL.revokeObjectURL(r)};or.prototype._onerror=function(t,r){if(!this._terminated){this._working--,t.running=!1;var e=this._workers.get(t);e&&e[1](r.message),this._workers.set(t,null),this._terminateOnError?this.terminate():this._exec()}};or.prototype._onmessage=function(t,r){if(!this._terminated){this._working--,t.running=!1;var e=this._workers.get(t);e&&e[0](r.data.data),this._workers.set(t,null),this._exec()}};or.prototype._exec=function(){for(var t of this._workers.keys()){if(this._working===this._numWorkers||this._waiting.length===0)return;if(!t.running)for(var r=0;r<this._waiting.length;r++){var e=this._waiting[r];if(!(typeof e[4]=="number"&&e[4]!==t.id)){this._waiting.splice(r,1),t.postMessage({action:"exec",event:e[0],args:e[1]},e[2]),t.running=!0,t.time=Date.now(),this._workers.set(t,e[3]),this._working++;break}}}};or.prototype.terminate=function(){if(!this._terminated){for(var t of this._workers)t[0].terminate(),t[1]&&t[1][1](new Error("Terminated"));this._workers.clear(),this._waiting=[],this._working=0,this._terminated=!0}};or.prototype.postAll=function(t,r){if(this._terminated)throw new Error("Cannot post (terminated)");var e=[];for(var i of this._workers.keys())e.push(this.post(t,r,[],i.id));return Promise.all(e)};or.prototype.post=function(t,r,e,i){r===void 0&&(r=[]),e===void 0&&(e=[]),Array.isArray(r)||(r=[r]),Array.isArray(e)||(e=[e]);var n=this;return new Promise(function(o,s){if(n._terminated)throw new Error("Cannot post (terminated)");n._waiting.push([t,r,e,[o,s],i]),n._exec()})};X1.exports=or});var Fh=W((HS,$1)=>{"use strict";$1.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}});var W1=W((ZS,q1)=>{q1.exports=function(r){return!r||typeof r=="string"?!1:r instanceof Array||Array.isArray(r)||r.length>=0&&(r.splice instanceof Function||Object.getOwnPropertyDescriptor(r,r.length-1)&&r.constructor.name!=="String")}});var Z1=W((JS,H1)=>{"use strict";var gv=W1(),xv=Array.prototype.concat,wv=Array.prototype.slice,K1=H1.exports=function(r){for(var e=[],i=0,n=r.length;i<n;i++){var o=r[i];gv(o)?e=xv.call(e,wv.call(o)):e.push(o)}return e};K1.wrap=function(t){return function(){return t(K1(arguments))}}});var ep=W((QS,tp)=>{var Xi=Fh(),ji=Z1(),J1=Object.hasOwnProperty,Q1=Object.create(null);for(so in Xi)J1.call(Xi,so)&&(Q1[Xi[so]]=so);var so,ge=tp.exports={to:{},get:{}};ge.get=function(t){var r=t.substring(0,3).toLowerCase(),e,i;switch(r){case"hsl":e=ge.get.hsl(t),i="hsl";break;case"hwb":e=ge.get.hwb(t),i="hwb";break;default:e=ge.get.rgb(t),i="rgb";break}return e?{model:i,value:e}:null};ge.get.rgb=function(t){if(!t)return null;var r=/^#([a-f0-9]{3,4})$/i,e=/^#([a-f0-9]{6})([a-f0-9]{2})?$/i,i=/^rgba?\\(\\s*([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/,n=/^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/,o=/^(\\w+)$/,s=[0,0,0,1],a,l,h;if(a=t.match(e)){for(h=a[2],a=a[1],l=0;l<3;l++){var f=l*2;s[l]=parseInt(a.slice(f,f+2),16)}h&&(s[3]=parseInt(h,16)/255)}else if(a=t.match(r)){for(a=a[1],h=a[3],l=0;l<3;l++)s[l]=parseInt(a[l]+a[l],16);h&&(s[3]=parseInt(h+h,16)/255)}else if(a=t.match(i)){for(l=0;l<3;l++)s[l]=parseInt(a[l+1],0);a[4]&&(a[5]?s[3]=parseFloat(a[4])*.01:s[3]=parseFloat(a[4]))}else if(a=t.match(n)){for(l=0;l<3;l++)s[l]=Math.round(parseFloat(a[l+1])*2.55);a[4]&&(a[5]?s[3]=parseFloat(a[4])*.01:s[3]=parseFloat(a[4]))}else return(a=t.match(o))?a[1]==="transparent"?[0,0,0,0]:J1.call(Xi,a[1])?(s=Xi[a[1]],s[3]=1,s):null:null;for(l=0;l<3;l++)s[l]=sr(s[l],0,255);return s[3]=sr(s[3],0,1),s};ge.get.hsl=function(t){if(!t)return null;var r=/^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*(?:[,|\\/]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/,e=t.match(r);if(e){var i=parseFloat(e[4]),n=(parseFloat(e[1])%360+360)%360,o=sr(parseFloat(e[2]),0,100),s=sr(parseFloat(e[3]),0,100),a=sr(isNaN(i)?1:i,0,1);return[n,o,s,a]}return null};ge.get.hwb=function(t){if(!t)return null;var r=/^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/,e=t.match(r);if(e){var i=parseFloat(e[4]),n=(parseFloat(e[1])%360+360)%360,o=sr(parseFloat(e[2]),0,100),s=sr(parseFloat(e[3]),0,100),a=sr(isNaN(i)?1:i,0,1);return[n,o,s,a]}return null};ge.to.hex=function(){var t=ji(arguments);return"#"+ao(t[0])+ao(t[1])+ao(t[2])+(t[3]<1?ao(Math.round(t[3]*255)):"")};ge.to.rgb=function(){var t=ji(arguments);return t.length<4||t[3]===1?"rgb("+Math.round(t[0])+", "+Math.round(t[1])+", "+Math.round(t[2])+")":"rgba("+Math.round(t[0])+", "+Math.round(t[1])+", "+Math.round(t[2])+", "+t[3]+")"};ge.to.rgb.percent=function(){var t=ji(arguments),r=Math.round(t[0]/255*100),e=Math.round(t[1]/255*100),i=Math.round(t[2]/255*100);return t.length<4||t[3]===1?"rgb("+r+"%, "+e+"%, "+i+"%)":"rgba("+r+"%, "+e+"%, "+i+"%, "+t[3]+")"};ge.to.hsl=function(){var t=ji(arguments);return t.length<4||t[3]===1?"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)":"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+t[3]+")"};ge.to.hwb=function(){var t=ji(arguments),r="";return t.length>=4&&t[3]!==1&&(r=", "+t[3]),"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+r+")"};ge.to.keyword=function(t){return Q1[t.slice(0,3)]};function sr(t,r,e){return Math.min(Math.max(r,t),e)}function ao(t){var r=Math.round(t).toString(16).toUpperCase();return r.length<2?"0"+r:r}});var Bh=W((tI,ip)=>{var Gi=Fh(),rp={};for(let t of Object.keys(Gi))rp[Gi[t]]=t;var Q={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};ip.exports=Q;for(let t of Object.keys(Q)){if(!("channels"in Q[t]))throw new Error("missing channels property: "+t);if(!("labels"in Q[t]))throw new Error("missing channel labels property: "+t);if(Q[t].labels.length!==Q[t].channels)throw new Error("channel and label counts mismatch: "+t);let{channels:r,labels:e}=Q[t];delete Q[t].channels,delete Q[t].labels,Object.defineProperty(Q[t],"channels",{value:r}),Object.defineProperty(Q[t],"labels",{value:e})}Q.rgb.hsl=function(t){let r=t[0]/255,e=t[1]/255,i=t[2]/255,n=Math.min(r,e,i),o=Math.max(r,e,i),s=o-n,a,l;o===n?a=0:r===o?a=(e-i)/s:e===o?a=2+(i-r)/s:i===o&&(a=4+(r-e)/s),a=Math.min(a*60,360),a<0&&(a+=360);let h=(n+o)/2;return o===n?l=0:h<=.5?l=s/(o+n):l=s/(2-o-n),[a,l*100,h*100]};Q.rgb.hsv=function(t){let r,e,i,n,o,s=t[0]/255,a=t[1]/255,l=t[2]/255,h=Math.max(s,a,l),f=h-Math.min(s,a,l),c=function(u){return(h-u)/6/f+1/2};return f===0?(n=0,o=0):(o=f/h,r=c(s),e=c(a),i=c(l),s===h?n=i-e:a===h?n=1/3+r-i:l===h&&(n=2/3+e-r),n<0?n+=1:n>1&&(n-=1)),[n*360,o*100,h*100]};Q.rgb.hwb=function(t){let r=t[0],e=t[1],i=t[2],n=Q.rgb.hsl(t)[0],o=1/255*Math.min(r,Math.min(e,i));return i=1-1/255*Math.max(r,Math.max(e,i)),[n,o*100,i*100]};Q.rgb.cmyk=function(t){let r=t[0]/255,e=t[1]/255,i=t[2]/255,n=Math.min(1-r,1-e,1-i),o=(1-r-n)/(1-n)||0,s=(1-e-n)/(1-n)||0,a=(1-i-n)/(1-n)||0;return[o*100,s*100,a*100,n*100]};function bv(t,r){return(t[0]-r[0])**2+(t[1]-r[1])**2+(t[2]-r[2])**2}Q.rgb.keyword=function(t){let r=rp[t];if(r)return r;let e=1/0,i;for(let n of Object.keys(Gi)){let o=Gi[n],s=bv(t,o);s<e&&(e=s,i=n)}return i};Q.keyword.rgb=function(t){return Gi[t]};Q.rgb.xyz=function(t){let r=t[0]/255,e=t[1]/255,i=t[2]/255;r=r>.04045?((r+.055)/1.055)**2.4:r/12.92,e=e>.04045?((e+.055)/1.055)**2.4:e/12.92,i=i>.04045?((i+.055)/1.055)**2.4:i/12.92;let n=r*.4124+e*.3576+i*.1805,o=r*.2126+e*.7152+i*.0722,s=r*.0193+e*.1192+i*.9505;return[n*100,o*100,s*100]};Q.rgb.lab=function(t){let r=Q.rgb.xyz(t),e=r[0],i=r[1],n=r[2];e/=95.047,i/=100,n/=108.883,e=e>.008856?e**(1/3):7.787*e+16/116,i=i>.008856?i**(1/3):7.787*i+16/116,n=n>.008856?n**(1/3):7.787*n+16/116;let o=116*i-16,s=500*(e-i),a=200*(i-n);return[o,s,a]};Q.hsl.rgb=function(t){let r=t[0]/360,e=t[1]/100,i=t[2]/100,n,o,s;if(e===0)return s=i*255,[s,s,s];i<.5?n=i*(1+e):n=i+e-i*e;let a=2*i-n,l=[0,0,0];for(let h=0;h<3;h++)o=r+1/3*-(h-1),o<0&&o++,o>1&&o--,6*o<1?s=a+(n-a)*6*o:2*o<1?s=n:3*o<2?s=a+(n-a)*(2/3-o)*6:s=a,l[h]=s*255;return l};Q.hsl.hsv=function(t){let r=t[0],e=t[1]/100,i=t[2]/100,n=e,o=Math.max(i,.01);i*=2,e*=i<=1?i:2-i,n*=o<=1?o:2-o;let s=(i+e)/2,a=i===0?2*n/(o+n):2*e/(i+e);return[r,a*100,s*100]};Q.hsv.rgb=function(t){let r=t[0]/60,e=t[1]/100,i=t[2]/100,n=Math.floor(r)%6,o=r-Math.floor(r),s=255*i*(1-e),a=255*i*(1-e*o),l=255*i*(1-e*(1-o));switch(i*=255,n){case 0:return[i,l,s];case 1:return[a,i,s];case 2:return[s,i,l];case 3:return[s,a,i];case 4:return[l,s,i];case 5:return[i,s,a]}};Q.hsv.hsl=function(t){let r=t[0],e=t[1]/100,i=t[2]/100,n=Math.max(i,.01),o,s;s=(2-e)*i;let a=(2-e)*n;return o=e*n,o/=a<=1?a:2-a,o=o||0,s/=2,[r,o*100,s*100]};Q.hwb.rgb=function(t){let r=t[0]/360,e=t[1]/100,i=t[2]/100,n=e+i,o;n>1&&(e/=n,i/=n);let s=Math.floor(6*r),a=1-i;o=6*r-s,s&1&&(o=1-o);let l=e+o*(a-e),h,f,c;switch(s){default:case 6:case 0:h=a,f=l,c=e;break;case 1:h=l,f=a,c=e;break;case 2:h=e,f=a,c=l;break;case 3:h=e,f=l,c=a;break;case 4:h=l,f=e,c=a;break;case 5:h=a,f=e,c=l;break}return[h*255,f*255,c*255]};Q.cmyk.rgb=function(t){let r=t[0]/100,e=t[1]/100,i=t[2]/100,n=t[3]/100,o=1-Math.min(1,r*(1-n)+n),s=1-Math.min(1,e*(1-n)+n),a=1-Math.min(1,i*(1-n)+n);return[o*255,s*255,a*255]};Q.xyz.rgb=function(t){let r=t[0]/100,e=t[1]/100,i=t[2]/100,n,o,s;return n=r*3.2406+e*-1.5372+i*-.4986,o=r*-.9689+e*1.8758+i*.0415,s=r*.0557+e*-.204+i*1.057,n=n>.0031308?1.055*n**(1/2.4)-.055:n*12.92,o=o>.0031308?1.055*o**(1/2.4)-.055:o*12.92,s=s>.0031308?1.055*s**(1/2.4)-.055:s*12.92,n=Math.min(Math.max(0,n),1),o=Math.min(Math.max(0,o),1),s=Math.min(Math.max(0,s),1),[n*255,o*255,s*255]};Q.xyz.lab=function(t){let r=t[0],e=t[1],i=t[2];r/=95.047,e/=100,i/=108.883,r=r>.008856?r**(1/3):7.787*r+16/116,e=e>.008856?e**(1/3):7.787*e+16/116,i=i>.008856?i**(1/3):7.787*i+16/116;let n=116*e-16,o=500*(r-e),s=200*(e-i);return[n,o,s]};Q.lab.xyz=function(t){let r=t[0],e=t[1],i=t[2],n,o,s;o=(r+16)/116,n=e/500+o,s=o-i/200;let a=o**3,l=n**3,h=s**3;return o=a>.008856?a:(o-16/116)/7.787,n=l>.008856?l:(n-16/116)/7.787,s=h>.008856?h:(s-16/116)/7.787,n*=95.047,o*=100,s*=108.883,[n,o,s]};Q.lab.lch=function(t){let r=t[0],e=t[1],i=t[2],n;n=Math.atan2(i,e)*360/2/Math.PI,n<0&&(n+=360);let s=Math.sqrt(e*e+i*i);return[r,s,n]};Q.lch.lab=function(t){let r=t[0],e=t[1],n=t[2]/360*2*Math.PI,o=e*Math.cos(n),s=e*Math.sin(n);return[r,o,s]};Q.rgb.ansi16=function(t,r=null){let[e,i,n]=t,o=r===null?Q.rgb.hsv(t)[2]:r;if(o=Math.round(o/50),o===0)return 30;let s=30+(Math.round(n/255)<<2|Math.round(i/255)<<1|Math.round(e/255));return o===2&&(s+=60),s};Q.hsv.ansi16=function(t){return Q.rgb.ansi16(Q.hsv.rgb(t),t[2])};Q.rgb.ansi256=function(t){let r=t[0],e=t[1],i=t[2];return r===e&&e===i?r<8?16:r>248?231:Math.round((r-8)/247*24)+232:16+36*Math.round(r/255*5)+6*Math.round(e/255*5)+Math.round(i/255*5)};Q.ansi16.rgb=function(t){let r=t%10;if(r===0||r===7)return t>50&&(r+=3.5),r=r/10.5*255,[r,r,r];let e=(~~(t>50)+1)*.5,i=(r&1)*e*255,n=(r>>1&1)*e*255,o=(r>>2&1)*e*255;return[i,n,o]};Q.ansi256.rgb=function(t){if(t>=232){let o=(t-232)*10+8;return[o,o,o]}t-=16;let r,e=Math.floor(t/36)/5*255,i=Math.floor((r=t%36)/6)/5*255,n=r%6/5*255;return[e,i,n]};Q.rgb.hex=function(t){let e=(((Math.round(t[0])&255)<<16)+((Math.round(t[1])&255)<<8)+(Math.round(t[2])&255)).toString(16).toUpperCase();return"000000".substring(e.length)+e};Q.hex.rgb=function(t){let r=t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!r)return[0,0,0];let e=r[0];r[0].length===3&&(e=e.split("").map(a=>a+a).join(""));let i=parseInt(e,16),n=i>>16&255,o=i>>8&255,s=i&255;return[n,o,s]};Q.rgb.hcg=function(t){let r=t[0]/255,e=t[1]/255,i=t[2]/255,n=Math.max(Math.max(r,e),i),o=Math.min(Math.min(r,e),i),s=n-o,a,l;return s<1?a=o/(1-s):a=0,s<=0?l=0:n===r?l=(e-i)/s%6:n===e?l=2+(i-r)/s:l=4+(r-e)/s,l/=6,l%=1,[l*360,s*100,a*100]};Q.hsl.hcg=function(t){let r=t[1]/100,e=t[2]/100,i=e<.5?2*r*e:2*r*(1-e),n=0;return i<1&&(n=(e-.5*i)/(1-i)),[t[0],i*100,n*100]};Q.hsv.hcg=function(t){let r=t[1]/100,e=t[2]/100,i=r*e,n=0;return i<1&&(n=(e-i)/(1-i)),[t[0],i*100,n*100]};Q.hcg.rgb=function(t){let r=t[0]/360,e=t[1]/100,i=t[2]/100;if(e===0)return[i*255,i*255,i*255];let n=[0,0,0],o=r%1*6,s=o%1,a=1-s,l=0;switch(Math.floor(o)){case 0:n[0]=1,n[1]=s,n[2]=0;break;case 1:n[0]=a,n[1]=1,n[2]=0;break;case 2:n[0]=0,n[1]=1,n[2]=s;break;case 3:n[0]=0,n[1]=a,n[2]=1;break;case 4:n[0]=s,n[1]=0,n[2]=1;break;default:n[0]=1,n[1]=0,n[2]=a}return l=(1-e)*i,[(e*n[0]+l)*255,(e*n[1]+l)*255,(e*n[2]+l)*255]};Q.hcg.hsv=function(t){let r=t[1]/100,e=t[2]/100,i=r+e*(1-r),n=0;return i>0&&(n=r/i),[t[0],n*100,i*100]};Q.hcg.hsl=function(t){let r=t[1]/100,i=t[2]/100*(1-r)+.5*r,n=0;return i>0&&i<.5?n=r/(2*i):i>=.5&&i<1&&(n=r/(2*(1-i))),[t[0],n*100,i*100]};Q.hcg.hwb=function(t){let r=t[1]/100,e=t[2]/100,i=r+e*(1-r);return[t[0],(i-r)*100,(1-i)*100]};Q.hwb.hcg=function(t){let r=t[1]/100,i=1-t[2]/100,n=i-r,o=0;return n<1&&(o=(i-n)/(1-n)),[t[0],n*100,o*100]};Q.apple.rgb=function(t){return[t[0]/65535*255,t[1]/65535*255,t[2]/65535*255]};Q.rgb.apple=function(t){return[t[0]/255*65535,t[1]/255*65535,t[2]/255*65535]};Q.gray.rgb=function(t){return[t[0]/100*255,t[0]/100*255,t[0]/100*255]};Q.gray.hsl=function(t){return[0,0,t[0]]};Q.gray.hsv=Q.gray.hsl;Q.gray.hwb=function(t){return[0,100,t[0]]};Q.gray.cmyk=function(t){return[0,0,0,t[0]]};Q.gray.lab=function(t){return[t[0],0,0]};Q.gray.hex=function(t){let r=Math.round(t[0]/100*255)&255,i=((r<<16)+(r<<8)+r).toString(16).toUpperCase();return"000000".substring(i.length)+i};Q.rgb.gray=function(t){return[(t[0]+t[1]+t[2])/3/255*100]}});var op=W((eI,np)=>{var lo=Bh();function yv(){let t={},r=Object.keys(lo);for(let e=r.length,i=0;i<e;i++)t[r[i]]={distance:-1,parent:null};return t}function vv(t){let r=yv(),e=[t];for(r[t].distance=0;e.length;){let i=e.pop(),n=Object.keys(lo[i]);for(let o=n.length,s=0;s<o;s++){let a=n[s],l=r[a];l.distance===-1&&(l.distance=r[i].distance+1,l.parent=i,e.unshift(a))}}return r}function _v(t,r){return function(e){return r(t(e))}}function Mv(t,r){let e=[r[t].parent,t],i=lo[r[t].parent][t],n=r[t].parent;for(;r[n].parent;)e.unshift(r[n].parent),i=_v(lo[r[n].parent][n],i),n=r[n].parent;return i.conversion=e,i}np.exports=function(t){let r=vv(t),e={},i=Object.keys(r);for(let n=i.length,o=0;o<n;o++){let s=i[o];r[s].parent!==null&&(e[s]=Mv(s,r))}return e}});var ap=W((rI,sp)=>{var Lh=Bh(),Ev=op(),Qr={},kv=Object.keys(Lh);function Av(t){let r=function(...e){let i=e[0];return i==null?i:(i.length>1&&(e=i),t(e))};return"conversion"in t&&(r.conversion=t.conversion),r}function Sv(t){let r=function(...e){let i=e[0];if(i==null)return i;i.length>1&&(e=i);let n=t(e);if(typeof n=="object")for(let o=n.length,s=0;s<o;s++)n[s]=Math.round(n[s]);return n};return"conversion"in t&&(r.conversion=t.conversion),r}kv.forEach(t=>{Qr[t]={},Object.defineProperty(Qr[t],"channels",{value:Lh[t].channels}),Object.defineProperty(Qr[t],"labels",{value:Lh[t].labels});let r=Ev(t);Object.keys(r).forEach(i=>{let n=r[i];Qr[t][i]=Sv(n),Qr[t][i].raw=Av(n)})});sp.exports=Qr});var fp=W((iI,hp)=>{var ti=ep(),xe=ap(),lp=["keyword","gray","hex"],Oh={};for(let t of Object.keys(xe))Oh[[...xe[t].labels].sort().join("")]=t;var ho={};function Kt(t,r){if(!(this instanceof Kt))return new Kt(t,r);if(r&&r in lp&&(r=null),r&&!(r in xe))throw new Error("Unknown model: "+r);let e,i;if(t==null)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(t instanceof Kt)this.model=t.model,this.color=[...t.color],this.valpha=t.valpha;else if(typeof t=="string"){let n=ti.get(t);if(n===null)throw new Error("Unable to parse color from string: "+t);this.model=n.model,i=xe[this.model].channels,this.color=n.value.slice(0,i),this.valpha=typeof n.value[i]=="number"?n.value[i]:1}else if(t.length>0){this.model=r||"rgb",i=xe[this.model].channels;let n=Array.prototype.slice.call(t,0,i);this.color=Uh(n,i),this.valpha=typeof t[i]=="number"?t[i]:1}else if(typeof t=="number")this.model="rgb",this.color=[t>>16&255,t>>8&255,t&255],this.valpha=1;else{this.valpha=1;let n=Object.keys(t);"alpha"in t&&(n.splice(n.indexOf("alpha"),1),this.valpha=typeof t.alpha=="number"?t.alpha:0);let o=n.sort().join("");if(!(o in Oh))throw new Error("Unable to parse color from object: "+JSON.stringify(t));this.model=Oh[o];let{labels:s}=xe[this.model],a=[];for(e=0;e<s.length;e++)a.push(t[s[e]]);this.color=Uh(a)}if(ho[this.model])for(i=xe[this.model].channels,e=0;e<i;e++){let n=ho[this.model][e];n&&(this.color[e]=n(this.color[e]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}Kt.prototype={toString(){return this.string()},toJSON(){return this[this.model]()},string(t){let r=this.model in ti.to?this:this.rgb();r=r.round(typeof t=="number"?t:1);let e=r.valpha===1?r.color:[...r.color,this.valpha];return ti.to[r.model](e)},percentString(t){let r=this.rgb().round(typeof t=="number"?t:1),e=r.valpha===1?r.color:[...r.color,this.valpha];return ti.to.rgb.percent(e)},array(){return this.valpha===1?[...this.color]:[...this.color,this.valpha]},object(){let t={},{channels:r}=xe[this.model],{labels:e}=xe[this.model];for(let i=0;i<r;i++)t[e[i]]=this.color[i];return this.valpha!==1&&(t.alpha=this.valpha),t},unitArray(){let t=this.rgb().color;return t[0]/=255,t[1]/=255,t[2]/=255,this.valpha!==1&&t.push(this.valpha),t},unitObject(){let t=this.rgb().object();return t.r/=255,t.g/=255,t.b/=255,this.valpha!==1&&(t.alpha=this.valpha),t},round(t){return t=Math.max(t||0,0),new Kt([...this.color.map(Dv(t)),this.valpha],this.model)},alpha(t){return t!==void 0?new Kt([...this.color,Math.max(0,Math.min(1,t))],this.model):this.valpha},red:Ut("rgb",0,Vt(255)),green:Ut("rgb",1,Vt(255)),blue:Ut("rgb",2,Vt(255)),hue:Ut(["hsl","hsv","hsl","hwb","hcg"],0,t=>(t%360+360)%360),saturationl:Ut("hsl",1,Vt(100)),lightness:Ut("hsl",2,Vt(100)),saturationv:Ut("hsv",1,Vt(100)),value:Ut("hsv",2,Vt(100)),chroma:Ut("hcg",1,Vt(100)),gray:Ut("hcg",2,Vt(100)),white:Ut("hwb",1,Vt(100)),wblack:Ut("hwb",2,Vt(100)),cyan:Ut("cmyk",0,Vt(100)),magenta:Ut("cmyk",1,Vt(100)),yellow:Ut("cmyk",2,Vt(100)),black:Ut("cmyk",3,Vt(100)),x:Ut("xyz",0,Vt(95.047)),y:Ut("xyz",1,Vt(100)),z:Ut("xyz",2,Vt(108.833)),l:Ut("lab",0,Vt(100)),a:Ut("lab",1),b:Ut("lab",2),keyword(t){return t!==void 0?new Kt(t):xe[this.model].keyword(this.color)},hex(t){return t!==void 0?new Kt(t):ti.to.hex(this.rgb().round().color)},hexa(t){if(t!==void 0)return new Kt(t);let r=this.rgb().round().color,e=Math.round(this.valpha*255).toString(16).toUpperCase();return e.length===1&&(e="0"+e),ti.to.hex(r)+e},rgbNumber(){let t=this.rgb().color;return(t[0]&255)<<16|(t[1]&255)<<8|t[2]&255},luminosity(){let t=this.rgb().color,r=[];for(let[e,i]of t.entries()){let n=i/255;r[e]=n<=.04045?n/12.92:((n+.055)/1.055)**2.4}return .2126*r[0]+.7152*r[1]+.0722*r[2]},contrast(t){let r=this.luminosity(),e=t.luminosity();return r>e?(r+.05)/(e+.05):(e+.05)/(r+.05)},level(t){let r=this.contrast(t);return r>=7?"AAA":r>=4.5?"AA":""},isDark(){let t=this.rgb().color;return(t[0]*2126+t[1]*7152+t[2]*722)/1e4<128},isLight(){return!this.isDark()},negate(){let t=this.rgb();for(let r=0;r<3;r++)t.color[r]=255-t.color[r];return t},lighten(t){let r=this.hsl();return r.color[2]+=r.color[2]*t,r},darken(t){let r=this.hsl();return r.color[2]-=r.color[2]*t,r},saturate(t){let r=this.hsl();return r.color[1]+=r.color[1]*t,r},desaturate(t){let r=this.hsl();return r.color[1]-=r.color[1]*t,r},whiten(t){let r=this.hwb();return r.color[1]+=r.color[1]*t,r},blacken(t){let r=this.hwb();return r.color[2]+=r.color[2]*t,r},grayscale(){let t=this.rgb().color,r=t[0]*.3+t[1]*.59+t[2]*.11;return Kt.rgb(r,r,r)},fade(t){return this.alpha(this.valpha-this.valpha*t)},opaquer(t){return this.alpha(this.valpha+this.valpha*t)},rotate(t){let r=this.hsl(),e=r.color[0];return e=(e+t)%360,e=e<0?360+e:e,r.color[0]=e,r},mix(t,r){if(!t||!t.rgb)throw new Error(\'Argument to "mix" was not a Color instance, but rather an instance of \'+typeof t);let e=t.rgb(),i=this.rgb(),n=r===void 0?.5:r,o=2*n-1,s=e.alpha()-i.alpha(),a=((o*s===-1?o:(o+s)/(1+o*s))+1)/2,l=1-a;return Kt.rgb(a*e.red()+l*i.red(),a*e.green()+l*i.green(),a*e.blue()+l*i.blue(),e.alpha()*n+i.alpha()*(1-n))}};for(let t of Object.keys(xe)){if(lp.includes(t))continue;let{channels:r}=xe[t];Kt.prototype[t]=function(...e){return this.model===t?new Kt(this):e.length>0?new Kt(e,t):new Kt([...Tv(xe[this.model][t].raw(this.color)),this.valpha],t)},Kt[t]=function(...e){let i=e[0];return typeof i=="number"&&(i=Uh(e,r)),new Kt(i,t)}}function Iv(t,r){return Number(t.toFixed(r))}function Dv(t){return function(r){return Iv(r,t)}}function Ut(t,r,e){t=Array.isArray(t)?t:[t];for(let i of t)(ho[i]||(ho[i]=[]))[r]=e;return t=t[0],function(i){let n;return i!==void 0?(e&&(i=e(i)),n=this[t](),n.color[r]=i,n):(n=this[t]().color[r],e&&(n=e(n)),n)}}function Vt(t){return function(r){return Math.max(0,Math.min(t,r))}}function Tv(t){return Array.isArray(t)?t:[t]}function Uh(t,r){for(let e=0;e<r;e++)typeof t[e]!="number"&&(t[e]=0);return t}hp.exports=Kt});var Hh={getBit(t){return this.data[Hi(t)]&1<<Zi(t)?1:0},setBit(t){this.data[Hi(t)]|=1<<Zi(t)},clearBit(t){this.data[Hi(t)]&=~(1<<Zi(t))},toggleBit(t){this.data[Hi(t)]^=1<<Zi(t)},getBitXY(t,r){return t>=this.width||r>=this.height?0:this.getBit(r*this.width+t)},setBitXY(t,r){this.setBit(r*this.width+t)},clearBitXY(t,r){this.clearBit(r*this.width+t)},toggleBitXY(t,r){this.toggleBit(r*this.width+t)}};function Hi(t){return t>>3}function Zi(t){return 7-(t&7)}function mo(t){for(let r in Hh)t.prototype[r]=Hh[r]}function go(t,r={}){let{bitDepth:e,alpha:i,colorModel:n,components:o,channels:s}=r;if(typeof t!="string"||t.length===0)throw new TypeError("processName must be a string");if(e&&(Array.isArray(e)||(e=[e]),!e.includes(this.bitDepth)))throw new TypeError(`The process: ${t} can only be applied if bit depth is in: ${e}`);if(i&&(Array.isArray(i)||(i=[i]),!i.includes(this.alpha)))throw new TypeError(`The process: ${t} can only be applied if alpha is in: ${i}`);if(n&&(Array.isArray(n)||(n=[n]),!n.includes(this.colorModel)))throw new TypeError(`The process: ${t} can only be applied if color model is in: ${n}`);if(o&&(Array.isArray(o)||(o=[o]),!o.includes(this.components))){let a=`The process: ${t} can only be applied if the number of components is in: ${o}`;throw o.length===1&&o[0]===1?new TypeError(`${a}.\\rYou should transform your image using "image.grey()" before applying the algorithm.`):new TypeError(a)}if(s&&(Array.isArray(s)||(s=[s]),!s.includes(this.channels)))throw new TypeError(`The process: ${t} can only be applied if the number of channels is in: ${s}`)}function wp(t,r){t=t||[],r=r||{},typeof r=="string"&&(r={type:r});try{return new Blob(t,r)}catch(o){if(o.name!=="TypeError")throw o;for(var e=typeof BlobBuilder!="undefined"?BlobBuilder:typeof MSBlobBuilder!="undefined"?MSBlobBuilder:typeof MozBlobBuilder!="undefined"?MozBlobBuilder:WebKitBlobBuilder,i=new e,n=0;n<t.length;n+=1)i.append(t[n]);return i.getBlob(r.type)}}function bp(t){var r=t.match(/data:([^;]+)/)[1],e=t.replace(/^[^,]+,/,""),i=yp(atob(e));return wp([i],{type:r})}function Zh(t,r,e){return typeof t.toBlob=="function"?new Promise(function(i){t.toBlob(i,r,e)}):Promise.resolve(bp(t.toDataURL(r,e)))}function yp(t){for(var r=t.length,e=new ArrayBuffer(r),i=new Uint8Array(e),n=-1;++n<r;)i[n]=t.charCodeAt(n);return e}var xn=vt(hf());var F0=vt(Tr());function Lr(t){let r=t.length;for(;--r>=0;)t[r]=0}var Sp=0,Wf=1,Ip=2,Dp=3,Tp=258,Vo=29,xi=256,hi=xi+1+Vo,Cr=30,$o=19,Kf=2*hi+1,hr=15,_o=16,Rp=7,qo=256,Hf=16,Zf=17,Jf=18,Lo=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),on=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Pp=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),Qf=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Cp=512,Ne=new Array((hi+2)*2);Lr(Ne);var si=new Array(Cr*2);Lr(si);var fi=new Array(Cp);Lr(fi);var ci=new Array(Tp-Dp+1);Lr(ci);var Wo=new Array(Vo);Lr(Wo);var sn=new Array(Cr);Lr(sn);function Mo(t,r,e,i,n){this.static_tree=t,this.extra_bits=r,this.extra_base=e,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}var t0,e0,r0;function Eo(t,r){this.dyn_tree=t,this.max_code=0,this.stat_desc=r}var i0=t=>t<256?fi[t]:fi[256+(t>>>7)],ui=(t,r)=>{t.pending_buf[t.pending++]=r&255,t.pending_buf[t.pending++]=r>>>8&255},se=(t,r,e)=>{t.bi_valid>_o-e?(t.bi_buf|=r<<t.bi_valid&65535,ui(t,t.bi_buf),t.bi_buf=r>>_o-t.bi_valid,t.bi_valid+=e-_o):(t.bi_buf|=r<<t.bi_valid&65535,t.bi_valid+=e)},De=(t,r,e)=>{se(t,e[r*2],e[r*2+1])},n0=(t,r)=>{let e=0;do e|=t&1,t>>>=1,e<<=1;while(--r>0);return e>>>1},Fp=t=>{t.bi_valid===16?(ui(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=t.bi_buf&255,t.bi_buf>>=8,t.bi_valid-=8)},Bp=(t,r)=>{let e=r.dyn_tree,i=r.max_code,n=r.stat_desc.static_tree,o=r.stat_desc.has_stree,s=r.stat_desc.extra_bits,a=r.stat_desc.extra_base,l=r.stat_desc.max_length,h,f,c,u,d,p,g=0;for(u=0;u<=hr;u++)t.bl_count[u]=0;for(e[t.heap[t.heap_max]*2+1]=0,h=t.heap_max+1;h<Kf;h++)f=t.heap[h],u=e[e[f*2+1]*2+1]+1,u>l&&(u=l,g++),e[f*2+1]=u,!(f>i)&&(t.bl_count[u]++,d=0,f>=a&&(d=s[f-a]),p=e[f*2],t.opt_len+=p*(u+d),o&&(t.static_len+=p*(n[f*2+1]+d)));if(g!==0){do{for(u=l-1;t.bl_count[u]===0;)u--;t.bl_count[u]--,t.bl_count[u+1]+=2,t.bl_count[l]--,g-=2}while(g>0);for(u=l;u!==0;u--)for(f=t.bl_count[u];f!==0;)c=t.heap[--h],!(c>i)&&(e[c*2+1]!==u&&(t.opt_len+=(u-e[c*2+1])*e[c*2],e[c*2+1]=u),f--)}},o0=(t,r,e)=>{let i=new Array(hr+1),n=0,o,s;for(o=1;o<=hr;o++)n=n+e[o-1]<<1,i[o]=n;for(s=0;s<=r;s++){let a=t[s*2+1];a!==0&&(t[s*2]=n0(i[a]++,a))}},Lp=()=>{let t,r,e,i,n,o=new Array(hr+1);for(e=0,i=0;i<Vo-1;i++)for(Wo[i]=e,t=0;t<1<<Lo[i];t++)ci[e++]=i;for(ci[e-1]=i,n=0,i=0;i<16;i++)for(sn[i]=n,t=0;t<1<<on[i];t++)fi[n++]=i;for(n>>=7;i<Cr;i++)for(sn[i]=n<<7,t=0;t<1<<on[i]-7;t++)fi[256+n++]=i;for(r=0;r<=hr;r++)o[r]=0;for(t=0;t<=143;)Ne[t*2+1]=8,t++,o[8]++;for(;t<=255;)Ne[t*2+1]=9,t++,o[9]++;for(;t<=279;)Ne[t*2+1]=7,t++,o[7]++;for(;t<=287;)Ne[t*2+1]=8,t++,o[8]++;for(o0(Ne,hi+1,o),t=0;t<Cr;t++)si[t*2+1]=5,si[t*2]=n0(t,5);t0=new Mo(Ne,Lo,xi+1,hi,hr),e0=new Mo(si,on,0,Cr,hr),r0=new Mo(new Array(0),Pp,0,$o,Rp)},s0=t=>{let r;for(r=0;r<hi;r++)t.dyn_ltree[r*2]=0;for(r=0;r<Cr;r++)t.dyn_dtree[r*2]=0;for(r=0;r<$o;r++)t.bl_tree[r*2]=0;t.dyn_ltree[qo*2]=1,t.opt_len=t.static_len=0,t.sym_next=t.matches=0},a0=t=>{t.bi_valid>8?ui(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},ff=(t,r,e,i)=>{let n=r*2,o=e*2;return t[n]<t[o]||t[n]===t[o]&&i[r]<=i[e]},ko=(t,r,e)=>{let i=t.heap[e],n=e<<1;for(;n<=t.heap_len&&(n<t.heap_len&&ff(r,t.heap[n+1],t.heap[n],t.depth)&&n++,!ff(r,i,t.heap[n],t.depth));)t.heap[e]=t.heap[n],e=n,n<<=1;t.heap[e]=i},cf=(t,r,e)=>{let i,n,o=0,s,a;if(t.sym_next!==0)do i=t.pending_buf[t.sym_buf+o++]&255,i+=(t.pending_buf[t.sym_buf+o++]&255)<<8,n=t.pending_buf[t.sym_buf+o++],i===0?De(t,n,r):(s=ci[n],De(t,s+xi+1,r),a=Lo[s],a!==0&&(n-=Wo[s],se(t,n,a)),i--,s=i0(i),De(t,s,e),a=on[s],a!==0&&(i-=sn[s],se(t,i,a)));while(o<t.sym_next);De(t,qo,r)},Oo=(t,r)=>{let e=r.dyn_tree,i=r.stat_desc.static_tree,n=r.stat_desc.has_stree,o=r.stat_desc.elems,s,a,l=-1,h;for(t.heap_len=0,t.heap_max=Kf,s=0;s<o;s++)e[s*2]!==0?(t.heap[++t.heap_len]=l=s,t.depth[s]=0):e[s*2+1]=0;for(;t.heap_len<2;)h=t.heap[++t.heap_len]=l<2?++l:0,e[h*2]=1,t.depth[h]=0,t.opt_len--,n&&(t.static_len-=i[h*2+1]);for(r.max_code=l,s=t.heap_len>>1;s>=1;s--)ko(t,e,s);h=o;do s=t.heap[1],t.heap[1]=t.heap[t.heap_len--],ko(t,e,1),a=t.heap[1],t.heap[--t.heap_max]=s,t.heap[--t.heap_max]=a,e[h*2]=e[s*2]+e[a*2],t.depth[h]=(t.depth[s]>=t.depth[a]?t.depth[s]:t.depth[a])+1,e[s*2+1]=e[a*2+1]=h,t.heap[1]=h++,ko(t,e,1);while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],Bp(t,r),o0(e,l,t.bl_count)},uf=(t,r,e)=>{let i,n=-1,o,s=r[0*2+1],a=0,l=7,h=4;for(s===0&&(l=138,h=3),r[(e+1)*2+1]=65535,i=0;i<=e;i++)o=s,s=r[(i+1)*2+1],!(++a<l&&o===s)&&(a<h?t.bl_tree[o*2]+=a:o!==0?(o!==n&&t.bl_tree[o*2]++,t.bl_tree[Hf*2]++):a<=10?t.bl_tree[Zf*2]++:t.bl_tree[Jf*2]++,a=0,n=o,s===0?(l=138,h=3):o===s?(l=6,h=3):(l=7,h=4))},df=(t,r,e)=>{let i,n=-1,o,s=r[0*2+1],a=0,l=7,h=4;for(s===0&&(l=138,h=3),i=0;i<=e;i++)if(o=s,s=r[(i+1)*2+1],!(++a<l&&o===s)){if(a<h)do De(t,o,t.bl_tree);while(--a!==0);else o!==0?(o!==n&&(De(t,o,t.bl_tree),a--),De(t,Hf,t.bl_tree),se(t,a-3,2)):a<=10?(De(t,Zf,t.bl_tree),se(t,a-3,3)):(De(t,Jf,t.bl_tree),se(t,a-11,7));a=0,n=o,s===0?(l=138,h=3):o===s?(l=6,h=3):(l=7,h=4)}},Op=t=>{let r;for(uf(t,t.dyn_ltree,t.l_desc.max_code),uf(t,t.dyn_dtree,t.d_desc.max_code),Oo(t,t.bl_desc),r=$o-1;r>=3&&t.bl_tree[Qf[r]*2+1]===0;r--);return t.opt_len+=3*(r+1)+5+5+4,r},Up=(t,r,e,i)=>{let n;for(se(t,r-257,5),se(t,e-1,5),se(t,i-4,4),n=0;n<i;n++)se(t,t.bl_tree[Qf[n]*2+1],3);df(t,t.dyn_ltree,r-1),df(t,t.dyn_dtree,e-1)},Np=t=>{let r=4093624447,e;for(e=0;e<=31;e++,r>>>=1)if(r&1&&t.dyn_ltree[e*2]!==0)return 0;if(t.dyn_ltree[9*2]!==0||t.dyn_ltree[10*2]!==0||t.dyn_ltree[13*2]!==0)return 1;for(e=32;e<xi;e++)if(t.dyn_ltree[e*2]!==0)return 1;return 0},pf=!1,Yp=t=>{pf||(Lp(),pf=!0),t.l_desc=new Eo(t.dyn_ltree,t0),t.d_desc=new Eo(t.dyn_dtree,e0),t.bl_desc=new Eo(t.bl_tree,r0),t.bi_buf=0,t.bi_valid=0,s0(t)},l0=(t,r,e,i)=>{se(t,(Sp<<1)+(i?1:0),3),a0(t),ui(t,e),ui(t,~e),e&&t.pending_buf.set(t.window.subarray(r,r+e),t.pending),t.pending+=e},zp=t=>{se(t,Wf<<1,3),De(t,qo,Ne),Fp(t)},Xp=(t,r,e,i)=>{let n,o,s=0;t.level>0?(t.strm.data_type===2&&(t.strm.data_type=Np(t)),Oo(t,t.l_desc),Oo(t,t.d_desc),s=Op(t),n=t.opt_len+3+7>>>3,o=t.static_len+3+7>>>3,o<=n&&(n=o)):n=o=e+5,e+4<=n&&r!==-1?l0(t,r,e,i):t.strategy===4||o===n?(se(t,(Wf<<1)+(i?1:0),3),cf(t,Ne,si)):(se(t,(Ip<<1)+(i?1:0),3),Up(t,t.l_desc.max_code+1,t.d_desc.max_code+1,s+1),cf(t,t.dyn_ltree,t.dyn_dtree)),s0(t),i&&a0(t)},jp=(t,r,e)=>(t.pending_buf[t.sym_buf+t.sym_next++]=r,t.pending_buf[t.sym_buf+t.sym_next++]=r>>8,t.pending_buf[t.sym_buf+t.sym_next++]=e,r===0?t.dyn_ltree[e*2]++:(t.matches++,r--,t.dyn_ltree[(ci[e]+xi+1)*2]++,t.dyn_dtree[i0(r)*2]++),t.sym_next===t.sym_end),Gp=Yp,Vp=l0,$p=Xp,qp=jp,Wp=zp,Kp={_tr_init:Gp,_tr_stored_block:Vp,_tr_flush_block:$p,_tr_tally:qp,_tr_align:Wp},Hp=(t,r,e,i)=>{let n=t&65535|0,o=t>>>16&65535|0,s=0;for(;e!==0;){s=e>2e3?2e3:e,e-=s;do n=n+r[i++]|0,o=o+n|0;while(--s);n%=65521,o%=65521}return n|o<<16|0},di=Hp,Zp=()=>{let t,r=[];for(var e=0;e<256;e++){t=e;for(var i=0;i<8;i++)t=t&1?3988292384^t>>>1:t>>>1;r[e]=t}return r},Jp=new Uint32Array(Zp()),Qp=(t,r,e,i)=>{let n=Jp,o=i+e;t^=-1;for(let s=i;s<o;s++)t=t>>>8^n[(t^r[s])&255];return t^-1},qt=Qp,ur={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Or={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:tm,_tr_stored_block:Uo,_tr_flush_block:em,_tr_tally:qe,_tr_align:rm}=Kp,{Z_NO_FLUSH:We,Z_PARTIAL_FLUSH:im,Z_FULL_FLUSH:nm,Z_FINISH:be,Z_BLOCK:mf,Z_OK:Zt,Z_STREAM_END:gf,Z_STREAM_ERROR:Te,Z_DATA_ERROR:om,Z_BUF_ERROR:Ao,Z_DEFAULT_COMPRESSION:sm,Z_FILTERED:am,Z_HUFFMAN_ONLY:Qi,Z_RLE:lm,Z_FIXED:hm,Z_DEFAULT_STRATEGY:fm,Z_UNKNOWN:cm,Z_DEFLATED:hn}=Or,um=9,dm=15,pm=8,mm=29,gm=256,No=gm+1+mm,xm=30,wm=19,bm=2*No+1,ym=15,kt=3,$e=258,Re=$e+kt+1,vm=32,Fr=42,Ko=57,Yo=69,zo=73,Xo=91,jo=103,fr=113,ni=666,re=1,Ur=2,dr=3,Nr=4,_m=3,cr=(t,r)=>(t.msg=ur[r],r),xf=t=>t*2-(t>4?9:0),Ve=t=>{let r=t.length;for(;--r>=0;)t[r]=0},Mm=t=>{let r,e,i,n=t.w_size;r=t.hash_size,i=r;do e=t.head[--i],t.head[i]=e>=n?e-n:0;while(--r);r=n,i=r;do e=t.prev[--i],t.prev[i]=e>=n?e-n:0;while(--r)},Em=(t,r,e)=>(r<<t.hash_shift^e)&t.hash_mask,Ke=Em,pe=t=>{let r=t.state,e=r.pending;e>t.avail_out&&(e=t.avail_out),e!==0&&(t.output.set(r.pending_buf.subarray(r.pending_out,r.pending_out+e),t.next_out),t.next_out+=e,r.pending_out+=e,t.total_out+=e,t.avail_out-=e,r.pending-=e,r.pending===0&&(r.pending_out=0))},me=(t,r)=>{em(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,r),t.block_start=t.strstart,pe(t.strm)},It=(t,r)=>{t.pending_buf[t.pending++]=r},ii=(t,r)=>{t.pending_buf[t.pending++]=r>>>8&255,t.pending_buf[t.pending++]=r&255},Go=(t,r,e,i)=>{let n=t.avail_in;return n>i&&(n=i),n===0?0:(t.avail_in-=n,r.set(t.input.subarray(t.next_in,t.next_in+n),e),t.state.wrap===1?t.adler=di(t.adler,r,n,e):t.state.wrap===2&&(t.adler=qt(t.adler,r,n,e)),t.next_in+=n,t.total_in+=n,n)},h0=(t,r)=>{let e=t.max_chain_length,i=t.strstart,n,o,s=t.prev_length,a=t.nice_match,l=t.strstart>t.w_size-Re?t.strstart-(t.w_size-Re):0,h=t.window,f=t.w_mask,c=t.prev,u=t.strstart+$e,d=h[i+s-1],p=h[i+s];t.prev_length>=t.good_match&&(e>>=2),a>t.lookahead&&(a=t.lookahead);do if(n=r,!(h[n+s]!==p||h[n+s-1]!==d||h[n]!==h[i]||h[++n]!==h[i+1])){i+=2,n++;do;while(h[++i]===h[++n]&&h[++i]===h[++n]&&h[++i]===h[++n]&&h[++i]===h[++n]&&h[++i]===h[++n]&&h[++i]===h[++n]&&h[++i]===h[++n]&&h[++i]===h[++n]&&i<u);if(o=$e-(u-i),i=u-$e,o>s){if(t.match_start=r,s=o,o>=a)break;d=h[i+s-1],p=h[i+s]}}while((r=c[r&f])>l&&--e!==0);return s<=t.lookahead?s:t.lookahead},Br=t=>{let r=t.w_size,e,i,n;do{if(i=t.window_size-t.lookahead-t.strstart,t.strstart>=r+(r-Re)&&(t.window.set(t.window.subarray(r,r+r-i),0),t.match_start-=r,t.strstart-=r,t.block_start-=r,t.insert>t.strstart&&(t.insert=t.strstart),Mm(t),i+=r),t.strm.avail_in===0)break;if(e=Go(t.strm,t.window,t.strstart+t.lookahead,i),t.lookahead+=e,t.lookahead+t.insert>=kt)for(n=t.strstart-t.insert,t.ins_h=t.window[n],t.ins_h=Ke(t,t.ins_h,t.window[n+1]);t.insert&&(t.ins_h=Ke(t,t.ins_h,t.window[n+kt-1]),t.prev[n&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=n,n++,t.insert--,!(t.lookahead+t.insert<kt)););}while(t.lookahead<Re&&t.strm.avail_in!==0)},f0=(t,r)=>{let e=t.pending_buf_size-5>t.w_size?t.w_size:t.pending_buf_size-5,i,n,o,s=0,a=t.strm.avail_in;do{if(i=65535,o=t.bi_valid+42>>3,t.strm.avail_out<o||(o=t.strm.avail_out-o,n=t.strstart-t.block_start,i>n+t.strm.avail_in&&(i=n+t.strm.avail_in),i>o&&(i=o),i<e&&(i===0&&r!==be||r===We||i!==n+t.strm.avail_in)))break;s=r===be&&i===n+t.strm.avail_in?1:0,Uo(t,0,0,s),t.pending_buf[t.pending-4]=i,t.pending_buf[t.pending-3]=i>>8,t.pending_buf[t.pending-2]=~i,t.pending_buf[t.pending-1]=~i>>8,pe(t.strm),n&&(n>i&&(n=i),t.strm.output.set(t.window.subarray(t.block_start,t.block_start+n),t.strm.next_out),t.strm.next_out+=n,t.strm.avail_out-=n,t.strm.total_out+=n,t.block_start+=n,i-=n),i&&(Go(t.strm,t.strm.output,t.strm.next_out,i),t.strm.next_out+=i,t.strm.avail_out-=i,t.strm.total_out+=i)}while(s===0);return a-=t.strm.avail_in,a&&(a>=t.w_size?(t.matches=2,t.window.set(t.strm.input.subarray(t.strm.next_in-t.w_size,t.strm.next_in),0),t.strstart=t.w_size,t.insert=t.strstart):(t.window_size-t.strstart<=a&&(t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,t.insert>t.strstart&&(t.insert=t.strstart)),t.window.set(t.strm.input.subarray(t.strm.next_in-a,t.strm.next_in),t.strstart),t.strstart+=a,t.insert+=a>t.w_size-t.insert?t.w_size-t.insert:a),t.block_start=t.strstart),t.high_water<t.strstart&&(t.high_water=t.strstart),s?Nr:r!==We&&r!==be&&t.strm.avail_in===0&&t.strstart===t.block_start?Ur:(o=t.window_size-t.strstart,t.strm.avail_in>o&&t.block_start>=t.w_size&&(t.block_start-=t.w_size,t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,o+=t.w_size,t.insert>t.strstart&&(t.insert=t.strstart)),o>t.strm.avail_in&&(o=t.strm.avail_in),o&&(Go(t.strm,t.window,t.strstart,o),t.strstart+=o,t.insert+=o>t.w_size-t.insert?t.w_size-t.insert:o),t.high_water<t.strstart&&(t.high_water=t.strstart),o=t.bi_valid+42>>3,o=t.pending_buf_size-o>65535?65535:t.pending_buf_size-o,e=o>t.w_size?t.w_size:o,n=t.strstart-t.block_start,(n>=e||(n||r===be)&&r!==We&&t.strm.avail_in===0&&n<=o)&&(i=n>o?o:n,s=r===be&&t.strm.avail_in===0&&i===n?1:0,Uo(t,t.block_start,i,s),t.block_start+=i,pe(t.strm)),s?dr:re)},So=(t,r)=>{let e,i;for(;;){if(t.lookahead<Re){if(Br(t),t.lookahead<Re&&r===We)return re;if(t.lookahead===0)break}if(e=0,t.lookahead>=kt&&(t.ins_h=Ke(t,t.ins_h,t.window[t.strstart+kt-1]),e=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),e!==0&&t.strstart-e<=t.w_size-Re&&(t.match_length=h0(t,e)),t.match_length>=kt)if(i=qe(t,t.strstart-t.match_start,t.match_length-kt),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=kt){t.match_length--;do t.strstart++,t.ins_h=Ke(t,t.ins_h,t.window[t.strstart+kt-1]),e=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart;while(--t.match_length!==0);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=Ke(t,t.ins_h,t.window[t.strstart+1]);else i=qe(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(me(t,!1),t.strm.avail_out===0))return re}return t.insert=t.strstart<kt-1?t.strstart:kt-1,r===be?(me(t,!0),t.strm.avail_out===0?dr:Nr):t.sym_next&&(me(t,!1),t.strm.avail_out===0)?re:Ur},Rr=(t,r)=>{let e,i,n;for(;;){if(t.lookahead<Re){if(Br(t),t.lookahead<Re&&r===We)return re;if(t.lookahead===0)break}if(e=0,t.lookahead>=kt&&(t.ins_h=Ke(t,t.ins_h,t.window[t.strstart+kt-1]),e=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=kt-1,e!==0&&t.prev_length<t.max_lazy_match&&t.strstart-e<=t.w_size-Re&&(t.match_length=h0(t,e),t.match_length<=5&&(t.strategy===am||t.match_length===kt&&t.strstart-t.match_start>4096)&&(t.match_length=kt-1)),t.prev_length>=kt&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-kt,i=qe(t,t.strstart-1-t.prev_match,t.prev_length-kt),t.lookahead-=t.prev_length-1,t.prev_length-=2;do++t.strstart<=n&&(t.ins_h=Ke(t,t.ins_h,t.window[t.strstart+kt-1]),e=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart);while(--t.prev_length!==0);if(t.match_available=0,t.match_length=kt-1,t.strstart++,i&&(me(t,!1),t.strm.avail_out===0))return re}else if(t.match_available){if(i=qe(t,0,t.window[t.strstart-1]),i&&me(t,!1),t.strstart++,t.lookahead--,t.strm.avail_out===0)return re}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=qe(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<kt-1?t.strstart:kt-1,r===be?(me(t,!0),t.strm.avail_out===0?dr:Nr):t.sym_next&&(me(t,!1),t.strm.avail_out===0)?re:Ur},km=(t,r)=>{let e,i,n,o,s=t.window;for(;;){if(t.lookahead<=$e){if(Br(t),t.lookahead<=$e&&r===We)return re;if(t.lookahead===0)break}if(t.match_length=0,t.lookahead>=kt&&t.strstart>0&&(n=t.strstart-1,i=s[n],i===s[++n]&&i===s[++n]&&i===s[++n])){o=t.strstart+$e;do;while(i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&n<o);t.match_length=$e-(o-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=kt?(e=qe(t,1,t.match_length-kt),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(e=qe(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),e&&(me(t,!1),t.strm.avail_out===0))return re}return t.insert=0,r===be?(me(t,!0),t.strm.avail_out===0?dr:Nr):t.sym_next&&(me(t,!1),t.strm.avail_out===0)?re:Ur},Am=(t,r)=>{let e;for(;;){if(t.lookahead===0&&(Br(t),t.lookahead===0)){if(r===We)return re;break}if(t.match_length=0,e=qe(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,e&&(me(t,!1),t.strm.avail_out===0))return re}return t.insert=0,r===be?(me(t,!0),t.strm.avail_out===0?dr:Nr):t.sym_next&&(me(t,!1),t.strm.avail_out===0)?re:Ur};function Ie(t,r,e,i,n){this.good_length=t,this.max_lazy=r,this.nice_length=e,this.max_chain=i,this.func=n}var oi=[new Ie(0,0,0,0,f0),new Ie(4,4,8,4,So),new Ie(4,5,16,8,So),new Ie(4,6,32,32,So),new Ie(4,4,16,16,Rr),new Ie(8,16,32,32,Rr),new Ie(8,16,128,128,Rr),new Ie(8,32,128,256,Rr),new Ie(32,128,258,1024,Rr),new Ie(32,258,258,4096,Rr)],Sm=t=>{t.window_size=2*t.w_size,Ve(t.head),t.max_lazy_match=oi[t.level].max_lazy,t.good_match=oi[t.level].good_length,t.nice_match=oi[t.level].nice_length,t.max_chain_length=oi[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=kt-1,t.match_available=0,t.ins_h=0};function Im(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=hn,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(bm*2),this.dyn_dtree=new Uint16Array((2*xm+1)*2),this.bl_tree=new Uint16Array((2*wm+1)*2),Ve(this.dyn_ltree),Ve(this.dyn_dtree),Ve(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(ym+1),this.heap=new Uint16Array(2*No+1),Ve(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*No+1),Ve(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}var wi=t=>{if(!t)return 1;let r=t.state;return!r||r.strm!==t||r.status!==Fr&&r.status!==Ko&&r.status!==Yo&&r.status!==zo&&r.status!==Xo&&r.status!==jo&&r.status!==fr&&r.status!==ni?1:0},c0=t=>{if(wi(t))return cr(t,Te);t.total_in=t.total_out=0,t.data_type=cm;let r=t.state;return r.pending=0,r.pending_out=0,r.wrap<0&&(r.wrap=-r.wrap),r.status=r.wrap===2?Ko:r.wrap?Fr:fr,t.adler=r.wrap===2?0:1,r.last_flush=-2,tm(r),Zt},u0=t=>{let r=c0(t);return r===Zt&&Sm(t.state),r},Dm=(t,r)=>wi(t)||t.state.wrap!==2?Te:(t.state.gzhead=r,Zt),d0=(t,r,e,i,n,o)=>{if(!t)return Te;let s=1;if(r===sm&&(r=6),i<0?(s=0,i=-i):i>15&&(s=2,i-=16),n<1||n>um||e!==hn||i<8||i>15||r<0||r>9||o<0||o>hm||i===8&&s!==1)return cr(t,Te);i===8&&(i=9);let a=new Im;return t.state=a,a.strm=t,a.status=Fr,a.wrap=s,a.gzhead=null,a.w_bits=i,a.w_size=1<<a.w_bits,a.w_mask=a.w_size-1,a.hash_bits=n+7,a.hash_size=1<<a.hash_bits,a.hash_mask=a.hash_size-1,a.hash_shift=~~((a.hash_bits+kt-1)/kt),a.window=new Uint8Array(a.w_size*2),a.head=new Uint16Array(a.hash_size),a.prev=new Uint16Array(a.w_size),a.lit_bufsize=1<<n+6,a.pending_buf_size=a.lit_bufsize*4,a.pending_buf=new Uint8Array(a.pending_buf_size),a.sym_buf=a.lit_bufsize,a.sym_end=(a.lit_bufsize-1)*3,a.level=r,a.strategy=o,a.method=e,u0(t)},Tm=(t,r)=>d0(t,r,hn,dm,pm,fm),Rm=(t,r)=>{if(wi(t)||r>mf||r<0)return t?cr(t,Te):Te;let e=t.state;if(!t.output||t.avail_in!==0&&!t.input||e.status===ni&&r!==be)return cr(t,t.avail_out===0?Ao:Te);let i=e.last_flush;if(e.last_flush=r,e.pending!==0){if(pe(t),t.avail_out===0)return e.last_flush=-1,Zt}else if(t.avail_in===0&&xf(r)<=xf(i)&&r!==be)return cr(t,Ao);if(e.status===ni&&t.avail_in!==0)return cr(t,Ao);if(e.status===Fr&&e.wrap===0&&(e.status=fr),e.status===Fr){let n=hn+(e.w_bits-8<<4)<<8,o=-1;if(e.strategy>=Qi||e.level<2?o=0:e.level<6?o=1:e.level===6?o=2:o=3,n|=o<<6,e.strstart!==0&&(n|=vm),n+=31-n%31,ii(e,n),e.strstart!==0&&(ii(e,t.adler>>>16),ii(e,t.adler&65535)),t.adler=1,e.status=fr,pe(t),e.pending!==0)return e.last_flush=-1,Zt}if(e.status===Ko){if(t.adler=0,It(e,31),It(e,139),It(e,8),e.gzhead)It(e,(e.gzhead.text?1:0)+(e.gzhead.hcrc?2:0)+(e.gzhead.extra?4:0)+(e.gzhead.name?8:0)+(e.gzhead.comment?16:0)),It(e,e.gzhead.time&255),It(e,e.gzhead.time>>8&255),It(e,e.gzhead.time>>16&255),It(e,e.gzhead.time>>24&255),It(e,e.level===9?2:e.strategy>=Qi||e.level<2?4:0),It(e,e.gzhead.os&255),e.gzhead.extra&&e.gzhead.extra.length&&(It(e,e.gzhead.extra.length&255),It(e,e.gzhead.extra.length>>8&255)),e.gzhead.hcrc&&(t.adler=qt(t.adler,e.pending_buf,e.pending,0)),e.gzindex=0,e.status=Yo;else if(It(e,0),It(e,0),It(e,0),It(e,0),It(e,0),It(e,e.level===9?2:e.strategy>=Qi||e.level<2?4:0),It(e,_m),e.status=fr,pe(t),e.pending!==0)return e.last_flush=-1,Zt}if(e.status===Yo){if(e.gzhead.extra){let n=e.pending,o=(e.gzhead.extra.length&65535)-e.gzindex;for(;e.pending+o>e.pending_buf_size;){let a=e.pending_buf_size-e.pending;if(e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex,e.gzindex+a),e.pending),e.pending=e.pending_buf_size,e.gzhead.hcrc&&e.pending>n&&(t.adler=qt(t.adler,e.pending_buf,e.pending-n,n)),e.gzindex+=a,pe(t),e.pending!==0)return e.last_flush=-1,Zt;n=0,o-=a}let s=new Uint8Array(e.gzhead.extra);e.pending_buf.set(s.subarray(e.gzindex,e.gzindex+o),e.pending),e.pending+=o,e.gzhead.hcrc&&e.pending>n&&(t.adler=qt(t.adler,e.pending_buf,e.pending-n,n)),e.gzindex=0}e.status=zo}if(e.status===zo){if(e.gzhead.name){let n=e.pending,o;do{if(e.pending===e.pending_buf_size){if(e.gzhead.hcrc&&e.pending>n&&(t.adler=qt(t.adler,e.pending_buf,e.pending-n,n)),pe(t),e.pending!==0)return e.last_flush=-1,Zt;n=0}e.gzindex<e.gzhead.name.length?o=e.gzhead.name.charCodeAt(e.gzindex++)&255:o=0,It(e,o)}while(o!==0);e.gzhead.hcrc&&e.pending>n&&(t.adler=qt(t.adler,e.pending_buf,e.pending-n,n)),e.gzindex=0}e.status=Xo}if(e.status===Xo){if(e.gzhead.comment){let n=e.pending,o;do{if(e.pending===e.pending_buf_size){if(e.gzhead.hcrc&&e.pending>n&&(t.adler=qt(t.adler,e.pending_buf,e.pending-n,n)),pe(t),e.pending!==0)return e.last_flush=-1,Zt;n=0}e.gzindex<e.gzhead.comment.length?o=e.gzhead.comment.charCodeAt(e.gzindex++)&255:o=0,It(e,o)}while(o!==0);e.gzhead.hcrc&&e.pending>n&&(t.adler=qt(t.adler,e.pending_buf,e.pending-n,n))}e.status=jo}if(e.status===jo){if(e.gzhead.hcrc){if(e.pending+2>e.pending_buf_size&&(pe(t),e.pending!==0))return e.last_flush=-1,Zt;It(e,t.adler&255),It(e,t.adler>>8&255),t.adler=0}if(e.status=fr,pe(t),e.pending!==0)return e.last_flush=-1,Zt}if(t.avail_in!==0||e.lookahead!==0||r!==We&&e.status!==ni){let n=e.level===0?f0(e,r):e.strategy===Qi?Am(e,r):e.strategy===lm?km(e,r):oi[e.level].func(e,r);if((n===dr||n===Nr)&&(e.status=ni),n===re||n===dr)return t.avail_out===0&&(e.last_flush=-1),Zt;if(n===Ur&&(r===im?rm(e):r!==mf&&(Uo(e,0,0,!1),r===nm&&(Ve(e.head),e.lookahead===0&&(e.strstart=0,e.block_start=0,e.insert=0))),pe(t),t.avail_out===0))return e.last_flush=-1,Zt}return r!==be?Zt:e.wrap<=0?gf:(e.wrap===2?(It(e,t.adler&255),It(e,t.adler>>8&255),It(e,t.adler>>16&255),It(e,t.adler>>24&255),It(e,t.total_in&255),It(e,t.total_in>>8&255),It(e,t.total_in>>16&255),It(e,t.total_in>>24&255)):(ii(e,t.adler>>>16),ii(e,t.adler&65535)),pe(t),e.wrap>0&&(e.wrap=-e.wrap),e.pending!==0?Zt:gf)},Pm=t=>{if(wi(t))return Te;let r=t.state.status;return t.state=null,r===fr?cr(t,om):Zt},Cm=(t,r)=>{let e=r.length;if(wi(t))return Te;let i=t.state,n=i.wrap;if(n===2||n===1&&i.status!==Fr||i.lookahead)return Te;if(n===1&&(t.adler=di(t.adler,r,e,0)),i.wrap=0,e>=i.w_size){n===0&&(Ve(i.head),i.strstart=0,i.block_start=0,i.insert=0);let l=new Uint8Array(i.w_size);l.set(r.subarray(e-i.w_size,e),0),r=l,e=i.w_size}let o=t.avail_in,s=t.next_in,a=t.input;for(t.avail_in=e,t.next_in=0,t.input=r,Br(i);i.lookahead>=kt;){let l=i.strstart,h=i.lookahead-(kt-1);do i.ins_h=Ke(i,i.ins_h,i.window[l+kt-1]),i.prev[l&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=l,l++;while(--h);i.strstart=l,i.lookahead=kt-1,Br(i)}return i.strstart+=i.lookahead,i.block_start=i.strstart,i.insert=i.lookahead,i.lookahead=0,i.match_length=i.prev_length=kt-1,i.match_available=0,t.next_in=s,t.input=a,t.avail_in=o,i.wrap=n,Zt},Fm=Tm,Bm=d0,Lm=u0,Om=c0,Um=Dm,Nm=Rm,Ym=Pm,zm=Cm,Xm="pako deflate (from Nodeca project)",ai={deflateInit:Fm,deflateInit2:Bm,deflateReset:Lm,deflateResetKeep:Om,deflateSetHeader:Um,deflate:Nm,deflateEnd:Ym,deflateSetDictionary:zm,deflateInfo:Xm},jm=(t,r)=>Object.prototype.hasOwnProperty.call(t,r),Gm=function(t){let r=Array.prototype.slice.call(arguments,1);for(;r.length;){let e=r.shift();if(e){if(typeof e!="object")throw new TypeError(e+"must be non-object");for(let i in e)jm(e,i)&&(t[i]=e[i])}}return t},Vm=t=>{let r=0;for(let i=0,n=t.length;i<n;i++)r+=t[i].length;let e=new Uint8Array(r);for(let i=0,n=0,o=t.length;i<o;i++){let s=t[i];e.set(s,n),n+=s.length}return e},fn={assign:Gm,flattenChunks:Vm},p0=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){p0=!1}var pi=new Uint8Array(256);for(let t=0;t<256;t++)pi[t]=t>=252?6:t>=248?5:t>=240?4:t>=224?3:t>=192?2:1;pi[254]=pi[254]=1;var $m=t=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(t);let r,e,i,n,o,s=t.length,a=0;for(n=0;n<s;n++)e=t.charCodeAt(n),(e&64512)===55296&&n+1<s&&(i=t.charCodeAt(n+1),(i&64512)===56320&&(e=65536+(e-55296<<10)+(i-56320),n++)),a+=e<128?1:e<2048?2:e<65536?3:4;for(r=new Uint8Array(a),o=0,n=0;o<a;n++)e=t.charCodeAt(n),(e&64512)===55296&&n+1<s&&(i=t.charCodeAt(n+1),(i&64512)===56320&&(e=65536+(e-55296<<10)+(i-56320),n++)),e<128?r[o++]=e:e<2048?(r[o++]=192|e>>>6,r[o++]=128|e&63):e<65536?(r[o++]=224|e>>>12,r[o++]=128|e>>>6&63,r[o++]=128|e&63):(r[o++]=240|e>>>18,r[o++]=128|e>>>12&63,r[o++]=128|e>>>6&63,r[o++]=128|e&63);return r},qm=(t,r)=>{if(r<65534&&t.subarray&&p0)return String.fromCharCode.apply(null,t.length===r?t:t.subarray(0,r));let e="";for(let i=0;i<r;i++)e+=String.fromCharCode(t[i]);return e},Wm=(t,r)=>{let e=r||t.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(t.subarray(0,r));let i,n,o=new Array(e*2);for(n=0,i=0;i<e;){let s=t[i++];if(s<128){o[n++]=s;continue}let a=pi[s];if(a>4){o[n++]=65533,i+=a-1;continue}for(s&=a===2?31:a===3?15:7;a>1&&i<e;)s=s<<6|t[i++]&63,a--;if(a>1){o[n++]=65533;continue}s<65536?o[n++]=s:(s-=65536,o[n++]=55296|s>>10&1023,o[n++]=56320|s&1023)}return qm(o,n)},Km=(t,r)=>{r=r||t.length,r>t.length&&(r=t.length);let e=r-1;for(;e>=0&&(t[e]&192)===128;)e--;return e<0||e===0?r:e+pi[t[e]]>r?e:r},mi={string2buf:$m,buf2string:Wm,utf8border:Km};function Hm(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var m0=Hm,g0=Object.prototype.toString,{Z_NO_FLUSH:Zm,Z_SYNC_FLUSH:Jm,Z_FULL_FLUSH:Qm,Z_FINISH:tg,Z_OK:an,Z_STREAM_END:eg,Z_DEFAULT_COMPRESSION:rg,Z_DEFAULT_STRATEGY:ig,Z_DEFLATED:ng}=Or;function bi(t){this.options=fn.assign({level:rg,method:ng,chunkSize:16384,windowBits:15,memLevel:8,strategy:ig},t||{});let r=this.options;r.raw&&r.windowBits>0?r.windowBits=-r.windowBits:r.gzip&&r.windowBits>0&&r.windowBits<16&&(r.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new m0,this.strm.avail_out=0;let e=ai.deflateInit2(this.strm,r.level,r.method,r.windowBits,r.memLevel,r.strategy);if(e!==an)throw new Error(ur[e]);if(r.header&&ai.deflateSetHeader(this.strm,r.header),r.dictionary){let i;if(typeof r.dictionary=="string"?i=mi.string2buf(r.dictionary):g0.call(r.dictionary)==="[object ArrayBuffer]"?i=new Uint8Array(r.dictionary):i=r.dictionary,e=ai.deflateSetDictionary(this.strm,i),e!==an)throw new Error(ur[e]);this._dict_set=!0}}bi.prototype.push=function(t,r){let e=this.strm,i=this.options.chunkSize,n,o;if(this.ended)return!1;for(r===~~r?o=r:o=r===!0?tg:Zm,typeof t=="string"?e.input=mi.string2buf(t):g0.call(t)==="[object ArrayBuffer]"?e.input=new Uint8Array(t):e.input=t,e.next_in=0,e.avail_in=e.input.length;;){if(e.avail_out===0&&(e.output=new Uint8Array(i),e.next_out=0,e.avail_out=i),(o===Jm||o===Qm)&&e.avail_out<=6){this.onData(e.output.subarray(0,e.next_out)),e.avail_out=0;continue}if(n=ai.deflate(e,o),n===eg)return e.next_out>0&&this.onData(e.output.subarray(0,e.next_out)),n=ai.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===an;if(e.avail_out===0){this.onData(e.output);continue}if(o>0&&e.next_out>0){this.onData(e.output.subarray(0,e.next_out)),e.avail_out=0;continue}if(e.avail_in===0)break}return!0};bi.prototype.onData=function(t){this.chunks.push(t)};bi.prototype.onEnd=function(t){t===an&&(this.result=fn.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};function Ho(t,r){let e=new bi(r);if(e.push(t,!0),e.err)throw e.msg||ur[e.err];return e.result}function og(t,r){return r=r||{},r.raw=!0,Ho(t,r)}function sg(t,r){return r=r||{},r.gzip=!0,Ho(t,r)}var ag=bi,lg=Ho,hg=og,fg=sg,cg=Or,ug={Deflate:ag,deflate:lg,deflateRaw:hg,gzip:fg,constants:cg},tn=16209,dg=16191,pg=function(r,e){let i,n,o,s,a,l,h,f,c,u,d,p,g,x,m,w,y,M,_,T,E,A,D,b,k=r.state;i=r.next_in,D=r.input,n=i+(r.avail_in-5),o=r.next_out,b=r.output,s=o-(e-r.avail_out),a=o+(r.avail_out-257),l=k.dmax,h=k.wsize,f=k.whave,c=k.wnext,u=k.window,d=k.hold,p=k.bits,g=k.lencode,x=k.distcode,m=(1<<k.lenbits)-1,w=(1<<k.distbits)-1;t:do{p<15&&(d+=D[i++]<<p,p+=8,d+=D[i++]<<p,p+=8),y=g[d&m];e:for(;;){if(M=y>>>24,d>>>=M,p-=M,M=y>>>16&255,M===0)b[o++]=y&65535;else if(M&16){_=y&65535,M&=15,M&&(p<M&&(d+=D[i++]<<p,p+=8),_+=d&(1<<M)-1,d>>>=M,p-=M),p<15&&(d+=D[i++]<<p,p+=8,d+=D[i++]<<p,p+=8),y=x[d&w];r:for(;;){if(M=y>>>24,d>>>=M,p-=M,M=y>>>16&255,M&16){if(T=y&65535,M&=15,p<M&&(d+=D[i++]<<p,p+=8,p<M&&(d+=D[i++]<<p,p+=8)),T+=d&(1<<M)-1,T>l){r.msg="invalid distance too far back",k.mode=tn;break t}if(d>>>=M,p-=M,M=o-s,T>M){if(M=T-M,M>f&&k.sane){r.msg="invalid distance too far back",k.mode=tn;break t}if(E=0,A=u,c===0){if(E+=h-M,M<_){_-=M;do b[o++]=u[E++];while(--M);E=o-T,A=b}}else if(c<M){if(E+=h+c-M,M-=c,M<_){_-=M;do b[o++]=u[E++];while(--M);if(E=0,c<_){M=c,_-=M;do b[o++]=u[E++];while(--M);E=o-T,A=b}}}else if(E+=c-M,M<_){_-=M;do b[o++]=u[E++];while(--M);E=o-T,A=b}for(;_>2;)b[o++]=A[E++],b[o++]=A[E++],b[o++]=A[E++],_-=3;_&&(b[o++]=A[E++],_>1&&(b[o++]=A[E++]))}else{E=o-T;do b[o++]=b[E++],b[o++]=b[E++],b[o++]=b[E++],_-=3;while(_>2);_&&(b[o++]=b[E++],_>1&&(b[o++]=b[E++]))}}else if(M&64){r.msg="invalid distance code",k.mode=tn;break t}else{y=x[(y&65535)+(d&(1<<M)-1)];continue r}break}}else if(M&64)if(M&32){k.mode=dg;break t}else{r.msg="invalid literal/length code",k.mode=tn;break t}else{y=g[(y&65535)+(d&(1<<M)-1)];continue e}break}}while(i<n&&o<a);_=p>>3,i-=_,p-=_<<3,d&=(1<<p)-1,r.next_in=i,r.next_out=o,r.avail_in=i<n?5+(n-i):5-(i-n),r.avail_out=o<a?257+(a-o):257-(o-a),k.hold=d,k.bits=p},Pr=15,wf=852,bf=592,yf=0,Io=1,vf=2,mg=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),gg=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),xg=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),wg=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),bg=(t,r,e,i,n,o,s,a)=>{let l=a.bits,h=0,f=0,c=0,u=0,d=0,p=0,g=0,x=0,m=0,w=0,y,M,_,T,E,A=null,D,b=new Uint16Array(Pr+1),k=new Uint16Array(Pr+1),C=null,S,X,B;for(h=0;h<=Pr;h++)b[h]=0;for(f=0;f<i;f++)b[r[e+f]]++;for(d=l,u=Pr;u>=1&&b[u]===0;u--);if(d>u&&(d=u),u===0)return n[o++]=1<<24|64<<16|0,n[o++]=1<<24|64<<16|0,a.bits=1,0;for(c=1;c<u&&b[c]===0;c++);for(d<c&&(d=c),x=1,h=1;h<=Pr;h++)if(x<<=1,x-=b[h],x<0)return-1;if(x>0&&(t===yf||u!==1))return-1;for(k[1]=0,h=1;h<Pr;h++)k[h+1]=k[h]+b[h];for(f=0;f<i;f++)r[e+f]!==0&&(s[k[r[e+f]]++]=f);if(t===yf?(A=C=s,D=20):t===Io?(A=mg,C=gg,D=257):(A=xg,C=wg,D=0),w=0,f=0,h=c,E=o,p=d,g=0,_=-1,m=1<<d,T=m-1,t===Io&&m>wf||t===vf&&m>bf)return 1;for(;;){S=h-g,s[f]+1<D?(X=0,B=s[f]):s[f]>=D?(X=C[s[f]-D],B=A[s[f]-D]):(X=96,B=0),y=1<<h-g,M=1<<p,c=M;do M-=y,n[E+(w>>g)+M]=S<<24|X<<16|B|0;while(M!==0);for(y=1<<h-1;w&y;)y>>=1;if(y!==0?(w&=y-1,w+=y):w=0,f++,--b[h]===0){if(h===u)break;h=r[e+s[f]]}if(h>d&&(w&T)!==_){for(g===0&&(g=d),E+=c,p=h-g,x=1<<p;p+g<u&&(x-=b[p+g],!(x<=0));)p++,x<<=1;if(m+=1<<p,t===Io&&m>wf||t===vf&&m>bf)return 1;_=w&T,n[_]=d<<24|p<<16|E-o|0}}return w!==0&&(n[E+w]=h-g<<24|64<<16|0),a.bits=d,0},li=bg,yg=0,x0=1,w0=2,{Z_FINISH:_f,Z_BLOCK:vg,Z_TREES:en,Z_OK:pr,Z_STREAM_END:_g,Z_NEED_DICT:Mg,Z_STREAM_ERROR:ye,Z_DATA_ERROR:b0,Z_MEM_ERROR:y0,Z_BUF_ERROR:Eg,Z_DEFLATED:Mf}=Or,cn=16180,Ef=16181,kf=16182,Af=16183,Sf=16184,If=16185,Df=16186,Tf=16187,Rf=16188,Pf=16189,ln=16190,Ue=16191,Do=16192,Cf=16193,To=16194,Ff=16195,Bf=16196,Lf=16197,Of=16198,rn=16199,nn=16200,Uf=16201,Nf=16202,Yf=16203,zf=16204,Xf=16205,Ro=16206,jf=16207,Gf=16208,Bt=16209,v0=16210,_0=16211,kg=852,Ag=592,Sg=15,Ig=Sg,Vf=t=>(t>>>24&255)+(t>>>8&65280)+((t&65280)<<8)+((t&255)<<24);function Dg(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var mr=t=>{if(!t)return 1;let r=t.state;return!r||r.strm!==t||r.mode<cn||r.mode>_0?1:0},M0=t=>{if(mr(t))return ye;let r=t.state;return t.total_in=t.total_out=r.total=0,t.msg="",r.wrap&&(t.adler=r.wrap&1),r.mode=cn,r.last=0,r.havedict=0,r.flags=-1,r.dmax=32768,r.head=null,r.hold=0,r.bits=0,r.lencode=r.lendyn=new Int32Array(kg),r.distcode=r.distdyn=new Int32Array(Ag),r.sane=1,r.back=-1,pr},E0=t=>{if(mr(t))return ye;let r=t.state;return r.wsize=0,r.whave=0,r.wnext=0,M0(t)},k0=(t,r)=>{let e;if(mr(t))return ye;let i=t.state;return r<0?(e=0,r=-r):(e=(r>>4)+5,r<48&&(r&=15)),r&&(r<8||r>15)?ye:(i.window!==null&&i.wbits!==r&&(i.window=null),i.wrap=e,i.wbits=r,E0(t))},A0=(t,r)=>{if(!t)return ye;let e=new Dg;t.state=e,e.strm=t,e.window=null,e.mode=cn;let i=k0(t,r);return i!==pr&&(t.state=null),i},Tg=t=>A0(t,Ig),$f=!0,Po,Co,Rg=t=>{if($f){Po=new Int32Array(512),Co=new Int32Array(32);let r=0;for(;r<144;)t.lens[r++]=8;for(;r<256;)t.lens[r++]=9;for(;r<280;)t.lens[r++]=7;for(;r<288;)t.lens[r++]=8;for(li(x0,t.lens,0,288,Po,0,t.work,{bits:9}),r=0;r<32;)t.lens[r++]=5;li(w0,t.lens,0,32,Co,0,t.work,{bits:5}),$f=!1}t.lencode=Po,t.lenbits=9,t.distcode=Co,t.distbits=5},S0=(t,r,e,i)=>{let n,o=t.state;return o.window===null&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new Uint8Array(o.wsize)),i>=o.wsize?(o.window.set(r.subarray(e-o.wsize,e),0),o.wnext=0,o.whave=o.wsize):(n=o.wsize-o.wnext,n>i&&(n=i),o.window.set(r.subarray(e-i,e-i+n),o.wnext),i-=n,i?(o.window.set(r.subarray(e-i,e),0),o.wnext=i,o.whave=o.wsize):(o.wnext+=n,o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=n))),0},Pg=(t,r)=>{let e,i,n,o,s,a,l,h,f,c,u,d,p,g,x=0,m,w,y,M,_,T,E,A,D=new Uint8Array(4),b,k,C=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(mr(t)||!t.output||!t.input&&t.avail_in!==0)return ye;e=t.state,e.mode===Ue&&(e.mode=Do),s=t.next_out,n=t.output,l=t.avail_out,o=t.next_in,i=t.input,a=t.avail_in,h=e.hold,f=e.bits,c=a,u=l,A=pr;t:for(;;)switch(e.mode){case cn:if(e.wrap===0){e.mode=Do;break}for(;f<16;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(e.wrap&2&&h===35615){e.wbits===0&&(e.wbits=15),e.check=0,D[0]=h&255,D[1]=h>>>8&255,e.check=qt(e.check,D,2,0),h=0,f=0,e.mode=Ef;break}if(e.head&&(e.head.done=!1),!(e.wrap&1)||(((h&255)<<8)+(h>>8))%31){t.msg="incorrect header check",e.mode=Bt;break}if((h&15)!==Mf){t.msg="unknown compression method",e.mode=Bt;break}if(h>>>=4,f-=4,E=(h&15)+8,e.wbits===0&&(e.wbits=E),E>15||E>e.wbits){t.msg="invalid window size",e.mode=Bt;break}e.dmax=1<<e.wbits,e.flags=0,t.adler=e.check=1,e.mode=h&512?Pf:Ue,h=0,f=0;break;case Ef:for(;f<16;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(e.flags=h,(e.flags&255)!==Mf){t.msg="unknown compression method",e.mode=Bt;break}if(e.flags&57344){t.msg="unknown header flags set",e.mode=Bt;break}e.head&&(e.head.text=h>>8&1),e.flags&512&&e.wrap&4&&(D[0]=h&255,D[1]=h>>>8&255,e.check=qt(e.check,D,2,0)),h=0,f=0,e.mode=kf;case kf:for(;f<32;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}e.head&&(e.head.time=h),e.flags&512&&e.wrap&4&&(D[0]=h&255,D[1]=h>>>8&255,D[2]=h>>>16&255,D[3]=h>>>24&255,e.check=qt(e.check,D,4,0)),h=0,f=0,e.mode=Af;case Af:for(;f<16;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}e.head&&(e.head.xflags=h&255,e.head.os=h>>8),e.flags&512&&e.wrap&4&&(D[0]=h&255,D[1]=h>>>8&255,e.check=qt(e.check,D,2,0)),h=0,f=0,e.mode=Sf;case Sf:if(e.flags&1024){for(;f<16;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}e.length=h,e.head&&(e.head.extra_len=h),e.flags&512&&e.wrap&4&&(D[0]=h&255,D[1]=h>>>8&255,e.check=qt(e.check,D,2,0)),h=0,f=0}else e.head&&(e.head.extra=null);e.mode=If;case If:if(e.flags&1024&&(d=e.length,d>a&&(d=a),d&&(e.head&&(E=e.head.extra_len-e.length,e.head.extra||(e.head.extra=new Uint8Array(e.head.extra_len)),e.head.extra.set(i.subarray(o,o+d),E)),e.flags&512&&e.wrap&4&&(e.check=qt(e.check,i,d,o)),a-=d,o+=d,e.length-=d),e.length))break t;e.length=0,e.mode=Df;case Df:if(e.flags&2048){if(a===0)break t;d=0;do E=i[o+d++],e.head&&E&&e.length<65536&&(e.head.name+=String.fromCharCode(E));while(E&&d<a);if(e.flags&512&&e.wrap&4&&(e.check=qt(e.check,i,d,o)),a-=d,o+=d,E)break t}else e.head&&(e.head.name=null);e.length=0,e.mode=Tf;case Tf:if(e.flags&4096){if(a===0)break t;d=0;do E=i[o+d++],e.head&&E&&e.length<65536&&(e.head.comment+=String.fromCharCode(E));while(E&&d<a);if(e.flags&512&&e.wrap&4&&(e.check=qt(e.check,i,d,o)),a-=d,o+=d,E)break t}else e.head&&(e.head.comment=null);e.mode=Rf;case Rf:if(e.flags&512){for(;f<16;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(e.wrap&4&&h!==(e.check&65535)){t.msg="header crc mismatch",e.mode=Bt;break}h=0,f=0}e.head&&(e.head.hcrc=e.flags>>9&1,e.head.done=!0),t.adler=e.check=0,e.mode=Ue;break;case Pf:for(;f<32;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}t.adler=e.check=Vf(h),h=0,f=0,e.mode=ln;case ln:if(e.havedict===0)return t.next_out=s,t.avail_out=l,t.next_in=o,t.avail_in=a,e.hold=h,e.bits=f,Mg;t.adler=e.check=1,e.mode=Ue;case Ue:if(r===vg||r===en)break t;case Do:if(e.last){h>>>=f&7,f-=f&7,e.mode=Ro;break}for(;f<3;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}switch(e.last=h&1,h>>>=1,f-=1,h&3){case 0:e.mode=Cf;break;case 1:if(Rg(e),e.mode=rn,r===en){h>>>=2,f-=2;break t}break;case 2:e.mode=Bf;break;case 3:t.msg="invalid block type",e.mode=Bt}h>>>=2,f-=2;break;case Cf:for(h>>>=f&7,f-=f&7;f<32;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if((h&65535)!==(h>>>16^65535)){t.msg="invalid stored block lengths",e.mode=Bt;break}if(e.length=h&65535,h=0,f=0,e.mode=To,r===en)break t;case To:e.mode=Ff;case Ff:if(d=e.length,d){if(d>a&&(d=a),d>l&&(d=l),d===0)break t;n.set(i.subarray(o,o+d),s),a-=d,o+=d,l-=d,s+=d,e.length-=d;break}e.mode=Ue;break;case Bf:for(;f<14;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(e.nlen=(h&31)+257,h>>>=5,f-=5,e.ndist=(h&31)+1,h>>>=5,f-=5,e.ncode=(h&15)+4,h>>>=4,f-=4,e.nlen>286||e.ndist>30){t.msg="too many length or distance symbols",e.mode=Bt;break}e.have=0,e.mode=Lf;case Lf:for(;e.have<e.ncode;){for(;f<3;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}e.lens[C[e.have++]]=h&7,h>>>=3,f-=3}for(;e.have<19;)e.lens[C[e.have++]]=0;if(e.lencode=e.lendyn,e.lenbits=7,b={bits:e.lenbits},A=li(yg,e.lens,0,19,e.lencode,0,e.work,b),e.lenbits=b.bits,A){t.msg="invalid code lengths set",e.mode=Bt;break}e.have=0,e.mode=Of;case Of:for(;e.have<e.nlen+e.ndist;){for(;x=e.lencode[h&(1<<e.lenbits)-1],m=x>>>24,w=x>>>16&255,y=x&65535,!(m<=f);){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(y<16)h>>>=m,f-=m,e.lens[e.have++]=y;else{if(y===16){for(k=m+2;f<k;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(h>>>=m,f-=m,e.have===0){t.msg="invalid bit length repeat",e.mode=Bt;break}E=e.lens[e.have-1],d=3+(h&3),h>>>=2,f-=2}else if(y===17){for(k=m+3;f<k;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}h>>>=m,f-=m,E=0,d=3+(h&7),h>>>=3,f-=3}else{for(k=m+7;f<k;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}h>>>=m,f-=m,E=0,d=11+(h&127),h>>>=7,f-=7}if(e.have+d>e.nlen+e.ndist){t.msg="invalid bit length repeat",e.mode=Bt;break}for(;d--;)e.lens[e.have++]=E}}if(e.mode===Bt)break;if(e.lens[256]===0){t.msg="invalid code -- missing end-of-block",e.mode=Bt;break}if(e.lenbits=9,b={bits:e.lenbits},A=li(x0,e.lens,0,e.nlen,e.lencode,0,e.work,b),e.lenbits=b.bits,A){t.msg="invalid literal/lengths set",e.mode=Bt;break}if(e.distbits=6,e.distcode=e.distdyn,b={bits:e.distbits},A=li(w0,e.lens,e.nlen,e.ndist,e.distcode,0,e.work,b),e.distbits=b.bits,A){t.msg="invalid distances set",e.mode=Bt;break}if(e.mode=rn,r===en)break t;case rn:e.mode=nn;case nn:if(a>=6&&l>=258){t.next_out=s,t.avail_out=l,t.next_in=o,t.avail_in=a,e.hold=h,e.bits=f,pg(t,u),s=t.next_out,n=t.output,l=t.avail_out,o=t.next_in,i=t.input,a=t.avail_in,h=e.hold,f=e.bits,e.mode===Ue&&(e.back=-1);break}for(e.back=0;x=e.lencode[h&(1<<e.lenbits)-1],m=x>>>24,w=x>>>16&255,y=x&65535,!(m<=f);){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(w&&!(w&240)){for(M=m,_=w,T=y;x=e.lencode[T+((h&(1<<M+_)-1)>>M)],m=x>>>24,w=x>>>16&255,y=x&65535,!(M+m<=f);){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}h>>>=M,f-=M,e.back+=M}if(h>>>=m,f-=m,e.back+=m,e.length=y,w===0){e.mode=Xf;break}if(w&32){e.back=-1,e.mode=Ue;break}if(w&64){t.msg="invalid literal/length code",e.mode=Bt;break}e.extra=w&15,e.mode=Uf;case Uf:if(e.extra){for(k=e.extra;f<k;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}e.length+=h&(1<<e.extra)-1,h>>>=e.extra,f-=e.extra,e.back+=e.extra}e.was=e.length,e.mode=Nf;case Nf:for(;x=e.distcode[h&(1<<e.distbits)-1],m=x>>>24,w=x>>>16&255,y=x&65535,!(m<=f);){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(!(w&240)){for(M=m,_=w,T=y;x=e.distcode[T+((h&(1<<M+_)-1)>>M)],m=x>>>24,w=x>>>16&255,y=x&65535,!(M+m<=f);){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}h>>>=M,f-=M,e.back+=M}if(h>>>=m,f-=m,e.back+=m,w&64){t.msg="invalid distance code",e.mode=Bt;break}e.offset=y,e.extra=w&15,e.mode=Yf;case Yf:if(e.extra){for(k=e.extra;f<k;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}e.offset+=h&(1<<e.extra)-1,h>>>=e.extra,f-=e.extra,e.back+=e.extra}if(e.offset>e.dmax){t.msg="invalid distance too far back",e.mode=Bt;break}e.mode=zf;case zf:if(l===0)break t;if(d=u-l,e.offset>d){if(d=e.offset-d,d>e.whave&&e.sane){t.msg="invalid distance too far back",e.mode=Bt;break}d>e.wnext?(d-=e.wnext,p=e.wsize-d):p=e.wnext-d,d>e.length&&(d=e.length),g=e.window}else g=n,p=s-e.offset,d=e.length;d>l&&(d=l),l-=d,e.length-=d;do n[s++]=g[p++];while(--d);e.length===0&&(e.mode=nn);break;case Xf:if(l===0)break t;n[s++]=e.length,l--,e.mode=nn;break;case Ro:if(e.wrap){for(;f<32;){if(a===0)break t;a--,h|=i[o++]<<f,f+=8}if(u-=l,t.total_out+=u,e.total+=u,e.wrap&4&&u&&(t.adler=e.check=e.flags?qt(e.check,n,u,s-u):di(e.check,n,u,s-u)),u=l,e.wrap&4&&(e.flags?h:Vf(h))!==e.check){t.msg="incorrect data check",e.mode=Bt;break}h=0,f=0}e.mode=jf;case jf:if(e.wrap&&e.flags){for(;f<32;){if(a===0)break t;a--,h+=i[o++]<<f,f+=8}if(e.wrap&4&&h!==(e.total&4294967295)){t.msg="incorrect length check",e.mode=Bt;break}h=0,f=0}e.mode=Gf;case Gf:A=_g;break t;case Bt:A=b0;break t;case v0:return y0;case _0:default:return ye}return t.next_out=s,t.avail_out=l,t.next_in=o,t.avail_in=a,e.hold=h,e.bits=f,(e.wsize||u!==t.avail_out&&e.mode<Bt&&(e.mode<Ro||r!==_f))&&S0(t,t.output,t.next_out,u-t.avail_out),c-=t.avail_in,u-=t.avail_out,t.total_in+=c,t.total_out+=u,e.total+=u,e.wrap&4&&u&&(t.adler=e.check=e.flags?qt(e.check,n,u,t.next_out-u):di(e.check,n,u,t.next_out-u)),t.data_type=e.bits+(e.last?64:0)+(e.mode===Ue?128:0)+(e.mode===rn||e.mode===To?256:0),(c===0&&u===0||r===_f)&&A===pr&&(A=Eg),A},Cg=t=>{if(mr(t))return ye;let r=t.state;return r.window&&(r.window=null),t.state=null,pr},Fg=(t,r)=>{if(mr(t))return ye;let e=t.state;return e.wrap&2?(e.head=r,r.done=!1,pr):ye},Bg=(t,r)=>{let e=r.length,i,n,o;return mr(t)||(i=t.state,i.wrap!==0&&i.mode!==ln)?ye:i.mode===ln&&(n=1,n=di(n,r,e,0),n!==i.check)?b0:(o=S0(t,r,e,e),o?(i.mode=v0,y0):(i.havedict=1,pr))},Lg=E0,Og=k0,Ug=M0,Ng=Tg,Yg=A0,zg=Pg,Xg=Cg,jg=Fg,Gg=Bg,Vg="pako inflate (from Nodeca project)",Ye={inflateReset:Lg,inflateReset2:Og,inflateResetKeep:Ug,inflateInit:Ng,inflateInit2:Yg,inflate:zg,inflateEnd:Xg,inflateGetHeader:jg,inflateSetDictionary:Gg,inflateInfo:Vg};function $g(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var qg=$g,I0=Object.prototype.toString,{Z_NO_FLUSH:Wg,Z_FINISH:Kg,Z_OK:gi,Z_STREAM_END:Fo,Z_NEED_DICT:Bo,Z_STREAM_ERROR:Hg,Z_DATA_ERROR:qf,Z_MEM_ERROR:Zg}=Or;function yi(t){this.options=fn.assign({chunkSize:1024*64,windowBits:15,to:""},t||{});let r=this.options;r.raw&&r.windowBits>=0&&r.windowBits<16&&(r.windowBits=-r.windowBits,r.windowBits===0&&(r.windowBits=-15)),r.windowBits>=0&&r.windowBits<16&&!(t&&t.windowBits)&&(r.windowBits+=32),r.windowBits>15&&r.windowBits<48&&(r.windowBits&15||(r.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new m0,this.strm.avail_out=0;let e=Ye.inflateInit2(this.strm,r.windowBits);if(e!==gi)throw new Error(ur[e]);if(this.header=new qg,Ye.inflateGetHeader(this.strm,this.header),r.dictionary&&(typeof r.dictionary=="string"?r.dictionary=mi.string2buf(r.dictionary):I0.call(r.dictionary)==="[object ArrayBuffer]"&&(r.dictionary=new Uint8Array(r.dictionary)),r.raw&&(e=Ye.inflateSetDictionary(this.strm,r.dictionary),e!==gi)))throw new Error(ur[e])}yi.prototype.push=function(t,r){let e=this.strm,i=this.options.chunkSize,n=this.options.dictionary,o,s,a;if(this.ended)return!1;for(r===~~r?s=r:s=r===!0?Kg:Wg,I0.call(t)==="[object ArrayBuffer]"?e.input=new Uint8Array(t):e.input=t,e.next_in=0,e.avail_in=e.input.length;;){for(e.avail_out===0&&(e.output=new Uint8Array(i),e.next_out=0,e.avail_out=i),o=Ye.inflate(e,s),o===Bo&&n&&(o=Ye.inflateSetDictionary(e,n),o===gi?o=Ye.inflate(e,s):o===qf&&(o=Bo));e.avail_in>0&&o===Fo&&e.state.wrap>0&&t[e.next_in]!==0;)Ye.inflateReset(e),o=Ye.inflate(e,s);switch(o){case Hg:case qf:case Bo:case Zg:return this.onEnd(o),this.ended=!0,!1}if(a=e.avail_out,e.next_out&&(e.avail_out===0||o===Fo))if(this.options.to==="string"){let l=mi.utf8border(e.output,e.next_out),h=e.next_out-l,f=mi.buf2string(e.output,l);e.next_out=h,e.avail_out=i-h,h&&e.output.set(e.output.subarray(l,l+h),0),this.onData(f)}else this.onData(e.output.length===e.next_out?e.output:e.output.subarray(0,e.next_out));if(!(o===gi&&a===0)){if(o===Fo)return o=Ye.inflateEnd(this.strm),this.onEnd(o),this.ended=!0,!0;if(e.avail_in===0)break}}return!0};yi.prototype.onData=function(t){this.chunks.push(t)};yi.prototype.onEnd=function(t){t===gi&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=fn.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};function Zo(t,r){let e=new yi(r);if(e.push(t),e.err)throw e.msg||ur[e.err];return e.result}function Jg(t,r){return r=r||{},r.raw=!0,Zo(t,r)}var Qg=yi,tx=Zo,ex=Jg,rx=Zo,ix=Or,nx={Inflate:Qg,inflate:tx,inflateRaw:ex,ungzip:rx,constants:ix},{Deflate:s_,deflate:ox,deflateRaw:a_,gzip:l_}=ug,{Inflate:sx,inflate:ax,inflateRaw:h_,ungzip:f_}=nx;var D0=ox;var T0=sx,un=ax;var Yr=[137,80,78,71,13,10,26,10],P0=[];for(let t=0;t<256;t++){let r=t;for(let e=0;e<8;e++)r&1?r=3988292384^r>>>1:r=r>>>1;P0[t]=r}var R0=4294967295;function lx(t,r,e){let i=t;for(let n=0;n<e;n++)i=P0[(i^r[n])&255]^i>>>8;return i}function dn(t,r){return(lx(R0,t,r)^R0)>>>0}var Gt;(function(t){t[t.UNKNOWN=-1]="UNKNOWN",t[t.GREYSCALE=0]="GREYSCALE",t[t.TRUECOLOUR=2]="TRUECOLOUR",t[t.INDEXED_COLOUR=3]="INDEXED_COLOUR",t[t.GREYSCALE_ALPHA=4]="GREYSCALE_ALPHA",t[t.TRUECOLOUR_ALPHA=6]="TRUECOLOUR_ALPHA"})(Gt||(Gt={}));var He;(function(t){t[t.UNKNOWN=-1]="UNKNOWN",t[t.DEFLATE=0]="DEFLATE"})(He||(He={}));var gr;(function(t){t[t.UNKNOWN=-1]="UNKNOWN",t[t.ADAPTIVE=0]="ADAPTIVE"})(gr||(gr={}));var xr;(function(t){t[t.UNKNOWN=-1]="UNKNOWN",t[t.NO_INTERLACE=0]="NO_INTERLACE",t[t.ADAM7=1]="ADAM7"})(xr||(xr={}));var hx=new Uint8Array(0),C0="\\0",fx=new Uint16Array([255]),cx=new Uint8Array(fx.buffer),ux=cx[0]===255,vi=class extends F0.IOBuffer{constructor(r,e={}){super(r);let{checkCrc:i=!1}=e;this._checkCrc=i,this._inflator=new T0,this._png={width:-1,height:-1,channels:-1,data:new Uint8Array(0),depth:1,text:{}},this._end=!1,this._hasPalette=!1,this._palette=[],this._hasTransparency=!1,this._transparency=new Uint16Array(0),this._compressionMethod=He.UNKNOWN,this._filterMethod=gr.UNKNOWN,this._interlaceMethod=xr.UNKNOWN,this._colorType=Gt.UNKNOWN,this.setBigEndian()}decode(){for(this.decodeSignature();!this._end;)this.decodeChunk();return this.decodeImage(),this._png}decodeSignature(){for(let r=0;r<Yr.length;r++)if(this.readUint8()!==Yr[r])throw new Error(`wrong PNG signature. Byte at ${r} should be ${Yr[r]}.`)}decodeChunk(){let r=this.readUint32(),e=this.readChars(4),i=this.offset;switch(e){case"IHDR":this.decodeIHDR();break;case"PLTE":this.decodePLTE(r);break;case"IDAT":this.decodeIDAT(r);break;case"IEND":this._end=!0;break;case"tRNS":this.decodetRNS(r);break;case"iCCP":this.decodeiCCP(r);break;case"tEXt":this.decodetEXt(r);break;case"pHYs":this.decodepHYs();break;default:this.skip(r);break}if(this.offset-i!==r)throw new Error(`Length mismatch while decoding chunk ${e}`);if(this._checkCrc){let n=this.readUint32(),o=r+4,s=dn(new Uint8Array(this.buffer,this.byteOffset+this.offset-o-4,o),o);if(s!==n)throw new Error(`CRC mismatch for chunk ${e}. Expected ${n}, found ${s}`)}else this.skip(4)}decodeIHDR(){let r=this._png;r.width=this.readUint32(),r.height=this.readUint32(),r.depth=yx(this.readUint8());let e=this.readUint8();this._colorType=e;let i;switch(e){case Gt.GREYSCALE:i=1;break;case Gt.TRUECOLOUR:i=3;break;case Gt.INDEXED_COLOUR:i=1;break;case Gt.GREYSCALE_ALPHA:i=2;break;case Gt.TRUECOLOUR_ALPHA:i=4;break;default:throw new Error(`Unknown color type: ${e}`)}if(this._png.channels=i,this._compressionMethod=this.readUint8(),this._compressionMethod!==He.DEFLATE)throw new Error(`Unsupported compression method: ${this._compressionMethod}`);this._filterMethod=this.readUint8(),this._interlaceMethod=this.readUint8()}decodePLTE(r){if(r%3!==0)throw new RangeError(`PLTE field length must be a multiple of 3. Got ${r}`);let e=r/3;this._hasPalette=!0;let i=[];this._palette=i;for(let n=0;n<e;n++)i.push([this.readUint8(),this.readUint8(),this.readUint8()])}decodeIDAT(r){this._inflator.push(new Uint8Array(this.buffer,this.offset+this.byteOffset,r)),this.skip(r)}decodetRNS(r){switch(this._colorType){case Gt.GREYSCALE:case Gt.TRUECOLOUR:{if(r%2!==0)throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${r}`);if(r/2>this._png.width*this._png.height)throw new Error(`tRNS chunk contains more alpha values than there are pixels (${r/2} vs ${this._png.width*this._png.height})`);this._hasTransparency=!0,this._transparency=new Uint16Array(r/2);for(let e=0;e<r/2;e++)this._transparency[e]=this.readUint16();break}case Gt.INDEXED_COLOUR:{if(r>this._palette.length)throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${r} vs ${this._palette.length})`);let e=0;for(;e<r;e++){let i=this.readByte();this._palette[e].push(i)}for(;e<this._palette.length;e++)this._palette[e].push(255);break}default:throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`)}}decodeiCCP(r){let e="",i;for(;(i=this.readChar())!==C0;)e+=i;let n=this.readUint8();if(n!==He.DEFLATE)throw new Error(`Unsupported iCCP compression method: ${n}`);let o=this.readBytes(r-e.length-2);this._png.iccEmbeddedProfile={name:e,profile:un(o)}}decodetEXt(r){let e="",i;for(;(i=this.readChar())!==C0;)e+=i;this._png.text[e]=this.readChars(r-e.length-1)}decodepHYs(){let r=this.readUint32(),e=this.readUint32(),i=this.readByte();this._png.resolution={x:r,y:e,unit:i}}decodeImage(){if(this._inflator.err)throw new Error(`Error while decompressing the data: ${this._inflator.err}`);let r=this._inflator.result;if(this._filterMethod!==gr.ADAPTIVE)throw new Error(`Filter method ${this._filterMethod} not supported`);if(this._interlaceMethod===xr.NO_INTERLACE)this.decodeInterlaceNull(r);else throw new Error(`Interlace method ${this._interlaceMethod} not supported`)}decodeInterlaceNull(r){let e=this._png.height,i=this._png.channels*this._png.depth/8,n=this._png.width*i,o=new Uint8Array(this._png.height*n),s=hx,a=0,l,h;for(let f=0;f<e;f++){switch(l=r.subarray(a+1,a+1+n),h=o.subarray(f*n,(f+1)*n),r[a]){case 0:dx(l,h,n);break;case 1:px(l,h,n,i);break;case 2:mx(l,h,s,n);break;case 3:gx(l,h,s,n,i);break;case 4:xx(l,h,s,n,i);break;default:throw new Error(`Unsupported filter: ${r[a]}`)}s=h,a+=n+1}if(this._hasPalette&&(this._png.palette=this._palette),this._hasTransparency&&(this._png.transparency=this._transparency),this._png.depth===16){let f=new Uint16Array(o.buffer);if(ux)for(let c=0;c<f.length;c++)f[c]=bx(f[c]);this._png.data=f}else this._png.data=o}};function dx(t,r,e){for(let i=0;i<e;i++)r[i]=t[i]}function px(t,r,e,i){let n=0;for(;n<i;n++)r[n]=t[n];for(;n<e;n++)r[n]=t[n]+r[n-i]&255}function mx(t,r,e,i){let n=0;if(e.length===0)for(;n<i;n++)r[n]=t[n];else for(;n<i;n++)r[n]=t[n]+e[n]&255}function gx(t,r,e,i,n){let o=0;if(e.length===0){for(;o<n;o++)r[o]=t[o];for(;o<i;o++)r[o]=t[o]+(r[o-n]>>1)&255}else{for(;o<n;o++)r[o]=t[o]+(e[o]>>1)&255;for(;o<i;o++)r[o]=t[o]+(r[o-n]+e[o]>>1)&255}}function xx(t,r,e,i,n){let o=0;if(e.length===0){for(;o<n;o++)r[o]=t[o];for(;o<i;o++)r[o]=t[o]+r[o-n]&255}else{for(;o<n;o++)r[o]=t[o]+e[o]&255;for(;o<i;o++)r[o]=t[o]+wx(r[o-n],e[o],e[o-n])&255}}function wx(t,r,e){let i=t+r-e,n=Math.abs(i-t),o=Math.abs(i-r),s=Math.abs(i-e);return n<=o&&n<=s?t:o<=s?r:e}function bx(t){return(t&255)<<8|t>>8&255}function yx(t){if(t!==1&&t!==2&&t!==4&&t!==8&&t!==16)throw new Error(`invalid bit depth: ${t}`);return t}var Jo=vt(Tr());var vx={level:3},_i=class extends Jo.IOBuffer{constructor(r,e={}){super(),this._colorType=Gt.UNKNOWN,this._zlibOptions=lr(lr({},vx),e.zlib),this._png=this._checkData(r),this.setBigEndian()}encode(){return this.encodeSignature(),this.encodeIHDR(),this.encodeData(),this.encodeIEND(),this.toArray()}encodeSignature(){this.writeBytes(Yr)}encodeIHDR(){this.writeUint32(13),this.writeChars("IHDR"),this.writeUint32(this._png.width),this.writeUint32(this._png.height),this.writeByte(this._png.depth),this.writeByte(this._colorType),this.writeByte(He.DEFLATE),this.writeByte(gr.ADAPTIVE),this.writeByte(xr.NO_INTERLACE),this.writeCrc(17)}encodeIEND(){this.writeUint32(0),this.writeChars("IEND"),this.writeCrc(4)}encodeIDAT(r){this.writeUint32(r.length),this.writeChars("IDAT"),this.writeBytes(r),this.writeCrc(r.length+4)}encodeData(){let{width:r,height:e,channels:i,depth:n,data:o}=this._png,s=i*r,a=new Jo.IOBuffer().setBigEndian(),l=0;for(let c=0;c<e;c++)if(a.writeByte(0),n===8)l=Mx(o,a,s,l);else if(n===16)l=Ex(o,a,s,l);else throw new Error("unreachable");let h=a.toArray(),f=D0(h,this._zlibOptions);this.encodeIDAT(f)}_checkData(r){let{colorType:e,channels:i,depth:n}=_x(r),o={width:B0(r.width,"width"),height:B0(r.height,"height"),channels:i,data:r.data,depth:n,text:{}};this._colorType=e;let s=o.width*o.height*i;if(o.data.length!==s)throw new RangeError(`wrong data size. Found ${o.data.length}, expected ${s}`);return o}writeCrc(r){this.writeUint32(dn(new Uint8Array(this.buffer,this.byteOffset+this.offset-r,r),r))}};function B0(t,r){if(Number.isInteger(t)&&t>0)return t;throw new TypeError(`${r} must be a positive integer`)}function _x(t){let{channels:r=4,depth:e=8}=t;if(r!==4&&r!==3&&r!==2&&r!==1)throw new RangeError(`unsupported number of channels: ${r}`);if(e!==8&&e!==16)throw new RangeError(`unsupported bit depth: ${e}`);let i={channels:r,depth:e,colorType:Gt.UNKNOWN};switch(r){case 4:i.colorType=Gt.TRUECOLOUR_ALPHA;break;case 3:i.colorType=Gt.TRUECOLOUR;break;case 1:i.colorType=Gt.GREYSCALE;break;case 2:i.colorType=Gt.GREYSCALE_ALPHA;break;default:throw new Error("unsupported number of channels")}return i}function Mx(t,r,e,i){for(let n=0;n<e;n++)r.writeByte(t[i++]);return i}function Ex(t,r,e,i){for(let n=0;n<e;n++)r.writeUint16(t[i++]);return i}var L0;(function(t){t[t.UNKNOWN=0]="UNKNOWN",t[t.METRE=1]="METRE"})(L0||(L0={}));function O0(t,r){return new vi(t,r).decode()}function U0(t,r){return new _i(t,r).encode()}var Q0=vt(es());var zr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Mi=new Uint8Array(256);for(let t=0;t<zr.length;t++)Mi[zr.charCodeAt(t)]=t;function Ix(t){let r,e=t.length,i="";for(r=0;r<e;r+=3)i+=zr[t[r]>>2],i+=zr[(t[r]&3)<<4|t[r+1]>>4],i+=zr[(t[r+1]&15)<<2|t[r+2]>>6],i+=zr[t[r+2]&63];return e%3===2?i=`${i.substring(0,i.length-1)}=`:e%3===1&&(i=`${i.substring(0,i.length-2)}==`),i}function V0(t){let r=t.length*.75,e=t.length,i=0,n,o,s,a;t[t.length-1]==="="&&(r--,t[t.length-2]==="="&&r--);let l=new Uint8Array(r);for(let h=0;h<e;h+=4)n=Mi[t.charCodeAt(h)],o=Mi[t.charCodeAt(h+1)],s=Mi[t.charCodeAt(h+2)],a=Mi[t.charCodeAt(h+3)],l[i++]=n<<2|o>>4,l[i++]=(o&15)<<4|s>>2,l[i++]=(s&3)<<6|a&63;return l}function mn(t,r){let e=Ix(t);return`data:${r};base64,${e}`}var $0=self.ImageData,q0=self.Image;function gn(t,r){let e=self.document.createElement("canvas");return e.width=t,e.height=r,e}function W0(t,{withCredentials:r=!1}={}){return new Promise(function(e,i){let n=new self.XMLHttpRequest;n.open("GET",t,!0),n.responseType="arraybuffer",n.withCredentials=r,n.onload=function(o){this.status!==200?i(o):e(this.response)},n.onerror=i,n.send()})}function K0(){throw new Error("createWriteStream does not exist in the browser")}function H0(){throw new Error("writeFile does not exist in the browser")}function Z0(t){return t.includes("/")||(t=`image/${t}`),t}function rs(t,r={}){let e={width:t.width,height:t.height,data:t.getRGBAData()};return(0,Q0.encode)(e,r.quality).data}function is(t,r){let e={width:t.width,height:t.height,channels:t.channels,depth:t.bitDepth,data:t.data};return(e.depth===1||e.depth===32)&&(e.depth=8,e.channels=4,e.data=t.getRGBAData()),U0(e,r)}var J0={save(t,r={}){let{useCanvas:e=!1,encoder:i=void 0}=r,{format:n}=r;if(!n){let o=new RegExp("\\\\.(?<format>[a-zA-Z]+)$").exec(t);o&&(n=o.groups.format.toLowerCase())}if(!n)throw new Error("file format not provided");return new Promise((o,s)=>{let a,l;switch(n.toLowerCase()){case"png":{e?a=this.getCanvas().pngStream():l=is(this,i);break}case"jpg":case"jpeg":e?a=this.getCanvas().jpegStream():l=rs(this,i);break;case"bmp":l=(0,xn.encode)(this,i);break;default:throw new RangeError(`invalid output format: ${n}`)}if(a){let h=K0(t);h.on("finish",o),h.on("error",s),a.pipe(h)}else l&&H0(t,l,h=>{if(h){s(h);return}o()})})},toDataURL(t="image/png",r={}){typeof t=="object"&&(r=t,t="image/png");let{useCanvas:e=!1,encoder:i=void 0}=r;t=Z0(t);function n(o,s){let a=o(s,i);return mn(a,t)}return t==="image/bmp"?n(xn.encode,this):t==="image/png"&&!e?n(is,this):t==="image/jpeg"&&!e?n(rs,this):this.getCanvas().toDataURL(t)},toBuffer(t={}){let{format:r="png",encoder:e=void 0}=t;switch(r.toLowerCase()){case"png":return is(this,e);case"jpeg":case"jpg":return rs(this,e);case"bmp":return(0,xn.encode)(this,e);default:throw new RangeError(`invalid output format: ${r}`)}},toBase64(t="image/png",r={}){if(r.async)return this.toDataURL(t,r).then(function(e){return e.substring(e.indexOf(",")+1)});{let e=this.toDataURL(t,r);return e.substring(e.indexOf(",")+1)}},toBlob(t="image/png",r=.8){return Zh(this.getCanvas(),t,r)},getCanvas(){let t=new $0(this.getRGBAData({clamped:!0}),this.width,this.height),r=gn(this.width,this.height);return r.getContext("2d").putImageData(t,0,0),r}};function ns(t){for(let r in J0)t.prototype[r]=J0[r]}var ic=vt(ss());var rc={configurable:!0,enumerable:!1,get:void 0};function nc(t,r,e={}){let{inPlace:i=!1,returnThis:n=!0,partialArgs:o=[]}=e;return i?L.prototype[t]=function(...s){this.computed=null;let a=r.apply(this,[...o,...s]);return n?this:a}:L.prototype[t]=function(...s){return r.apply(this,[...o,...s])},L}function oc(t,r,e={}){let{partialArgs:i=[]}=e;return rc.get=function(){if(this.computed===null)this.computed={};else if((0,ic.default)(t,this.computed))return this.computed[t];let n=r.apply(this,i);return this.computed[t]=n,n},Object.defineProperty(L.prototype,t,rc),L}var Ai={};Wi(Ai,{CMYK:()=>Ze,GREY:()=>Wt,HSL:()=>Ei,HSV:()=>ki,RGB:()=>Lt});var Wt="GREY",Lt="RGB",Ei="HSL",ki="HSV",Ze="CMYK";function as(t={}){let{clamped:r}=t;this.checkProcessable("getRGBAData",{components:[1,3],bitDepth:[1,8,16,32]});let e=this.width*this.height*4,i=r?new Uint8ClampedArray(e):new Uint8Array(e);return this.bitDepth===1?Rx(this,i):this.bitDepth===32?(this.checkProcessable("getRGBAData",{alpha:0}),this.components===1?Px(this,i):this.components===3&&(this.checkProcessable("getRGBAData",{colorModel:[Lt]}),Cx(this,i))):this.components===1?Fx(this,i):this.components===3&&(this.checkProcessable("getRGBAData",{colorModel:[Lt]}),Bx(this,i)),this.alpha===1?(this.checkProcessable("getRGBAData",{bitDepth:[8,16]}),Lx(this,i)):Ox(this,i),i}function Rx(t,r){for(let e=0;e<t.size;e++){let i=t.getBit(e);r[e*4]=i*255,r[e*4+1]=i*255,r[e*4+2]=i*255}}function Px(t,r){let e=t.min[0],n=t.max[0]-e;for(let o=0;o<t.size;o++){let s=Math.floor(255*(t.data[o]-e)/n);r[o*4]=s,r[o*4+1]=s,r[o*4+2]=s}}function Cx(t,r){let e=Math.min(...t.min),n=Math.max(...t.max)-e;for(let o=0;o<t.size;o++){let s=Math.floor(255*(t.data[o*3]-e)/n),a=Math.floor(255*(t.data[o*3+1]-e)/n),l=Math.floor(255*(t.data[o*3+2]-e)/n);r[o*4]=s,r[o*4+1]=a,r[o*4+2]=l}}function Fx(t,r){for(let e=0;e<t.size;e++)r[e*4]=t.data[e*t.channels]>>>t.bitDepth-8,r[e*4+1]=t.data[e*t.channels]>>>t.bitDepth-8,r[e*4+2]=t.data[e*t.channels]>>>t.bitDepth-8}function Bx(t,r){for(let e=0;e<t.size;e++)r[e*4]=t.data[e*t.channels]>>>t.bitDepth-8,r[e*4+1]=t.data[e*t.channels+1]>>>t.bitDepth-8,r[e*4+2]=t.data[e*t.channels+2]>>>t.bitDepth-8}function Lx(t,r){for(let e=0;e<t.size;e++)r[e*4+3]=t.data[e*t.channels+t.components]>>t.bitDepth-8}function Ox(t,r){for(let e=0;e<t.size;e++)r[e*4+3]=255}var ie="BINARY",sc="GREY",ac="GREYA",lc="RGB",wn="RGBA",hc="CMYK",fc="CMYKA";var Je={};Je[ie]={components:1,alpha:0,bitDepth:1,colorModel:Wt};Je[ac]={components:1,alpha:1,bitDepth:8,colorModel:Wt};Je[sc]={components:1,alpha:0,bitDepth:8,colorModel:Wt};Je[wn]={components:3,alpha:1,bitDepth:8,colorModel:Lt};Je[lc]={components:3,alpha:0,bitDepth:8,colorModel:Lt};Je[hc]={components:4,alpha:0,bitDepth:8,colorModel:Ze};Je[fc]={components:4,alpha:1,bitDepth:8,colorModel:Ze};function dc(t){let r=Je[t];if(!r)throw new RangeError(`invalid image kind: ${t}`);return r}var uc=[1,8,16,32];function pc(t){let{components:r,alpha:e,bitDepth:i,colorModel:n}=t;if(!Number.isInteger(r)||r<=0)throw new RangeError(`invalid components: ${r}. Must be a positive integer`);if(e!==0&&e!==1&&typeof e!="boolean")throw new TypeError(`invalid alpha: ${e}: must be a boolean, 0 or 1`);if(!uc.includes(i))throw new RangeError(`invalid bitDepth: ${i}. Must be one of ${uc.join(", ")}`);if(!Ai[n])throw new RangeError(`invalid colorModel: ${n}. Must be one of ${Object.keys(Ai).join(", ")}`)}function mc(t,r,e){let i=r*t;return e===1&&(i=Math.ceil(i/8)),i}function gc(t,r,e,i,n,o){let s=i*t,a;switch(n){case 1:a=new Uint8Array(Math.ceil(s/8));break;case 8:a=new Uint8Array(s);break;case 16:a=new Uint16Array(s);break;case 32:a=new Float32Array(s);break;default:throw new Error(`Cannot create pixel array for bit depth ${n}`)}if(e)for(let l=r;l<a.length;l+=i)a[l]=o;return a}var bu=vt(Vc());var yu=vt(Wc()),vu=vt(es());var uu=vt(Tr());function Kc(t){if(t.compression!==1)throw new Error("missing mandatory StripByteCounts field in compressed image");let r=t.rowsPerStrip*t.width*t.samplesPerPixel*(t.bitsPerSample/8);return new Array(t.stripOffsets.length).fill(r)}function Hc(t,r,e){let i=0;for(;i<t.length;){for(let n=e;n<r*e;n+=e)for(let o=0;o<e;o++)t[i+n+o]=t[i+n+o]+t[i+n-(e-o)]&255;i+=r*e}}function Zc(t,r,e){let i=0;for(;i<t.length;){for(let n=e;n<r*e;n+=e)for(let o=0;o<e;o++)t[i+n+o]=t[i+n+o]+t[i+n-(e-o)]&65535;i+=r*e}}var ks={};Wi(ks,{tagsById:()=>Es,tagsByName:()=>Jc});var Es={33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"ISOSpeedRatings",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",36864:"ExifVersion",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBiasValue",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37386:"FocalLength",37396:"SubjectArea",37500:"MakerNote",37510:"UserComment",37520:"SubsecTime",37521:"SubsecTimeOriginal",37522:"SubsecTimeDigitized",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",40964:"RelatedSoundFile",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber",42240:"Gamma"},Jc={};for(let t in Es)Jc[Es[t]]=Number(t);var Ss={};Wi(Ss,{tagsById:()=>As,tagsByName:()=>Qc});var As={0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},Qc={};for(let t in As)Qc[As[t]]=Number(t);var Ds={};Wi(Ds,{tagsById:()=>Is,tagsByName:()=>tu});var Is={254:"NewSubfileType",255:"SubfileType",256:"ImageWidth",257:"ImageLength",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",263:"Threshholding",264:"CellWidth",265:"CellLength",266:"FillOrder",270:"ImageDescription",271:"Make",272:"Model",273:"StripOffsets",274:"Orientation",277:"SamplesPerPixel",278:"RowsPerStrip",279:"StripByteCounts",280:"MinSampleValue",281:"MaxSampleValue",282:"XResolution",283:"YResolution",284:"PlanarConfiguration",288:"FreeOffsets",289:"FreeByteCounts",290:"GrayResponseUnit",291:"GrayResponseCurve",296:"ResolutionUnit",305:"Software",306:"DateTime",315:"Artist",316:"HostComputer",320:"ColorMap",338:"ExtraSamples",33432:"Copyright",269:"DocumentName",285:"PageName",286:"XPosition",287:"YPosition",292:"T4Options",293:"T6Options",297:"PageNumber",301:"TransferFunction",317:"Predictor",318:"WhitePoint",319:"PrimaryChromaticities",321:"HalftoneHints",322:"TileWidth",323:"TileLength",324:"TileOffsets",325:"TileByteCounts",326:"BadFaxLines",327:"CleanFaxData",328:"ConsecutiveBadFaxLines",330:"SubIFDs",332:"InkSet",333:"InkNames",334:"NumberOfInks",336:"DotRange",337:"TargetPrinter",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",342:"TransferRange",343:"ClipPath",344:"XClipPathUnits",345:"YClipPathUnits",346:"Indexed",347:"JPEGTables",351:"OPIProxy",400:"GlobalParametersIFD",401:"ProfileType",402:"FaxProfile",403:"CodingMethods",404:"VersionYear",405:"ModeNumber",433:"Decode",434:"DefaultImageColor",512:"JPEGProc",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",515:"JPEGRestartInterval",517:"JPEGLosslessPredictors",518:"JPEGPointTransforms",519:"JPEGQTables",520:"JPEGDCTables",521:"JPEGACTables",529:"YCbCrCoefficients",530:"YCbCrSubSampling",531:"YCbCrPositioning",532:"ReferenceBlackWhite",559:"StripRowCounts",700:"XMP",32781:"ImageID",34732:"ImageLayer",32932:"WangAnnotatio",33445:"MDFileTag",33446:"MDScalePixel",33447:"MDColorTable",33448:"MDLabName",33449:"MDSampleInfo",33450:"MDPrepDate",33451:"MDPrepTime",33452:"MDFileUnits",33550:"ModelPixelScaleTag",33723:"IPTC",33918:"INGRPacketDataTag",33919:"INGRFlagRegisters",33920:"IrasBTransformationMatrix",33922:"ModelTiepointTag",34264:"ModelTransformationTag",34377:"Photoshop",34665:"ExifIFD",34675:"ICCProfile",34735:"GeoKeyDirectoryTag",34736:"GeoDoubleParamsTag",34737:"GeoAsciiParamsTag",34853:"GPSIFD",34908:"HylaFAXFaxRecvParams",34909:"HylaFAXFaxSubAddress",34910:"HylaFAXFaxRecvTime",37724:"ImageSourceData",40965:"InteroperabilityIFD",42112:"GDAL_METADATA",42113:"GDAL_NODATA",50215:"OceScanjobDescription",50216:"OceApplicationSelector",50217:"OceIdentificationNumber",50218:"OceImageLogicCharacteristics",50706:"DNGVersion",50707:"DNGBackwardVersion",50708:"UniqueCameraModel",50709:"LocalizedCameraModel",50710:"CFAPlaneColor",50711:"CFALayout",50712:"LinearizationTable",50713:"BlackLevelRepeatDim",50714:"BlackLevel",50715:"BlackLevelDeltaH",50716:"BlackLevelDeltaV",50717:"WhiteLevel",50718:"DefaultScale",50719:"DefaultCropOrigin",50720:"DefaultCropSize",50721:"ColorMatrix1",50722:"ColorMatrix2",50723:"CameraCalibration1",50724:"CameraCalibration2",50725:"ReductionMatrix1",50726:"ReductionMatrix2",50727:"AnalogBalance",50728:"AsShotNeutral",50729:"AsShotWhiteXY",50730:"BaselineExposure",50731:"BaselineNoise",50732:"BaselineSharpness",50733:"BayerGreenSplit",50734:"LinearResponseLimit",50735:"CameraSerialNumber",50736:"LensInfo",50737:"ChromaBlurRadius",50738:"AntiAliasStrength",50740:"DNGPrivateData",50741:"MakerNoteSafety",50778:"CalibrationIlluminant1",50779:"CalibrationIlluminant2",50780:"BestQualityScale",50784:"AliasLayerMetadata"},tu={};for(let t in Is)tu[Is[t]]=Number(t);var eu={standard:Ds,exif:ks,gps:Ss},wr=class{constructor(r){if(!r)throw new Error("missing kind");this.data=new Uint8Array,this.fields=new Map,this.kind=r,this._hasMap=!1,this._map={}}get(r){if(typeof r=="number")return this.fields.get(r);if(typeof r=="string")return this.fields.get(eu[this.kind].tagsByName[r]);throw new Error("expected a number or string")}get map(){if(!this._hasMap){let r=eu[this.kind].tagsById;for(let e of this.fields.keys())r[e]&&(this._map[r[e]]=this.fields.get(e));this._hasMap=!0}return this._map}};var iu=new Map([[1,[1,ru]],[2,[1,fw]],[3,[2,cw]],[4,[4,uw]],[5,[8,dw]],[6,[1,pw]],[7,[1,ru]],[8,[2,mw]],[9,[4,gw]],[10,[8,xw]],[11,[4,ww]],[12,[8,bw]]]);function nu(t,r){let e=iu.get(t);if(!e)throw new Error(`type not found: ${t}`);return e[0]*r}function ou(t,r,e){let i=iu.get(r);if(!i)throw new Error(`type not found: ${r}`);return i[1](t,e)}function ru(t,r){if(r===1)return t.readUint8();let e=new Uint8Array(r);for(let i=0;i<r;i++)e[i]=t.readUint8();return e}function fw(t,r){let e=[],i="";for(let n=0;n<r;n++){let o=String.fromCharCode(t.readUint8());o==="\\0"?(e.push(i),i=""):i+=o}return e.length===1?e[0]:e}function cw(t,r){if(r===1)return t.readUint16();let e=new Uint16Array(r);for(let i=0;i<r;i++)e[i]=t.readUint16();return e}function uw(t,r){if(r===1)return t.readUint32();let e=new Uint32Array(r);for(let i=0;i<r;i++)e[i]=t.readUint32();return e}function dw(t,r){if(r===1)return t.readUint32()/t.readUint32();let e=new Array(r);for(let i=0;i<r;i++)e[i]=t.readUint32()/t.readUint32();return e}function pw(t,r){if(r===1)return t.readInt8();let e=new Int8Array(r);for(let i=0;i<r;i++)e[i]=t.readInt8();return e}function mw(t,r){if(r===1)return t.readInt16();let e=new Int16Array(r);for(let i=0;i<r;i++)e[i]=t.readInt16();return e}function gw(t,r){if(r===1)return t.readInt32();let e=new Int32Array(r);for(let i=0;i<r;i++)e[i]=t.readInt32();return e}function xw(t,r){if(r===1)return t.readInt32()/t.readInt32();let e=new Array(r);for(let i=0;i<r;i++)e[i]=t.readInt32()/t.readInt32();return e}function ww(t,r){if(r===1)return t.readFloat32();let e=new Float32Array(r);for(let i=0;i<r;i++)e[i]=t.readFloat32();return e}function bw(t,r){if(r===1)return t.readFloat64();let e=new Float64Array(r);for(let i=0;i<r;i++)e[i]=t.readFloat64();return e}var hu=vt(Tr()),yw=256,su=257,au=258,lu=9,br=[];function vw(){if(br.length===0){for(let r=0;r<256;r++)br.push([r]);let t=[];for(let r=256;r<4096;r++)br.push(t)}}var _w=[511,1023,2047,4095],Mw=[0,0,0,0,0,0,0,0,0,511,1023,2047,4095],Ts=class{constructor(r){this.nextData=0,this.nextBits=0,this.bytePointer=0,this.tableLength=au,this.currentBitLength=lu,this.stripArray=new Uint8Array(r.buffer,r.byteOffset,r.byteLength),this.outData=new hu.IOBuffer(r.byteLength),this.initializeTable()}decode(){let r=0,e=0;for(;(r=this.getNextCode())!==su;)if(r===yw){if(this.initializeTable(),r=this.getNextCode(),r===su)break;this.writeString(this.stringFromCode(r)),e=r}else if(this.isInTable(r))this.writeString(this.stringFromCode(r)),this.addStringToTable(this.stringFromCode(e).concat(this.stringFromCode(r)[0])),e=r;else{let n=this.stringFromCode(e).concat(this.stringFromCode(e)[0]);this.writeString(n),this.addStringToTable(n),e=r}let i=this.outData.toArray();return new DataView(i.buffer,i.byteOffset,i.byteLength)}initializeTable(){vw(),this.tableLength=au,this.currentBitLength=lu}writeString(r){this.outData.writeBytes(r)}stringFromCode(r){return br[r]}isInTable(r){return r<this.tableLength}addStringToTable(r){if(br[this.tableLength++]=r,br.length>4096)throw br=[],new Error("LZW decoding error. Please open an issue at https://github.com/image-js/tiff/issues/new/choose (include a test image).");this.tableLength===Mw[this.currentBitLength]&&this.currentBitLength++}getNextCode(){this.nextData=this.nextData<<8|this.stripArray[this.bytePointer++]&255,this.nextBits+=8,this.nextBits<this.currentBitLength&&(this.nextData=this.nextData<<8|this.stripArray[this.bytePointer++]&255,this.nextBits+=8);let r=this.nextData>>this.nextBits-this.currentBitLength&_w[this.currentBitLength-9];return this.nextBits-=this.currentBitLength,this.bytePointer>this.stripArray.length?257:r}};function fu(t){return new Ts(t).decode()}var Ew=/^(\\d{4}):(\\d{2}):(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})$/,jr=class extends wr{constructor(){super("standard")}get size(){return this.width*this.height}get width(){return this.imageWidth}get height(){return this.imageLength}get components(){return this.samplesPerPixel}get date(){let r=new Date,e=Ew.exec(this.dateTime);if(e===null)throw new Error(`invalid dateTime: ${this.dateTime}`);return r.setFullYear(Number(e[1]),Number(e[2])-1,Number(e[3])),r.setHours(Number(e[4]),Number(e[5]),Number(e[6])),r}get newSubfileType(){return this.get("NewSubfileType")}get imageWidth(){return this.get("ImageWidth")}get imageLength(){return this.get("ImageLength")}get bitsPerSample(){let r=this.get("BitsPerSample");return r&&typeof r!="number"?r[0]:r}get alpha(){let r=this.extraSamples;return r?r[0]!==0:!1}get associatedAlpha(){let r=this.extraSamples;return r?r[0]===1:!1}get extraSamples(){return Rs(this.get("ExtraSamples"))}get compression(){return this.get("Compression")||1}get type(){return this.get("PhotometricInterpretation")}get fillOrder(){return this.get("FillOrder")||1}get documentName(){return this.get("DocumentName")}get imageDescription(){return this.get("ImageDescription")}get stripOffsets(){return Rs(this.get("StripOffsets"))}get orientation(){return this.get("Orientation")}get samplesPerPixel(){return this.get("SamplesPerPixel")||1}get rowsPerStrip(){return this.get("RowsPerStrip")}get stripByteCounts(){return Rs(this.get("StripByteCounts"))}get minSampleValue(){return this.get("MinSampleValue")||0}get maxSampleValue(){return this.get("MaxSampleValue")||Math.pow(2,this.bitsPerSample)-1}get xResolution(){return this.get("XResolution")}get yResolution(){return this.get("YResolution")}get planarConfiguration(){return this.get("PlanarConfiguration")||1}get resolutionUnit(){return this.get("ResolutionUnit")||2}get dateTime(){return this.get("DateTime")}get predictor(){return this.get("Predictor")||1}get sampleFormat(){return this.get("SampleFormat")||1}get sMinSampleValue(){return this.get("SMinSampleValue")||this.minSampleValue}get sMaxSampleValue(){return this.get("SMaxSampleValue")||this.maxSampleValue}get palette(){let r=2**this.bitsPerSample,e=this.get("ColorMap");if(!e)return;if(e.length!==3*r)throw new Error(`ColorMap size must be ${r}`);let i=[];for(let n=0;n<r;n++)i.push([e[n],e[n+r],e[n+2*r]]);return i}};function Rs(t){return typeof t=="number"?[t]:t}function cu(t){let r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength),e=un(r);return new DataView(e.buffer,e.byteOffset,e.byteLength)}var kw={ignoreImageData:!1,onlyFirst:!1},Si=class extends uu.IOBuffer{constructor(r){super(r),this._nextIFD=0}get isMultiPage(){let r=0;for(this.decodeHeader();this._nextIFD;)if(r++,this.decodeIFD({ignoreImageData:!0},!0),r===2)return!0;if(r===1)return!1;throw ze("ifdCount",r)}get pageCount(){let r=0;for(this.decodeHeader();this._nextIFD;)r++,this.decodeIFD({ignoreImageData:!0},!0);if(r>0)return r;throw ze("ifdCount",r)}decode(r={}){r=Object.assign({},kw,r);let e=[];for(this.decodeHeader();this._nextIFD;)if(e.push(this.decodeIFD(r,!0)),r.onlyFirst)return[e[0]];return e}decodeHeader(){let r=this.readUint16();if(r===18761)this.setLittleEndian();else if(r===19789)this.setBigEndian();else throw new Error(`invalid byte order: 0x${r.toString(16)}`);if(this.readUint16()!==42)throw new Error("not a TIFF file");this._nextIFD=this.readUint32()}decodeIFD(r,e){this.seek(this._nextIFD);let i;if(e)i=new jr;else{if(!r.kind)throw new Error("kind is missing");i=new wr(r.kind)}let n=this.readUint16();for(let o=0;o<n;o++)this.decodeIFDEntry(i);if(!r.ignoreImageData){if(!(i instanceof jr))throw new Error("must be a tiff ifd");this.decodeImageData(i)}return this._nextIFD=this.readUint32(),i}decodeIFDEntry(r){let e=this.offset,i=this.readUint16(),n=this.readUint16(),o=this.readUint32();if(n<1||n>12){this.skip(4);return}nu(n,o)>4&&this.seek(this.readUint32());let a=ou(this,n,o);if(r.fields.set(i,a),i===34665||i===34853){let l=this.offset,h="exif";i===34665?h="exif":i===34853&&(h="gps"),this._nextIFD=a,r[h]=this.decodeIFD({kind:h,ignoreImageData:!0},!1),this.offset=l}this.seek(e),this.skip(12)}decodeImageData(r){let e=r.orientation;if(e&&e!==1)throw ze("orientation",e);switch(r.type){case 0:case 1:case 2:case 3:this.readStripData(r);break;default:throw ze("image type",r.type)}if(this.applyPredictor(r),this.convertAlpha(r),r.type===0){let i=r.bitsPerSample,n=Math.pow(2,i)-1;for(let o=0;o<r.data.length;o++)r.data[o]=n-r.data[o]}}readStripData(r){let e=r.width,i=r.height,n=r.bitsPerSample,o=r.sampleFormat,s=e*i*r.samplesPerPixel,a=Aw(s,n,o),h=r.rowsPerStrip*e*r.samplesPerPixel,f=r.stripOffsets,c=r.stripByteCounts||Kc(r),u=s,d=0;for(let p=0;p<f.length;p++){let g=new DataView(this.buffer,this.byteOffset+f[p],c[p]),x=u>h?h:u;u-=x;let m=g;switch(r.compression){case 1:break;case 5:{m=fu(g);break}case 8:{m=cu(g);break}case 2:throw ze("Compression","CCITT Group 3");case 32773:throw ze("Compression","PackBits");default:throw ze("Compression",r.compression)}d=this.fillUncompressed(n,o,a,m,d,x)}r.data=a}fillUncompressed(r,e,i,n,o,s){if(r===8)return Sw(i,n,o,s);if(r===16)return Iw(i,n,o,s,this.isLittleEndian());if(r===32&&e===3)return Dw(i,n,o,s,this.isLittleEndian());throw ze("bitDepth",r)}applyPredictor(r){let e=r.bitsPerSample;switch(r.predictor){case 1:break;case 2:{if(e===8)Hc(r.data,r.width,r.components);else if(e===16)Zc(r.data,r.width,r.components);else throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${e}`);break}default:throw new Error(`invalid predictor: ${r.predictor}`)}}convertAlpha(r){if(r.alpha&&r.associatedAlpha){let{data:e,components:i,maxSampleValue:n}=r;for(let o=0;o<e.length;o+=i){let s=e[o+i-1];for(let a=0;a<i-1;a++)e[o+a]=Math.round(e[o+a]*n/s)}}}};function Aw(t,r,e){if(r===8)return new Uint8Array(t);if(r===16)return new Uint16Array(t);if(r===32&&e===3)return new Float32Array(t);throw ze("bit depth / sample format",`${r} / ${e}`)}function Sw(t,r,e,i){for(let n=0;n<i;n++)t[e++]=r.getUint8(n);return e}function Iw(t,r,e,i,n){for(let o=0;o<i*2;o+=2)t[e++]=r.getUint16(o,n);return e}function Dw(t,r,e,i,n){for(let o=0;o<i*4;o+=4)t[e++]=r.getFloat32(o,n);return e}function ze(t,r){return new Error(`Unsupported ${t}: ${r}`)}function du(t,r){return new Si(t).decode(r)}var gu=vt(ss());function Ps(t={}){let{algorithm:r="matchToPrevious",ignoreBorder:e=[0,0]}=t;this.checkProcessable("matchAndCrop",{bitDepth:[8,16]});let i=r==="matchToPrevious",n=this[0],o=[];o[0]={position:[0,0],image:this[0]};let s=[0,0];for(let u=1;u<this.length;u++){let d=n.getBestMatch(this[u],{border:e});o[u]={position:[d[0]+s[0],d[1]+s[1]],image:this[u]},i&&(s[0]+=d[0],s[1]+=d[1],n=this[u])}let a=0,l=0,h=0,f=0;for(let u=0;u<o.length;u++){let d=o[u];d.position[0]>a&&(a=d.position[0]),d.position[0]<l&&(l=d.position[0]),d.position[1]>h&&(h=d.position[1]),d.position[1]<f&&(f=d.position[1])}l=0-l,f=0-f;for(let u=0;u<o.length;u++){let d=o[u];d.crop=d.image.crop({x:a-d.position[0],y:h-d.position[1],width:n.width-l-a,height:n.height-f-h})}let c=[];for(let u=0;u<o.length;u++)c[u]=o[u].crop;return new ae(c)}function Cs(){this.checkProcessable("min",{bitDepth:[8,16]});let t=this[0].min;for(let r=1;r<this.length;r++)for(let e=0;e<t.length;e++)t[e]=Math.min(t[e],this[r].min[e]);return t}function Fs(){this.checkProcessable("min",{bitDepth:[8,16]});let t=this[0].max;for(let r=1;r<this.length;r++)for(let e=0;e<t.length;e++)t[e]=Math.max(t[e],this[r].max[e]);return t}function bn(t){let r=t.reduce((s,a)=>s+a);if(r===0)throw new Error("unreachable");let e=0,i=0,n=r/2,o;for(;;){if(t[e]>0){if(o!==void 0)return(o+e)/2;if(i+=t[e],i>n)return e;i===n&&(o=e)}e++}}function pu(t){let r=0,e=0;for(let i=0;i<t.length;i++)r+=t[i],e+=t[i]*i;return r===0?0:e/r}function Bs(){this.checkProcessable("median",{bitDepth:[8,16]});let t=this.getHistograms({maxSlots:this[0].maxValue+1}),r=new Array(t.length);for(let e=0;e<t.length;e++){let i=t[e];r[e]=bn(i)}return r}function Ls(t){this.checkProcessable("min",{bitDepth:[8,16]});let r=this[0].getHistogram(t);for(let e=1;e<this.length;e++){let i=this[e].getHistogram(t);for(let n=0;n<r.length;n++)r[n]+=i[n]}return r}function Os(t){this.checkProcessable("min",{bitDepth:[8,16]});let r=this[0].getHistograms(t),e=r[0].length;for(let i=1;i<this.length;i++){let n=this[i].getHistograms(t);for(let o=0;o<r.length;o++)for(let s=0;s<e;s++)r[o][s]+=n[o][s]}return r}function yn(){this.checkProcessable("averageImage",{bitDepth:[8,16]});let t=new Uint32Array(this[0].data.length);for(let i=0;i<this.length;i++){let n=this[i];for(let o=0;o<this[0].data.length;o++)t[o]+=n.data[o]}let r=L.createFrom(this[0]),e=r.data;for(let i=0;i<this[0].data.length;i++)e[i]=t[i]/this.length;return r}function Us(){this.checkProcessable("max",{bitDepth:[8,16]});let t=L.createFrom(this[0]);t.data.fill(0);for(let r of this)for(let e=0;e<t.data.length;e++)t.data[e]=Math.max(r.data[e],t.data[e]);return t}function Ns(){this.checkProcessable("max",{bitDepth:[8,16]});let t=L.createFrom(this[0]);t.data.fill(t.maxValue);for(let r of this)for(let e=0;e<t.data.length;e++)t.data[e]=Math.min(r.data[e],t.data[e]);return t}function Ys(t){t.extendMethod("matchAndCrop",Ps),t.extendMethod("getMin",Cs),t.extendMethod("getMax",Fs),t.extendMethod("getMedian",Bs),t.extendMethod("getHistogram",Ls),t.extendMethod("getHistograms",Os),t.extendMethod("getAverage",yn),t.extendMethod("getAverageImage",yn),t.extendMethod("getMaxImage",Us),t.extendMethod("getMinImage",Ns)}var mu={configurable:!0,enumerable:!1,get:void 0},ae=class t extends Array{constructor(r){if(Array.isArray(r)){super(r.length);for(let e=0;e<r.length;e++)this[e]=r[e]}else typeof r=="number"?super(r):super();this.computed=null}static load(r){return Promise.all(r.map(L.load)).then(e=>new t(e))}static extendMethod(r,e,i={}){let{inPlace:n=!1,returnThis:o=!0,partialArgs:s=[]}=i;return n?t.prototype[r]=function(...a){this.computed=null;let l=e.apply(this,[...s,...a]);return o?this:l}:t.prototype[r]=function(...a){return e.apply(this,[...s,...a])},t}static extendProperty(r,e,i={}){let{partialArgs:n=[]}=i;return mu.get=function(){if(this.computed===null)this.computed={};else if((0,gu.default)(r,this.computed))return this.computed[r];let o=e.apply(this,n);return this.computed[r]=o,o},Object.defineProperty(t.prototype,r,mu),t}checkProcessable(r,e={}){if(typeof r!="string")throw new TypeError("checkProcessable requires as first parameter the processName (a string)");if(this.size===0)throw new TypeError(`The process: ${r} can not be applied on an empty stack`);this[0].checkProcessable(r,e);for(let i=1;i<this.length;i++){if((e.sameSize===void 0||e.sameSize)&&this[0].width!==this[i].width)throw new TypeError(`The process: ${r} can not be applied if width is not identical in all images`);if((e.sameSize===void 0||e.sameSize)&&this[0].height!==this[i].height)throw new TypeError(`The process: ${r} can not be applied if height is not identical in all images`);if((e.sameAlpha===void 0||e.sameAlpha)&&this[0].alpha!==this[i].alpha)throw new TypeError(`The process: ${r} can not be applied if alpha is not identical in all images`);if((e.sameBitDepth===void 0||e.sameBitDepth)&&this[0].bitDepth!==this[i].bitDepth)throw new TypeError(`The process: ${r} can not be applied if bitDepth is not identical in all images`);if((e.sameColorModel===void 0||e.sameColorModel)&&this[0].colorModel!==this[i].colorModel)throw new TypeError(`The process: ${r} can not be applied if colorModel is not identical in all images`);if((e.sameNumberChannels===void 0||e.sameNumberChannels)&&this[0].channels!==this[i].channels)throw new TypeError(`The process: ${r} can not be applied if channels is not identical in all images`)}}};Array[Symbol.species]||(ae.prototype.map=function(t,r){if(typeof t!="function")throw new TypeError(`${t} is not a function`);let e=new ae(this.length);for(let i=0;i<this.length;i++)e[i]=t.call(r,this[i],i,this);return e});Ys(ae);var Tw=/^data:[a-z]+\\/(?:[a-z]+);base64,/;function js(t,r){if(typeof t=="string")return Rw(t,r);if(t instanceof ArrayBuffer)return Promise.resolve(zs(new Uint8Array(t),void 0,r&&r.ignorePalette));if(t.buffer)return Promise.resolve(zs(t,void 0,r&&r.ignorePalette));throw new Error(\'argument to "load" must be a string or buffer.\')}function zs(t,r,e){let i=(0,yu.default)(t);if(i)switch(i.mime){case"image/png":return Pw(t);case"image/jpeg":return Fw(t);case"image/tiff":return Bw(t,e);default:return wu(n(i.mime))}return wu(n("application/octet-stream"));function n(o){return r||mn(t,o)}}function Rw(t,r){let e=t.slice(0,64).match(Tw),i;return e!==null?i=Promise.resolve(V0(t.slice(e[0].length))):i=W0(t,r),i.then(n=>{let o=new Uint8Array(n);return zs(o,e?t:void 0,r&&r.ignorePalette)})}function Pw(t){let r=O0(t),e=r.channels,i,n=0;return e===2||e===4?(i=e-1,n=1):i=e,r.palette?Cw(r):new L(r.width,r.height,r.data,{components:i,alpha:n,bitDepth:r.depth})}function Cw(t){let r=t.width*t.height,e=t.palette[0].length,i=new Uint8Array(r*e),n=8/t.depth,o=t.depth<8?n:1,s=parseInt("1".repeat(t.depth),2),a=e===4,l=0;for(let h=0;h<r;h++){let f=Math.floor(h/o),c=t.data[f];t.depth<8&&(c=c>>>t.depth*(n-1-h%n)&s);let u=t.palette[c];i[l++]=u[0],i[l++]=u[1],i[l++]=u[2],a&&(i[l++]=u[3])}return new L(t.width,t.height,i,{components:3,alpha:a,bitDepth:8})}function Fw(t){let r=(0,bu.decode)(t),e;r.exif&&(e=Xs(r.exif));let i=(0,vu.decode)(t,{useTArray:!0,maxMemoryUsageInMB:1024}),n=new L(i.width,i.height,i.data,{meta:e});if(e&&e.tiff.tags.Orientation){let o=e.tiff.tags.Orientation;o>2&&(n=n.rotate({3:180,4:180,5:90,6:90,7:270,8:270}[o])),[2,4,5,7].includes(o)&&(n=n.flipX())}return n}function Bw(t,r){let e=du(t);return e.length===1?xu(e[0],r):new ae(e.map(function(i){return xu(i,r)}))}function Xs(t){let r={tiff:{fields:t.fields,tags:t.map}};return t.exif&&(r.exif=t.exif),t.gps&&(r.gps=t.gps),r}function xu(t,r){if(!r&&t.type===3){let e=new Uint16Array(3*t.width*t.height),i=t.palette,n=0;for(let o=0;o<t.data.length;o++){let s=t.data[o],a=i[s];e[n++]=a[0],e[n++]=a[1],e[n++]=a[2]}return new L(t.width,t.height,e,{components:3,alpha:t.alpha,colorModel:Lt,bitDepth:16,meta:Xs(t)})}else return new L(t.width,t.height,t.data,{components:t.type===2?3:1,alpha:t.alpha,colorModel:t.type===2?Lt:Wt,bitDepth:t.bitsPerSample.length?t.bitsPerSample[0]:t.bitsPerSample,meta:Xs(t)})}function wu(t,r){return r=r||{},new Promise(function(e,i){let n=new q0;n.onload=function(){let o=n.width,s=n.height,l=gn(o,s).getContext("2d");l.drawImage(n,0,0,o,s);let h=l.getImageData(0,0,o,s).data;e(new L(o,s,h,r))},n.onerror=function(){i(new Error(`Could not load ${t}`))},n.src=t})}var _u={getValueXY(t,r,e){return this.data[(r*this.width+t)*this.channels+e]},setValueXY(t,r,e,i){return this.data[(r*this.width+t)*this.channels+e]=i,this.computed=null,this},getValue(t,r){return this.data[t*this.channels+r]},setValue(t,r,e){return this.data[t*this.channels+r]=e,this.computed=null,this},getPixelXY(t,r){return this.getPixel(r*this.width+t)},setPixelXY(t,r,e){return this.setPixel(r*this.width+t,e)},getPixel(t){let r=new Array(this.channels),e=t*this.channels;for(let i=0;i<this.channels;i++)r[i]=this.data[e+i];return r},setPixel(t,r){let e=t*this.channels;for(let i=0;i<r.length;i++)this.data[e+i]=r[i];return this.computed=null,this}};function Gs(t){for(let r in _u)t.prototype[r]=_u[r]}function yr(t){return{width:t.width,height:t.height,components:t.components,alpha:t.alpha,colorModel:t.colorModel,bitDepth:t.bitDepth}}function Vs(t,r,e,i={}){let{out:n}=r;if(n===void 0)return i.copy?t.clone():L.createFrom(t,e);{if(!L.isImage(n))throw new TypeError("out must be an Image object");let o=Object.assign(yr(t),e);for(let s in o)if(n[s]!==o[s])throw new RangeError(`cannot use out. Its ${s} must be "${o[s]}" (found "${n[s]}")`);return n}}function Gr(t,r,e){if(r.inPlace!==void 0&&typeof r.inPlace!="boolean")throw new TypeError("inPlace option must be a boolean");if(r.inPlace){if(r.out!==void 0)throw new TypeError("out option must not be set if inPlace option is true");return t}return Vs(t,r,null,e)}function $s(t={}){this.checkProcessable("abs",{bitDepth:[32]});let r=Gr(this,t);return Lw(this,r),r}function Lw(t,r){for(let e=0;e<t.data.length;e++)r.data[e]=Math.abs(t.data[e])}function qs(t,r){if(t.alpha===1&&r.alpha===1)for(let e=0;e<t.size;e++)r.data[e*r.channels+r.components]=t.data[e*t.channels+t.components]}function Ws(t={}){this.checkProcessable("invert",{bitDepth:[1,8,16]});let r=Gr(this,t);return this.bitDepth===1?Ow(this,r):(Uw(this,r),this!==r&&qs(this,r)),r}function Ow(t,r){for(let e=0;e<t.data.length;e++)r.data[e]=~t.data[e]}function Uw(t,r){for(let e=0;e<t.data.length;e+=t.channels)for(let i=0;i<t.components;i++)r.data[e+i]=t.maxValue-t.data[e+i]}function Ks(){this.checkProcessable("flipX",{bitDepth:[8,16]});for(let t=0;t<this.height;t++){let r=t*this.width*this.channels;for(let e=0;e<Math.floor(this.width/2);e++){let i=e*this.channels+r,n=(this.width-e-1)*this.channels+r;for(let o=0;o<this.channels;o++){let s=this.data[i+o];this.data[i+o]=this.data[n+o],this.data[n+o]=s}}}return this}function Hs(){this.checkProcessable("flipY",{bitDepth:[8,16]});for(let t=0;t<Math.floor(this.height/2);t++)for(let r=0;r<this.width;r++){let e=r*this.channels+t*this.width*this.channels,i=r*this.channels+(this.height-1-t)*this.channels*this.width;for(let n=0;n<this.channels;n++){let o=this.data[e+n];this.data[e+n]=this.data[i+n],this.data[i+n]=o}}return this}function Zs(t={}){let{radius:r=1}=t;if(r<1)throw new Error("radius must be greater than 1");let e=2*r+1,i=new Array(e);for(let n=0;n<e;n++){i[n]=new Array(e);for(let o=0;o<e;o++)i[n][o]=1/(e*e)}return this.convolution(i)}var Mu=vt(Js());function zt(t,r={}){let{channels:e,allowAlpha:i,defaultAlpha:n}=r;return typeof i!="boolean"&&(i=!0),typeof e=="undefined"?Nw(t,n):Yw(t,e,i)}function Nw(t,r){let e=r?t.channels:t.components,i=new Array(e);for(let n=0;n<e;n++)i[n]=n;return i}function Yw(t,r,e){Array.isArray(r)||(r=[r]);for(let i=0;i<r.length;i++)r[i]=Ii(t,r[i],e);return r}function Ii(t,r,e=!0){if(r===void 0)throw new RangeError(`validateChannel : the channel has to be >=0 and <${t.channels}`);if(typeof r=="string"){switch(t.colorModel){case Wt:break;case Lt:if("rgb".includes(r))switch(r){case"r":r=0;break;case"g":r=1;break;case"b":r=2;break}break;case Ei:if("hsl".includes(r))switch(r){case"h":r=0;break;case"s":r=1;break;case"l":r=2;break}break;case ki:if("hsv".includes(r))switch(r){case"h":r=0;break;case"s":r=1;break;case"v":r=2;break}break;case Ze:if("cmyk".includes(r))switch(r){case"c":r=0;break;case"m":r=1;break;case"y":r=2;break;case"k":r=3;break}break;default:throw new Error(`Unexpected color model: ${t.colorModel}`)}if(r==="a"){if(!t.alpha)throw new Error("validateChannel : the image does not contain alpha channel");r=t.components}if(typeof r=="string")throw new Error(`validateChannel : undefined channel: ${r}`)}if(r>=t.channels)throw new RangeError(`validateChannel : the channel has to be >=0 and <${t.channels}`);if(!e&&r>=t.components)throw new RangeError("validateChannel : alpha channel may not be selected");return r}function Qs(t={}){let{radius:r=1,border:e="copy",channels:i}=t;if(this.checkProcessable("medianFilter",{bitDepth:[8,16]}),r<1)throw new Error("radius must be greater than 0");i=zt(this,i,!0);let n=r,o=r,s=L.createFrom(this),a=(n*2+1)*(o*2+1),l=new Array(a);for(let h=0;h<i.length;h++){let f=i[h];for(let c=o;c<this.height-o;c++)for(let u=n;u<this.width-n;u++){let d=0;for(let g=-o;g<=o;g++)for(let x=-n;x<=n;x++){let m=((c+g)*this.width+u+x)*this.channels+f;l[d++]=this.data[m]}let p=(c*this.width+u)*this.channels+f;s.data[p]=(0,Mu.default)(l)}}if(this.alpha&&!i.includes(this.channels))for(let h=this.components;h<this.data.length;h=h+this.channels)s.data[h]=this.data[h];return s.setBorder({size:[n,o],algorithm:e}),s}function ta(t={}){let{radius:r=1,sigma:e,channels:i,border:n="copy"}=t;this.checkProcessable("gaussian",{bitDepth:[8,16]});let o=zw(r,e);return this.convolution([o,o],{border:n,channels:i,algorithm:"separable"})}function zw(t,r){let e=t*2+1,i=new Array(e),n=r||((e-1)*.5-1)*.3+.8,o=-.5/(n*n),s=0;for(let a=0;a<e;a++){let l=a-t,h=Math.exp(o*l*l);i[a]=h,s+=h}for(let a=0;a<e;a++)i[a]/=s;return i}var Eu=[[-1,0,1],[-2,0,2],[-1,0,1]],ku=[[-1,-2,-1],[0,0,0],[1,2,1]],Au=[[3,0,-3],[10,0,-10],[3,0,-3]],Su=[[3,10,3],[0,0,0],[-3,-10,-3]];var Ln=vt(Pu());var Lu=vt(oa());function Ou(t){let r,e;if(Array.isArray(t))if(Array.isArray(t[0])){if(!(t.length&1)||!(t[0].length&1))throw new RangeError("validateKernel: Kernel rows and columns should be odd numbers");r=Math.floor(t.length/2),e=Math.floor(t[0].length/2)}else{let i=Math.sqrt(t.length);if((0,Lu.default)(i))e=r=Math.floor(Math.sqrt(t.length)/2);else throw new RangeError("validateKernel: Kernel array should be a square");let n=new Array(i);for(let o=0;o<i;o++){n[o]=new Array(i);for(let s=0;s<i;s++)n[o][s]=t[o*i+s]}t=n}else throw new Error(`validateKernel: Invalid Kernel: ${t}`);return{kernel:t,kWidth:e,kHeight:r}}function Di(t,r){return Math.round(Math.min(Math.max(t,0),r.maxValue))}function Ti(t,r,e){if(e===void 0){let o=t.length+r.length-1;e=new Array(o)}qw(e);for(var i=0;i<t.length;i++)for(var n=0;n<r.length;n++)e[i+n]+=t[i]*r[n];return e}function qw(t){for(var r=0;r<t.length;r++)t[r]=0}var Kw=vt(Nu()),Hw=vt(zu());function sa(t,r,e,i){let n=new Array(t.length),o,s,a,l;l=r[1],a=(l.length-1)/2,s=new Array(e+l.length-1),o=new Array(e);for(let h=0;h<i;h++){for(let f=0;f<e;f++)o[f]=t[h*e+f];Ti(o,l,s);for(let f=0;f<e;f++)n[h*e+f]=s[a+f]}l=r[0],a=(l.length-1)/2,s=new Array(i+l.length-1),o=new Array(i);for(let h=0;h<e;h++){for(let f=0;f<i;f++)o[f]=n[f*e+h];Ti(o,l,s);for(let f=0;f<i;f++)n[f*e+h]=s[a+f]}return n}var wt=vt(ba(),1);var fe=wt.Matrix;var rd=wt.SVD,id=wt.SingularValueDecomposition;var QM=wt.default.Matrix?wt.default.Matrix:wt.Matrix;var ya=wt.inverse;var nd=wt.solve;function va(t){let r=new rd(t,{autoTranspose:!0});if(r.rank!==1)return null;let e=Math.sqrt(r.s[0]),i=r.U.to2DArray().map(o=>o[0]*e),n=r.V.to2DArray().map(o=>o[0]*e);return[i,n]}function er(t,r={}){let{channels:e,bitDepth:i,normalize:n=!1,divisor:o=1,border:s="copy",algorithm:a="auto"}=r,l={};i&&(l.bitDepth=i);let h=L.createFrom(this,l);if(e=zt(this,e,!0),a!=="separable")({kernel:t}=Ou(t));else if(!Array.isArray(t)||t.length!==2)throw new RangeError("separable convolution requires two arrays of numbers to represent the kernel");if(a==="auto"){let M=va(t);M!==null?(a="separable",t=M):(t.length>9||t[0].length>9)&&this.width<=4096&&this.height<=4096?a="fft":a="direct"}let f,c;a==="separable"?(f=Math.floor(t[0].length/2),c=Math.floor(t[1].length/2)):(f=Math.floor(t.length/2),c=Math.floor(t[0].length/2));let u=h.isClamped,d=new Array(this.height*this.width),p,g,x,m,w,y;for(m=0;m<e.length;m++){for(w=e[m],x=0;x<this.height;x++)for(g=0;g<this.width;g++)p=x*this.width+g,d[p]=this.data[p*this.channels+w];if(a==="direct")y=(0,Ln.direct)(d,t,{rows:this.height,cols:this.width,normalize:n,divisor:o});else if(a==="separable"){if(y=sa(d,t,this.width,this.height),n){o=0;for(let M=0;M<t[0].length;M++)for(let _=0;_<t[1].length;_++)o+=t[0][M]*t[1][_]}if(o!==1)for(let M=0;M<y.length;M++)y[M]/=o}else y=(0,Ln.fft)(d,t,{rows:this.height,cols:this.width,normalize:n,divisor:o});for(x=0;x<this.height;x++)for(g=0;g<this.width;g++)p=x*this.width+g,u?h.data[p*this.channels+w]=Di(y[p],h):h.data[p*this.channels+w]=y[p]}if(this.alpha&&!e.includes(this.channels))for(g=this.components;g<this.data.length;g=g+this.channels)h.data[g]=this.data[g];return s!=="periodic"&&h.setBorder({size:[c,f],algorithm:s}),h}function Mr(t={}){let{direction:r="xy",border:e="copy",kernelX:i,kernelY:n,channels:o,bitDepth:s=this.bitDepth}=t;switch(this.checkProcessable("gradientFilter",{bitDepth:[8,16]}),r){case"x":if(!i)throw new Error("kernelX option is missing");return er.call(this,i,{channels:o,border:e,bitDepth:s});case"y":if(!n)throw new Error("kernelY option is missing");return er.call(this,n,{channels:o,border:e,bitDepth:s});case"xy":{if(!i)throw new Error("kernelX option is missing");if(!n)throw new Error("kernelY option is missing");let a=er.call(this,i,{channels:o,border:e,bitDepth:32}),l=er.call(this,n,{channels:o,border:e,bitDepth:32});return a.hypotenuse(l,{bitDepth:s,channels:o})}default:throw new Error(`Unknown parameter direction: ${r}`)}}function _a(t){return Mr.call(this,Object.assign({},t,{kernelX:Eu,kernelY:ku}))}function Ma(t){return Mr.call(this,Object.assign({},t,{kernelX:Au,kernelY:Su}))}var Ea=vt(Pe());function ka(t={}){let{algorithm:r="range",channels:e,min:i=this.min,max:n=this.max}=t;switch(this.checkProcessable("level",{bitDepth:[8,16,32]}),e=zt(this,{channels:e}),e.length!==this.channel&&(Array.isArray(i)&&i.length===this.channels&&(i=i.filter((o,s)=>e.includes(s))),Array.isArray(n)&&n.length===this.channels&&(n=n.filter((o,s)=>e.includes(s)))),r){case"range":i<0&&(i=0),n>this.maxValue&&(n=this.maxValue),Array.isArray(i)||(i=(0,Ea.default)(e.length,i)),Array.isArray(n)||(n=(0,Ea.default)(e.length,n)),G2(this,i,n,e);break;default:throw new Error(`level: algorithm not implement: ${r}`)}return this}function G2(t,r,e,i){let n=1e-5,o=new Array(i.length);for(let s=0;s<i.length;s++)r[s]===0&&e[s]===t.maxValue||e[s]===r[s]?o[s]=0:o[s]=(t.maxValue+1-n)/(e[s]-r[s]),r[s]+=(.5-n/2)/o[s];for(let s=0;s<i.length;s++){let a=i[s];if(o[s]!==0)for(let l=0;l<t.data.length;l+=t.channels)t.data[l+a]=Math.min(Math.max(0,(t.data[l+a]-r[s])*o[s]+.5|0),t.maxValue)}}var ld=vt(ad());function rr(t){if(isNaN(t)){if(t instanceof L)return t.data;if(!(0,ld.default)(t))throw new Error("checkNumberArray: the value should be either a number, array or Image");return t}else{if(t<=0)throw new Error("checkNumberArray: the value must be greater than 0");return t}}function Aa(t,r={}){let{channels:e}=r;if(this.checkProcessable("add",{bitDepth:[8,16]}),e=zt(this,{channels:e}),t=rr(t),isNaN(t)){if(this.data.length!==t.length)throw new Error("add: the data size is different");for(let i=0;i<e.length;i++){let n=e[i];for(let o=0;o<this.data.length;o+=this.channels)this.data[o+n]=Math.max(0,Math.min(this.maxValue,this.data[o+n]+t[o+n]>>0))}}else for(let i=0;i<e.length;i++){let n=e[i];for(let o=0;o<this.data.length;o+=this.channels)this.data[o+n]=Math.min(this.maxValue,this.data[o+n]+t>>0)}return this}function Sa(t,r={}){let{channels:e}=r;if(this.checkProcessable("subtract",{bitDepth:[8,16]}),e=zt(this,{channels:e}),t=rr(t),isNaN(t)){if(this.data.length!==t.length)throw new Error("subtract: the data size is different");for(let i=0;i<e.length;i++){let n=e[i];for(let o=0;o<this.data.length;o+=this.channels)this.data[o+n]=Math.max(0,Math.min(this.maxValue,this.data[o+n]-t[o+n]>>0))}}else for(let i=0;i<e.length;i++){let n=e[i];for(let o=0;o<this.data.length;o+=this.channels)this.data[o+n]=Math.max(0,this.data[o+n]-t>>0)}return this}function Ia(t,r={}){let{channels:e,absolute:i=!1}=r;if(this.checkProcessable("subtractImage",{bitDepth:[8,16]}),this.width!==t.width||this.height!==t.height)throw new Error("subtractImage: both images must have the same size");if(this.alpha!==t.alpha||this.bitDepth!==t.bitDepth)throw new Error("subtractImage: both images must have the same alpha and bitDepth");if(this.channels!==t.channels)throw new Error("subtractImage: both images must have the same number of channels");let n=this.clone();e=zt(this,{channels:e});for(let o=0;o<e.length;o++){let s=e[o];for(let a=s;a<this.data.length;a+=this.channels){let l=this.data[a]-t.data[a];i?n.data[a]=Math.abs(l):n.data[a]=Math.max(l,0)}}return n}function Da(t,r={}){let{bitDepth:e=this.bitDepth,channels:i}=r;if(this.checkProcessable("hypotenuse",{bitDepth:[8,16,32]}),this.width!==t.width||this.height!==t.height)throw new Error("hypotenuse: both images must have the same size");if(this.alpha!==t.alpha||this.bitDepth!==t.bitDepth)throw new Error("hypotenuse: both images must have the same alpha and bitDepth");if(this.channels!==t.channels)throw new Error("hypotenuse: both images must have the same number of channels");let n=L.createFrom(this,{bitDepth:e});i=zt(this,{channels:i});let o=n.isClamped;for(let s=0;s<i.length;s++){let a=i[s];for(let l=a;l<this.data.length;l+=this.channels){let h=Math.hypot(this.data[l],t.data[l]);o?n.data[l]=Math.min(Math.max(Math.round(h),0),n.maxValue):n.data[l]=h}}return n}function Ta(t,r={}){let{channels:e}=r;if(this.checkProcessable("multiply",{bitDepth:[8,16]}),t<=0)throw new Error("multiply: the value must be greater than 0");if(e=zt(this,{channels:e}),t=rr(t),isNaN(t)){if(this.data.length!==t.length)throw new Error("multiply: the data size is different");for(let i=0;i<e.length;i++){let n=e[i];for(let o=0;o<this.data.length;o+=this.channels)this.data[o+n]=Math.max(0,Math.min(this.maxValue,this.data[o+n]*t[o+n]>>0))}}else for(let i=0;i<e.length;i++){let n=e[i];for(let o=0;o<this.data.length;o+=this.channels)this.data[o+n]=Math.min(this.maxValue,this.data[o+n]*t>>0)}return this}function Ra(t,r={}){let{channels:e}=r;if(this.checkProcessable("divide",{bitDepth:[8,16]}),e=zt(this,{channels:e}),t=rr(t),isNaN(t)){if(this.data.length!==t.length)throw new Error("divide: the: the data size is different");for(let i=0;i<e.length;i++){let n=e[i];for(let o=0;o<this.data.length;o+=this.channels)this.data[o+n]=Math.max(0,Math.min(this.maxValue,this.data[o+n]/t[o+n]>>0))}}else for(let i=0;i<e.length;i++){let n=e[i];for(let o=0;o<this.data.length;o+=this.channels)this.data[o+n]=Math.min(this.maxValue,this.data[o+n]/t>>0)}return this}var On=vt(vr());var Ci=class t{constructor(){if(new.target===t)throw new Error("BaseRegression must be subclassed")}predict(r){if(typeof r=="number")return this._predict(r);if((0,On.isAnyArray)(r)){let e=[];for(let i=0;i<r.length;i++)e.push(this._predict(r[i]));return e}else throw new TypeError("x must be a number or array")}_predict(){throw new Error("_predict must be implemented")}train(){}toString(){return""}toLaTeX(){return""}score(r,e){if(!(0,On.isAnyArray)(r)||!(0,On.isAnyArray)(e)||r.length!==e.length)throw new Error("x and y must be arrays of the same length");let i=r.length,n=new Array(i);for(let d=0;d<i;d++)n[d]=this._predict(r[d]);let o=0,s=0,a=0,l=0,h=0,f=0,c=0;for(let d=0;d<i;d++)o+=n[d],s+=e[d],h+=n[d]*n[d],f+=e[d]*e[d],c+=n[d]*e[d],e[d]!==0&&(a+=(e[d]-n[d])*(e[d]-n[d])/e[d]),l+=(e[d]-n[d])*(e[d]-n[d]);let u=(i*c-o*s)/Math.sqrt((i*h-o*o)*(i*f-s*s));return{r:u,r2:u*u,chi2:a,rmsd:Math.sqrt(l/i)}}};var Ga=vt(Bd());var xb={lambda:.1,kernelType:"gaussian",kernelOptions:{},computeCoefficient:!1},kr=class t extends Ci{constructor(r,e,i){if(super(),r===!0)this.alpha=e.alpha,this.inputs=e.inputs,this.kernelType=e.kernelType,this.kernelOptions=e.kernelOptions,this.kernel=new Ga.default(e.kernelType,e.kernelOptions);else{r=fe.checkMatrix(r),i=Object.assign({},xb,i);let n=new Ga.default(i.kernelType,i.kernelOptions),o=n.compute(r),s=r.rows;o.add(fe.eye(s,s).mul(i.lambda)),this.alpha=nd(o,e),this.inputs=r,this.kernelType=i.kernelType,this.kernelOptions=i.kernelOptions,this.kernel=n}}_predict(r){return this.kernel.compute([r],this.inputs).mmul(this.alpha).getRow(0)}toJSON(){return{name:"kernelRidgeRegression",alpha:this.alpha,inputs:this.inputs,kernelType:this.kernelType,kernelOptions:this.kernelOptions}}static load(r){if(r.name!=="kernelRidgeRegression")throw new TypeError("not a KRR model");return new t(!0,r)}};var wb=vt(vr()),bb=vt(Js());function Va(t,r,e){let i=new kr(t,r,e),n=new Array(this.size);for(let a=0;a<this.width;a++)for(let l=0;l<this.height;l++)n[l*this.width+a]=[a,l];let o=i.predict(n),s=L.createFrom(this);for(let a=0;a<this.size;a++)s.data[a]=Math.min(this.maxValue,Math.max(0,o[a][0]));return s}function $a(t={}){let{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=t;if(this.checkProcessable("dilate",{bitDepth:[1,8,16],components:1,alpha:0}),r.columns%2===0||r.rows%2===0)throw new TypeError("dilate: The number of rows and columns of the kernel must be odd");let i=!0;t:for(let o of r)for(let s of o)if(s!==1){i=!1;break t}let n=this;for(let o=0;o<e;o++)if(this.bitDepth===1)if(i){let s=n.clone();n=Mb(n,s,r.length,r[0].length)}else{let s=L.createFrom(n);n=_b(n,s,r)}else if(i){let s=L.createFrom(n);n=vb(n,s,r.length,r[0].length)}else{let s=L.createFrom(n);n=yb(n,s,r)}return n}function yb(t,r,e){let i=e.length,n=e[0].length,o=(i-1)/2,s=(n-1)/2;for(let a=0;a<t.height;a++)for(let l=0;l<t.width;l++){let h=0;for(let f=0;f<n;f++)for(let c=0;c<i;c++){if(e[c][f]!==1)continue;let u=c-o+l,d=f-s+a;if(u<0||d<0||u>=t.width||d>=t.height)continue;let p=t.getValueXY(u,d,0);p>h&&(h=p)}r.setValueXY(l,a,0,h)}return r}function vb(t,r,e,i){let n=(e-1)/2,o=(i-1)/2,s=[];for(let a=0;a<t.width;a++)s.push(0);for(let a=0;a<t.height;a++){for(let l=0;l<t.width;l++){let h=0;for(let f=Math.max(0,a-o);f<Math.min(t.height,a+o+1);f++){let c=t.getValueXY(l,f,0);c>h&&(h=c)}s[l]=h}for(let l=0;l<t.width;l++){let h=0;for(let f=Math.max(0,l-n);f<Math.min(t.width,l+n+1);f++)s[f]>h&&(h=s[f]);r.setValueXY(l,a,0,h)}}return r}function _b(t,r,e){let i=e.length,n=e[0].length,o=(i-1)/2,s=(n-1)/2;for(let a=0;a<t.height;a++)for(let l=0;l<t.width;l++){let h=0;t:for(let f=0;f<n;f++)for(let c=0;c<i;c++){if(e[c][f]!==1)continue;let u=c-o+l,d=f-s+a;if(d<0||u<0||u>=t.width||d>=t.height)continue;if(t.getBitXY(u,d)===1){h=1;break t}}h===1&&r.setBitXY(l,a)}return r}function Mb(t,r,e,i){let n=(e-1)/2,o=(i-1)/2,s=[];for(let a=0;a<t.width;a++)s.push(1);for(let a=0;a<t.height;a++){for(let l=0;l<t.width;l++){s[l]=0;for(let h=Math.max(0,a-o);h<Math.min(t.height,a+o+1);h++)if(t.getBitXY(l,h)===1){s[l]=1;break}}for(let l=0;l<t.width;l++)if(r.getBitXY(l,a)!==1){for(let h=Math.max(0,l-n);h<Math.min(t.width,l+n+1);h++)if(s[h]===1){r.setBitXY(l,a);break}}}return r}function qa(t={}){let{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=t;if(this.checkProcessable("erode",{bitDepth:[1,8,16],components:1,alpha:0}),r.columns%2===0||r.rows%2===0)throw new TypeError("erode: The number of rows and columns of the kernel must be odd");let i=!0;t:for(let o of r)for(let s of o)if(s!==1){i=!1;break t}let n=this;for(let o=0;o<e;o++)if(this.bitDepth===1)if(i){let s=n.clone();n=Sb(n,s,r.length,r[0].length)}else{let s=L.createFrom(n);n=Ab(n,s,r)}else if(i){let s=L.createFrom(n);n=kb(n,s,r.length,r[0].length)}else{let s=L.createFrom(n);n=Eb(n,s,r)}return n}function Eb(t,r,e){let i=e.length,n=e[0].length,o=(i-1)/2,s=(n-1)/2;for(let a=0;a<t.height;a++)for(let l=0;l<t.width;l++){let h=t.maxValue;for(let f=0;f<n;f++)for(let c=0;c<i;c++){if(e[c][f]!==1)continue;let u=c-o+l,d=f-s+a;if(u<0||d<0||u>=t.width||d>=t.height)continue;let p=t.getValueXY(u,d,0);p<h&&(h=p)}r.setValueXY(l,a,0,h)}return r}function kb(t,r,e,i){let n=(e-1)/2,o=(i-1)/2,s=[];for(let a=0;a<t.width;a++)s.push(0);for(let a=0;a<t.height;a++){for(let l=0;l<t.width;l++){let h=t.maxValue;for(let f=Math.max(0,a-o);f<Math.min(t.height,a+o+1);f++){let c=t.getValueXY(l,f,0);c<h&&(h=c)}s[l]=h}for(let l=0;l<t.width;l++){let h=t.maxValue;for(let f=Math.max(0,l-n);f<Math.min(t.width,l+n+1);f++)s[f]<h&&(h=s[f]);r.setValueXY(l,a,0,h)}}return r}function Ab(t,r,e){let i=e.length,n=e[0].length,o=(i-1)/2,s=(n-1)/2;for(let a=0;a<t.height;a++)for(let l=0;l<t.width;l++){let h=1;t:for(let f=0;f<n;f++)for(let c=0;c<i;c++){if(e[c][f]!==1)continue;let u=c-o+l,d=f-s+a;if(d<0||u<0||u>=t.width||d>=t.height)continue;if(t.getBitXY(u,d)===0){h=0;break t}}h===1&&r.setBitXY(l,a)}return r}function Sb(t,r,e,i){let n=(e-1)/2,o=(i-1)/2,s=[];for(let a=0;a<t.width;a++)s.push(0);for(let a=0;a<t.height;a++){for(let l=0;l<t.width;l++){s[l]=1;for(let h=Math.max(0,a-o);h<Math.min(t.height,a+o+1);h++)if(t.getBitXY(l,h)===0){s[l]=0;break}}for(let l=0;l<t.width;l++)if(r.getBitXY(l,a)!==0){for(let h=Math.max(0,l-n);h<Math.min(t.width,l+n+1);h++)if(s[h]===0){r.clearBitXY(l,a);break}}}return r}function Wa(t={}){let{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=t;if(this.checkProcessable("open",{bitDepth:[8,16],components:1,alpha:0}),r.columns%2===0||r.rows%2===0)throw new TypeError("open: The number of rows and columns of the kernel must be odd");let i=this;for(let n=0;n<e;n++)i=i.erode({kernel:r}),i=i.dilate({kernel:r});return i}function Ka(t={}){let{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=t;if(this.checkProcessable("close",{bitDepth:[1,8,16],components:1,alpha:0}),r.columns%2===0||r.rows%2===0)throw new TypeError("close: The number of rows and columns of the kernel must be odd");let i=this;for(let n=0;n<e;n++)i=i.dilate({kernel:r}).erode({kernel:r});return i}function Ha(t={}){let{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=t;if(this.checkProcessable("topHat",{bitDepth:[8,16],components:1,alpha:0}),r.length%2===0||r[0].length%2===0)throw new TypeError("topHat: The number of rows and columns of the kernel must be odd");let i=this;for(let n=0;n<e;n++)i=i.open({kernel:r}).subtractImage(i,{absolute:!0});return i}function Za(t={}){let{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=t;if(this.checkProcessable("blackHat",{bitDepth:[8,16],components:1,alpha:0}),r.columns%2===0||r.rows%2===0)throw new TypeError("blackHat: The number of rows and columns of the kernel must be odd");let i=this;for(let n=0;n<e;n++)i=i.close({kernel:r}).subtractImage(i,{absolute:!0});return i}function Ja(t={}){let{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=t;if(this.checkProcessable("morphologicalGradient",{bitDepth:[8,16],components:1,alpha:0}),r.columns%2===0||r.rows%2===0)throw new TypeError("morphologicalGradient: The number of rows and columns of the kernel must be odd");let i=this;for(let n=0;n<e;n++){let o=i.dilate({kernel:r}),s=i.erode({kernel:r});i=o.subtractImage(s,{absolute:!0})}return i}function Ib(t){let r=0,e=0,i=0,n=0,o=t[0][0],s=0;for(let h=1;h<t.length;h++)t[h][0]<o&&(o=t[h][0],s=h);let a=t[(s+1)%t.length][0],l=(s+1)%t.length;for(let h=1;h<t.length;h++)t[h][0]<a&&h!==s&&(a=t[h][0],l=h);return t[l][1]<t[s][1]?(r=t[l],n=t[s],s!==(l+1)%4?(e=t[(l+1)%4],i=t[(l+2)%4]):(e=t[(l+2)%4],i=t[(l+3)%4])):(n=t[l],r=t[s],l!==(s+1)%4?(e=t[(s+1)%4],i=t[(s+2)%4]):(e=t[(s+2)%4],i=t[(s+3)%4])),[r,e,i,n]}function ir(t,r){return Math.sqrt(Math.pow(t[0]-r[0],2)+Math.pow(t[1]-r[1],2))}function Nn(t,r){return[t[1]*r[2]-t[2]*r[1],t[2]*r[0]-t[0]*r[2],t[0]*r[1]-t[1]*r[0]]}function Hr(t,r){return t[0]*r[0]+t[1]*r[1]+t[2]*r[2]}function Db(t,r,e,i,n,o){let s=Math.max(ir(t,r),ir(i,e)),a=Math.max(ir(t,i),ir(r,e)),l=0,h=0,f=Math.ceil(n/2),c=Math.ceil(o/2),u=s/a,d=[t[0],t[1],1],p=[r[0],r[1],1],g=[i[0],i[1],1],x=[e[0],e[1],1],m=Hr(Nn(d,x),g)/Hr(Nn(p,x),g),w=Hr(Nn(d,x),p)/Hr(Nn(g,x),p),y=[m*p[0]-d[0],m*p[1]-d[1],m*p[2]-d[2]],M=[w*g[0]-d[0],w*g[1]-d[1],w*g[2]-d[2]],_=y[0],T=y[1],E=y[2],A=M[0],D=M[1],b=M[2],k=1/(E*b)*(_*A-(_*b+E*A)*f+E*b*f*f+(T*D-(T*b+E*D)*c+E*b*c*c));k>=0?k=Math.sqrt(k):k=Math.sqrt(-k);let C=new fe([[k,0,f],[0,k,c],[0,0,1]]),S=C.transpose(),X=ya(S),B=ya(C),j=fe.rowVector(y),Z=fe.rowVector(M),tt=Math.sqrt(Hr(j.mmul(X).mmul(B).to1DArray(),y)/Hr(Z.mmul(X).mmul(B).to1DArray(),M));return tt===0||u===0?(l=Math.ceil(s),h=Math.ceil(a)):tt<u?(l=Math.ceil(s),h=Math.ceil(l/tt)):(h=Math.ceil(a),l=Math.ceil(tt*h)),[l,h]}function Tb(t,r,e,i,n,o,s,a,l,h,f,c){let[u,d]=[(e*t+i*r+n)/(l*t+h*r+1),(o*t+s*r+a)/(l*t+h*r+1)];return f.getValueXY(Math.floor(u),Math.floor(d),c)}function Qa(t,r={}){let{calculateRatio:e=!0}=r;if(t.length!==4)throw new Error(`The array pts must have four elements, which are the four corners. Currently, pts have ${t.length} elements`);let[i,n,o,s]=t,a=[i,n,o,s],[l,h,f,c]=Ib(a),u,d;e?[u,d]=Db(l,h,f,c,this.width,this.height):(u=Math.ceil(Math.max(ir(l,h),ir(c,f))),d=Math.ceil(Math.max(ir(l,c),ir(h,f))));let p=L.createFrom(this,{width:u,height:d}),[g,x]=l,[m,w]=h,[y,M]=f,[_,T]=c,[E,A]=[0,0],[D,b]=[0,u-1],[k,C]=[d-1,u-1],[S,X]=[d-1,0],B=new fe([[E,A,1,0,0,0,-E*g,-A*g],[D,b,1,0,0,0,-D*m,-b*m],[k,C,1,0,0,0,-k*y,-A*y],[S,X,1,0,0,0,-S*_,-X*_],[0,0,0,E,A,1,-E*x,-A*x],[0,0,0,D,b,1,-D*w,-b*w],[0,0,0,k,C,1,-k*M,-C*M],[0,0,0,S,X,1,-S*T,-X*T]]),j=fe.columnVector([g,m,y,_,x,w,M,T]),tt=new id(B).solve(j),[rt,ht,at,nt,Y,P,V,st]=tt.to1DArray(),J=new fe(d,u);for(let ft=0;ft<this.channels;ft++){for(let ct=0;ct<d;ct++)for(let ot=0;ot<u;ot++)J.set(ct,ot,Tb(ct,ot,rt,ht,at,nt,Y,P,V,st,this,ft));p.setMatrix(J,{channel:ft})}return p}function tl(t={}){let{x:r=0,y:e=0,width:i=this.width-r,height:n=this.height-e}=t;if(this.checkProcessable("crop",{bitDepth:[1,8,16]}),r=Math.round(r),e=Math.round(e),i=Math.round(i),n=Math.round(n),r>this.width-1||e>this.height-1)throw new RangeError(`crop: origin (x:${r}, y:${e}) out of range (${this.width-1}; ${this.height-1})`);if(i<=0||n<=0)throw new RangeError(`crop: width and height (width:${i}; height:${n}) must be positive numbers`);if(r<0||e<0)throw new RangeError(`crop: x and y (x:${r}, y:${e}) must be positive numbers`);if(i>this.width-r||n>this.height-e)throw new RangeError(`crop: (x: ${r}, y:${e}, width:${i}, height:${n}) size is out of range`);let o=this;if(this.bitDepth===1){let s=new L(i,n,{kind:"BINARY",parent:this});o=Pb(this,s,r,e,i,n)}else{let s=L.createFrom(this,{width:i,height:n,position:[r,e]});o=Rb(this,s,r,e,i,n)}return o}function Rb(t,r,e,i,n,o){let s=n*t.channels,a=i+o,l=0,h=e*t.channels;for(let f=i;f<a;f++){let c=f*t.width*t.channels+h,u=c+s;for(;c<u;c++)r.data[l++]=t.data[c]}return r}function Pb(t,r,e,i,n,o){let s=n*t.channels,a=i+o,l=0,h=e*t.channels;for(let f=i;f<a;f++){let c=f*t.width*t.channels+h,u=c+s;for(;c<u;c++)t.getBit(c)&&r.setBit(l),++l}return r}function el(t={}){this.checkProcessable("cropAlpha",{alpha:1});let{threshold:r=this.maxValue}=t,e=Cb(this,r,this.components);if(e===-1)throw new Error("Could not find new dimensions. Threshold may be too high.");let i=Fb(this,r,this.components,e),n=Bb(this,r,this.components,e),o=Lb(this,r,this.components,e,i,n);return this.crop({x:e,y:i,width:o-e+1,height:n-i+1})}function Cb(t,r,e){for(let i=0;i<t.width;i++)for(let n=0;n<t.height;n++)if(t.getValueXY(i,n,e)>=r)return i;return-1}function Fb(t,r,e,i){for(let n=0;n<t.height;n++)for(let o=i;o<t.width;o++)if(t.getValueXY(o,n,e)>=r)return n;return-1}function Bb(t,r,e,i){for(let n=t.height-1;n>=0;n--)for(let o=i;o<t.width;o++)if(t.getValueXY(o,n,e)>=r)return n;return-1}function Lb(t,r,e,i,n,o){for(let s=t.width-1;s>=i;s--)for(let a=n;a<=o;a++)if(t.getValueXY(s,a,e)>=r)return s;return-1}function Ob(t){if(typeof t=="string"){let r=t[t.length-1];t=parseFloat(t),r==="%"&&(t/=100)}return t}function Ld(t,r){if(!r)throw Error("getThreshold : the maxValue should be specified");if(typeof t=="string"){if(t[t.length-1]!=="%")throw Error("getThreshold : if the value is a string it must finish by %");return parseFloat(t)/100*r}else{if(typeof t=="number")return t<1?t*r:t;throw Error("getThreshold : the value is not valid")}}function Od(t,r,e){t=Ob(t);let i=Math.round(t*r),n=Math.round(t*e);return i<=0&&(i=1),n<=0&&(n=1),{width:i,height:n}}function Ud(t,r){if(r<0||r>=t.height)throw new RangeError(`row must be included between 0 and ${t.height-1}. Current value: ${r}`)}function Nd(t,r){if(r<0||r>=t.width)throw new RangeError(`column must be included between 0 and ${t.width-1}. Current value: ${r}`)}function Yn(t,r){if(r<0||r>=t.channels)throw new RangeError(`channel must be included between 0 and ${t.channels-1}. Current value: ${r}`)}var ke={nearestneighbor:"nearestNeighbor",nearestneighbour:"nearestNeighbor",bilinear:"bilinear"};function zn(t){if(typeof t!="string")throw new TypeError("interpolation must be a string");if(t=t.toLowerCase(),!ke[t])throw new RangeError(`invalid interpolation algorithm: ${t}`);return ke[t]}function rl(t,r,e){let i=this.width/r,n=this.height/e;if(this.bitDepth>1)for(let o=0;o<r;o++){let s=Math.floor((o+.5)*i);for(let a=0;a<e;a++){let l=Math.floor((a+.5)*n);for(let h=0;h<this.channels;h++)t.setValueXY(o,a,h,this.getValueXY(s,l,h))}}else for(let o=0;o<r;o++){let s=Math.floor((o+.5)*i);for(let a=0;a<e;a++){let l=Math.floor((a+.5)*n);this.getBitXY(s,l)&&t.setBitXY(o,a)}}}function Xn(t={}){let{factor:r=1,interpolation:e=ke.nearestneighbor,preserveAspectRatio:i=!0}=t,n=zn(e),o=t.width,s=t.height;if(o||(s&&i?o=Math.round(s*(this.width/this.height)):o=this.width),s||(i?s=Math.round(o*(this.height/this.width)):s=this.height),{width:o,height:s}=Od(r,o,s),o===this.width&&s===this.height){let f=this.clone();return f.position=[0,0],f}let a=Math.round((this.width-o)/2),l=Math.round((this.height-s)/2),h=L.createFrom(this,{width:o,height:s,position:[a,l]});switch(n){case ke.nearestneighbor:rl.call(this,h,o,s);break;default:throw new Error(`unsupported resize interpolation: ${n}`)}return h}function il(){this.checkProcessable("hsv",{bitDepth:[8,16],alpha:[0,1],colorModel:[Lt]});let t=L.createFrom(this,{colorModel:ki}),r=0,e=this.data;for(let i=0;i<e.length;i+=this.channels){let n=e[i],o=e[i+1],s=e[i+2],a=Math.min(n,o,s),l=Math.max(n,o,s),h=l-a,f=0,c=l===0?0:h/l,u=l;if(l!==a){switch(l){case n:f=(o-s)/h+(o<s?6:0);break;case o:f=(s-n)/h+2;break;case s:f=(n-o)/h+4;break;default:throw new Error("unreachable")}f/=6}t.data[r++]=f*this.maxValue,t.data[r++]=c*this.maxValue,t.data[r++]=u,this.alpha&&(t.data[r++]=e[i+3])}return t}function nl(){this.checkProcessable("hsl",{bitDepth:[8,16],alpha:[0,1],colorModel:[Lt]});let t=L.createFrom(this,{colorModel:Ei}),r=Math.floor(this.maxValue/2),e=0,i=this.data;for(let n=0;n<i.length;n+=this.channels){let o=i[n],s=i[n+1],a=i[n+2],l=Math.max(o,s,a),h=Math.min(o,s,a),f=0,c=0,u=(l+h)/2;if(l!==h){let d=l-h;switch(c=u>r?d/(2-l-h):d/(l+h),l){case o:f=(s-a)/d+(s<a?6:0);break;case s:f=(a-o)/d+2;break;case a:f=(o-s)/d+4;break;default:throw new Error("unreachable")}f/=6}t.data[e++]=f*this.maxValue,t.data[e++]=c*this.maxValue,t.data[e++]=u,this.alpha&&(t.data[e++]=i[n+3])}return t}function ol(){this.checkProcessable("cmyk",{bitDepth:[8,16],alpha:[0,1],colorModel:[Lt]});let t=L.createFrom(this,{components:4,colorModel:Ze}),r=0,e=this.data;for(let i=0;i<e.length;i+=this.channels){let n=e[i],o=e[i+1],s=e[i+2],a=Math.min(this.maxValue-n,this.maxValue-o,this.maxValue-s),l=(this.maxValue-n-a)/(1-a/this.maxValue),h=(this.maxValue-o-a)/(1-a/this.maxValue),f=(this.maxValue-s-a)/(1-a/this.maxValue);t.data[r++]=Math.round(l),t.data[r++]=Math.round(h),t.data[r++]=Math.round(f),t.data[r++]=Math.round(a),this.alpha&&(t.data[r++]=e[i+3])}return t}function sl(){return new L(this.width,this.height,this.getRGBAData(),{kind:"RGBA",parent:this})}var Ot={luma709(t,r,e){return t*6966+r*23436+e*2366>>15},luma601(t,r,e){return t*9798+r*19235+e*3735>>15},maximum(t,r,e){return Math.max(t,r,e)},minimum(t,r,e){return Math.min(t,r,e)},average(t,r,e){return(t+r+e)/3>>0},minmax(t,r,e){return(Math.max(t,r,e)+Math.min(t,r,e))/2},red(t){return t},green(t,r){return r},blue(t,r,e){return e},cyan(t,r,e,i){let n=Ot.black(t,r,e,i);return(i.maxValue-t-n)/(1-n/i.maxValue)>>0},magenta(t,r,e,i){let n=Ot.black(t,r,e,i);return(i.maxValue-r-n)/(1-n/i.maxValue)>>0},yellow(t,r,e,i){let n=Ot.black(t,r,e,i);return(i.maxValue-e-n)/(1-n/i.maxValue)>>0},black(t,r,e,i){return Math.min(i.maxValue-t,i.maxValue-r,i.maxValue-e)},hue(t,r,e,i){let n=Ot.min(t,r,e),o=Ot.max(t,r,e);if(o===n)return 0;let s=0,a=o-n;switch(o){case t:s=(r-e)/a+(r<e?6:0);break;case r:s=(e-t)/a+2;break;case e:s=(t-r)/a+4;break;default:throw new Error("unreachable")}return s/6*i.maxValue>>0},saturation(t,r,e,i){let n=Ot.min(t,r,e),o=Ot.max(t,r,e),s=o-n;return o===0?0:s/o*i.maxValue},lightness(t,r,e){let i=Ot.min(t,r,e);return(Ot.max(t,r,e)+i)/2}};Object.defineProperty(Ot,"luminosity",{enumerable:!1,value:Ot.lightness});Object.defineProperty(Ot,"luminance",{enumerable:!1,value:Ot.lightness});Object.defineProperty(Ot,"min",{enumerable:!1,value:Ot.minimum});Object.defineProperty(Ot,"max",{enumerable:!1,value:Ot.maximum});Object.defineProperty(Ot,"brightness",{enumerable:!1,value:Ot.maximum});var Yd={};Object.keys(Ot).forEach(t=>{Yd[t]=t});function jn(t={}){let{algorithm:r="luma709",keepAlpha:e=!1,mergeAlpha:i=!0}=t;if(typeof r!="string"&&typeof r!="function")throw new TypeError("algorithm must be a string or a function");this.checkProcessable("grey",{bitDepth:[8,16],alpha:[0,1]}),this.components===1&&(r="red"),e&=this.alpha,i&=this.alpha,e&&(i=!1);let n=Vs(this,t,{components:1,alpha:e,colorModel:Wt}),o;if(typeof r=="function")o=r;else if(o=Ot[r.toLowerCase()],!o)throw new Error(`unsupported grey algorithm: ${r}`);let s=0;for(let a=0;a<this.data.length;a+=this.channels)i?n.data[s++]=Di(o(this.data[a],this.data[a+1],this.data[a+2],this)*this.data[a+this.components]/this.maxValue,this):(n.data[s++]=Di(o(this.data[a],this.data[a+1],this.data[a+2],this),this),n.alpha&&(n.data[s++]=this.data[a+this.components]));return n}function al(t){let r=0;for(let f=0;f<t.length;f++)if(t[f]!==0){r=f;break}let e=t.length-1;for(let f=t.length-1;f>=r;f--)if(t[f]!==0){e=f;break}let i=1/(e-r),n=new Array(t.length),o=0,s=0;for(let f=r;f<t.length;f++)o+=f*t[f],s+=t[f],n[f]=o/s;let a=new Array(t.length);o=s=0;for(let f=e;f>0;f--)o+=f*t[f],s+=t[f],a[f-1]=o/s;let l=-1,h=Number.MAX_VALUE;for(let f=0;f<t.length;f++){let c=0,u;for(let d=0;d<=f;d++)u=1/(1+i*Math.abs(d-n[f])),u<1e-6||u>.999999||(c+=t[d]*(-u*Math.log(u)-(1-u)*Math.log(1-u)));for(let d=f+1;d<t.length;d++)u=1/(1+i*Math.abs(d-a[f])),u<1e-6||u>.999999||(c+=t[d]*(-u*Math.log(u)-(1-u)*Math.log(1-u)));c<h&&(h=c,l=f)}return l}function ll(t){let r=t.slice(),e=0;for(;!Ub(r);){let n=0,o=0,s=r[0];for(let a=0;a<t.length-1;a++)n=o,o=s,s=r[a+1],r[a]=(n+o+s)/3;if(r[t.length-1]=(o+s)/3,e++,e>1e4)throw new Error("Intermodes Threshold not found after 10000 iterations")}let i=0;for(let n=1;n<t.length-1;n++)r[n-1]<r[n]&&r[n+1]<r[n]&&(i+=n);return Math.floor(i/2)}function Ub(t){let r=!1,e=0;for(let i=1;i<t.length-1;i++)if(t[i-1]<t[i]&&t[i+1]<t[i]&&(e++,e>2))return!1;return e===2&&(r=!0),r}function hl(t){let r,e,i,n,o=0;for(let s=1;s<t.length;s++)if(t[s]>0){o=s+1;break}for(;;){r=0,i=0;for(let s=0;s<o;s++)i=i+t[s],r=r+t[s]*s;n=0,e=0;for(let s=o+1;s<t.length;s++)e+=t[s],n+=t[s]*s;if(i>0&&e>0&&(r/=i,n/=e,o===Math.round((r+n)/2)))break;if(o++,o>t.length-2)throw new Error("Threshold not found")}return o}function fl(t,r){let e,i,n,o,s,a,l,h,f,c,u,d;u=.5,c=0;for(let p=0;p<t.length;p++)c+=p*t[p];c/=r,l=c;do{a=l,e=a+.5|0,i=0,o=0;for(let p=0;p<=e;p++)i+=p*t[p],o+=t[p];h=o===0?0:i/o,n=0,s=0;for(let p=e+1;p<t.length;p++)n+=p*t[p],s+=t[p];f=s===0?0:n/s,d=(h-f)/(Math.log(h)-Math.log(f)),d<-Number.EPSILON?l=d-.5|0:l=d+.5|0}while(Math.abs(l-a)>u);return e}function cl(t,r){let e=new Array(t.length);for(let u=0;u<t.length;u++)e[u]=t[u]/r;let i=new Array(t.length),n=new Array(t.length);i[0]=e[0],n[0]=1-i[0];for(let u=1;u<t.length;u++)i[u]=i[u-1]+e[u],n[u]=1-i[u];let o=0;for(let u=0;u<t.length;u++)if(Math.abs(i[u])>=Number.EPSILON){o=u;break}let s=t.length-1;for(let u=t.length-1;u>=o;u--)if(Math.abs(n[u])>=Number.EPSILON){s=u;break}let a=-1,l,h=Number.MIN_VALUE,f,c;for(let u=o;u<=s;u++){f=0;for(let d=0;d<=u;d++)t[d]!==0&&(f-=e[d]/i[u]*Math.log(e[d]/i[u]));c=0;for(let d=u+1;d<t.length;d++)t[d]!==0&&(c-=e[d]/n[u]*Math.log(e[d]/n[u]));l=f+c,h<l&&(h=l,a=u)}return a}function ul(t,r){let e=0;for(let i=0;i<t.length;i++)e+=i*t[i];return Math.floor(e/r)}function dl(t,r){let e,i=-2,n,o,s,a,l,h,f,c,u,d,p,g=0;for(let x=0;x<t.length;x++)g+=x*t[x];for(g/=r,e=g;e!==i;){let x=zd(t,e),m=zd(t,t.length-1),w=Xd(t,e),y=Xd(t,t.length-1),M=jd(t,e),_=jd(t,t.length-1);if(n=w/x,o=(y-w)/(m-x),s=x/m,a=(m-x)/m,l=M/x-n*n,h=(_-M)/(m-x)-o*o,f=1/l-1/h,c=n/l-o/h,u=n*n/l-o*o/h+Math.log10(l*(a*a)/(h*(s*s))),d=c*c-f*u,d<0)return e;i=e,p=(c+Math.sqrt(d))/f,isNaN(p)?e=i:e=Math.floor(p)}return e}function zd(t,r){let e=0;for(let i=0;i<=r;i++)e+=t[i];return e}function Xd(t,r){let e=0;for(let i=0;i<=r;i++)e+=i*t[i];return e}function jd(t,r){let e=0;for(let i=0;i<=r;i++)e+=i*i*t[i];return e}function pl(t){if(t.length<2)return 0;let r=0,e=-1,i=-1,n=new Array(t.length);for(let o=0;o<t.length;o++)n[o]=t[o],t[o]>0&&(i=o);for(;!zb(n);)if(n=Nb(n),r++,r>1e4)return e;return e=Yb(n,i),e}function Nb(t){let r=new Array(t.length);for(let e=1;e<t.length-1;e++)r[e]=(t[e-1]+t[e]+t[e+1])/3;return r[0]=(t[0]+t[1])/3,r[t.length-1]=(t[t.length-2]+t[t.length-1])/3,r}function Yb(t,r){let e;for(let i=1;i<r;i++)if(t[i-1]>t[i]&&t[i+1]>=t[i]){e=i;break}return e}function zb(t){let r=t.length,e=!1,i=0;for(let n=1;n<r-1;n++)if(t[n-1]<t[n]&&t[n+1]<t[n]&&(i++,i>2))return!1;return i===2&&(e=!0),e}function ml(t,r){let e=1,i=0,n=0,o=0,s=0,a,l,h,f,c,u,d=-1,p=t.length,g=new Array(p);for(let x=0;x<p;x++)g[x]=t[x]/r;for(let x=0;x<p;x++)i+=x*g[x],n+=x*x*g[x],o+=x*x*x*g[x];l=e*n-i*i,h=(-n*n+i*o)/l,f=(e*-o+n*i)/l,c=.5*(-f-Math.sqrt(f*f-4*h)),u=.5*(-f+Math.sqrt(f*f-4*h)),a=(u-i)/(u-c);for(let x=0;x<p;x++)if(s+=g[x],s>a){d=x;break}return d}function gl(t,r){let e=0,i=0,n=0,o=0,s=0;for(let a=0;a<t.length;a++)s+=a*t[a];for(let a=0;a<t.length;a++){i=i+t[a];let l=r-i;if(i===0||l===0)continue;e=e+a*t[a];let h=(s-e)/l,f=i*l*(e/i-h)*(e/i-h);f>=n&&(o=a,n=f)}return o}function xl(t){let r=-1,e=.5,i=new Array(t.length),n=Gd(t,t.length-1),o=1;for(let s=0;s<t.length;s++)i[s]=Math.abs(Gd(t,s)/n-e),i[s]<o&&(o=i[s],r=s);return r}function Gd(t,r){let e=0;for(let i=0;i<=r;i++)e+=t[i];return e}function wl(t,r){let e,i,n,o=new Array(t.length),s=new Array(t.length),a=new Array(t.length),l=0,h=0,f=0,c=0,u=0,d=0,g=1/(1-.5),m=1/(1-2);for(let _=0;_<t.length;_++)o[_]=t[_]/r;s[0]=o[0],a[0]=1-s[0];for(let _=1;_<t.length;_++)s[_]=s[_-1]+o[_],a[_]=1-s[_];i=0;for(let _=0;_<t.length;_++)if(Math.abs(s[_])>=Number.EPSILON){i=_;break}n=t.length-1;for(let _=t.length-1;_>=i;_--)if(Math.abs(a[_])>=Number.EPSILON){n=_;break}for(let _=i;_<=n;_++){let T=0,E=0,A=0;for(let B=0;B<=_;B++)t[B]!==0&&(T-=o[B]/s[_]*Math.log(o[B]/s[_])),E+=Math.sqrt(o[B]/s[_]),A+=o[B]*o[B]/(s[_]*s[_]);let D=0,b=0,k=0;for(let B=_+1;B<t.length;B++)t[B]!==0&&(D-=o[B]/a[_]*Math.log(o[B]/a[_])),b+=Math.sqrt(o[B]/a[_]),k+=o[B]*o[B]/(a[_]*a[_]);let C=T+D,S=g*(E*b>0?Math.log(E*b):0),X=m*(A*k>0?Math.log(A*k):0);C>c&&(c=C,l=_),S>u&&(u=S,h=_),X>d&&(d=X,f=_)}let w=[l,h,f];w.sort((_,T)=>_-T);let y;Math.abs(w[0]-w[1])<=5?Math.abs(w[1]-w[2])<=5?y=[1,2,1]:y=[0,1,3]:Math.abs(w[1]-w[2])<=5?y=[3,1,0]:y=[1,2,1];let M=s[w[2]]-s[w[0]];return e=Math.round(w[0]*(s[w[0]]+.25*M*y[0])+.25*w[1]*M*y[1]+w[2]*(a[w[2]]+.25*M*y[2])),e}function bl(t,r){let e=new Array(t.length);for(let d=0;d<t.length;d++)e[d]=t[d]/r;let i=new Array(t.length),n=new Array(t.length);i[0]=e[0],n[0]=1-i[0];for(let d=1;d<t.length;d++)i[d]=i[d-1]+e[d],n[d]=1-i[d];let o=0;for(let d=0;d<t.length;d++)if(Math.abs(i[d])>=Number.EPSILON){o=d;break}let s=t.length-1;for(let d=t.length-1;d>=o;d--)if(Math.abs(n[d])>=Number.EPSILON){s=d;break}let a=-1,l=Number.MAX_VALUE,h,f,c,u;for(let d=o;d<=s;d++){c=0,h=.5/i[d];for(let p=1;p<=d;p++)c-=e[p]*Math.log(1-h*i[p-1]);c*=h,u=0,h=.5/n[d];for(let p=d+1;p<t.length;p++)u-=e[p]*Math.log(1-h*n[p]);u*=h,f=Math.abs(c-u),f<l&&(l=f,a=d)}return a}function yl(t){let r=0,e=0,i=0,n=0;for(let c=0;c<t.length;c++)if(t[c]>0){r=c;break}r>0&&r--;for(let c=t.length-1;c>0;c--)if(t[c]>0){n=c;break}n<t.length-1&&n++;for(let c=0;c<t.length;c++)t[c]>e&&(i=c,e=t[c]);let o=!1;if(i-r<n-i){o=!0;let c=0,u=t.length-1;for(;c<u;){let d=t[c];t[c]=t[u],t[u]=d,c++,u--}r=t.length-1-n,i=t.length-1-i}if(r===i)return r;let s,a,l;s=t[i],a=r-i,l=Math.sqrt(s*s+a*a),s/=l,a/=l,l=s*r+a*t[r];let h=r,f=0;for(let c=r+1;c<=i;c++){let u=s*c+a*t[c]-l;u>f&&(h=c,f=u)}if(h--,o){let c=0,u=t.length-1;for(;c<u;){let d=t[c];t[c]=t[u],t[u]=d,c++,u--}return t.length-1-h}else return h}function vl(t,r){let e=new Array(t.length);for(let h=0;h<t.length;h++)e[h]=t[h]/r;let i=new Array(t.length);i[0]=e[0];for(let h=1;h<t.length;h++)i[h]=i[h-1]+e[h];let n=new Array(t.length);n[0]=e[0]*e[0];for(let h=1;h<t.length;h++)n[h]=n[h-1]+e[h]*e[h];let o=new Array(t.length);o[t.length-1]=0;for(let h=t.length-2;h>=0;h--)o[h]=o[h+1]+e[h+1]*e[h+1];let s=-1,a=Number.MIN_VALUE,l;for(let h=0;h<t.length;h++)l=-1*(n[h]*o[h]>0?Math.log(n[h]*o[h]):0)+2*(i[h]*(1-i[h])>0?Math.log(i[h]*(1-i[h])):0),l>a&&(a=l,s=h);return s}var _l={huang:al,intermodes:ll,isodata:hl,li:fl,maxentropy:cl,mean:ul,minerror:dl,minimum:pl,moments:ml,otsu:gl,percentile:xl,renyientropy:wl,shanbhag:bl,triangle:yl,yen:vl},Gn={};Object.keys(_l).forEach(t=>{Gn[t]=t});function Fi(t={}){let{algorithm:r=Gn.otsu}=t;this.checkProcessable("getThreshold",{components:1,bitDepth:[8,16]});let e=_l[r.toLowerCase()];if(e){let i=this.getHistogram();return e(i,this.size)}else throw new Error(`unknown thresholding algorithm: ${r}`)}var Vd="threshold";function Ml(t={}){let{algorithm:r=Vd,threshold:e=.5,useAlpha:i=!0,invert:n=!1}=t;this.checkProcessable("mask",{components:1,bitDepth:[8,16]}),r===Vd?e=Ld(e,this.maxValue):e=Fi.call(this,t);let o=new L(this.width,this.height,{kind:"BINARY",parent:this}),s=0;if(this.alpha&&i)for(let a=0;a<this.data.length;a+=this.channels){let l=this.data[a]+(this.maxValue-this.data[a])*(this.maxValue-this.data[a+1])/this.maxValue;(n&&l<=e||!n&&l>=e)&&o.setBit(s),s++}else for(let a=0;a<this.data.length;a+=this.channels)(n&&this.data[a]<=e||!n&&this.data[a]>=e)&&o.setBit(s),s++;return o}var $d=vt(Pe());function El(t,r,e,i){let n=t.width,o=t.height,s=r.width,a=t.channels;for(let l=0;l<n;l++)for(let h=0;h<o;h++)for(let f=0;f<a;f++){let c=(h*n+l)*a+f,u=((i+h)*s+e+l)*a+f;r.data[u]=t.data[c]}}function kl(t={}){let{size:r=0,algorithm:e="copy",color:i}=t;if(this.checkProcessable("pad",{bitDepth:[8,16]}),e==="set"){if(i.length!==this.channels)throw new Error(`pad: the color array must have the same length as the number of channels. Here: ${this.channels}`);for(let l=0;l<i.length;l++)i[l]===0&&(i[l]=.001)}else i=(0,$d.default)(this.channels,null);Array.isArray(r)||(r=[r,r]);let n=this.width+r[0]*2,o=this.height+r[1]*2,s=this.channels,a=L.createFrom(this,{width:n,height:o});El(this,a,r[0],r[1]);for(let l=r[0];l<n-r[0];l++)for(let h=0;h<s;h++){let f=i[h]||a.data[(r[1]*n+l)*s+h];for(let c=0;c<r[1];c++)a.data[(c*n+l)*s+h]=f;f=i[h]||a.data[((o-r[1]-1)*n+l)*s+h];for(let c=o-r[1];c<o;c++)a.data[(c*n+l)*s+h]=f}for(let l=0;l<o;l++)for(let h=0;h<s;h++){let f=i[h]||a.data[(l*n+r[0])*s+h];for(let c=0;c<r[0];c++)a.data[(l*n+c)*s+h]=f;f=i[h]||a.data[(l*n+n-r[0]-1)*s+h];for(let c=n-r[0];c<n;c++)a.data[(l*n+c)*s+h]=f}return a}function Al(t=8){if(this.checkProcessable("colorDepth",{bitDepth:[1,8,16]}),![8,16].includes(t))throw Error("You need to specify the new colorDepth as 8 or 16");if(this.bitDepth===t)return this.clone();let r=L.createFrom(this,{bitDepth:t});switch(t){case 8:if(this.bitDepth===1)for(let e=0;e<this.size;e++)this.getBit(e)&&(r.data[e]=255);else for(let e=0;e<this.data.length;e++)r.data[e]=this.data[e]>>8;break;case 16:if(this.bitDepth===1)for(let e=0;e<this.size;e++)this.getBit(e)&&(r.data[e]=65535);else for(let e=0;e<this.data.length;e++)r.data[e]=this.data[e]<<8|this.data[e];break;default:throw new Error("colorDepth conversion unexpected case")}return r}function Sl(t,r={}){let{interpolation:e=ke.nearestneighbor,width:i=this.width,height:n=this.height}=r;if(typeof t!="number")throw new TypeError("degrees must be a number");let o=zn(e),s=t*Math.PI/180,a=Math.floor(Math.abs(i*Math.cos(s))+Math.abs(n*Math.sin(s))),l=Math.floor(Math.abs(n*Math.cos(s))+Math.abs(i*Math.sin(s))),h=Math.cos(-s),f=Math.sin(-s),c=a/2,u=l/2;a%2===0?(c=c-.5,l%2===0?u=u-.5:u=Math.floor(u)):(c=Math.floor(c),l%2===0?u=u-.5:u=Math.floor(u));let d=Math.floor(i/2-c),p=Math.floor(n/2-u);if(this.bitDepth===1){let g=new L(a,l,{kind:"BINARY",parent:this});switch(o){case ke.nearestneighbor:return jb(this,g,d,p,c,u,h,f);case ke.bilinear:return Vb(this,g,d,p,c,u,h,f);default:throw new Error(`unsupported rotate interpolation: ${o}`)}}else{let g=L.createFrom(this,{width:a,height:l});switch(o){case ke.nearestneighbor:return Xb(this,g,d,p,c,u,h,f);case ke.bilinear:return Gb(this,g,d,p,c,u,h,f);default:throw new Error(`unsupported rotate interpolation: ${o}`)}}}function Xb(t,r,e,i,n,o,s,a){for(let l=0;l<r.width;l+=1)for(let h=0;h<r.height;h+=1)for(let f=0;f<t.channels;f++){let c=Math.round((l-n)*s-(h-o)*a+n)+e,u=Math.round((h-o)*s+(l-n)*a+o)+i;c<0||c>=t.width||u<0||u>=t.height?t.alpha===1&&f===t.channels-1?r.setValueXY(l,h,f,0):r.setValueXY(l,h,f,t.maxValue):r.setValueXY(l,h,f,t.getValueXY(c,u,f))}return r}function jb(t,r,e,i,n,o,s,a){for(let l=0;l<r.width;l+=1)for(let h=0;h<r.height;h+=1){let f=Math.round((l-n)*s-(h-o)*a+n)+e,c=Math.round((h-o)*s+(l-n)*a+o)+i;(f<0||f>=t.width||c<0||c>=t.height||t.getBitXY(f,c))&&r.setBitXY(l,h)}return r}function Gb(t,r,e,i,n,o,s,a){let l=t.width*t.channels;for(let h=0;h<r.height;h++)for(let f=0;f<r.width;f++){let c=(f-n)*s-(h-o)*a+n+e,u=(h-o)*s+(f-n)*a+o+i,d=c|0,p=u|0,g=c-d,x=u-p;for(let m=0;m<t.channels;m++)if(c<0||c>=t.width||u<0||u>=t.height)t.alpha===1&&m===t.channels-1?r.setValueXY(f,h,m,0):r.setValueXY(f,h,m,t.maxValue);else{let w=(p*t.width+d)*t.channels+m,y=t.data[w],M=t.data[w+t.channels],_=t.data[w+l],T=t.data[w+l+t.channels],E=y+g*(M-y)+x*(_-y)+g*x*(y-M-_+T)|0;r.setValueXY(f,h,m,E)}}return r}function Vb(t,r,e,i,n,o,s,a){let l=t.width;for(let h=0;h<r.height;h++)for(let f=0;f<r.width;f++){let c=(f-n)*s-(h-o)*a+n+e,u=(h-o)*s+(f-n)*a+o+i,d=c|0,p=u|0,g=c-d,x=u-p;if(c<0||c>=t.width||u<0||u>=t.height)r.setBitXY(f,h);else{let m=p*t.width+d,w=t.getBit(m),y=t.getBit(m+1),M=t.getBit(m+l),_=t.getBit(m+1+l);(w|g&y-w|x&M-w|g&x&w-y-M+_)>0&&r.setBitXY(f,h)}}return r}function qd(t,r){if(this.checkProcessable("rotate",{bitDepth:[1,8,16]}),typeof t!="number")throw new TypeError("angle must be a number");switch(t<0&&(t=Math.ceil(-t/360)*360+t),t%360){case 0:return this.clone();case 90:return Dl.call(this);case 180:return $b.call(this);case 270:return Il.call(this);default:return Sl.call(this,t,r)}}function Il(){if(this.bitDepth===1){let t=new L(this.height,this.width,{kind:"BINARY",parent:this}),r=t.height-1;for(let e=0;e<this.height;e++)for(let i=0;i<this.width;i++)this.getBitXY(i,e)&&t.setBitXY(e,r-i);return t}else{let t=L.createFrom(this,{width:this.height,height:this.width}),r=t.height-1;for(let e=0;e<this.height;e++)for(let i=0;i<this.width;i++)for(let n=0;n<this.channels;n++)t.setValueXY(e,r-i,n,this.getValueXY(i,e,n));return t}}function Dl(){if(this.bitDepth===1){let t=new L(this.height,this.width,{kind:"BINARY",parent:this}),r=t.width-1;for(let e=0;e<this.height;e++)for(let i=0;i<this.width;i++)this.getBitXY(i,e)&&t.setBitXY(r-e,i);return t}else{let t=L.createFrom(this,{width:this.height,height:this.width}),r=t.width-1;for(let e=0;e<this.height;e++)for(let i=0;i<this.width;i++)for(let n=0;n<this.channels;n++)t.setValueXY(r-e,i,n,this.getValueXY(i,e,n));return t}}function $b(){if(this.bitDepth===1){let t=new L(this.width,this.height,{kind:"BINARY",parent:this}),r=t.width-1,e=t.height-1;for(let i=0;i<this.height;i++)for(let n=0;n<this.width;n++)this.getBitXY(n,i)&&t.setBitXY(r-n,e-i);return t}else{let t=L.createFrom(this),r=t.width-1,e=t.height-1;for(let i=0;i<this.height;i++)for(let n=0;n<this.width;n++)for(let o=0;o<this.channels;o++)t.setValueXY(r-n,e-i,o,this.getValueXY(n,i,o));return t}}function Tl(t,r={}){let e=yr(t);this.checkProcessable("insert",e);let{x:i=0,y:n=0}=r,o=Gr(this,r,{copy:!0}),s=Math.min(o.height,n+t.height),a=Math.min(o.width,i+t.width);if(o.bitDepth===1)for(let l=n;l<s;l++)for(let h=i;h<a;h++)t.getBitXY(h-i,l-n)?o.setBitXY(h,l):o.clearBitXY(h,l);else for(let l=n;l<s;l++)for(let h=i;h<a;h++)o.setPixelXY(h,l,t.getPixelXY(h-i,l-n));return o}var Wd=vt(Pe());function Rl(t={}){let{size:r=0,algorithm:e="copy",color:i}=t;if(this.checkProcessable("setBorder",{bitDepth:[8,16,32,64]}),e==="set"){if(i.length!==this.channels)throw new Error(`setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`);for(let a=0;a<i.length;a++)i[a]===0&&(i[a]=.001)}else i=(0,Wd.default)(this.channels,null);Array.isArray(r)||(r=[r,r]);let n=r[0],o=r[1],s=this.channels;for(let a=n;a<this.width-n;a++)for(let l=0;l<s;l++){let h=i[l]||this.data[(a+this.width*o)*s+l];for(let f=0;f<o;f++)this.data[(f*this.width+a)*s+l]=h;h=i[l]||this.data[(a+this.width*(this.height-o-1))*s+l];for(let f=this.height-o;f<this.height;f++)this.data[(f*this.width+a)*s+l]=h}for(let a=0;a<this.height;a++)for(let l=0;l<s;l++){let h=i[l]||this.data[(a*this.width+n)*s+l];for(let f=0;f<n;f++)this.data[(a*this.width+f)*s+l]=h;h=i[l]||this.data[(a*this.width+this.width-n-1)*s+l];for(let f=this.width-n;f<this.width;f++)this.data[(a*this.width+f)*s+l]=h}return this}function Pl(t={}){let{preserveAlpha:r=!0}=t;if(this.checkProcessable("split",{bitDepth:[8,16]}),this.components===1)return new ae([this.clone()]);let e=new ae,i=this.data;if(this.alpha&&r)for(let n=0;n<this.components;n++){let o=L.createFrom(this,{components:1,alpha:!0,colorModel:Wt}),s=0;for(let a=0;a<i.length;a+=this.channels)o.data[s++]=i[a+n],o.data[s++]=i[a+this.components];e.push(o)}else for(let n=0;n<this.channels;n++){let o=L.createFrom(this,{components:1,alpha:!1,colorModel:Wt}),s=0;for(let a=0;a<i.length;a+=this.channels)o.data[s++]=i[a+n];e.push(o)}return e}function Cl(t,r={}){let{keepAlpha:e=!1,mergeAlpha:i=!1}=r;e&=this.alpha,i&=this.alpha,this.checkProcessable("getChannel",{bitDepth:[8,16]}),t=Ii(this,t);let n=L.createFrom(this,{components:1,alpha:e,colorModel:Wt}),o=0;for(let s=0;s<this.data.length;s+=this.channels)i?n.data[o++]=this.data[s+t]*this.data[s+this.components]/this.maxValue:(n.data[o++]=this.data[s+t],e&&(n.data[o++]=this.data[s+this.components]));return n}function Fl(t=qb,r={}){let{mergeAlpha:e=!1,keepAlpha:i=!1}=r;e&=this.alpha,i&=this.alpha,this.checkProcessable("combineChannels",{bitDepth:[8,16]});let n=L.createFrom(this,{components:1,alpha:i,colorModel:Wt}),o=0;for(let s=0;s<this.size;s++){let a=t(this.getPixel(s));e?n.data[o++]=a*this.data[s*this.channels+this.components]/this.maxValue:(n.data[o++]=a,i&&(n.data[o++]=this.data[s*this.channels+this.components]))}return n}function qb(t){return(t[0]+t[1]+t[2])/3}function Bl(t,r){if(this.checkProcessable("setChannel",{bitDepth:[8,16]}),r.checkProcessable("setChannel (image parameter check)",{bitDepth:[this.bitDepth],alpha:[0],components:[1]}),r.width!==this.width||r.height!==this.height)throw new Error("Images must have exactly the same width and height");t=Ii(this,t);let e=t;for(let i=0;i<r.data.length;i++)this.data[e]=r.data[i],e+=this.channels;return this}var Kd=vt(Pe());function Ll(t,r={}){let{shift:e=[0,0],average:i,channels:n,defaultAlpha:o,normalize:s,border:a=[0,0]}=r;if(this.checkProcessable("getSimilarity",{bitDepth:[8,16]}),Array.isArray(a)||(a=[a,a]),n=zt(this,{channels:n,defaultAlpha:o}),this.bitDepth!==t.bitDepth)throw new Error("Both images must have the same bitDepth");if(this.channels!==t.channels)throw new Error("Both images must have the same number of channels");if(this.colorModel!==t.colorModel)throw new Error("Both images must have the same colorModel");typeof i=="undefined"&&(i=!0);let l=Math.max(a[0],-e[0]),h=Math.min(this.width-a[0],this.width-e[0]),f=Math.max(a[1],-e[1]),c=Math.min(this.height-a[1],this.height-e[1]),u=(0,Kd.default)(n.length,0);for(let d=0;d<n.length;d++){let p=n[d],g=s?this.sum[p]:Math.max(this.sum[p],t.sum[p]),x=s?t.sum[p]:Math.max(this.sum[p],t.sum[p]);if(g!==0&&x!==0)for(let m=l;m<h;m++)for(let w=f;w<c;w++){let y=m*this.multiplierX+w*this.multiplierY+p,M=y+e[0]*this.multiplierX+e[1]*this.multiplierY;u[d]+=Math.min(this.data[y]/g,t.data[M]/x)}}return i?u.reduce((d,p)=>d+p)/u.length:u}function Ol(t={}){let{sampling:r=[10,10],painted:e=!1,mask:i}=t;this.checkProcessable("getPixelsGrid",{bitDepth:[8,16],channels:1}),Array.isArray(r)||(r=[r,r]);let n=r[0],o=r[1],s=[],a=[],l=this.width/n,h=this.height/o,f=Math.floor(l/2);for(let u=0;u<n;u++){let d=Math.floor(h/2);for(let p=0;p<o;p++){let g=Math.round(f),x=Math.round(d);(!i||i.getBitXY(g,x))&&(s.push([g,x]),a.push(this.getPixelXY(g,x))),d+=h}f+=l}let c={xyS:s,zS:a};return e&&(c.painted=this.rgba8().paintPoints(s)),c}function Ar(t,r,e){let i=new Array(t);for(let n=0;n<t;n++)i[n]=new Array(r);if(e)for(let n=0;n<t;n++)for(let o=0;o<r;o++)i[n][o]=e;return i.width=t,i.height=r,Object.setPrototypeOf(i,Ar.prototype),i}Ar.prototype.localMin=function(t,r){let e=this[t][r],i=[t,r];for(let n=Math.max(0,t-1);n<Math.min(this.length,t+2);n++)for(let o=Math.max(0,r-1);o<Math.min(this[0].length,r+2);o++)this[n][o]<e&&(e=this[n][o],i=[n,o]);return{position:i,value:e}};Ar.prototype.localMax=function(t,r){let e=this[t][r],i=[t,r];for(let n=Math.max(0,t-1);n<Math.min(this.length,t+2);n++)for(let o=Math.max(0,r-1);o<Math.min(this[0].length,r+2);o++)this[n][o]>e&&(e=this[n][o],i=[n,o]);return{position:i,value:e}};Ar.prototype.localSearch=function(t,r,e){let i=[];for(let n=Math.max(0,t-1);n<Math.min(this.length,t+2);n++)for(let o=Math.max(0,r-1);o<Math.min(this[0].length,r+2);o++)this[n][o]===e&&i.push([n,o]);return i};function Ul(t,r={}){let{border:e}=r;if(this.checkProcessable("getChannel",{bitDepth:[8,16]}),this.bitDepth!==t.bitDepth)throw new Error("Both images must have the same bitDepth");if(this.channels!==t.channels)throw new Error("Both images must have the same number of channels");if(this.colorModel!==t.colorModel)throw new Error("Both images must have the same colorModel");let i=new Ar(t.width,t.height,-1/0),n=Math.floor(t.width/2),o=Math.floor(t.height/2),s=n,a=o,l=!1;for(;!l;){let h=i.localSearch(n,o,-1/0);for(let c=0;c<h.length;c++){let u=h[c],d=this.getSimilarity(t,{border:e,shift:[s-u[0],a-u[1]]});i[u[0]][u[1]]=d}let f=i.localMax(n,o);f.position[0]!==n||f.position[1]!==o?(n=f.position[0],o=f.position[1]):l=!0}return[n-s,o-a]}function Nl(t,r=0){this.checkProcessable("getRow",{bitDepth:[8,16]}),Ud(this,t),Yn(this,r);let e=new Array(this.width),i=0,n=t*this.width*this.channels+r,o=n+this.width*this.channels;for(let s=n;s<o;s+=this.channels)e[i++]=this.data[s];return e}function Yl(t,r=0){this.checkProcessable("getColumn",{bitDepth:[8,16]}),Nd(this,t),Yn(this,r);let e=new Array(this.height),i=0,n=this.width*this.channels;for(let o=r+t*this.channels;o<this.data.length;o+=n)e[i++]=this.data[o];return e}function zl(t={}){let{channel:r}=t;if(this.checkProcessable("getMatrix",{bitDepth:[8,16]}),r===void 0){if(this.components>1)throw new RangeError("You need to define the channel for an image that contains more than one channel");r=0}let e=new fe(this.height,this.width);for(let i=0;i<this.height;i++)for(let n=0;n<this.width;n++)e.set(i,n,this.getValueXY(n,i,r));return e}function Xl(t,r={}){t=new fe(t);let{channel:e}=r;if(this.checkProcessable("getMatrix",{bitDepth:[8,16]}),e===void 0){if(this.components>1)throw new RangeError("You need to define the channel for an image that contains more than one channel");e=0}if(this.width!==t.columns||this.height!==t.rows)throw new RangeError("The size of the matrix must be equal to the size of the image");for(let i=0;i<this.height;i++)for(let n=0;n<this.width;n++)this.setValueXY(n,i,e,t.get(i,n));return this}function jl(){this.checkProcessable("getPixelsArray",{bitDepth:[8,16,32]});let t=new Array(this.size),r=0;for(let e=0;e<this.data.length;e+=this.channels){let i=new Array(this.components);for(let n=0;n<this.components;n++)i[n]=this.data[e+n];t[r++]=i}return t}function Gl(t){let r=this,e=r.getClosestCommonParent(t),i=r.getRelativePosition(e,{defaultFurther:!0}),n=Hd(r,i),o=t.getRelativePosition(e,{defaultFurther:!0}),s=Hd(t,o),a=Wb(n,s),l={whitePixelsMask1:[],whitePixelsMask2:[],commonWhitePixels:[]};for(let h=0;h<a.length;h++){let f=a[h],c=[f[0]-i[0],f[1]-i[1]],u=[f[0]-o[0],f[1]-o[1]],d=r.getBitXY(c[0],c[1]),p=t.getBitXY(u[0],u[1]);d===1&&p===1&&l.commonWhitePixels.push(f)}for(let h=0;h<n.length;h++){let f,c;h!==0&&(f=Math.floor(h/r.width),c=h%r.width),r.getBitXY(f,c)===1&&l.whitePixelsMask1.push(n[h])}for(let h=0;h<s.length;h++){let f=0,c=0;h!==0&&(f=Math.floor(h/t.width),c=h%t.width),t.getBitXY(f,c)===1&&l.whitePixelsMask2.push(s[h])}return l}function Hd(t,r){let e=[];for(let i=0;i<t.height;i++)for(let n=0;n<t.width;n++){let o=[i,n];e.push([o[0]+r[0],o[1]+r[1]])}return e}function Wb(t,r){let e=0,i=0,n=[];for(;e<t.length&&i<r.length;)t[e][0]===r[i][0]&&t[e][1]===r[i][1]?(n.push(t[e]),e++,i++):t[e][0]<r[i][0]||t[e][0]===r[i][0]&&t[e][1]<r[i][1]?e++:i++;return n}function Vl(t){let r=Zd(this),e=Zd(t),i;if(r>=e?i=Jd(this,r):i=Jd(t,e),r===0||e===0)return i;let n=this,o=t;for(;r!==e;)if(r>e){if(n=n.parent,n===null)return i;r=r-1}else{if(o=o.parent,o===null)return i;e=e-1}for(;n!==o&&n!==null&&o!==null;)if(n=n.parent,o=o.parent,n===null||o===null)return i;return n!==o?i:n}function Zd(t){let r=0,e=t;for(;e.parent!=null;)e=e.parent,r++;return r}function Jd(t,r){let e=t;for(;r>0;)e=e.parent,r=r-1;return e}var Kb={lowThreshold:10,highThreshold:30,gaussianBlur:1.1},Hb=[[-1,0,1],[-2,0,2],[-1,0,1]],Zb=[[-1,-2,-1],[0,0,0],[1,2,1]],Qd={bitDepth:32,mode:"periodic"};function $l(t,r){t.checkProcessable("Canny edge detector",{bitDepth:8,channels:1,components:1}),r=Object.assign({},Kb,r);let e=t.width,i=t.height,n=t.maxValue,o={sigma:r.gaussianBlur,radius:3},s=t.gaussianFilter(o),a=s.convolution(Zb,Qd),l=s.convolution(Hb,Qd),h=l.hypotenuse(a),f=t.constructor,c=new f(e,i,{kind:"GREY",bitDepth:32}),u=new f(e,i,{kind:"GREY",bitDepth:32}),d=new f(e,i,{kind:"GREY"});for(var p=1;p<e-1;p++)for(var g=1;g<i-1;g++){var x=(Math.round(Math.atan2(l.getValueXY(p,g,0),a.getValueXY(p,g,0))*(5/Math.PI))+5)%5;x===0&&(h.getValueXY(p,g,0)<=h.getValueXY(p,g-1,0)||h.getValueXY(p,g,0)<=h.getValueXY(p,g+1,0))||x===1&&(h.getValueXY(p,g,0)<=h.getValueXY(p-1,g+1,0)||h.getValueXY(p,g,0)<=h.getValueXY(p+1,g-1,0))||x===2&&(h.getValueXY(p,g,0)<=h.getValueXY(p-1,g,0)||h.getValueXY(p,g,0)<=h.getValueXY(p+1,g,0))||x===3&&(h.getValueXY(p,g,0)<=h.getValueXY(p-1,g-1,0)||h.getValueXY(p,g,0)<=h.getValueXY(p+1,g+1,0))||c.setValueXY(p,g,0,h.getValueXY(p,g,0))}for(p=0;p<e*i;++p){var m=c.data[p],w=0;m>r.highThreshold&&(w++,d.data[p]=n),m>r.lowThreshold&&w++,u.data[p]=w}var y=[];for(p=1;p<e-1;++p)for(g=1;g<i-1;++g)if(u.getValueXY(p,g,0)===1){t:for(var M=p-1;M<p+2;++M)for(var _=g-1;_<g+2;++_)if(u.getValueXY(M,_,0)===2){y.push([p,g]),d.setValueXY(p,g,0,n);break t}}for(;y.length>0;){var T=[];for(p=0;p<y.length;++p)for(g=-1;g<2;++g)for(M=-1;M<2;++M)if(!(g===0&&M===0)){var E=y[p][0]+g,A=y[p][1]+M;u.getValueXY(E,A,0)===1&&d.getValueXY(E,A,0)===0&&(T.push([E,A]),d.setValueXY(E,A,0,n))}y=T}return d}function ql(t){return $l(this,t)}function Wl(t,r={}){let{position:e}=r;if(this.checkProcessable("extract",{bitDepth:[1,8,16]}),!e&&(e=t.getRelativePosition(this),!e))throw new Error("extract : can not extract an image because the relative position can not be determined, try to specify manually the position as an array of 2 elements [x,y].");if(this.bitDepth>1){let i=L.createFrom(this,{width:t.width,height:t.height,alpha:1,position:e,parent:this});for(let n=0;n<t.width;n++)for(let o=0;o<t.height;o++){for(let s=0;s<this.channels;s++){let a=this.getValueXY(n+e[0],o+e[1],s);i.setValueXY(n,o,s,a)}t.getBitXY(n,o)||i.setValueXY(n,o,this.components,0)}return i}else{let i=L.createFrom(this,{width:t.width,height:t.height,position:e,parent:this});for(let n=0;n<t.height;n++)for(let o=0;o<t.width;o++)t.getBitXY(o,n)&&this.getBitXY(o+e[0],n+e[1])&&i.setBitXY(o,n);return i}}var i1=vt(r1());function Kl(t={}){let{x:r=0,y:e=0,inPlace:i=!0}=t,n=i?this:L.createFrom(this);if(this.checkProcessable("floodFill",{bitDepth:1}),this.getBitXY(r,e))return n;let s=new i1.default;for(s.push(new Bi(r,e));s.length>0;){let a=s.shift();n.setBitXY(a.x,a.y);for(let l=a.x+1;l<this.width&&(!n.getBitXY(l,a.y)&&!this.getBitXY(l,a.y));l++)n.setBitXY(l,a.y),a.y+1<this.height&&!this.getBitXY(l,a.y+1)&&s.push(new Bi(l,a.y+1)),a.y-1>=0&&!this.getBitXY(l,a.y-1)&&s.push(new Bi(l,a.y-1));for(let l=a.x-1;l>=0&&(!n.getBitXY(l,a.y)&&!this.getBitXY(l,a.y));l++)n.setBitXY(l,a.y),a.y+1<this.height&&!this.getBitXY(l,a.y+1)&&s.push(new Bi(l,a.y+1)),a.y-1>=0&&!this.getBitXY(l,a.y-1)&&s.push(new Bi(l,a.y-1))}return n}function Bi(t,r){this.x=t,this.y=r}function Zr(){return Zr=Object.assign?Object.assign.bind():function(t){for(var r=1;r<arguments.length;r++){var e=arguments[r];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i])}return t},Zr.apply(this,arguments)}function Jb(t,r,e){r=r/100,e=e/100;var i=[],n=e*r,o=t/60,s=n*(1-Math.abs(o%2-1)),a=e-n;return o>=0&&o<1?i=[n,s,0]:o>=1&&o<2?i=[s,n,0]:o>=2&&o<3?i=[0,n,s]:t>=3&&o<4?i=[0,s,n]:t>=4&&o<5?i=[s,0,n]:t>=5&&o<=6?i=[n,0,s]:i=[0,0,0],{r:Math.round(255*(i[0]+a)),g:Math.round(255*(i[1]+a)),b:Math.round(255*(i[2]+a))}}function Qb(t,r,e){return r*=(e<50?e:100-e)/100,{h:t,s:2*r/(e+r)*100,v:e+r}}function n1(t,r,e){var i=Qb(t,r,e);return Jb(i.h,i.s,i.v)}var ty={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,132,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,255,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,203],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[119,128,144],slategrey:[119,128,144],snow:[255,255,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,5]};function o1(t){return ey(t)||oy(t)||ny(t)||ry(t)||iy(t)||sy(t)||ay(t)}function ey(t){var r=ty[t.toLowerCase()];if(r)return{r:r[0],g:r[1],b:r[2],a:100}}function ry(t){var r=t.match(/rgb\\(([^)]+)\\)/);if(r){var e=r[1].split(/ *, */).map(Number);return{r:e[0],g:e[1],b:e[2],a:100}}}function iy(t){var r=t.match(/rgba\\(([^)]+)\\)/);if(r){var e=r[1].split(/ *, */).map(Number);return{r:e[0],g:e[1],b:e[2],a:e[3]*100}}}function ny(t){if(t[0]==="#"&&t.length===7)return{r:parseInt(t.slice(1,3),16),g:parseInt(t.slice(3,5),16),b:parseInt(t.slice(5,7),16),a:100}}function oy(t){if(t[0]==="#"&&t.length===4)return{r:parseInt(t[1]+t[1],16),g:parseInt(t[2]+t[2],16),b:parseInt(t[3]+t[3],16),a:100}}function sy(t){var r=t.match(/hsl\\(([^)]+)\\)/);if(r){var e=r[1].split(/ *, */),i=parseInt(e[0],10),n=parseInt(e[1],10),o=parseInt(e[2],10),s=n1(i,n,o);return Zr({},s,{a:100})}}function ay(t){var r=t.match(/hsla\\(([^)]+)\\)/);if(r){var e=r[1].split(/ *, */),i=parseInt(e[0],10),n=parseInt(e[1],10),o=parseInt(e[2],10),s=parseInt(parseFloat(e[3])*100,10),a=n1(i,n,o);return Zr({},a,{a:s})}}function Li(t){let r=o1(t);return[r.r,r.g,r.b,Math.round(r.a*255/100)]}function Hl(t,r,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?t+(r-t)*6*e:e<1/2?r:e<2/3?t+(r-t)*(2/3-e)*6:t}function ly(t,r,e){let i,n,o,s,a,l;return r/=100,e/=100,r===0?s=a=l=e*255:(e<=.5?n=e*(r+1):n=e+r-e*r,i=e*2-n,o=t/360,s=Hl(i,n,o+1/3),a=Hl(i,n,o),l=Hl(i,n,o-1/3)),{r:s,g:a,b:l}}function hy(t){let r=new Array(t),e=0;for(let i=0;i<360;i+=360/t){e++;let n=ly(i,100,30+e%4*15);r[e-1]=[Math.round(n.r*255),Math.round(n.g*255),Math.round(n.b*255)]}return r}function fy(){return[Math.floor(Math.random()*256),Math.floor(Math.random()*256),Math.floor(Math.random()*256)]}function nr(t){let{color:r,colors:e,randomColors:i,numberColors:n=50}=t;if(r&&!Array.isArray(r)&&(r=Li(r)),r)return[r];if(e)return e=e.map(function(o){return Array.isArray(o)?o:Li(o)}),e;if(i){e=new Array(n);for(let o=0;o<n;o++)e[o]=fy()}return hy(n)}function Zl(t,r,e={}){let{color:i="blue",colors:n,font:o="12px Helvetica",rotate:s=0}=e;if(this.checkProcessable("paintMasks",{channels:[3,4],bitDepth:[8,16],colorModel:Lt}),!Array.isArray(t))throw Error("paintLabels: labels must be an array");if(!Array.isArray(r))throw Error("paintLabels: positions must be an array");if(i&&!Array.isArray(i)&&(i=Li(i)),n?n=n.map(function(h){return Array.isArray(h)?h:Li(h)}):n=[i],t.length!==r.length)throw Error("paintLabels: positions and labels must be arrays from the same size");Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]);let l=this.getCanvas().getContext("2d");for(let h=0;h<t.length;h++){l.save();let f=n[h%n.length];l.fillStyle=`rgba(${f[0]},${f[1]},${f[2]},${f[3]/this.maxValue})`,l.font=o[h%o.length];let c=r[h];l.translate(c[0],c[1]),l.rotate(s[h%s.length]/180*Math.PI),l.fillText(t[h],0,0),l.restore()}return this.data=Uint8Array.from(l.getImageData(0,0,this.width,this.height).data),this}function Jl(t,r={}){let{alpha:e=255,labels:i=[],labelsPosition:n=[],labelColor:o="blue",labelFont:s="12px Helvetica"}=r;this.checkProcessable("paintMasks",{channels:[3,4],bitDepth:[8,16],colorModel:Lt});let a=nr(Object.assign({},r,{numberColors:t.length}));Array.isArray(t)||(t=[t]);for(let l=0;l<t.length;l++){let h=t[l],f=a[l%a.length];for(let c=0;c<h.width;c++)for(let u=0;u<h.height;u++)if(h.getBitXY(c,u))for(let d=0;d<Math.min(this.components,f.length);d++)if(e===255)this.setValueXY(c+h.position[0],u+h.position[1],d,f[d]);else{let p=this.getValueXY(c+h.position[0],u+h.position[1],d);p=Math.round((p*(255-e)+f[d]*e)/255),this.setValueXY(c+h.position[0],u+h.position[1],d,p)}}if(Array.isArray(i)&&i.length>0){let h=this.getCanvas().getContext("2d");h.fillStyle=o,h.font=s;for(let f=0;f<Math.min(t.length,i.length);f++){let c=n[f]?n[f]:t[f].position;h.fillText(i[f],c[0],c[1])}this.data=Uint8Array.from(h.getImageData(0,0,this.width,this.height).data)}return this}function Oi(t,r){let e=new Array(t);for(let i=0;i<t;i++)e[i]=new Array(r).fill(0);return e}var cy=[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0]],uy=[[0,1,0],[1,1,1],[0,1,0]],Ce=class{constructor(r={}){let{kind:e="cross",shape:i,size:n,width:o,height:s,filled:a=!0}=r;if(n&&(o=n,s=n),i)switch(i.toLowerCase()){case"square":case"rectangle":this.matrix=dy(o,s,{filled:a});break;case"circle":case"ellipse":this.matrix=py(o,s,{filled:a});break;case"triangle":this.matrix=my(o,s,{filled:a});break;default:throw new Error(`Shape: unexpected shape: ${i}`)}else if(e)switch(e.toLowerCase()){case"cross":this.matrix=cy;break;case"smallcross":this.matrix=uy;break;default:throw new Error(`Shape: unexpected kind: ${e}`)}else throw new Error("Shape: expected a kind or a shape option");this.height=this.matrix.length,this.width=this.matrix[0].length,this.halfHeight=this.height/2>>0,this.halfWidth=this.width/2>>0}getPoints(){let r=this.matrix,e=[];for(let i=0;i<r.length;i++)for(let n=0;n<r[0].length;n++)r[i][n]&&e.push([n-this.halfWidth,i-this.halfHeight]);return e}getMask(){let r=new L(this.width,this.height,{kind:ie});for(let e=0;e<this.matrix.length;e++)for(let i=0;i<this.matrix[0].length;i++)this.matrix[e][i]&&r.setBitXY(i,e);return r}};function dy(t,r,e){let i=Oi(r,t);if(e.filled)for(let n=0;n<r;n++)for(let o=0;o<t;o++)i[n][o]=1;else{for(let n of[0,r-1])for(let o=0;o<t;o++)i[n][o]=1;for(let n=0;n<r;n++)for(let o of[0,t-1])i[n][o]=1}return i}function py(t,r,e){let i=Oi(r,t,e),n=1-r%2,o=1-t%2,s=Math.floor((t-1)/2),a=Math.floor((r-1)/2),l=s*s,h=a*a;if(e.filled)for(let f=0;f<=a;f++){let c=Math.floor(Math.sqrt(l-l*f*f/h));for(let u=s-c;u<=s;u++)i[a-f][u]=1,i[a+f+n][u]=1,i[a-f][t-u-1]=1,i[a+f+n][t-u-1]=1}else{for(let f=0;f<=a;f++){let c=Math.floor(Math.sqrt(l-l*f*f/h)),u=s-c;i[a-f][u]=1,i[a+f+n][u]=1,i[a-f][t-u-1]=1,i[a+f+n][t-u-1]=1}for(let f=0;f<=s;f++){let c=Math.floor(Math.sqrt(h-h*f*f/l)),u=a-c;i[u][s-f]=1,i[u][s+f+o]=1,i[r-u-1][s-f]=1,i[r-u-1][s+f+o]=1}}return i}function my(t,r,e){if(!e.filled)throw new Error("Non filled triangle is not implemented");let i=Oi(r,t,e);for(let n=0;n<r;n++){let o=Math.floor((1-n/r)*t/2);for(let s=o;s<t-o;s++)i[n][s]=1}return i}function Ql(t,r={}){let{shape:e}=r;this.checkProcessable("paintPoints",{bitDepth:[8,16]});let i=nr(Object.assign({},r,{numberColors:t.length})),n=new Ce(e).getPoints(),o=Math.min(this.channels,i[0].length);for(let s=0;s<t.length;s++){let a=i[s%i.length],l=t[s][0],h=t[s][1];for(let f=0;f<n.length;f++){let c=n[f][0],u=n[f][1];if(l+c>=0&&h+u>=0&&l+c<this.width&&h+u<this.height){let d=(l+c+(h+u)*this.width)*this.channels;for(let p=0;p<o;p++)this.data[d+p]=a[p]}}}return this}function th(t,r={}){let{color:e=[this.maxValue,0,0],closed:i=!1}=r;this.checkProcessable("paintPoints",{bitDepth:[1,8,16]});let n=Math.min(this.channels,e.length);for(let o=0;o<t.length-1+i;o++){let s=t[o],a=t[(o+1)%t.length],l=a[0]-s[0],h=a[1]-s[1],f=Math.max(Math.abs(l),Math.abs(h)),c=l/f,u=h/f,d=s[0],p=s[1];for(let g=0;g<=f;g++){let x=Math.round(d),m=Math.round(p);if(x>=0&&m>=0&&x<this.width&&m<this.height)if(this.bitDepth===1)this.setBitXY(x,m);else{let w=(x+m*this.width)*this.channels;for(let y=0;y<n;y++)this.data[w+y]=e[y]}d=d+c,p=p+u}}return this}function eh(t,r={}){let e=Object.assign({},r);this.checkProcessable("paintPolylines",{bitDepth:[8,16]});let i=nr(Object.assign({},r,{numberColors:t.length}));for(let n=0;n<t.length;n++)e.color=i[n%i.length],this.paintPolyline(t[n],e);return this}function rh(t,r={}){let{color:e=[this.maxValue,0,0],filled:i=!1}=r;this.checkProcessable("paintPoints",{bitDepth:[1,8,16]}),r.closed=!0;let n=gy(t);if(i===!1)return this.paintPolyline(t,r);{let o=Array(this.height);for(let s=0;s<this.height;s++){o[s]=[];for(let a=0;a<this.width;a++)o[s].push(0)}for(let s=0;s<n.length;s++){let a=xy(n[s],n[(s+1)%n.length]);for(let l=0;l<this.height;l++)for(let h=0;h<this.width;h++)wy(h,l,a,this.height)&&(o[l][h]=o[l][h]===0?1:0)}for(let s=0;s<this.height;s++)for(let a=0;a<this.width;a++)if(o[s][a]===1)if(this.bitDepth===1)this.setBitXY(a,s);else{let l=Math.min(this.channels,e.length),h=(a+s*this.width)*this.channels;for(let f=0;f<l;f++)this.data[h+f]=e[f]}return this.paintPolyline(t,r)}}function gy(t){let r=[];for(let e=0;e<t.length;e++)if(!(t[e][0]===t[(e+1)%t.length][0]&&t[e][1]===t[(e+1)%t.length][1])){if(t[e][0]===t[(e-1+t.length)%t.length][0]&&t[e][1]===t[(e-1+t.length)%t.length][1])continue;if(t[(e+1)%t.length][0]===t[(e-1+t.length)%t.length][0]&&t[(e-1+t.length)%t.length][1]===t[(e+1)%t.length][1])continue;r.push(t[e])}return r}function xy(t,r){if(t[0]===r[0])return{a:0,b:t[0],vertical:!0};{let e=(r[1]-t[1])/(r[0]-t[0]),i=t[1]-e*t[0];return{a:e,b:i,vertical:!1}}}function wy(t,r,e,i){if(e.vertical===!0)return e.b<=t;if(e.a===0)return!1;{let n=(r-e.b)/e.a;return n<t&&n>=0&&n<=i}}function ih(t,r={}){let e=Object.assign({},r);this.checkProcessable("paintPolygons",{bitDepth:[8,16]});let i=nr(Object.assign({},r,{numberColors:t.length}));for(let n=0;n<t.length;n++)e.color=i[n%i.length],this.paintPolygon(t[n],e);return this}var s1=vt(oa()),a1=vt(Pe());function nh(t={}){let{maxSlots:r=256,channel:e,useAlpha:i=!0}=t;if(this.checkProcessable("getHistogram",{bitDepth:[1,8,16]}),e===void 0){if(this.components>1)throw new RangeError("You need to define the channel for an image that contains more than one channel");e=0}return l1.call(this,e,{useAlpha:i,maxSlots:r})}function oh(t={}){let{maxSlots:r=256,useAlpha:e=!0}=t;this.checkProcessable("getHistograms",{bitDepth:[8,16]});let i=new Array(e?this.components:this.channels);for(let n=0;n<i.length;n++)i[n]=l1.call(this,n,{useAlpha:e,maxSlots:r});return i}function l1(t,r){let{useAlpha:e,maxSlots:i}=r;if(this.bitDepth===1){let l=[0,0];for(let h=0;h<this.height;h++)for(let f=0;f<this.width;f++){let c=this.getBitXY(h,f);c===0?l[0]+=1:c===1&&(l[1]+=1)}return l}let n=Math.log2(i);if(!(0,s1.default)(n))throw new RangeError("maxSlots must be a power of 2, for example: 64, 256, 1024");let o=0;this.bitDepth>n&&(o=this.bitDepth-n);let s=this.data,a=(0,a1.default)(Math.pow(2,Math.min(this.bitDepth,n)),0);if(e&&this.alpha){let l=this.channels-t-1;for(let h=t;h<s.length;h+=this.channels)a[s[h]>>o]+=s[h+l]/this.maxValue}else for(let l=t;l<s.length;l+=this.channels)a[s[l]>>o]++;return a}var h1=vt(Pe());function Vn(t={}){let{useAlpha:r=!0,nbSlots:e=512}=t;this.checkProcessable("getColorHistogram",{bitDepth:[8,16],components:[3]});let i=Math.log(e)/Math.log(8);if(i!==Math.floor(i))throw new RangeError("nbSlots must be a power of 8. Usually 8, 64, 512 or 4096");let n=this.bitDepth-i,o=this.data,s=(0,h1.default)(Math.pow(8,i),0),a=Math.pow(2,i*2),l=Math.pow(2,i);for(let h=0;h<o.length;h+=this.channels){let f=(o[h]>>n)*a+(o[h+1]>>n)*l+(o[h+2]>>n);r&&this.alpha?s[f]+=o[h+this.channels-1]/this.maxValue:s[f]++}return s}var f1=vt(Pe());function $n(){this.checkProcessable("min",{bitDepth:[8,16,32]});let t=(0,f1.default)(this.channels,1/0);for(let r=0;r<this.data.length;r+=this.channels)for(let e=0;e<this.channels;e++)this.data[r+e]<t[e]&&(t[e]=this.data[r+e]);return t}var c1=vt(Pe());function qn(){this.checkProcessable("max",{bitDepth:[8,16,32]});let t=(0,c1.default)(this.channels,-1/0);for(let r=0;r<this.data.length;r+=this.channels)for(let e=0;e<this.channels;e++)this.data[r+e]>t[e]&&(t[e]=this.data[r+e]);return t}var u1=vt(Pe());function Wn(){this.checkProcessable("sum",{bitDepth:[8,16]});let t=(0,u1.default)(this.channels,0);for(let r=0;r<this.data.length;r+=this.channels)for(let e=0;e<this.channels;e++)t[e]+=this.data[r+e];return t}function Kn(t=0,r=0){this.checkProcessable("getMoment",{bitDepth:[1]});let e=0;for(let i=0;i<this.width;i++)for(let n=0;n<this.height;n++)this.getBitXY(i,n)===1&&(e+=i**t*n**r);return e}function sh(t={}){let{mask:r,region:e=3,removeClosePoints:i=0,invert:n=!1,maxEquals:o=2}=t,s=this;this.checkProcessable("localMaxima",{bitDepth:[8,16],components:1}),e*=4;let a=n?0:1,l=[1,0,-1,0,1,1,-1,-1,2,0,-2,0,2,2,-2,-2],h=[0,1,0,-1,1,-1,1,-1,0,2,0,-2,2,-2,2,-2],f=e<=8?1:2,c=[];for(let u=f;u<s.height-f;u++)for(let d=f;d<s.width-f;d++){if(r&&r.getBitXY(d,u)!==a)continue;let p=0,g=0,x=s.data[d+u*s.width];for(let m=0;m<e;m++)n?s.data[d+l[m]+(u+h[m])*s.width]>x&&p++:s.data[d+l[m]+(u+h[m])*s.width]<x&&p++,s.data[d+l[m]+(u+h[m])*s.width]===x&&g++;p+g===e&&g<=o&&c.push([d,u])}if(i>0)for(let u=0;u<c.length;u++)for(let d=u+1;d<c.length;d++)Math.sqrt(Math.pow(c[u][0]-c[d][0],2)+Math.pow(c[u][1]-c[d][1],2))<i&&(c[u][0]=c[u][0]+c[d][0]>>1,c[u][1]=c[u][1]+c[d][1]>>1,c.splice(d,1),d--);return c}function Hn(){let t=this.getHistograms({maxSlots:this.maxValue+1}),r=new Array(t.length);for(let e=0;e<t.length;e++){let i=t[e];r[e]=pu(i)}return r}function Zn(){let t=this.getHistograms({maxSlots:this.maxValue+1}),r=new Array(t.length);for(let e=0;e<t.length;e++){let i=t[e];r[e]=bn(i)}return r}function Jn(){this.checkProcessable("points",{bitDepth:[1]});let t=[];for(let r=0;r<this.width;r++)for(let e=0;e<this.height;e++)this.getBitXY(r,e)===1&&t.push([r,e]);return t}function Qn(){this.checkProcessable("extendedPoints",{bitDepth:[1]});let t=[];for(let r=0;r<this.height;r++)for(let e=0;e<this.width;e++)if(this.getBitXY(e,r)===1)for(t.push([e,r]),this.getBitXY(e+1,r)!==1?(t.push([e+1,r]),t.push([e+1,r+1]),this.getBitXY(e,r+1)!==1&&t.push([e,r+1])):this.getBitXY(e,r+1)!==1&&(t.push([e,r+1]),t.push([e+1,r+1]));e<this.width-2&&this.getBitXY(e+1,r)===1&&this.getBitXY(e+2,r)===1;)e++;return t}function ah(t,r={}){if(this===t)return[0,0];let e=[0,0],i=this;for(;i;){if(i===t)return e;i.position&&(e[0]+=i.position[0],e[1]+=i.position[1]),i=i.parent}return r.defaultFurther?e:!1}function lh(t={}){let{alpha:r=1}=t;this.checkProcessable("countAlphaPixels",{bitDepth:[8,16],alpha:1});let e=0;if(r!==void 0){for(let i=this.components;i<this.data.length;i+=this.channels)this.data[i]===r&&e++;return e}else return this.size}function Ui(t,r={}){let{sorted:e}=r;e||(t=t.slice().sort(by));let i=t.length,n=new Array(i*2),o=0;for(let a=0;a<i;a++){let l=t[a];for(;o>=2&&d1(n[o-2],n[o-1],l)<=0;)o--;n[o++]=l}let s=o+1;for(let a=i-2;a>=0;a--){let l=t[a];for(;o>=s&&d1(n[o-2],n[o-1],l)<=0;)o--;n[o++]=l}return n.slice(0,o-1)}function d1(t,r,e){return(r[1]-t[1])*(e[0]-t[0])-(r[0]-t[0])*(e[1]-t[1])}function by(t,r){return t[0]===r[0]?t[1]-r[1]:t[0]-r[0]}function Sr(){return Ui(this.extendedPoints,{sorted:!1})}function p1(t){for(let r=0;r<t.length;r++)t[r][0]=Math.round(t[r][0]),t[r][1]=Math.round(t[r][1]);return t}function to(t,r){return[t[0]-r[0],t[1]-r[1]]}function eo(t){let r=Math.sqrt(t[0]**2+t[1]**2);return[t[0]/r,t[1]/r]}function Jr(t,r,e){e===void 0&&(e=new Array(r.length));let i=Math.cos(t),n=Math.sin(t);for(let o=0;o<e.length;++o)e[o]=[i*r[o][0]-n*r[o][1],n*r[o][0]+i*r[o][1]];return e}function m1(t){let r=0;for(let e=0;e<t.length;e++){let i=t[e][0],n=t[e][1],o=t[e===t.length-1?0:e+1][0],s=t[e===t.length-1?0:e+1][1];r+=Math.sqrt((o-i)**2+(s-n)**2)}return r}function g1(t){let r=0;for(let e=0;e<t.length;e++){let i=t[e][0],n=t[e===t.length-1?0:e+1][1],o=t[e===t.length-1?0:e+1][0],s=t[e][1];r+=i*n*.5,r-=o*s*.5}return Math.abs(r)}function hh(t){let r=1/0,e=1/0,i=-1/0,n=-1/0;for(let o=0;o<t.length;o++)t[o][0]<r&&(r=t[o][0]),t[o][0]>i&&(i=t[o][0]),t[o][1]<e&&(e=t[o][1]),t[o][1]>n&&(n=t[o][1]);return[[r,e],[i,n]]}function x1(t,r){r===void 0&&(r=new Array(t.length).fill(0).map(()=>[]));let e=hh(t),i=e[0][0],n=e[0][1];for(let o=0;o<t.length;o++)r[o][0]=t[o][0]-i,r[o][1]=t[o][1]-n;return r}function Ni(t={}){let{originalPoints:r=Sr.call(this)}=t;if(r.length===0)return[];if(r.length===1)return[r[0],r[0],r[0],r[0]];let e=new Array(r.length),i=1/0,n=0,o;for(let s=0;s<e.length;s++){let a=yy(r[s],r[(s+1)%e.length]);Jr(-a,r,e);let l=e[s][0],h=e[s][1],f=e[(s+1)%e.length][0],c=e[(s+1)%e.length][1],u=!0,d=0,p=0,g=0;for(let y=0;y<e.length;y++){let M=e[y][0],_=e[y][1],T=(M-l)/(f-l);u===!0?(u=!1,d=T,p=T):(T<d&&(d=T),T>p&&(p=T));let E=(-(f-l)*_+f*h-c*l)/(f-l);Math.abs(E)>Math.abs(g)&&(g=E)}let x=[l+d*(f-l),h],m=[l+p*(f-l),h],w=Math.abs(g*(d-p)*(f-l));w<i&&(n=a,i=w,o=[x,m,[m[0],m[1]-g],[x[0],x[1]-g]])}return Jr(n,o,o),o}function yy(t,r){let e=to(r,t),i=eo(e),n=Math.acos(i[0]);return i[1]<0?-n:n}function fh(t){let r={inPlace:!0};t.extendMethod("invert",Ws),t.extendMethod("abs",$s),t.extendMethod("level",ka,r),t.extendMethod("add",Aa,r),t.extendMethod("subtract",Sa,r),t.extendMethod("subtractImage",Ia),t.extendMethod("multiply",Ta,r),t.extendMethod("divide",Ra,r),t.extendMethod("hypotenuse",Da),t.extendMethod("background",Va),t.extendMethod("flipX",Ks),t.extendMethod("flipY",Hs),t.extendMethod("blurFilter",Zs),t.extendMethod("medianFilter",Qs),t.extendMethod("gaussianFilter",ta),t.extendMethod("sobelFilter",_a),t.extendMethod("gradientFilter",Mr),t.extendMethod("scharrFilter",Ma),t.extendMethod("dilate",$a),t.extendMethod("erode",qa),t.extendMethod("open",Wa),t.extendMethod("close",Ka),t.extendMethod("topHat",Ha),t.extendMethod("blackHat",Za),t.extendMethod("morphologicalGradient",Ja),t.extendMethod("warpingFourPoints",Qa),t.extendMethod("crop",tl),t.extendMethod("cropAlpha",el),t.extendMethod("resize",Xn).extendMethod("scale",Xn),t.extendMethod("hsv",il),t.extendMethod("hsl",nl),t.extendMethod("cmyk",ol),t.extendMethod("rgba8",sl),t.extendMethod("grey",jn).extendMethod("gray",jn),t.extendMethod("mask",Ml),t.extendMethod("pad",kl),t.extendMethod("colorDepth",Al),t.extendMethod("setBorder",Rl,r),t.extendMethod("rotate",qd),t.extendMethod("rotateLeft",Il),t.extendMethod("rotateRight",Dl),t.extendMethod("insert",Tl),t.extendMethod("getRow",Nl),t.extendMethod("getColumn",Yl),t.extendMethod("getMatrix",zl),t.extendMethod("setMatrix",Xl),t.extendMethod("getPixelsArray",jl),t.extendMethod("getIntersection",Gl),t.extendMethod("getClosestCommonParent",Vl),t.extendMethod("getThreshold",Fi),t.extendMethod("split",Pl),t.extendMethod("getChannel",Cl),t.extendMethod("combineChannels",Fl),t.extendMethod("setChannel",Bl),t.extendMethod("getSimilarity",Ll),t.extendMethod("getPixelsGrid",Ol),t.extendMethod("getBestMatch",Ul),t.extendMethod("cannyEdge",ql),t.extendMethod("convolution",er),t.extendMethod("extract",Wl),t.extendMethod("floodFill",Kl),t.extendMethod("paintLabels",Zl,r),t.extendMethod("paintMasks",Jl,r),t.extendMethod("paintPoints",Ql,r),t.extendMethod("paintPolyline",th,r),t.extendMethod("paintPolylines",eh,r),t.extendMethod("paintPolygon",rh,r),t.extendMethod("paintPolygons",ih,r),t.extendMethod("countAlphaPixels",lh),t.extendMethod("monotoneChainConvexHull",Sr),t.extendMethod("minimalBoundingRectangle",Ni),t.extendMethod("getHistogram",nh).extendProperty("histogram",nh),t.extendMethod("getHistograms",oh).extendProperty("histograms",oh),t.extendMethod("getColorHistogram",Vn).extendProperty("colorHistogram",Vn),t.extendMethod("getMin",$n).extendProperty("min",$n),t.extendMethod("getMax",qn).extendProperty("max",qn),t.extendMethod("getSum",Wn).extendProperty("sum",Wn),t.extendMethod("getMoment",Kn).extendProperty("moment",Kn),t.extendMethod("getLocalMaxima",sh),t.extendMethod("getMedian",Zn).extendProperty("median",Zn),t.extendMethod("getMean",Hn).extendProperty("mean",Hn),t.extendMethod("getPoints",Jn).extendProperty("points",Jn),t.extendMethod("getExtendedPoints",Qn).extendProperty("extendedPoints",Qn),t.extendMethod("getRelativePosition",ah)}var U1=vt(w1());function dh(t,r=""){let e=r.split(".");for(let i of e){if(t[i]===void 0)return;t=t[i]}return t}var wh=vt(P1());function xh(t={}){let{originalPoints:r=Sr.call(this)}=t;if(r.length===0)return{min:0,max:0,minLine:[],maxLine:[],aspectRatio:1};if(r.length===1)return{min:1,max:1,minLine:[r[0],r[0]],maxLine:[r[0],r[0]],aspectRatio:1};let e=new Array(r.length),i=1/0,n=0,o=[];for(let h=0;h<r.length;h++){let f=Gy(r[h],r[(h+1)%r.length]);Jr(-f,r,e);let c=0,u=[];for(let d=0;d<r.length;d++){let p=Math.abs(e[h][1]-e[d][1]);p>c&&(c=p,u=[],u.push([e[d][0],e[h][1]],[e[d][0],e[d][1]]))}c<i&&(i=c,n=f,o=u)}Jr(n,o,o);let s=0,a=[],l=0;for(let h=0;h<r.length-1;h++)for(let f=h+1;f<r.length;f++){let c=(r[h][0]-r[f][0])**2+(r[h][1]-r[f][1])**2;c>l&&(l=c,s=Math.sqrt(c),a=[r[h],r[f]])}return{min:i,minLine:o,max:s,maxLine:a,aspectRatio:i/s}}function Gy(t,r){let e=to(r,t),i=eo(e),n=Math.acos(i[0]);return i[1]<0?-n:n}var Yi=class{constructor(r,e){this.map=r,this.id=e,this.minX=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY,this.meanX=0,this.meanY=0,this.surface=0,this.computed={}}getMask(r={}){let{scale:e=1,kind:i=""}=r,n;switch(i){case"contour":n=this.contourMask;break;case"box":n=this.boxMask;break;case"filled":n=this.filledMask;break;case"center":n=this.centerMask;break;case"mbr":n=this.mbrFilledMask;break;case"hull":n=this.convexHullFilledMask;break;case"hullContour":n=this.convexHullMask;break;case"mbrContour":n=this.mbrMask;break;case"feret":n=this.feretMask;break;default:n=this.mask}return e<1&&(n=n.resize({factor:e}),n.parent=this.mask.parent,n.position[0]+=this.minX,n.position[1]+=this.minY),n}get mean(){throw new Error("Roi mean not implemented yet")}get center(){return this.computed.center||(this.computed.center=[this.width/2>>0,this.height/2>>0]),this.computed.center}get ratio(){return this.width/this.height}get width(){return this.maxX-this.minX+1}get height(){return this.maxY-this.minY+1}_computExternalIDs(){let r=this.borderIDs,e=this.borderLengths;this.computed.externalIDs=[],this.computed.externalLengths=[];let i=this.internalIDs;for(let n=0;n<r.length;n++)i.includes(r[n])||(this.computed.externalIDs.push(r[n]),this.computed.externalLengths.push(e[n]))}get externalIDs(){return this.computed.externalIDs?this.computed.externalIDs:(this._computExternalIDs(),this.computed.externalIDs)}get externalLengths(){return this.computed.externalLengths?this.computed.externalLengths:(this._computExternalIDs(),this.computed.externalLengths)}_computeBorderIDs(){let r=Vy(this);this.computed.borderIDs=r.ids,this.computed.borderLengths=r.lengths}get borderIDs(){return this.computed.borderIDs?this.computed.borderIDs:(this._computeBorderIDs(),this.computed.borderIDs)}get borderLengths(){return this.computed.borderLengths?this.computed.borderLengths:(this._computeBorderIDs(),this.computed.borderLengths)}get boxIDs(){return this.computed.boxIDs||(this.computed.boxIDs=$y(this)),this.computed.boxIDs}get internalIDs(){return this.computed.internalIDs||(this.computed.internalIDs=Jy(this)),this.computed.internalIDs}get box(){return this.computed.box||(this.computed.box=qy(this)),this.computed.box}get external(){return this.computed.external||(this.computed.external=Hy(this)),this.computed.external}get holesInfo(){return this.computed.holesInfo||(this.computed.holesInfo=Zy(this)),this.computed.holesInfo}get border(){return this.computed.border||(this.computed.border=Wy(this)),this.computed.border}get contourMask(){if(!this.computed.contourMask){let r=new L(this.width,this.height,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent});for(let e=0;e<this.width;e++)for(let i=0;i<this.height;i++)this.map.data[e+this.minX+(i+this.minY)*this.map.width]===this.id&&(e>0&&e<this.width-1&&i>0&&i<this.height-1?(this.map.data[e-1+this.minX+(i+this.minY)*this.map.width]!==this.id||this.map.data[e+1+this.minX+(i+this.minY)*this.map.width]!==this.id||this.map.data[e+this.minX+(i-1+this.minY)*this.map.width]!==this.id||this.map.data[e+this.minX+(i+1+this.minY)*this.map.width]!==this.id)&&r.setBitXY(e,i):r.setBitXY(e,i));this.computed.contourMask=r}return this.computed.contourMask}get boxMask(){if(!this.computed.boxMask){let r=new L(this.width,this.height,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent});for(let e=0;e<this.width;e++)r.setBitXY(e,0),r.setBitXY(e,this.height-1);for(let e=0;e<this.height;e++)r.setBitXY(0,e),r.setBitXY(this.width-1,e);this.computed.boxMask=r}return this.computed.boxMask}get mask(){if(!this.computed.mask){let r=new L(this.width,this.height,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent});for(let e=0;e<this.width;e++)for(let i=0;i<this.height;i++)this.map.data[e+this.minX+(i+this.minY)*this.map.width]===this.id&&r.setBitXY(e,i);this.computed.mask=r}return this.computed.mask}get filledMask(){if(!this.computed.filledMask){let r=new L(this.width,this.height,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent});for(let e=0;e<this.width;e++)for(let i=0;i<this.height;i++){let n=e+this.minX+(i+this.minY)*this.map.width;this.internalIDs.includes(this.map.data[n])&&r.setBitXY(e,i)}this.computed.filledMask=r}return this.computed.filledMask}get centerMask(){if(!this.computed.centerMask){let r=new Ce({kind:"smallCross"}).getMask();r.parent=this.map.parent,r.position=[this.minX+this.center[0]-1,this.minY+this.center[1]-1],this.computed.centerMask=r}return this.computed.centerMask}get convexHull(){if(!this.computed.convexHull){let r=[];for(let i=0;i<this.width;i++)for(let n=0;n<this.height;n++)this.map.data[i+this.minX+(n+this.minY)*this.map.width]===this.id&&(i>0&&i<this.width-1&&n>0&&n<this.height-1?(this.map.data[i-1+this.minX+(n+this.minY)*this.map.width]!==this.id||this.map.data[i+1+this.minX+(n+this.minY)*this.map.width]!==this.id||this.map.data[i+this.minX+(n-1+this.minY)*this.map.width]!==this.id||this.map.data[i+this.minX+(n+1+this.minY)*this.map.width]!==this.id)&&(r.push([i,n]),r.push([i+1,n]),r.push([i,n+1]),r.push([i+1,n+1])):(r.push([i,n]),r.push([i+1,n]),r.push([i,n+1]),r.push([i+1,n+1])));let e=Ui(r);this.computed.convexHull={polyline:e,surface:g1(e),perimeter:m1(e)}}return this.computed.convexHull}get convexHullMask(){if(!this.computed.convexHullMask){let r=this.convexHull,e=new L(this.width+1,this.height+1,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent});e.paintPolyline(r.polyline,{closed:!0}),this.computed.convexHullMask=e}return this.computed.convexHullMask}get convexHullFilledMask(){if(!this.computed.convexHullFilledMask){let r=this.convexHull,e=new L(this.width,this.height,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent});for(let i=0;i<this.width;i++)for(let n=0;n<this.height;n++)(0,wh.default)(r.polyline,[i,n])!==1&&e.setBitXY(i,n);this.computed.convexHullFilledMask=e}return this.computed.convexHullFilledMask}get mbr(){if(!this.computed.mbr){let r=Ni({originalPoints:this.convexHull.polyline});if(r.length===0)this.computed.mbr={width:0,height:0,surface:0,perimeter:0,rectangle:r};else{let e=r[0],i=r[1],n=r[2],o=Math.sqrt((e[0]-i[0])**2+(e[1]-i[1])**2),s=Math.sqrt((n[0]-i[0])**2+(n[1]-i[1])**2);this.computed.mbr={width:o,height:s,elongation:1-o/s,aspectRatio:o/s,surface:o*s,perimeter:(o+s)*2,rectangle:r}}}return this.computed.mbr}get fillRatio(){return this.surface/(this.surface+this.holesInfo.surface)}get feretDiameters(){return this.computed.feretDiameters||(this.computed.feretDiameters=xh({originalPoints:this.convexHull.polyline})),this.computed.feretDiameters}get eqpc(){return this.computed.eqpc||(this.computed.eqpc=2*Math.sqrt(this.surface/Math.PI)),this.computed.eqpc}get perimeterInfo(){return this.computed.perimeterInfo||(this.computed.perimeterInfo=Ky(this)),this.computed.perimeterInfo}get perimeter(){let r=this.perimeterInfo,e=2-Math.sqrt(2);return r.one+r.two*2+r.three*3+r.four*4-e*(r.two+r.three*2+r.four)}get ped(){return this.computed.ped||(this.computed.ped=this.perimeter/Math.PI),this.computed.ped}get feretMask(){if(!this.computed.feretMask){let r=new L(this.width+1,this.height+1,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent});r.paintPolyline(this.feretDiameters.minLine),r.paintPolyline(this.feretDiameters.maxLine),this.computed.feretMask=r}return this.computed.feretMask}get mbrMask(){if(!this.computed.mbrMask){let r=p1(this.mbr.rectangle);if(r.length>0){let e=hh(r),i=new L(e[1][0]-e[0][0]+1,e[1][1]-e[0][1]+1,{kind:ie,position:[this.minX+e[0][0],this.minY+e[0][1]],parent:this.map.parent});r=x1(r),i.paintPolyline(r,{closed:!0}),this.computed.mbrMask=i}else this.computed.mbrMask=new L(1,1,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent})}return this.computed.mbrMask}get mbrFilledMask(){if(!this.computed.mbrFilledMask){let r=new L(this.width,this.height,{kind:ie,position:[this.minX,this.minY],parent:this.map.parent}),e=this.mask.minimalBoundingRectangle();for(let i=0;i<this.width;i++)for(let n=0;n<this.height;n++)(0,wh.default)(e,[i,n])!==1&&r.setBitXY(i,n);this.computed.mbrFilledMask=r}return this.computed.mbrFilledMask}get points(){if(!this.computed.points){let r=[];for(let e=0;e<this.height;e++)for(let i=0;i<this.width;i++){let n=(e+this.minY)*this.map.width+i+this.minX;this.map.data[n]===this.id&&r.push([i,e])}this.computed.points=r}return this.computed.points}get maxLengthPoints(){if(!this.computed.maxLengthPoints){let r=0,e,i=this.points;for(let n=0;n<i.length;n++)for(let o=n+1;o<i.length;o++){let s=Math.pow(i[n][0]-i[o][0],2)+Math.pow(i[n][1]-i[o][1],2);s>=r&&(r=s,e=[i[n],i[o]])}this.computed.maxLengthPoints=e}return this.computed.maxLengthPoints}get maxLength(){if(!this.computed.maxLength){let r=Math.sqrt(Math.pow(this.maxLengthPoints[0][0]-this.maxLengthPoints[1][0],2)+Math.pow(this.maxLengthPoints[0][1]-this.maxLengthPoints[1][1],2));this.computed.maxLength=r}return this.computed.maxLength}get roundness(){return 4*this.surface/(Math.PI*this.feretDiameters.max**2)}get sphericity(){return 2*Math.sqrt(this.surface*Math.PI)/this.perimeter}get solidity(){return this.surface/this.convexHull.surface}get angle(){if(!this.computed.angle){let r=this.maxLengthPoints,e=-Math.atan2(r[0][1]-r[1][1],r[0][0]-r[1][0])*180/Math.PI;this.computed.angle=e}return this.computed.angle}toJSON(){return{id:this.id,minX:this.minX,maxX:this.maxX,minY:this.minY,maxY:this.maxY,meanX:this.meanX,meanY:this.meanY,height:this.height,width:this.width,surface:this.surface,mbrWidth:this.mbr.width,mbrHeight:this.mbr.height,mbrSurface:this.mbr.surface,eqpc:this.eqpc,ped:this.ped,feretDiameterMin:this.feretDiameters.min,feretDiameterMax:this.feretDiameters.max,aspectRatio:this.feretDiameters.aspectRatio,fillRatio:this.fillRatio,sphericity:this.sphericity,roundness:this.roundness,solidity:this.solidity,perimeter:this.perimeter}}};function Vy(t){let r=t.map,e=r.data,i=new Set,n=new Map,o=new Set,s=[1,0,-1,0],a=[0,1,0,-1];for(let f=t.minX;f<=t.maxX;f++)for(let c=t.minY;c<=t.maxY;c++){let u=f+c*r.width;if(e[u]===t.id)for(let d=0;d<4;d++){let p=f+s[d],g=c+a[d];if(p>=0&&g>=0&&p<r.width&&g<r.height){let x=p+g*r.width;if(e[x]!==t.id&&!o.has(x)){o.add(x),i.add(e[x]);let m=n.get(e[x]);m?n.set(e[x],++m):n.set(e[x],1)}}}}let l=Array.from(i),h=l.map(function(f){return n.get(f)});return{ids:l,lengths:h}}function $y(t){let r=new Set,e=t.map,i=e.data;for(let n of[0,t.height-1])for(let o=0;o<t.width;o++){let s=(n+t.minY)*e.width+o+t.minX;if(o-t.minX>0&&i[s]===t.id&&i[s-1]!==t.id){let a=i[s-1];r.add(a)}if(e.width-o-t.minX>1&&i[s]===t.id&&i[s+1]!==t.id){let a=i[s+1];r.add(a)}}for(let n of[0,t.width-1])for(let o=0;o<t.height;o++){let s=(o+t.minY)*e.width+n+t.minX;if(o-t.minY>0&&i[s]===t.id&&i[s-e.width]!==t.id){let a=i[s-e.width];r.add(a)}if(e.height-o-t.minY>1&&i[s]===t.id&&i[s+e.width]!==t.id){let a=i[s+e.width];r.add(a)}}return Array.from(r)}function qy(t){let r=0,e=t.map,i=e.data,n=[0];t.height>1&&(n[1]=t.height-1);for(let s of n)for(let a=1;a<t.width-1;a++){let l=(s+t.minY)*e.width+a+t.minX;i[l]===t.id&&r++}let o=[0];t.width>1&&(o[1]=t.width-1);for(let s of o)for(let a=0;a<t.height;a++){let l=(a+t.minY)*e.width+s+t.minX;i[l]===t.id&&r++}return r}function Wy(t){let r=0,e=t.map,i=e.data;for(let n=1;n<t.width-1;n++)for(let o=1;o<t.height-1;o++){let s=(o+t.minY)*e.width+n+t.minX;i[s]===t.id&&(i[s-1]!==t.id||i[s+1]!==t.id||i[s-e.width]!==t.id||i[s+e.width]!==t.id)&&r++}return r+t.box}function Ky(t){let r=t.map,e=r.data,i=0,n=0,o=0,s=0;for(let a=0;a<t.width;a++)for(let l=0;l<t.height;l++){let h=(l+t.minY)*r.width+a+t.minX;if(e[h]===t.id){let f=0;switch((a===0||t.externalIDs.includes(e[h-1]))&&f++,(a===t.width-1||t.externalIDs.includes(e[h+1]))&&f++,(l===0||t.externalIDs.includes(e[h-r.width]))&&f++,(l===t.height-1||t.externalIDs.includes(e[h+r.width]))&&f++,f){case 1:i++;break;case 2:n++;break;case 3:o++;break;case 4:s++;break;default:}}}return{one:i,two:n,three:o,four:s}}function Hy(t){let r=0,e=t.map,i=e.data;for(let n=1;n<t.width-1;n++)for(let o=1;o<t.height-1;o++){let s=(o+t.minY)*e.width+n+t.minX;i[s]===t.id&&(t.externalIDs.includes(i[s-1])||t.externalIDs.includes(i[s+1])||t.externalIDs.includes(i[s-e.width])||t.externalIDs.includes(i[s+e.width]))&&r++}return r+t.box}function Zy(t){let r=0,e=t.map.width,i=t.map.data;for(let n=1;n<t.width-1;n++)for(let o=1;o<t.height-1;o++){let s=(o+t.minY)*e+n+t.minX;t.internalIDs.includes(i[s])&&i[s]!==t.id&&r++}return{number:t.internalIDs.length-1,surface:r}}function Jy(t){let r=[t.id],e=t.map,i=e.data;if(t.height>2)for(let o=0;o<t.width;o++){let s=t.minY*e.width+o+t.minX;if(r.includes(i[s])){let a=i[s+e.width];!r.includes(a)&&!t.boxIDs.includes(a)&&r.push(a)}}let n=new Array(4);for(let o=1;o<t.width-1;o++)for(let s=1;s<t.height-1;s++){let a=(s+t.minY)*e.width+o+t.minX;if(r.includes(i[a])){n[0]=i[a-1],n[1]=i[a+1],n[2]=i[a-e.width],n[3]=i[a+e.width];for(let l=0;l<4;l++){let h=n[l];!r.includes(h)&&!t.boxIDs.includes(h)&&r.push(h)}}}return r}var Fe=class{constructor(r,e){this.roiMap=r,this.options=e,this.roi=this.createRoi()}createRoi(){let r=this.roiMap.data,e={};this.roiMap.positive=0,this.roiMap.negative=0;for(let a=0;a<r.length;a++)r[a]&&!e[r[a]]&&(e[r[a]]=!0,r[a]>0?this.roiMap.positive++:this.roiMap.negative++);let i={};for(let a in e)i[a]=new Yi(this.roiMap,a*1);let n=this.roiMap.width,o=this.roiMap.height;for(let a=0;a<o;a++)for(let l=0;l<n;l++){let h=a*n+l;if(r[h]!==0){let f=r[h],c=i[f];l<c.minX&&(c.minX=l),l>c.maxX&&(c.maxX=l),a<c.minY&&(c.minY=a),a>c.maxY&&(c.maxY=a),c.meanX+=l,c.meanY+=a,c.surface++}}let s=[];for(let a in e)i[a].meanX/=i[a].surface,i[a].meanY/=i[a].surface,s.push(i[a]);return s}};function bh(t){let r=t.data,e=[1,0,-1,0],i=[0,1,0,-1],n=t.minMax,o=-n.min,s=n.max+o,a=[];for(let h=0;h<=s;h++)a.push(Object.create(null));for(let h=0;h<t.width;h++)for(let f=0;f<t.height;f++){let c=h+f*t.width,u=r[c];if(u!==0){let d=Object.create(null),p=!1;for(let g=0;g<4;g++){let x=h+e[g],m=f+i[g];if(x>=0&&m>=0&&x<t.width&&m<t.height){let w=r[x+m*t.width];u!==w&&(p=!0,w!==0&&d[w]===void 0&&(d[w]=!0,a[w+o][u]?a[w+o][u]++:a[w+o][u]=1))}else p=!0}p&&(a[u+o][u]?a[u+o][u]++:a[u+o][u]=1)}}let l={};for(let h=0;h<a.length;h++)Object.keys(a[h]).length>0&&(l[h-o]=a[h]);return l}function yh(t={}){let{algorithm:r="commonBorderLength",minCommonBorderLength:e=5,maxCommonBorderLength:i=100,minCommonBorderRatio:n=.3,maxCommonBorderRatio:o=1}=t,s=function(x,m,w){return x[w]>=e&&x[w]<=i};typeof r=="function"&&(s=r),r.toLowerCase()==="commonborderratio"&&(s=function(x,m,w){let y=Math.min(x[w]/x[m],1);return y>=n&&y<=o});let a=this,l=a.commonBorderLength,h={},f={};for(let x of Object.keys(l)){let m=l[x],w=Object.keys(m);for(let y of w)if(y!==x&&s(m,x,y)){let M=y;f[y]&&(M=f[y]);let _=x;if(f[x]&&(_=f[x]),Number(M)!==_){let T=Math.min(M,_),E=Math.max(M,_);if(h[T]||(h[T]={}),h[T][E]=!0,f[E]=T,h[E]){for(let A of Object.keys(h[E]))h[T][A]=!0,f[A]=T;delete h[E]}}}}let c=a.minMax,u=-c.min,d=c.max+u,p=new Array(d+1).fill(0);for(let x of Object.keys(f))p[Number(x)+u]=f[x];let g=a.data;for(let x=0;x<g.length;x++){let m=g[x];if(m!==0){let w=p[m+u];w!==0&&(g[x]=w)}}return a.computed={},a}var oe=class{constructor(r,e){this.parent=r,this.width=r.width,this.height=r.height,this.data=e,this.negative=0,this.positive=0}get total(){return this.negative+this.positive}get minMax(){let r=Number.MAX_SAFE_INTEGER,e=Number.MIN_SAFE_INTEGER;for(let i=0;i<this.data.length;i++)this.data[i]<r&&(r=this.data[i]),this.data[i]>e&&(e=this.data[i]);return{min:r,max:e}}get commonBorderLength(){return bh(this)}mergeRoi(r={}){return yh.call(this,r)}mergeRois(r){let e=r[0],i=r.slice(1);for(let n=0;n<this.data.length;n++)i.includes(this.data[n])&&(this.data[n]=e)}rowsInfo(){let r=new Array(this.height),e=0;for(let i=0;i<this.data.length;i+=this.width){let n={row:e,positivePixel:0,negativePixel:0,zeroPixel:0,positiveRoi:0,negativeRoi:0,medianChange:0};r[e++]=n;let o={},s={},a=[],l=this.data[i],h=0;for(let f=i;f<i+this.width;f++){let c=this.data[f];l!==c&&(l=c,a.push(h),h=0),h++,c>0?(n.positivePixel++,o[c]||(o[c]=!0)):c<0?(n.negativePixel++,s[c]||(s[c]=!0)):n.zeroPixel++}a.push(h),n.medianChange=a.sort((f,c)=>f-c)[Math.floor(a.length/2)],n.positiveRoiIDs=Object.keys(o),n.negativeRoiIDs=Object.keys(s),n.positiveRoi=n.positiveRoiIDs.length,n.negativeRoi=n.negativeRoiIDs.length}return r}colsInfo(){let r=new Array(this.width),e=0;for(let i=0;i<this.width;i++){let n={col:e,positivePixel:0,negativePixel:0,zeroPixel:0,positiveRoi:0,negativeRoi:0,medianChange:0};r[e++]=n;let o={},s={},a=[],l=this.data[i],h=0;for(let f=i;f<i+this.data.length;f+=this.width){let c=this.data[f];l!==c&&(l=c,a.push(h),h=0),h++,c>0?(n.positivePixel++,o[c]||(o[c]=!0)):c<0?(n.negativePixel++,s[c]||(s[c]=!0)):n.zeroPixel++}a.push(h),n.medianChange=a.sort((f,c)=>f-c)[Math.floor(a.length/2)],n.positiveRoiIDs=Object.keys(o),n.negativeRoiIDs=Object.keys(s),n.positiveRoi=n.positiveRoiIDs.length,n.negativeRoi=n.negativeRoiIDs.length}return r}};function vh(t,r={}){let{allowCorners:e=!1}=r,i=65535,n=new Int16Array(t.size),o=0,s=0,a=new Uint16Array(i+1),l=new Uint16Array(i+1);for(let f=0;f<t.width;f++)for(let c=0;c<t.height;c++)n[c*t.width+f]===0&&h(f,c);function h(f,c){let u=0,d=0,p=t.getBitXY(f,c),g=p?++o:--s;if(o>32767||s<-32768)throw new Error("Too many regions of interest");for(a[0]=f,l[0]=c;u<=d;){let x=a[u&i],m=l[u&i];if(n[m*t.width+x]=g,x>0&&n[m*t.width+x-1]===0&&t.getBitXY(x-1,m)===p&&(d++,a[d&i]=x-1,l[d&i]=m,n[m*t.width+x-1]=-32768),m>0&&n[(m-1)*t.width+x]===0&&t.getBitXY(x,m-1)===p&&(d++,a[d&i]=x,l[d&i]=m-1,n[(m-1)*t.width+x]=-32768),x<t.width-1&&n[m*t.width+x+1]===0&&t.getBitXY(x+1,m)===p&&(d++,a[d&i]=x+1,l[d&i]=m,n[m*t.width+x+1]=-32768),m<t.height-1&&n[(m+1)*t.width+x]===0&&t.getBitXY(x,m+1)===p&&(d++,a[d&i]=x,l[d&i]=m+1,n[(m+1)*t.width+x]=-32768),e&&(x>0&&m>0&&n[(m-1)*t.width+x-1]===0&&t.getBitXY(x-1,m-1)===p&&(d++,a[d&i]=x-1,l[d&i]=m-1,n[(m-1)*t.width+x-1]=-32768),x<t.width-1&&m>0&&n[(m-1)*t.width+x+1]===0&&t.getBitXY(x+1,m-1)===p&&(d++,a[d&i]=x+1,l[d&i]=m-1,n[(m-1)*t.width+x+1]=-32768),x>0&&m<t.height-1&&n[(m+1)*t.width+x-1]===0&&t.getBitXY(x-1,m+1)===p&&(d++,a[d&i]=x-1,l[d&i]=m+1,n[(m+1)*t.width+x-1]=-32768),x<t.width-1&&m<t.height-1&&n[(m+1)*t.width+x+1]===0&&t.getBitXY(x+1,m+1)===p&&(d++,a[d&i]=x+1,l[d&i]=m+1,n[(m+1)*t.width+x+1]=-32768)),u++,d-u>i)throw new Error("analyseMask can not finish, the array to manage internal data is not big enough.You could improve mask by changing MAX_ARRAY")}}return new oe(t,n)}var B1=vt(F1());var tv=[-1,0],ev=[0,-1],rv=[null,null],iv=[-1,-1,0,1],nv=[0,-1,-1,-1],ov=[null,null,null,null];function Mh(t,r={}){let{allowCorners:e=!1}=r,i=4;e&&(i=8);let n,o,s;if(i===8)n=iv,o=nv,s=ov;else if(i===4)n=tv,o=ev,s=rv;else throw new RangeError(`unsupported neighbours count: ${i}`);let a=t.size,l=t.width,h=t.height,f=new Array(a),c=new Uint32Array(a),u=new B1.default,d=1;for(let p=0;p<h;p++)for(let g=0;g<l;g++){let x=g+p*l;if(t.getBit(x)){let m=null;for(let w=0;w<s.length;w++){let y=g+n[w],M=p+o[w];if(y>=0&&M>=0&&y<l&&M<h){let _=y+M*l,T=f[_];T?(s[w]=T,(!m||s[w].value<m.value)&&(m=s[w])):s[w]=null}}if(!m)f[x]=u.add(d++);else{f[x]=m;for(let w=0;w<s.length;w++)s[w]&&s[w]!==m&&u.union(m,s[w])}}}for(let p=0;p<h;p++)for(let g=0;g<l;g++){let x=g+p*l;t.getBit(x)&&(c[x]=u.find(f[x]).value)}return new oe(t,c)}function Eh(t={}){let{allowCorner:r=!0,onlyTop:e=!1,invert:i=!1}=t,n=this;n.checkProcessable("fromMaxima",{components:[1]});let o=1,s=2,a=0,l=0,h=new Int16Array(n.size),f=new Int8Array(n.size),c=new Float32Array(n.size),u=1048575,d=new Uint16Array(u+1),p=new Uint16Array(u+1),g=0,x=0,m=new Uint16Array(u+1),w=new Uint16Array(u+1),y=0,M=0;for(_(n,{maxima:!i});g<x;){let A=d[g&u],D=p[g&u];E(A,D,s),g++}return new oe(n,h);function _({maxima:A=!0}){for(let D=1;D<n.height-1;D++)for(let b=1;b<n.width-1;b++){let k=b+D*n.width;if(f[k]===0){let C=A?n.data[k]:-n.data[b+D*n.width];if(n.data[D*n.width+b-1]>C||n.data[D*n.width+b+1]>C||n.data[(D-1)*n.width+b]>C||n.data[(D+1)*n.width+b]>C||r&&(n.data[(D-1)*n.width+b-1]>C||n.data[(D-1)*n.width+b+1]>C||n.data[(D+1)*n.width+b-1]>C||n.data[(D+1)*n.width+b+1]>C))continue;h[k]=A?++a:--l,T(b,D,o)||(A?--a:++l)}}}function T(A,D){let b=x;y=0,M=1,m[0]=A,w[0]=D;let k=!0;for(;y<M;){let C=m[y&u],S=w[y&u];k&=E(C,S,o),y++}if(!k){for(let C=0;C<M;C++){let S=m[C&u],B=w[C&u]*n.width+S;h[B]=0}x=b}return k}function E(A,D,b){let k=h[D*n.width+A],C=n.data[D*n.width+A];for(let S=D-1;S<=D+1;S++)for(let X=A-1;X<=A+1;X++){let B=S*n.width+X;if(f[B]===0)switch(f[B]=1,c[B]=n.data[B]-C,b){case o:if(c[B]===0){if(X===0||S===0||X===n.width-1||S===n.height-1)return!1;h[B]=k,m[M&u]=X,w[M&u]=S,M++}else{if(c[B]>0)return!1;e||(h[B]=k,d[x&u]=X,p[x&u]=S,x++)}break;case s:c[B]<=0&&(h[B]=k,d[x&u]=X,p[x&u]=S,x++);break;default:throw new Error("unreachable")}}return!0}}function kh(t,r={}){let e=new Ce(r),i=new Int16Array(this.size),n=0,o=e.getPoints();for(let s=0;s<t.length;s++){n++;let a=t[s][0],l=t[s][1];for(let h=0;h<o.length;h++){let f=o[h][0],c=o[h][1];a+f>=0&&l+c>=0&&a+f<this.width&&l+c<this.height&&(i[a+f+(l+c)*this.width]=n)}}return new oe(this,i)}var Dh=vt(O1());var Sh=[1,0,-1,0,1,1,-1,-1],Ih=[0,1,0,-1,1,-1,1,-1];function Th(t={}){let{points:r,mask:e,image:i,fillMaxValue:n=this.maxValue,invert:o=!1}=t,s=i||this;s.checkProcessable("fromWaterShed",{bitDepth:[8,16],components:1}),o=!o,r||(r=s.getLocalMaxima({invert:o,mask:e}));let a=o?0:1,l=new Int16Array(s.size),h=s.width,f=s.height,c=new Dh.default({comparator:(u,d)=>u[2]-d[2],strategy:Dh.default.BinaryHeapStrategy});for(let u=0;u<r.length;u++){let d=r[u][0]+r[u][1]*h;l[d]=u+1;let p=s.data[d];(o&&p<=n||!o&&p>=n)&&c.queue([r[u][0],r[u][1],p])}for(;c.length>0;){let u=c.dequeue(),d=u[0]+u[1]*h;for(let p=0;p<4;p++){let g=u[0]+Sh[p],x=u[1]+Ih[p];if(g>=0&&x>=0&&g<h&&x<f){let m=g+x*h;if(!e||e.getBit(m)===a){let w=s.data[m];(o&&w<=n||!o&&w>=n)&&l[m]===0&&(l[m]=l[d],c.queue([u[0]+Sh[p],u[1]+Ih[p],w]))}}}}return new oe(s,l)}var zi=class{constructor(r,e={}){this._image=r,this._options=e,this._options.label||(this._options.label="default"),this._layers={},this._painted=null}fromMaxima(r={}){let e=Object.assign({},this._options,r),i=Eh.call(this._image,r);this._layers[e.label]=new Fe(i,e)}fromPoints(r,e={}){let i=Object.assign({},this._options,e),n=kh.call(this._image,r,e);return this._layers[i.label]=new Fe(n,i),this}putMap(r,e={}){let i=new oe(this._image,r),n=Object.assign({},this._options,e);return this._layers[n.label]=new Fe(i,n),this}fromWaterShed(r={}){let e=Object.assign({},this._options,r),i=Th.call(this._image,r);this._layers[e.label]=new Fe(i,e)}fromMask(r,e={}){let i=Object.assign({},this._options,e),n=vh.call(this._image,r,e);return this._layers[i.label]=new Fe(n,i),this}fromMaskConnectedComponentLabelingAlgorithm(r,e={}){let i=Object.assign({},this._options,e),n=Mh.call(this._image,r,e);return this._layers[i.label]=new Fe(n,i),this}getMap(r={}){let e=Object.assign({},this._options,r);return this._assertLayerWithLabel(e.label),this._layers[e.label].roiMap}rowsInfo(r={}){return this.getMap(r).rowsInfo()}colsInfo(r={}){return this.getMap(r).rowsInfo()}getRoiIds(r={}){let e=this.getRois(r);if(e){let i=new Array(e.length);for(let n=0;n<e.length;n++)i[n]=e[n].id;return i}throw new Error("ROIs not found")}getRois(r={}){let{label:e=this._options.label,positive:i=!0,negative:n=!0,minSurface:o=0,maxSurface:s=Number.POSITIVE_INFINITY,minWidth:a=0,maxWidth:l=Number.POSITIVE_INFINITY,minHeight:h=0,maxHeight:f=Number.POSITIVE_INFINITY,minRatio:c=0,maxRatio:u=Number.POSITIVE_INFINITY}=r;if(!this._layers[e])throw new Error(`this Roi layer (${e}) does not exist`);let d=this._layers[e].roi,p=[];for(let g of d)(g.id<0&&n||g.id>0&&i)&&g.surface>=o&&g.surface<=s&&g.width>=a&&g.width<=l&&g.height>=h&&g.height<=f&&g.ratio>=c&&g.ratio<=u&&p.push(g);return p}getRoi(r,e={}){let{label:i=this._options.label}=e;if(!this._layers[i])throw new Error(`this Roi layer (${i}) does not exist`);let n=this._layers[i].roi.find(o=>o.id===r);if(!n)throw new Error(`found no Roi with id ${r}`);return n}getMasks(r={}){let e=this.getRois(r),i=new Array(e.length);for(let n=0;n<e.length;n++)i[n]=e[n].getMask(r);return i}getAnalysisMasks(r={}){let{analysisProperty:e}=r,i=`${e}Mask`,n=this.getRois(r);return n.length===0||!n[0][i]?[]:n.map(o=>o[i])}getData(r={}){let e=Object.assign({},this._options,r);return this._assertLayerWithLabel(e.label),this._layers[e.label].roiMap.data}paint(r={}){let{labelProperty:e,analysisProperty:i}=r;this._painted||(this._painted=this._image.rgba8());let n=this.getMasks(r);if(e){let o=this.getRois(r);r.labels=o.map(h=>dh(h,e));let s=Math.max(...r.labels),a=!1,l=!1;if(e.includes("surface")?a=!0:/(?:perimeter|min|max|external|width|height|length)/.test(e)&&(l=!0),isFinite(s)){let h="";if(r.unit!=="pixel"&&r.pixelSize&&(l||a)){h=a?`${r.unit}^2`:r.unit;let f=a?"m^2":"m",c=a?r.pixelSize**2:r.pixelSize,u=U1.default.swiftConverter(f,h);r.labels=r.labels.map(d=>u(c*d))}s>50?r.labels=r.labels.map(f=>Math.round(f)+h):s>10?r.labels=r.labels.map(f=>f.toFixed(1)+h):r.labels=r.labels.map(f=>f.toFixed(2)+h)}r.labelsPosition=o.map(h=>[h.meanX,h.meanY])}if(this._painted.paintMasks(n,r),i){let o=this.getAnalysisMasks(r);this._painted.paintMasks(o,{color:r.analysisColor,alpha:r.analysisAlpha})}return this._painted}getMask(r={}){let e=new L(this._image.width,this._image.height,{kind:"BINARY"}),i=this.getMasks(r);for(let n=0;n<i.length;n++){let o=i[n];for(let s=0;s<o.width;s++)for(let a=0;a<o.height;a++)o.getBitXY(s,a)&&e.setBitXY(s+o.position[0],a+o.position[1])}return e}resetPainted(r={}){let{image:e}=r;e?this._painted=this.image.rgba8():this._painted=this._image.rgba8()}mergeRoi(r={}){let e=this.getMap(r);return e.mergeRoi(r),this.putMap(e.data,r),this}mergeRois(r,e={}){if(!Array.isArray(r)||r.some(n=>!Number.isInteger(n)))throw new Error("Roi ids must be an array of integers");if(r.length<2)throw new Error("Roi ids must have at least two elements");if(new Set(r).size!==r.length)throw new Error("Roi ids must be all different");r.forEach(n=>this.getRoi(n));let i=this.getMap(e);return i.mergeRois(r),this.putMap(i.data,e),this}findCorrespondingRoi(r,e={}){let i=this.getRois(e),n=[];for(let o=0;o<i.length;o++){let s=i[o],a=s.minX,l=s.minY,h=s.points,f=Math.sign(s.id),c=sv(a,l,h,r,f);n.push(c)}return n}_assertLayerWithLabel(r){if(!this._layers[r])throw new Error(`no layer with label ${r}`)}};function sv(t,r,e,i,n){let o={id:[],surface:[],roiSurfaceCovered:[],same:0,opposite:0,total:0};for(let s=0;s<e.length;s++){let a=e[s],l=a[0],h=a[1],f=l+t+(h+r)*i.width,c=i.data[f];(c>0||c<0)&&(o.id.includes(c)?o.surface[o.id.indexOf(c)]+=1:(o.id.push(c),o.surface.push(1)))}for(let s=0;s<o.id.length;s++)Math.sign(o.id[s])===n?o.same+=o.surface[s]:o.opposite+=o.surface[s],o.roiSurfaceCovered[s]=o.surface[s]/e.length;return o.total=o.opposite+o.same,o}var av=Object.prototype.toString,L=class t{constructor(r,e,i,n){if(arguments.length===1?(n=r,{width:r,height:e,data:i}=n):i&&!i.length&&(n=i,{data:i}=n),r===void 0&&(r=1),e===void 0&&(e=1),n===void 0&&(n={}),typeof n!="object"||n===null)throw new TypeError("options must be an object");if(!Number.isInteger(r)||r<=0)throw new RangeError("width must be a positive integer");if(!Number.isInteger(e)||e<=0)throw new RangeError("height must be a positive integer");let{kind:o=wn}=n;if(typeof o!="string")throw new TypeError("kind must be a string");let s=dc(o),a=Object.assign({},n);for(let g in s)a[g]===void 0&&(a[g]=s[g]);pc(a);let{components:l,bitDepth:h,colorModel:f}=a,c=a.alpha+0,u=r*e,d=l+c,p=h===32?Number.MAX_VALUE:2**h-1;if(i===void 0)i=gc(u,l,c,d,h,p);else{let g=mc(u,d,h);if(i.length!==g)throw new RangeError(`incorrect data size: ${i.length}. Should be ${g}`)}this.width=r,this.height=e,this.data=i,this.size=u,this.components=l,this.alpha=c,this.bitDepth=h,this.maxValue=p,this.colorModel=f,this.channels=d,this.meta=n.meta||{},Object.defineProperty(this,"parent",{enumerable:!1,writable:!0,configurable:!0,value:n.parent||null}),this.position=n.position||[0,0],this.computed=null,this.sizes=[this.width,this.height],this.multiplierX=this.channels,this.multiplierY=this.channels*this.width,this.isClamped=this.bitDepth<32,this.borderSizes=[0,0]}get[Symbol.toStringTag](){return"IJSImage"}static isImage(r){return av.call(r)==="[object IJSImage]"}static fromCanvas(r){let i=r.getContext("2d").getImageData(0,0,r.width,r.height);return new t(i.width,i.height,i.data)}static createFrom(r,e){let i=yr(r);return Object.assign(i,{parent:r,position:[0,0]},e),new t(i)}getRoiManager(r){return new zi(this,r)}clone(){let r=this.data.slice();return new t(this.width,this.height,r,this)}apply(r){for(let e=0;e<this.height;e++)for(let i=0;i<this.width;i++){let n=(e*this.width+i)*this.channels;r.call(this,n)}}};Gs(L);mo(L);ns(L);L.prototype.checkProcessable=go;L.prototype.getRGBAData=as;L.load=js;L.extendMethod=nc;L.extendProperty=oc;fh(L);var Ch=vt(j1());var cv={regression:{kernelType:"polynomial",kernelOptions:{degree:2,constant:1}},threshold:.02,roi:{minSurface:100,positive:!1},sampling:20,include:[]};function uv(t,r,e){r=Object.assign({},cv,r);let i=this.manager;return Array.isArray(t)?Promise.all(t.map(function(n){let o=G1(i,n,r);return typeof e=="function"&&o.then(e),o})):G1(i,t,r)}function G1(t,r,e){return t.post("data",[r,e]).then(function(i){for(let n in i)i[n]=new L(i[n]);return i})}function dv(){worker.on("data",function(t,r,e){r=new IJS(r);let i={},n=[],o=r.grey(),s=o.sobelFilter();d("sobel",s);let a=s.level().mask({threshold:e.threshold});d("mask",a);let l=s.getRoiManager();l.fromMask(a);let h=l.getMask(e.roi);d("realMask",h);let f=o.getPixelsGrid({sampling:e.sampling,mask:h}),c=r.getBackground(f.xyS,f.zS,e.regression);d("background",c);let u=r.subtract(c);i.result=u,n.push(u.data.buffer),t(i,n);function d(p,g){e.include.includes(p)&&(i[p]=g,n.push(g.data.buffer))}})}var pv={run:uv,work:dv},V1=pv;function Ph(t){t.extendMethod("background",V1)}var oo=class t{constructor(){this._url=null,this._deps=[null]}checkUrl(){if(this._url===null)throw new Error("image worker must be initialized with an URL")}get url(){return this._url}set url(r){if(typeof r!="string")throw new TypeError("worker URL must be a string");this._url=r,this._deps[0]=r}static extendMethod(r,e){let i,n,o={};function s(...a){return i||(this.checkUrl(),n=this.url,i=new Ch.default(e.work,{deps:n}),o.manager=i),e.run.call(o,...a)}s.reset=function(){i&&(i.terminate(),i=new Ch.default(e.work,{deps:n}),o.manager=i)},t.prototype[r]=s}};Ph(oo);var mv=new oo;var ce=vt(fp());function Rv(t){let r=0;for(let n of t)r+=n.length;let e=new Uint8Array(r),i=0;for(let n of t)e.set(n,i),i+=n.length;return e}async function Pv(t,r){if(t.width!==r.width||t.height!==r.height)throw new Error("Images must have the same dimensions for compositing.");for(let e=0;e<r.height;e++)for(let i=0;i<r.width;i++){let n=t.getPixelXY(i,e),o=r.getPixelXY(i,e),s=Cv(n,o);r.setPixelXY(i,e,s)}}function Cv(t,r){let[e,i,n,o]=t,[s,a,l,h]=r;return i===0&&n===0&&o===0&&e==0?[s,a,l,h]:t}function Yh(t,r){let e=r?r.map(n=>t.pages[n-1]):t.pages,i=new Nh;return Promise.all(e.map(async(n,o)=>{let s=n.LAYERSEQ.map(f=>n[f]).filter(f=>f.bitmapBuffer!==null&&f.bitmapBuffer.length),a=s.map(async f=>{let c=null;return f.LAYERNAME=="BGLAYER"&&n.PAGESTYLE.startsWith("user_")?await L.load(f.bitmapBuffer):(c=i.decode(f.bitmapBuffer,t.pageWidth,t.pageHeight),new L(t.pageWidth,t.pageHeight,c,{components:3,alpha:1}))}),l=await Promise.all(a);l=l.reverse();let h=l[0].clone();for(let f=1;f<s.length;f++)Pv(l[f],h);return h.grey({keepAlpha:!0})}))}var cp={background:(0,ce.default)("transparent"),black:(0,ce.default)("black"),darkGray:(0,ce.default)("darkgray"),gray:(0,ce.default)("gray"),white:(0,ce.default)("white"),markerBlack:(0,ce.default)("black"),markerDarkGray:(0,ce.default)("darkgray"),markerGray:(0,ce.default)("gray"),darkGrayX2:(0,ce.default)("darkgray"),grayX2:(0,ce.default)("gray"),markerDarkGrayX2:(0,ce.default)("darkgray"),markerGrayX2:(0,ce.default)("gray")},Nh=class{constructor(){this.encodedPalette={black:97,background:98,darkGray:99,gray:100,white:101,markerBlack:102,markerDarkGray:103,markerGray:104,darkGrayX2:157,grayX2:201,markerDarkGrayX2:158,markerGrayX2:202};this.specialLengthMarker=255;this.specialLength=16384;this.specialLengthForBlank=1024}decode(r,e,i,n,o=!1){let s=n!=null?n:cp,a=Object.entries(this.encodedPalette).reduce((g,[x,m])=>{var w;return g[m]=(w=s[x])!=null?w:cp[x],g},{}),l=e*i*4,h=[],f=[],c=null,[u,d]=[0,0];for(let g=1;g<r.length;g+=2){u=r.at(g-1),d=r.at(g);let x=!1;if(c!==null){let[m,w]=c;c=null,u===m?(d=1+d+((w&127)+1<<7),f.push([u,d]),x=!0):(w=(w&127)+1<<7,f.push([m,w]))}x||(d===this.specialLengthMarker?(o?d=this.specialLengthForBlank:d=this.specialLength,f.push([u,d]),x=!0):d&128?c=[u,d]:(d+=1,f.push([u,d]),x=!0));for(let[m,w]of f.values())this.addColorBuffer(h,m,w,a);f=[]}c!==null&&([u,d]=c,d=this.adjustTailLength(d,this.getChunksLength(h),l),d>0&&this.addColorBuffer(h,u,d,a));let p=Rv(h);if(p.length!==l)throw new Error(`Uint8Array length ${p.length} doesn\'t match expected length ${l}.`);return p}addColorBuffer(r,e,i,n){let o=e===-1?(0,ce.default)("transparent"):n[e],s;o===void 0?s=Uint8Array.from(new Uint8Array([255,255,255,0])):o.alpha()===0?s=Uint8Array.from(new Uint8Array([0,0,0,0])):s=Uint8Array.from(new Uint8Array([...o.rgb().array(),~~(255*o.alpha())]));for(let a=0;a<i;a++)r.push(s);return r}adjustTailLength(r,e,i){let n=i-e,o;for(let s=7;s>=0;s--)if(o=(r&127)+1<<s,o<=n)return o;return 0}getChunksLength(r){return r.reduce((e,i)=>e+i.length,0)}};self.onmessage=async t=>{try{let{type:r,note:e,pageNumbers:i}=t.data;if(r==="convert"){let o=(await Yh(e,i)).map(s=>s&&typeof s.toDataURL=="function"?s.toDataURL():(console.error("Result is not a canvas or does not support toDataURL"),null));self.postMessage({type:"result",images:o})}}catch(r){self.postMessage({type:"result",images:[],error:r instanceof Error?r.message:"Unknown error occurred"})}};\n/*! Bundled license information:\n\npako/dist/pako.esm.mjs:\n  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)\n*/\n');
}

// src/main.ts
var DEFAULT_SETTINGS = {
  mirrorIP: "",
  invertColorsWhenDark: true,
  showTOC: true,
  showExportButtons: true,
  collapseRecognizedText: false,
  noteImageMaxDim: 800
  // Sensible default for Nomad pages to be legible but not too big. Unit: px
};
function generateTimestamp() {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  const seconds = String(date.getSeconds()).padStart(2, "0");
  const timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
  return timestamp;
}
function dataUrlToBuffer(dataUrl) {
  const base64 = dataUrl.split(",")[1];
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i3 = 0; i3 < binaryString.length; i3++) {
    bytes[i3] = binaryString.charCodeAt(i3);
  }
  return bytes.buffer;
}
var WorkerPool = class {
  constructor(maxWorkers = navigator.hardwareConcurrency) {
    this.maxWorkers = maxWorkers;
    this.workers = Array(maxWorkers).fill(null).map(
      () => new Worker3()
    );
  }
  processChunk(worker2, note, pageNumbers) {
    return new Promise((resolve2, reject2) => {
      const startTime = Date.now();
      worker2.onmessage = (e2) => {
        const duration = Date.now() - startTime;
        if (e2.data.error) {
          reject2(new Error(e2.data.error));
        } else {
          resolve2(e2.data.images);
        }
      };
      worker2.onerror = (error) => {
        console.error("Worker error:", error);
        reject2(error);
      };
      const message = {
        type: "convert",
        note,
        pageNumbers
      };
      worker2.postMessage(message);
    });
  }
  async processPages(note, allPageNumbers) {
    const chunkSize = Math.ceil(allPageNumbers.length / this.workers.length);
    const chunks = [];
    for (let i3 = 0; i3 < allPageNumbers.length; i3 += chunkSize) {
      chunks.push(allPageNumbers.slice(i3, i3 + chunkSize));
    }
    const results = await Promise.all(
      chunks.map(
        (chunk, index2) => this.processChunk(this.workers[index2 % this.workers.length], note, chunk)
      )
    );
    return results.flat();
  }
  terminate() {
    this.workers.forEach((worker2) => worker2.terminate());
    this.workers = [];
  }
};
var ImageConverter = class {
  constructor(maxWorkers = navigator.hardwareConcurrency) {
    this.workerPool = new WorkerPool(maxWorkers);
  }
  async convertToImages(note, pageNumbers) {
    const pages = pageNumbers != null ? pageNumbers : Array.from({ length: note.pages.length }, (_3, i3) => i3 + 1);
    const results = await this.workerPool.processPages(note, pages);
    return results;
  }
  terminate() {
    this.workerPool.terminate();
  }
};
var VaultWriter = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async writeMarkdownFile(file, sn, imgs) {
    var _a2, _b2;
    let content = "";
    let filename = `${(_a2 = file.parent) == null ? void 0 : _a2.path}/${file.basename}.md`;
    let i3 = 0;
    while (this.app.vault.getFileByPath(filename) !== null) {
      filename = `${(_b2 = file.parent) == null ? void 0 : _b2.path}/${file.basename} ${++i3}.md`;
    }
    content = this.app.fileManager.generateMarkdownLink(file, filename);
    content += "\n";
    for (let i4 = 0; i4 < sn.pages.length; i4++) {
      content += `## Page ${i4 + 1}

`;
      if (sn.pages[i4].text !== void 0 && sn.pages[i4].text.length > 0) {
        content += `${sn.pages[i4].text}
`;
      }
      if (imgs) {
        let subpath = "";
        if (this.settings.invertColorsWhenDark) {
          subpath = "#supernote-invert-dark";
        }
        const link = this.app.fileManager.generateMarkdownLink(imgs[i4], filename, subpath);
        content += `${link}
`;
      }
    }
    this.app.vault.create(filename, content);
  }
  async writeImageFiles(file, sn) {
    let images = [];
    const converter = new ImageConverter();
    try {
      images = await converter.convertToImages(sn);
    } finally {
      converter.terminate();
    }
    let imgs = [];
    for (let i3 = 0; i3 < images.length; i3++) {
      let filename = await this.app.fileManager.getAvailablePathForAttachment(`${file.basename}-${i3}.png`);
      const buffer = dataUrlToBuffer(images[i3]);
      imgs.push(await this.app.vault.createBinary(filename, buffer));
    }
    return imgs;
  }
  async attachMarkdownFile(file) {
    const note = await this.app.vault.readBinary(file);
    let sn = new SupernoteX(new Uint8Array(note));
    this.writeMarkdownFile(file, sn, null);
  }
  async attachNoteFiles(file) {
    const note = await this.app.vault.readBinary(file);
    let sn = new SupernoteX(new Uint8Array(note));
    const imgs = await this.writeImageFiles(file, sn);
    this.writeMarkdownFile(file, sn, imgs);
  }
  async exportToPDF(file) {
    const note = await this.app.vault.readBinary(file);
    let sn = new SupernoteX(new Uint8Array(note));
    const pdf = new E({
      orientation: "portrait",
      unit: "px",
      format: [sn.pageWidth, sn.pageHeight]
      // A4 size in pixels
    });
    const converter = new ImageConverter();
    let images = [];
    try {
      images = await converter.convertToImages(sn);
    } finally {
      converter.terminate();
    }
    for (let i3 = 0; i3 < images.length; i3++) {
      if (i3 > 0) {
        pdf.addPage();
      }
      if (sn.pages[i3].text !== void 0 && sn.pages[i3].text.length > 0) {
        pdf.setFontSize(100);
        pdf.setTextColor(0, 0, 0, 0);
        pdf.text(sn.pages[i3].text, 20, 20, { maxWidth: sn.pageWidth });
        pdf.setTextColor(0, 0, 0, 1);
      }
      pdf.addImage(images[i3], "PNG", 0, 0, sn.pageWidth, sn.pageHeight);
    }
    let filename = await this.app.fileManager.getAvailablePathForAttachment(`${file.basename}.pdf`);
    const pdfOutput = pdf.output("arraybuffer");
    await this.app.vault.createBinary(filename, pdfOutput);
  }
};
var vw;
var VIEW_TYPE_SUPERNOTE = "supernote-view";
var SupernoteView = class extends import_obsidian2.FileView {
  constructor(leaf, settings) {
    super(leaf);
    this.settings = settings;
  }
  getViewType() {
    return VIEW_TYPE_SUPERNOTE;
  }
  getDisplayText() {
    if (!this.file) {
      return "Supernote View";
    }
    return this.file.basename;
  }
  async onLoadFile(file) {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h1", { text: file.name });
    const note = await this.app.vault.readBinary(file);
    let sn = new SupernoteX(new Uint8Array(note));
    let images = [];
    const converter = new ImageConverter();
    try {
      images = await converter.convertToImages(sn);
    } finally {
      converter.terminate();
    }
    if (this.settings.showExportButtons) {
      const exportNoteBtn = container.createEl("p").createEl("button", {
        text: "Attach markdown to vault",
        cls: "mod-cta"
      });
      exportNoteBtn.addEventListener("click", async () => {
        vw.attachMarkdownFile(file);
      });
      const exportAllBtn = container.createEl("p").createEl("button", {
        text: "Attach markdown and images to vault",
        cls: "mod-cta"
      });
      exportAllBtn.addEventListener("click", async () => {
        vw.attachNoteFiles(file);
      });
      const exportPDFBtn = container.createEl("p").createEl("button", {
        text: "Attach as PDF",
        cls: "mod-cta"
      });
      exportPDFBtn.addEventListener("click", async () => {
        vw.exportToPDF(file);
      });
    }
    if (images.length > 1 && this.settings.showTOC) {
      const atoc = container.createEl("a");
      atoc.id = "toc";
      atoc.createEl("h2", { text: "Table of contents" });
      const ul = container.createEl("ul");
      for (let i3 = 0; i3 < images.length; i3++) {
        const a3 = container.createEl("li").createEl("a");
        a3.href = `#page${i3 + 1}`;
        a3.text = `Page ${i3 + 1}`;
      }
    }
    for (let i3 = 0; i3 < images.length; i3++) {
      const imageDataUrl = images[i3];
      const pageContainer = container.createEl("div", {
        cls: "page-container"
      });
      pageContainer.setAttr("style", "max-width: " + this.settings.noteImageMaxDim + "px;");
      if (images.length > 1 && this.settings.showTOC) {
        const a3 = pageContainer.createEl("a");
        a3.id = `page${i3 + 1}`;
        a3.href = "#toc";
        a3.createEl("h3", { text: `Page ${i3 + 1}` });
      }
      if (sn.pages[i3].text !== void 0 && sn.pages[i3].text.length > 0) {
        let text;
        if (this.settings.collapseRecognizedText) {
          text = pageContainer.createEl("details", {
            text: "\n" + sn.pages[i3].text,
            cls: "page-recognized-text"
          });
          text.createEl("summary", { text: `Page ${i3 + 1} Recognized Text` });
        } else {
          text = pageContainer.createEl("div", {
            text: sn.pages[i3].text,
            cls: "page-recognized-text"
          });
        }
      }
      const imgElement = pageContainer.createEl("img");
      imgElement.src = imageDataUrl;
      if (this.settings.invertColorsWhenDark) {
        imgElement.addClass("supernote-invert-dark");
      }
      imgElement.setAttr("style", "max-height: " + this.settings.noteImageMaxDim + "px;");
      imgElement.draggable = true;
      if (this.settings.showExportButtons) {
        const saveButton = pageContainer.createEl("button", {
          text: "Save image to vault",
          cls: "mod-cta"
        });
        saveButton.addEventListener("click", async () => {
          const filename = await this.app.fileManager.getAvailablePathForAttachment(`${file.basename}-${i3}.png`);
          const buffer = dataUrlToBuffer(imageDataUrl);
          await this.app.vault.createBinary(filename, buffer);
        });
      }
    }
  }
  async onClose() {
  }
};
var SupernotePlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    vw = new VaultWriter(this.app, this.settings);
    this.addSettingTab(new SupernoteSettingTab(this.app, this));
    this.addCommand({
      id: "attach-supernote-file-from-device",
      name: "Attach Supernote file from device",
      callback: () => {
        if (this.settings.mirrorIP.length === 0) {
          new MirrorErrorModal(this.app, this.settings, new Error("IP is unset")).open();
          return;
        }
        new FileListModal(this.app, this.settings).open();
      }
    });
    this.registerView(
      VIEW_TYPE_SUPERNOTE,
      (leaf) => new SupernoteView(leaf, this.settings)
    );
    this.registerExtensions(["note"], VIEW_TYPE_SUPERNOTE);
    this.addCommand({
      id: "insert-supernote-screen-mirror-image",
      name: "Insert a Supernote screen mirroring image as attachment",
      editorCallback: async (editor, view) => {
        var _a2, _b2, _c, _d;
        let ts = generateTimestamp();
        const f3 = ((_b2 = (_a2 = this.app.workspace.activeEditor) == null ? void 0 : _a2.file) == null ? void 0 : _b2.basename) || "";
        const filename = await this.app.fileManager.getAvailablePathForAttachment(`supernote-mirror-${f3}-${ts}.png`);
        try {
          if (this.settings.mirrorIP.length == 0) {
            throw new Error("IP is unset, please set in Supernote plugin settings");
          }
          let image = await fetchMirrorFrame(`${this.settings.mirrorIP}:8080`);
          const file = await this.app.vault.createBinary(filename, image.toBuffer());
          const path = (_d = (_c = this.app.workspace.activeEditor) == null ? void 0 : _c.file) == null ? void 0 : _d.path;
          if (!path) {
            throw new Error("Active file path is null");
          }
          const link = this.app.fileManager.generateMarkdownLink(file, path);
          editor.replaceRange(link, editor.getCursor());
        } catch (err3) {
          new MirrorErrorModal(this.app, this.settings, err3).open();
        }
      }
    });
    this.addCommand({
      id: "export-supernote-note-as-files",
      name: "Export this Supernote note as a markdown and PNG files as attachments",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        const ext = file == null ? void 0 : file.extension;
        if (ext === "note") {
          if (checking) {
            return true;
          }
          try {
            if (!file) {
              throw new Error("No file to attach");
            }
            vw.attachNoteFiles(file);
          } catch (err3) {
            new ErrorModal(this.app, err3).open();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "export-supernote-note-as-pdf",
      name: "Export this Supernote note as PDF",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        const ext = file == null ? void 0 : file.extension;
        if (ext === "note") {
          if (checking) {
            return true;
          }
          try {
            if (!file) {
              throw new Error("No file to attach");
            }
            vw.exportToPDF(file);
          } catch (err3) {
            new ErrorModal(this.app, err3).open();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "export-supernote-note-as-markdown",
      name: "Export this Supernote note as a markdown file attachment",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        const ext = file == null ? void 0 : file.extension;
        if (ext === "note") {
          if (checking) {
            return true;
          }
          try {
            if (!file) {
              throw new Error("No file to attach");
            }
            vw.attachMarkdownFile(file);
          } catch (err3) {
            new ErrorModal(this.app, err3).open();
          }
          return true;
        }
        return false;
      }
    });
  }
  onunload() {
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_SUPERNOTE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        throw new Error("leaf is null");
      }
      await leaf.setViewState({ type: VIEW_TYPE_SUPERNOTE, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var MirrorErrorModal = class extends import_obsidian2.Modal {
  constructor(app, settings, error) {
    super(app);
    this.error = error;
    this.settings = settings;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText("Error: ${this.error.message}. Is the Supernote connected to Wifi on IP ${this.settings.mirrorIP} and running Browse and Access on HTTP://a.b.c.d:8089 ?");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ErrorModal = class extends import_obsidian2.Modal {
  constructor(app, error) {
    super(app);
    this.error = error;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText(`Error: ${this.error.message}.`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SupernoteSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName('Supernote IP address for "Browse and Access"').setDesc('See Supernote "Browse and Access" documentation. Hint, swipe down, click the Tie Fighter icon, this opens up your Supernote on HTTP://a.b.c.d:8089. This is unencrypted, so watch out for Wiresharkers on your LAN').addText(
      (text) => text.setPlaceholder("IP )e.g. 192.168.1.2").setValue(this.plugin.settings.mirrorIP).onChange(async (value) => {
        this.plugin.settings.mirrorIP = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName('Invert colors in "Dark mode"').setDesc('When Obsidian is in "Dark mode" increase image visibility by inverting colors of images').addToggle(
      (text) => text.setValue(this.plugin.settings.invertColorsWhenDark).onChange(async (value) => {
        this.plugin.settings.invertColorsWhenDark = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Show table of contents and page headings").setDesc(
      "When viewing .note files, show a table of contents and page number headings"
    ).addToggle(
      (text) => text.setValue(this.plugin.settings.showTOC).onChange(async (value) => {
        this.plugin.settings.showTOC = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Show export buttons").setDesc(
      "When viewing .note files, show buttons for exporting images and/or markdown files to vault. These features can still be accessed via the command pallete."
    ).addToggle(
      (text) => text.setValue(this.plugin.settings.showExportButtons).onChange(async (value) => {
        this.plugin.settings.showExportButtons = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Collapse recognized text").setDesc("When viewing .note files, hide recognized text in a collapsible element. This does not affect exported markdown.").addToggle(
      (text) => text.setValue(this.plugin.settings.collapseRecognizedText).onChange(async (value) => {
        this.plugin.settings.collapseRecognizedText = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Max image side length in .note files").setDesc("Maximum width and height (in pixels) of the note image when viewing .note files. Does not affect exported images and markdown.").addSlider(
      (text) => text.setLimits(200, 1900, 100).setDynamicTooltip().setValue(this.plugin.settings.noteImageMaxDim).onChange(async (value) => {
        this.plugin.settings.noteImageMaxDim = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
/*! Bundled license information:

html2canvas/dist/html2canvas.js:
  (*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   *)
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

dompurify/dist/purify.js:
  (*! @license DOMPurify 2.5.8 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.5.8/LICENSE *)

svg-pathdata/lib/SVGPathData.module.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

jspdf/dist/jspdf.es.min.js:
  (** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2021 yWorks GmbH, http://www.yworks.com
   *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   *)
  (**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   *)
  (**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   *)
  (**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   *
   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   *)
  (**
   * @license
   * (c) Dean McNamee <dean@gmail.com>, 2013.
   *
   * https://github.com/deanm/omggif
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
   * including animation and compression.  It does not rely on any specific
   * underlying system, so should run in the browser, Node, or Plask.
   *)
  (**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.
  
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:
  
    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   *)
*/
